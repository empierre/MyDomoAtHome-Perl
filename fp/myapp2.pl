
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Dancer2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2';
  package Dancer2;
  # ABSTRACT: Lightweight yet powerful web application framework
  $Dancer2::VERSION = '0.162000';
  use strict;
  use warnings;
  use List::Util  'first';
  use Class::Load 'load_class';
  use Import::Into;
  use Dancer2::Core;
  use Dancer2::Core::App;
  use Dancer2::Core::Runner;
  use Dancer2::FileUtils;
  
  our $AUTHORITY = 'SUKRIA';
  
  sub VERSION { shift->SUPER::VERSION(@_) || '0.000000_000' }
  
  our $runner;
  
  sub runner   {$runner}
  sub psgi_app { shift->runner->psgi_app(@_) }
  
  sub import {
      my ( $class,  @args   ) = @_;
      my ( $caller, $script ) = caller;
  
      $_->import::into($caller) for qw(strict warnings utf8);
  
      my @final_args;
      foreach my $arg (@args) {
          grep +( $arg eq $_ ), qw<:script :syntax :tests>
              and next;
  
          if ( substr( $arg, 0, 1 ) eq '!' ) {
              push @final_args, $arg, 1;
          } else {
              push @final_args, $arg;
          }
      }
  
      scalar @final_args % 2
        and die q{parameters must be key/value pairs or '!keyword'};
  
      my %final_args = @final_args;
  
      my $appname = delete $final_args{appname};
      $appname ||= $caller;
  
      # never instantiated the runner, should do it now
      if ( not defined $runner ) {
          $runner = Dancer2::Core::Runner->new();
      }
  
      # Search through registered apps, creating a new app object
      # if we do not find one with the same name.
      my $app;
      ($app) = first { $_->name eq $appname } @{ $runner->apps };
  
      if ( ! $app ) {
          # populating with the server's postponed hooks in advance
          $app = Dancer2::Core::App->new(
              name            => $appname,
              caller          => $script,
              environment     => $runner->environment,
              postponed_hooks => $runner->postponed_hooks->{$appname} || {},
          );
  
          # register the app within the runner instance
          $runner->register_application($app);
      }
  
      _set_import_method_to_caller($caller);
  
      # use config dsl class, must extend Dancer2::Core::DSL
      my $config_dsl = $app->setting('dsl_class') || 'Dancer2::Core::DSL';
      $final_args{dsl} ||= $config_dsl;
  
      # load the DSL, defaulting to Dancer2::Core::DSL
      load_class( $final_args{dsl} );
      my $dsl = $final_args{dsl}->new( app => $app );
      $dsl->export_symbols_to( $caller, \%final_args );
  }
  
  sub _set_import_method_to_caller {
      my ($caller) = @_;
  
      my $import = sub {
          my ( $self, %options ) = @_;
  
          my $with = $options{with};
          for my $key ( keys %$with ) {
              $self->dancer_app->setting( $key => $with->{$key} );
          }
      };
  
      {
          no strict 'refs';
          no warnings 'redefine';
          *{"${caller}::import"} = $import;
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2 - Lightweight yet powerful web application framework
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  Dancer2 is the new generation of L<Dancer>, the lightweight web-framework for
  Perl. Dancer2 is a complete rewrite based on L<Moo>.
  
  Dancer2 can optionally use XS modules for speed, but at its core remains
  fatpackable (packable by L<App::FatPacker>) so you could easily deploy Dancer2
  applications on hosts that do not support custom CPAN modules.
  
  Dancer2 is easy and fun:
  
      use Dancer2;
      get '/' => sub { "Hello World" };
      dance;
  
  This is the main module for the Dancer2 distribution. It contains logic for
  creating a new Dancer2 application.
  
  You are welcome to join our mailing list.
  For subscription information, mail address and archives see
  L<http://lists.preshweb.co.uk/mailman/listinfo/dancer-users>.
  
  We are also on IRC: #dancer on irc.perl.org.
  
  =head2 Documentation Index
  
  Documentation on Dancer2 is split into several manpages. Below is a
  complete outline on where to go for help.
  
  =over 4
  
  =item * Dancer2 Tutorial
  
  If you are new to the Dancer approach, you should start by reading
  our L<Dancer2::Tutorial>.
  
  =item * Dancer2 Manual
  
  L<Dancer2::Manual> is the reference for Dancer2. Here you will find
  information on the concepts of Dancer2 application development and
  a comprehensive reference to the Dancer2 domain specific
  language.
  
  =item * Dancer2 Keywords
  
  The keywords for Dancer2 can be found under L<DSL Keywords|Dancer2::Manual/DSL KEYWORDS>.
  
  =item * Dancer2 Deployment
  
  For configuration examples of different deployment solutions involving
  Dancer2 and Plack, refer to L<Dancer2::Manual::Deployment>.
  
  =item * Dancer2 Cookbook
  
  Specific examples of code for real-life problems and some 'tricks' for
  applications in Dancer can be found in L<Dancer2::Cookbook>
  
  =item * Dancer2 Config
  
  For configuration file details refer to L<Dancer2::Config>. It is a
  complete list of all configuration options.
  
  =item * Dancer2 Plugins
  
  Refer to L<Dancer2::Plugins> for a partial list of available Dancer2
  plugins. Note that although we try to keep this list up to date we
  expect plugin authors to tell us about new modules.
  
  =item * Dancer2 Migration guide
  
  L<Dancer2::Manual::Migration> provides the most up-to-date instruction on
  how to convert a Dancer (1) based application to Dancer2.
  
  =back
  
  =head1 METHODS
  
  =head2 import;
  
  If it doesn't exist already, C<import> creates a new runner, imports strict
  and warnings, loads additional libraries, creates a new Dancer2 app (of type
  L<Dancer2::Core::App>) and exports the DSL symbols to the caller.
  
  If any additional argument processing is needed, it will be done at this point.
  
  Import gets called when you use Dancer2. You can specify import options giving
  you control over the keywords that will be imported into your webapp and other
  things:
  
      use Dancer2 '!quux'; # Don't import DSL keyword quux
      use Dancer2 appname => 'MyAwesomeApp'; # Add routes and hooks to MyAwesomeApp
      use Dancer2 ( foo => 'bar' ); # sets option foo to bar (currently not implemented)
  
  =head1 FUNCTIONS
  
  =head2 my $runner=runner();
  
  Returns the current runner. It is of type L<Dancer2::Core::Runner>.
  
  =head1 AUTHORS
  
  =head2 CORE DEVELOPERS
  
      Alberto Simões
      Alexis Sukrieh
      Damien Krotkine
      David Golden
      David Precious
      Franck Cuny
      Mickey Nasriachi
      Russell Jenkins
      Sawyer X
      Stefan Hornburg (Racke)
      Steven Humphrey
      Yanick Champoux
  
  =head2 CONTRIBUTORS
  
      Ahmad M. Zawawi
      Alex Beamish
      Alexander Karelas
      Alexandr Ciornii
      Andrew Grangaard
      Andrew Inishev
      andrewsolomon
      Ashvini V
      B10m
      baynes
      Blabos de Blebe
      Bas Bloemsaat
      Breno G. de Oliveira
      Celogeek
      Cesare Gargano
      Christian Walde
      Colin Kuskie
      cym0n
      Dale Gallagher
      David Steinbrunner
      Dinis Rebolo
      Erik Smit
      geistteufel
      Gideon D'souza
      Graham Knop
      Gregor Herrmann
      Grzegorz Rożniecki
      Hobbestigrou
      Ivan Bessarabov
      Jakob Voss
      James Aitken
      Jason A. Crome
      Javier Rojas
      Jean Stebens
      Jonathan Scott Duff
      Julio Fraire
      Keith Broughton
      Mark A. Stratman
      Mateu X Hunter
      Matt Phillips
      Matt S Trout
      Maurice
      Michał Wojciechowski
      mokko
      Olivier Mengué
      Omar M. Othman
      Pau Amma
      Pedro Melo
      Rick Yakubowski
      Sam Kington
      Samit Badle
      Shlomi Fish
      Slava Goltser
      smashz
      Tom Hukins
      Upasana
      Vincent Bachelier
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2

$fatpacked{"Dancer2/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CLI';
  package Dancer2::CLI;
  # ABSTRACT: Dancer2 cli application
  $Dancer2::CLI::VERSION = '0.162000';
  use App::Cmd::Setup -app;
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::CLI - Dancer2 cli application
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CLI

$fatpacked{"Dancer2/CLI/Command/gen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CLI_COMMAND_GEN';
  # ABSTRACT: create new Dancer2 application
  package Dancer2::CLI::Command::gen;
  $Dancer2::CLI::Command::gen::VERSION = '0.162000';
  use strict;
  use warnings;
  
  use App::Cmd::Setup -command;
  
  use HTTP::Tiny;
  use File::Find;
  use File::Path 'mkpath';
  use File::Spec::Functions;
  use File::ShareDir 'dist_dir';
  use File::Basename qw/dirname basename/;
  use Dancer2::Template::Simple;
  use Class::Load 'try_load_class';
  
  my $SKEL_APP_FILE = 'lib/AppFile.pm';
  
  sub description { 'Helper script to create new Dancer2 applications' }
  
  sub opt_spec {
      return (
          [ 'application|a=s', 'application name' ],
          [ 'directory|d=s',   'application folder (default: same as application name)' ],
          [ 'path|p=s',        'application path (default: current directory)',
              { default => '.' } ],
          [ 'overwrite|o',     'overwrite existing files' ],
          [ 'no-check|x',      'don\'t check latest Dancer2 version (requires internet)' ],
      );
  }
  
  sub validate_args {
      my ($self, $opt, $args) = @_;
  
      my $name = $opt->{application}
          or $self->usage_error('Application name must be defined');
  
      if ( $name =~ /[^\w:]/ || $name =~ /^\d/ || $name =~ /\b:\b|:{3,}/ ) {
          $self->usage_error(
              "Invalid application name.\n" .
              "Application names must not contain single colons, dots, " .
              "hyphens or start with a number.\n"
          );
      }
  
      my $path = $opt->{path};
      -d $path or $self->usage_error("directory '$path' does not exist");
      -w $path or $self->usage_error("directory '$path' is not writeable");
  }
  
  sub execute {
      my ($self, $opt, $args) = @_;
      $self->_version_check() unless $opt->{'no_check'};
  
      my $dist_dir = $ENV{DANCER2_SHARE_DIR} || dist_dir('Dancer2');
      my $skel_dir = catdir($dist_dir, 'skel');
      -d $skel_dir or die "$skel_dir doesn't exist";
  
      my $app_name = $opt->{application};
      my $app_file = _get_app_file($app_name);
      my $app_path = _get_app_path($opt->{path}, $app_name);
  
      if( my $dir = $opt->{directory} ) {
          $app_path = catdir( $opt->{path}, $dir );
      }
  
      my $files_to_copy = _build_file_list($skel_dir, $app_path);
      foreach my $pair (@$files_to_copy) {
          if ($pair->[0] =~ m/$SKEL_APP_FILE$/) {
              $pair->[1] = catfile($app_path, $app_file);
              last;
          }
      }
  
      my $vars = {
          appname          => $app_name,
          appfile          => $app_file,
          appdir           => File::Spec->rel2abs($app_path),
          perl_interpreter => _get_perl_interpreter(),
          cleanfiles       => _get_dashed_name($app_name),
          dancer_version   => $self->version(),
      };
  
      _copy_templates($files_to_copy, $vars, $opt->{overwrite});
      _create_manifest($files_to_copy, $app_path);
      _add_to_manifest_skip($app_path);
  
      if ( ! try_load_class('YAML') ) {
          print <<NOYAML;
  *****
  WARNING: YAML.pm is not installed.  This is not a full dependency, but is highly
  recommended; in particular, the scaffolded Dancer app being created will not be
  able to read settings from the config file without YAML.pm being installed.
  
  To resolve this, simply install YAML from CPAN, for instance using one of the
  following commands:
  
    cpan YAML
    perl -MCPAN -e 'install YAML'
    curl -L http://cpanmin.us | perl - --sudo YAML
  *****
  NOYAML
      }
  
      return 0;
  }
  
  sub version {
      require Dancer2;
      return Dancer2->VERSION;
  }
  
  # skel creation routines
  sub _build_file_list {
      my ($from, $to) = @_;
      my $len = length($from) + 1;
  
      my @result;
      my $wanted = sub {
          return unless -f;
          my $file = substr($_, $len);
          push @result, [ $_, catfile($to, $file) ];
      };
  
      find({ wanted => $wanted, no_chdir => 1 }, $from);
      return \@result;
  }
  
  sub _copy_templates {
      my ($files, $vars, $overwrite) = @_;
  
      foreach my $pair (@$files) {
          my ($from, $to) = @{$pair};
          if (-f $to && !$overwrite) {
              print "! $to exists, overwrite? [N/y/a]: ";
              my $res = <STDIN>; chomp($res);
              $overwrite = 1 if $res eq 'a';
              next unless ($res eq 'y') or ($res eq 'a');
          }
  
          my $to_dir = dirname($to);
          if (! -d $to_dir) {
              print "+ $to_dir\n";
              mkpath $to_dir or die "could not mkpath $to_dir: $!";
          }
  
          my $to_file = basename($to);
          my $ex = ($to_file =~ s/^\+//);
          $to = catfile($to_dir, $to_file) if $ex;
  
          print "+ $to\n";
          my $content;
  
          {
              local $/;
              open(my $fh, '<', $from) or die "unable to open file `$from' for reading: $!";
              $content = <$fh>;
              close $fh;
          }
  
          if ($from !~ m/\.(ico|jpg|css|js)$/) {
              $content = _process_template($content, $vars);
          }
  
          open(my $fh, '>', $to) or die "unable to open file `$to' for writing: $!";
          print $fh $content;
          close $fh;
  
          if ($ex) {
              chmod(0755, $to) or warn "unable to change permissions for $to: $!";
          }
      }
  }
  
  sub _create_manifest {
      my ($files, $dir) = @_;
  
      my $manifest_name = catfile($dir, 'MANIFEST');
      open(my $manifest, '>', $manifest_name) or die $!;
      print $manifest "MANIFEST\n";
  
      foreach my $file (@{$files}) {
          my $filename = substr $file->[1], length($dir) + 1;
          my $basename = basename $filename;
          my $clean_basename = $basename;
          $clean_basename =~ s/^\+//;
          $filename =~ s/\Q$basename\E/$clean_basename/;
          print {$manifest} "$filename\n";
      }
  
      close($manifest);
  }
  
  sub _add_to_manifest_skip {
      my $dir = shift;
  
      my $filename = catfile($dir, 'MANIFEST.SKIP');
      open my $fh, '>>', $filename or die $!;
      print {$fh} "^$dir-\n";
      close $fh;
  }
  
  sub _process_template {
      my ($template, $tokens) = @_;
      my $engine = Dancer2::Template::Simple->new;
      $engine->{start_tag} = '[%';
      $engine->{stop_tag} = '%]';
      return $engine->render(\$template, $tokens);
  }
  
  sub _get_app_path {
      my ($path, $appname) = @_;
      return catdir($path, _get_dashed_name($appname));
  }
  
  sub _get_app_file {
      my $appname = shift;
      $appname =~ s{::}{/}g;
      return catfile('lib', "$appname.pm");
  }
  
  sub _get_perl_interpreter {
      return -r '/usr/bin/env' ? '#!/usr/bin/env perl' : "#!$^X";
  }
  
  sub _get_dashed_name {
      my $name = shift;
      $name =~ s{::}{-}g;
      return $name;
  }
  
  # version check routines
  sub _version_check {
      my $self = shift;
      my $version = $self->version();
      return if $version =~  m/_/;
  
      my $latest_version = 0;
      my $resp = _send_http_request('http://search.cpan.org/api/module/Dancer2');
  
      if ($resp) {
          if ( $resp =~ /"version" (?:\s+)? \: (?:\s+)? "(\d\.\d+)"/x ) {
              $latest_version = $1;
          } else {
              die "Can't understand search.cpan.org's reply.\n";
          }
      }
  
      if ($latest_version > $version) {
          print qq|
  The latest stable Dancer2 release is $latest_version, you are currently using $version.
  Please check http://search.cpan.org/dist/Dancer2/ for updates.
  
  |;
      }
  }
  
  sub _send_http_request {
      my $url = shift;
  
      my $ua = HTTP::Tiny->new( timeout => 5 );
  
      my $response = $ua->get($url);
      return $response->{'success'} ? $response->{'content'} : undef;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::CLI::Command::gen - create new Dancer2 application
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CLI_COMMAND_GEN

$fatpacked{"Dancer2/CLI/Command/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CLI_COMMAND_VERSION';
  package Dancer2::CLI::Command::version;
  # ABSTRACT: display version
  $Dancer2::CLI::Command::version::VERSION = '0.162000';
  use App::Cmd::Setup -command;
  
  sub description { 'Display version of Dancer2' }
  
  sub command_names {
      qw/version --version -v/;
  }
  
  sub execute {
      require Dancer2;
      print 'Dancer2 ' . Dancer2->VERSION . "\n";
      return 0;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::CLI::Command::version - display version
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CLI_COMMAND_VERSION

$fatpacked{"Dancer2/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE';
  package Dancer2::Core;
  # ABSTRACT: Core libraries for Dancer2 2.0
  $Dancer2::Core::VERSION = '0.162000';
  use strict;
  use warnings;
  
  sub camelize {
      my ($value) = @_;
  
      my $camelized = '';
      for my $word ( split /_/, $value ) {
          $camelized .= ucfirst($word);
      }
      return $camelized;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core - Core libraries for Dancer2 2.0
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 FUNCTIONS
  
  =head2 camelize
  
  Camelize a underscore-separated-string.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE

$fatpacked{"Dancer2/Core/App.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_APP';
  # ABSTRACT: encapsulation of Dancer2 packages
  package Dancer2::Core::App;
  $Dancer2::Core::App::VERSION = '0.162000';
  use Moo;
  use Carp               'croak';
  use Scalar::Util       'blessed';
  use Module::Runtime    'is_module_name';
  use Return::MultiLevel ();
  use Safe::Isa;
  use Sub::Quote;
  use File::Spec;
  
  use Plack::Middleware::FixMissingBodyInRedirect;
  use Plack::Middleware::Head;
  use Plack::Middleware::Static;
  
  use Dancer2::FileUtils 'path';
  use Dancer2::Core;
  use Dancer2::Core::Cookie;
  use Dancer2::Core::Error;
  use Dancer2::Core::Types;
  use Dancer2::Core::Route;
  use Dancer2::Core::Hook;
  use Dancer2::Core::Request;
  use Dancer2::Core::Factory;
  
  use Dancer2::Handler::File;
  
  # we have hooks here
  with qw<
      Dancer2::Core::Role::Hookable
      Dancer2::Core::Role::ConfigReader
  >;
  
  sub supported_engines { [ qw<logger serializer session template> ] }
  
  has _factory => (
      is      => 'ro',
      isa     => Object['Dancer2::Core::Factory'],
      lazy    => 1,
      default => sub { Dancer2::Core::Factory->new },
  );
  
  has logger_engine => (
      is        => 'ro',
      isa       => ConsumerOf['Dancer2::Core::Role::Logger'],
      lazy      => 1,
      builder   => '_build_logger_engine',
      writer    => 'set_logger_engine',
  );
  
  has session_engine => (
      is      => 'ro',
      isa     => ConsumerOf['Dancer2::Core::Role::SessionFactory'],
      lazy    => 1,
      builder => '_build_session_engine',
      writer  => 'set_session_engine',
  );
  
  has template_engine => (
      is      => 'ro',
      isa     => ConsumerOf['Dancer2::Core::Role::Template'],
      lazy    => 1,
      builder => '_build_template_engine',
      writer  => 'set_template_engine',
  );
  
  has serializer_engine => (
      is      => 'ro',
      isa     => ConsumerOf['Dancer2::Core::Role::Serializer'],
      lazy    => 1,
      builder => '_build_serializer_engine',
      writer  => 'set_serializer_engine',
      predicate => 'has_serializer_engine',
  );
  
  has defined_engines => (
      is      => 'ro',
      isa     => ArrayRef,
      lazy    => 1,
      default => sub {
          my $self = shift;
          [
              $self->template_engine,
              $self->session_engine,
              $self->logger_engine,
              $self->has_serializer_engine
                  ? $self->serializer_engine
                  : (),
          ];
      },
  );
  
  has '+local_triggers' => (
      default => sub {
          my $self     = shift;
          my $triggers = {
              # general triggers we want to allow, besides engines
              views => sub {
                  my $self  = shift;
                  my $value = shift;
                  $self->template_engine->views($value);
              },
  
              layout => sub {
                  my $self  = shift;
                  my $value = shift;
                  $self->template_engine->layout($value);
              },
  
              log => sub {
                  my ( $self, $value, $config ) = @_;
  
                  # This will allow to set the log level
                  # using: set log => warning
                  $self->logger_engine->log_level($value);
              },
          };
  
          foreach my $engine ( @{ $self->supported_engines } ) {
              $triggers->{$engine} = sub {
                  my $self   = shift;
                  my $value  = shift;
                  my $config = shift;
  
                  ref $value and return $value;
  
                  my $build_method    = "_build_${engine}_engine";
                  my $setter_method   = "set_${engine}_engine";
                  my $engine_instance = $self->$build_method( $value, $config );
  
                  # set the engine with the new value from the builder
                  $self->$setter_method($engine_instance);
  
                  return $engine_instance;
              };
          }
  
          return $triggers;
      },
  );
  
  sub _build_logger_engine {
      my $self   = shift;
      my $value  = shift;
      my $config = shift;
  
      defined $config or $config = $self->config;
      defined $value  or $value  = $config->{logger};
  
      ref $value and return $value;
  
      # XXX This is needed for the tests that create an app without
      # a runner.
      defined $value or $value = 'console';
  
      is_module_name($value)
          or croak "Cannot load logger engine '$value': illegal module name";
  
      my $engine_options =
          $self->_get_config_for_engine( logger => $value, $config );
  
      my $logger = $self->_factory->create(
          logger          => $value,
          %{$engine_options},
          location        => $self->config_location,
          environment     => $self->environment,
          app_name        => $self->name,
          postponed_hooks => $self->postponed_hooks
      );
  
      exists $config->{log} and $logger->log_level($config->{log});
  
      return $logger;
  }
  
  sub _build_session_engine {
      my $self   = shift;
      my $value  = shift;
      my $config = shift;
  
      defined $config or $config = $self->config;
      defined $value  or $value  = $config->{'session'} || 'simple';
  
      ref $value and return $value;
  
      is_module_name($value)
          or croak "Cannot load session engine '$value': illegal module name";
  
      my $engine_options =
            $self->_get_config_for_engine( session => $value, $config );
  
      Scalar::Util::weaken( my $weak_self = $self );
  
      # Note that engine options will replace the default session_dir (if provided).
      return $self->_factory->create(
          session         => $value,
          session_dir     => path( $self->config->{appdir}, 'sessions' ),
          %{$engine_options},
          postponed_hooks => $self->postponed_hooks,
  
          log_cb => sub { $weak_self->logger->log(@_) },
      );
  }
  
  sub _build_template_engine {
      my $self   = shift;
      my $value  = shift;
      my $config = shift;
  
      defined $config or $config = $self->config;
      defined $value  or $value  = $config->{'template'};
  
      defined $value or return;
      ref $value    and return $value;
  
      is_module_name($value)
          or croak "Cannot load template engine '$value': illegal module name";
  
      my $engine_options =
            $self->_get_config_for_engine( template => $value, $config );
  
      my $engine_attrs = { config => $engine_options };
      $engine_attrs->{layout} ||= $config->{layout};
      $engine_attrs->{views}  ||= $config->{views}
          || path( $self->location, 'views' );
  
      Scalar::Util::weaken( my $weak_self = $self );
  
      return $self->_factory->create(
          template        => $value,
          %{$engine_attrs},
          postponed_hooks => $self->postponed_hooks,
  
          log_cb => sub { $weak_self->logger->log(@_) },
      );
  }
  
  sub _build_serializer_engine {
      my $self   = shift;
      my $value  = shift;
      my $config = shift;
  
      defined $config or $config = $self->config;
      defined $value  or $value  = $config->{serializer};
  
      defined $value or return;
      ref $value    and return $value;
  
      my $engine_options =
          $self->_get_config_for_engine( serializer => $value, $config );
  
      Scalar::Util::weaken( my $weak_self = $self );
  
      return $self->_factory->create(
          serializer      => $value,
          config          => $engine_options,
          postponed_hooks => $self->postponed_hooks,
  
          log_cb => sub { $weak_self->logger_engine->log(@_) },
      );
  }
  
  sub _get_config_for_engine {
      my $self   = shift;
      my $engine = shift;
      my $name   = shift;
      my $config = shift;
  
      defined $config->{'engines'} && defined $config->{'engines'}{$engine}
          or return {};
  
      # try both camelized name and regular name
      my $engine_config = {};
      foreach my $engine_name ( $name, Dancer2::Core::camelize($name) ) {
          if ( defined $config->{'engines'}{$engine}{$engine_name} ) {
              $engine_config = $config->{'engines'}{$engine}{$engine_name};
              last;
          }
      }
  
      return $engine_config;
  }
  
  has postponed_hooks => (
      is      => 'ro',
      isa     => HashRef,
      default => sub { {} },
  );
  
  has plugins => (
      is      => 'rw',
      isa     => ArrayRef,
      default => sub { [] },
  );
  
  has route_handlers => (
      is      => 'rw',
      isa     => ArrayRef,
      default => sub { [] },
  );
  
  has name => (
      is      => 'ro',
      isa     => Str,
      default => sub { (caller(1))[0] },
  );
  
  has request => (
      is        => 'ro',
      isa       => InstanceOf['Dancer2::Core::Request'],
      writer    => '_set_request',
      clearer   => 'clear_request',
      predicate => 'has_request',
  );
  
  sub set_request {
      my ($self, $request) = @_;
      # populate request in app and all engines
      $self->_set_request($request);
      $_->set_request( $request ) for @{ $self->defined_engines };
  }
  
  has response => (
      is        => 'ro',
      isa       => InstanceOf['Dancer2::Core::Response'],
      lazy      => 1,
      writer    => 'set_response',
      clearer   => 'clear_response',
      builder   => '_build_response',
      predicate => 'has_response',
  );
  
  has with_return => (
      is        => 'ro',
      predicate => 1,
      writer    => 'set_with_return',
      clearer   => 'clear_with_return',
  );
  
  has session => (
      is        => 'ro',
      isa       => InstanceOf['Dancer2::Core::Session'],
      lazy      => 1,
      builder   => '_build_session',
      writer    => 'set_session',
      clearer   => 'clear_session',
      predicate => '_has_session',
  );
  
  around _build_config => sub {
      my ( $orig, $self ) = @_;
      my $config          = $self->$orig;
  
      if ( $config && $config->{'engines'} ) {
          $self->_validate_engine($_) for keys %{ $config->{'engines'} };
      }
  
      return $config;
  };
  
  sub _build_response {
      my $self = shift;
      return Dancer2::Core::Response->new(
          $self->has_serializer_engine
              ? ( serializer => $self->serializer_engine )
              : (),
      );
  }
  
  sub _build_session {
      my $self = shift;
      my $session;
  
      # Find the session engine
      my $engine = $self->session_engine;
  
      # find the session cookie if any
      if ( !$self->has_destroyed_session ) {
          my $session_id;
          my $session_cookie = $self->cookie( $engine->cookie_name );
          defined $session_cookie and
              $session_id = $session_cookie->value;
  
          # if we have a session cookie, try to retrieve the session
          if ( defined $session_id ) {
              eval  { $session = $engine->retrieve( id => $session_id ); 1; }
              or do { $@ and $@ !~ /Unable to retrieve session/
                          and croak "Fail to retrieve session: $@" };
          }
      }
  
      # create the session if none retrieved
      return $session ||= $engine->create();
  }
  
  sub has_session {
      my $self = shift;
  
      my $engine = $self->session_engine;
  
      return $self->_has_session
          || ( $self->cookie( $engine->cookie_name )
               && !$self->has_destroyed_session );
  }
  
  has destroyed_session => (
      is        => 'ro',
      isa       => InstanceOf ['Dancer2::Core::Session'],
      predicate => 1,
      writer    => 'set_destroyed_session',
      clearer   => 'clear_destroyed_session',
  );
  
  sub destroy_session {
      my $self = shift;
  
      # Find the session engine
      my $engine = $self->session_engine;
  
      # Expire session, set the expired cookie and destroy the session
      # Setting the cookie ensures client gets an expired cookie unless
      # a new session is created and supercedes it
      my $session = $self->session;
      $session->expires(-86400);    # yesterday
      $engine->destroy( id => $session->id );
  
      # Invalidate session cookie in request
      # and clear session in app and engines
      $self->set_destroyed_session($session);
      $self->clear_session;
      $_->clear_session for @{ $self->defined_engines };
  
      return;
  }
  
  sub setup_session {
      my $self = shift;
  
      for my $engine ( @{ $self->defined_engines } ) {
          $self->has_session                         ?
              $engine->set_session( $self->session ) :
              $engine->clear_session;
      }
  }
  
  has prefix => (
      is        => 'rw',
      isa       => Maybe [Dancer2Prefix],
      predicate => 1,
      coerce    => sub {
          my $prefix = shift;
          defined($prefix) and $prefix eq "/" and return;
          return $prefix;
      },
  );
  
  # routes registry, stored by method:
  has routes => (
      is      => 'rw',
      isa     => HashRef,
      default => sub {
          {   get     => [],
              head    => [],
              post    => [],
              put     => [],
              del     => [],
              options => [],
          };
      },
  );
  
  # add_hook will add the hook to the first "hook candidate" it finds that support
  # it. If none, then it will try to add the hook to the current application.
  around add_hook => sub {
      my $orig = shift;
      my $self = shift;
  
      # saving caller information
      my ( $package, $file, $line ) = caller(4);    # deep to 4 : user's app code
      my $add_hook_caller = [ $package, $file, $line ];
  
      my ($hook)       = @_;
      my $name         = $hook->name;
      my $hook_aliases = $self->all_hook_aliases;
  
      # look for an alias
      defined $hook_aliases->{$name} and $name = $hook_aliases->{$name};
      $hook->name($name);
  
      # if that hook belongs to the app, register it now and return
      $self->has_hook($name) and return $self->$orig(@_);
  
      # at this point the hook name must be formatted like:
      # '$type.$candidate.$name', eg: 'engine.template.before_render' or
      # 'plugin.database.before_dbi_connect'
      my ( $hookable_type, $hookable_name, $hook_name ) = split( /\./, $name );
  
      ( defined $hookable_name && defined $hook_name )
          or croak "Invalid hook name `$name'";
  
      grep /^$hookable_type$/, qw(core engine handler plugin)
          or croak "Unknown hook type `$hookable_type'";
  
      # register the hooks for existing hookable candidates
      foreach my $hookable ( $self->hook_candidates ) {
          $hookable->has_hook($name) and $hookable->add_hook(@_);
      }
  
      # we register the hook for upcoming objects;
      # that way, each components that can claim the hook will have a chance
      # to register it.
  
      my $postponed_hooks = $self->postponed_hooks;
  
      # Hmm, so the hook was not claimed, at this point we'll cache it and
      # register it when the owner is instantiated
      $postponed_hooks->{$hookable_type}{$hookable_name} ||= {};
      $postponed_hooks->{$hookable_type}{$hookable_name}{$name} ||= {};
      $postponed_hooks->{$hookable_type}{$hookable_name}{$name}{hook} = $hook;
      $postponed_hooks->{$hookable_type}{$hookable_name}{$name}{caller} =
        $add_hook_caller;
  
  };
  
  around execute_hook => sub {
      my $orig = shift;
      my $self = shift;
  
      local $Dancer2::Core::Route::REQUEST  = $self->request;
      local $Dancer2::Core::Route::RESPONSE = $self->response;
  
      my ( $hook, @args ) = @_;
      if ( !$self->has_hook($hook) ) {
          foreach my $cand ( $self->hook_candidates ) {
              $cand->has_hook($hook) and return $cand->execute_hook(@_);
          }
      }
  
      return $self->$orig(@_);
  };
  
  sub _build_default_config {
      my $self = shift;
  
      my $public = $ENV{DANCER_PUBLIC} || path( $self->location, 'public' );
      return {
          content_type   => ( $ENV{DANCER_CONTENT_TYPE} || 'text/html' ),
          charset        => ( $ENV{DANCER_CHARSET}      || '' ),
          logger         => ( $ENV{DANCER_LOGGER}       || 'console' ),
          views          => ( $ENV{DANCER_VIEWS}
                              || path( $self->config_location, 'views' ) ),
          environment    => $self->environment,
          appdir         => $self->location,
          public_dir     => $public,
          static_handler => ( -d $public ),
          template       => 'Tiny',
          route_handlers => [
              [
                  AutoPage => 1
              ],
          ],
      };
  }
  
  sub _init_hooks {
      my $self = shift;
  
      # Hook to flush the session at the end of the request,
      # this way, we're sure we flush only once per request
      #
      # Note: we create a weakened copy $self
      # before closing over the weakened copy
      # to avoid circular memory refs.
      Scalar::Util::weaken(my $app = $self);
  
      $self->add_hook(
          Dancer2::Core::Hook->new(
              name => 'core.app.after_request',
              code => sub {
                  my $response = $Dancer2::Core::Route::RESPONSE;
  
                  # make sure an engine is defined, if not, nothing to do
                  my $engine = $app->session_engine;
                  defined $engine or return;
  
                  # if a session has been instantiated or we already had a
                  # session, first flush the session so cookie-based sessions can
                  # update the session ID if needed, then set the session cookie
                  # in the response
                  #
                  # if there is NO session object but the request has a cookie with
                  # a session key, create a dummy session with the same ID (without
                  # actually retrieving and flushing immediately) and generate the
                  # cookie header from the dummy session. Lazy Sessions FTW!
  
                  if ( $app->has_session ) {
                      my $session;
                      if ( $app->_has_session ) { # Session object exists
                          $session = $app->session;
                          $session->is_dirty and $engine->flush( session => $session );
                      }
                      else { # Cookie header exists. Create a dummy session object
                          my $cookie = $app->cookie( $engine->cookie_name );
                          my $session_id = $cookie->value;
                          $session = Dancer2::Core::Session->new( id => $session_id );
                      }
                      $engine->set_cookie_header(
                          response => $response,
                          session  => $session
                      );
                  }
                  elsif ( $app->has_destroyed_session ) {
                      my $session = $app->destroyed_session;
                      $engine->set_cookie_header(
                          response  => $response,
                          session   => $session,
                          destroyed => 1
                      );
                  }
              },
          )
      );
  }
  
  sub supported_hooks {
      qw/
        core.app.before_request
        core.app.after_request
        core.app.route_exception
        core.app.before_file_render
        core.app.after_file_render
        core.error.before
        core.error.after
        core.error.init
        /;
  }
  
  sub hook_aliases {
      {
          before                 => 'core.app.before_request',
          before_request         => 'core.app.before_request',
          after                  => 'core.app.after_request',
          after_request          => 'core.app.after_request',
          init_error             => 'core.error.init',
          before_error           => 'core.error.before',
          after_error            => 'core.error.after',
          on_route_exception     => 'core.app.route_exception',
  
          before_file_render         => 'core.app.before_file_render',
          after_file_render          => 'core.app.after_file_render',
          before_handler_file_render => 'handler.file.before_render',
          after_handler_file_render  => 'handler.file.after_render',
  
  
          # compatibility from Dancer1
          before_error_render    => 'core.error.before',
          after_error_render     => 'core.error.after',
          before_error_init      => 'core.error.init',
  
          # TODO: call $engine->hook_aliases as needed
          # But.. currently there are use cases where hook_aliases
          # are needed before the engines are intiialized :(
          before_template_render => 'engine.template.before_render',
          after_template_render  => 'engine.template.after_render',
          before_layout_render   => 'engine.template.before_layout_render',
          after_layout_render    => 'engine.template.after_layout_render',
          before_serializer      => 'engine.serializer.before',
          after_serializer       => 'engine.serializer.after',
      };
  }
  
  # FIXME not needed anymore, I suppose...
  sub api_version {2}
  
  sub register_plugin {
      my $self   = shift;
      my $plugin = shift;
  
      $self->log( core => "Registered $plugin");
  
      push @{ $self->plugins }, $plugin;
  }
  
  # This method overrides the default one from Role::ConfigReader
  sub settings {
      my $self = shift;
      +{ %{ Dancer2::runner()->config }, %{ $self->config } };
  }
  
  sub cleanup {
      my $self = shift;
      $self->clear_request;
      $self->clear_response;
      $self->clear_session;
      $self->clear_destroyed_session;
      # Clear engine attributes
      for my $engine ( @{ $self->defined_engines } ) {
          $engine->clear_session;
          $engine->clear_request;
      }
  }
  
  sub _validate_engine {
      my $self = shift;
      my $name = shift;
  
      grep +( $_ eq $name ), @{ $self->supported_engines }
          or croak "Engine '$name' is not supported.";
  }
  
  sub engine {
      my $self = shift;
      my $name = shift;
  
      $self->_validate_engine($name);
  
      my $attr_name = "${name}_engine";
      return $self->$attr_name;
  }
  
  sub template {
      my $self = shift;
  
      my $template = $self->template_engine;
      $template->set_settings( $self->config );
  
      # A session may exist but the route code may not have instantiated
      # the session object (sessions are lazy). If this is the case, do
      # that now, so the templates have the session data for rendering.
      $self->has_session && ! $template->has_session
          and $self->setup_session;
  
      # return content
      return $template->process( @_ );
  }
  
  sub hook_candidates {
      my $self = shift;
  
      my @engines = @{ $self->defined_engines };
  
      my @route_handlers;
      for my $handler ( @{ $self->route_handlers } ) {
          my $handler_code = $handler->{handler};
          blessed $handler_code and $handler_code->can('supported_hooks')
              and push @route_handlers, $handler_code;
      }
  
      # TODO : get the list of all plugins registered
      my @plugins = @{ $self->plugins };
  
      ( @route_handlers, @engines, @plugins );
  }
  
  sub all_hook_aliases {
      my $self = shift;
  
      my $aliases = $self->hook_aliases;
      for my $plugin ( @{ $self->plugins } ) {
          $aliases = { %{$aliases}, %{ $plugin->hook_aliases } };
      }
  
      return $aliases;
  }
  
  sub mime_type {
      my $self   = shift;
      my $runner = Dancer2::runner();
  
      exists $self->config->{default_mime_type}
          ? $runner->mime_type->default( $self->config->{default_mime_type} )
          : $runner->mime_type->reset_default;
  
      $runner->mime_type;
  }
  
  sub log {
      my $self  = shift;
      my $level = shift;
  
      my $logger = $self->logger_engine
        or croak "No logger defined";
  
      $logger->$level(@_);
  }
  
  sub send_error {
      my $self = shift;
      my ( $message, $status ) = @_;
  
      my $err = Dancer2::Core::Error->new(
            message    => $message,
            app        => $self,
          ( status     => $status     )x!! $status,
  
          $self->has_serializer_engine
              ? ( serializer => $self->serializer_engine )
              : (),
      )->throw;
  
      # Immediately return to dispatch if with_return coderef exists
      $self->has_with_return && $self->with_return->($err);
      return $err;
  }
  
  sub send_file {
      my $self    = shift;
      my $thing   = shift;
      my %options = @_;
  
      my ($content_type, $file_path);
  
      # are we're given a filehandle? (based on what Plack::Middleware::Lint accepts)
      my $is_filehandle = Plack::Util::is_real_fh($thing)
        || ( ref $thing eq 'GLOB' && *{$thing}{IO} && *{$thing}{IO}->can('getline') )
        || ( Scalar::Util::blessed($thing) && $thing->can('getline') );
      my ($fh) = ($thing)x!! $is_filehandle;
  
      # if we're given an IO::Scalar object, DTRT (take the scalar ref from it)
      if (Scalar::Util::blessed($thing) && $thing->isa('IO::Scalar')) {
          $thing = $thing->sref;
      }
  
      # if we're given a SCALAR reference, build a filehandle to it
      if ( ref $thing eq 'SCALAR' ) {
          open $fh, "<", $thing;
      }
  
      # If we haven't got a filehandle, create one to the requested content
      if (! $fh) {
          my $path = $thing;
          # remove prefix from given path (if not a filehandle)
          my $prefix = $self->prefix;
          if ( $prefix && $prefix ne '/' ) {
              $path =~ s/^\Q$prefix\E//;
          }
          # static file dir - either system root or public_dir
          my $dir = $options{system_path}
              ? File::Spec->rootdir
              : $ENV{DANCER_PUBLIC}
                  || $self->config->{public_dir}
                  || path( $self->location, 'public' );
  
          $file_path = Dancer2::Handler::File->merge_paths( $path, $dir );
          my $err_response = sub {
              my $status = shift;
              $self->response->status($status);
              $self->response->header( 'Content-Type', 'text/plain' );
              $self->response->content( Dancer2::Core::HTTP->status_message($status) );
              $self->with_return->( $self->response );
          };
          $err_response->(403) if !defined $file_path;
          $err_response->(404) if !-f $file_path;
          $err_response->(403) if !-r $file_path;
  
          # Read file content as bytes
          $fh = Dancer2::FileUtils::open_file( "<", $file_path );
          binmode $fh;
  
          $content_type = Dancer2::runner()->mime_type->for_file($file_path) || 'text/plain';
          if ( $content_type =~ m!^text/! ) {
               $content_type .= "; charset=" . ( $self->config->{charset} || "utf-8" );
          }
      }
  
      # Now we are sure we can render the file...
      $self->execute_hook( 'core.app.before_file_render', $file_path );
  
      # response content type
      ( exists $options{'content_type'} ) and $content_type = $options{'content_type'};
      ( defined $content_type )
        and $self->response->header('Content-Type' => $content_type );
  
      # content disposition
      ( exists $options{filename} )
        and $self->response->header( 'Content-Disposition' =>
            "attachment; filename=\"$options{filename}\"" );
  
      # use a delayed response unless server does not support streaming
      my $use_streaming = exists $options{streaming} ? $options{streaming} : 1;
      my $response;
      my $env = $self->request->env;
      if ( $env->{'psgi.streaming'} && $use_streaming ) {
          my $cb = sub {
              my $responder = $Dancer2::Core::Route::RESPONDER;
              my $res = $Dancer2::Core::Route::RESPONSE;
              return $responder->(
                  [ $res->status, $res->headers_to_array, $fh ]
              );
          };
          $response = Dancer2::Core::Response::Delayed->new(
              cb       => $cb,
              request  => $Dancer2::Core::Route::REQUEST,
              response => $Dancer2::Core::Route::RESPONSE,
          );
      }
      else {
          $response = $self->response;
          # direct assignment to hash element, avoids around modifier
          # trying to serialise this this content.
          $response->{content} = Dancer2::FileUtils::read_glob_content($fh);
          $response->is_encoded(1);    # bytes are already encoded
      }
  
      $self->execute_hook( 'core.app.after_file_render', $response );
      $self->with_return->( $response );
  }
  
  sub BUILD {
      my $self = shift;
      $self->init_route_handlers();
      $self->_init_hooks();
  }
  
  sub finish {
      my $self = shift;
      $self->register_route_handlers;
      $self->compile_hooks;
      @{$self->plugins} &&
        $self->plugins->[0]->_add_postponed_plugin_hooks(
          $self->postponed_hooks
      );
  }
  
  sub init_route_handlers {
      my $self = shift;
  
      my $handlers_config = $self->config->{route_handlers};
      for my $handler_data ( @{$handlers_config} ) {
          my ($handler_name, $config) = @{$handler_data};
          $config = {} if !ref($config);
  
          my $handler = $self->_factory->create(
              Handler         => $handler_name,
              app             => $self,
              %$config,
              postponed_hooks => $self->postponed_hooks,
          );
  
          push @{ $self->route_handlers }, {
              name    => $handler_name,
              handler => $handler,
          };
      }
  }
  
  sub register_route_handlers {
      my $self = shift;
      for my $handler ( @{$self->route_handlers} ) {
          my $handler_code = $handler->{handler};
          $handler_code->register($self);
      }
  }
  
  sub compile_hooks {
      my ($self) = @_;
  
      for my $position ( $self->supported_hooks ) {
          my $compiled_hooks = [];
          for my $hook ( @{ $self->hooks->{$position} } ) {
              Scalar::Util::weaken( my $app = $self );
              my $compiled = sub {
                  # don't run the filter if halt has been used
                  $Dancer2::Core::Route::RESPONSE &&
                  $Dancer2::Core::Route::RESPONSE->is_halted
                      and return;
  
                  eval  { $hook->(@_); 1; }
                  or do {
                      $app->cleanup;
                      $app->log('error', "Exception caught in '$position' filter: $@");
                      croak "Exception caught in '$position' filter: $@";
                  };
              };
  
              push @{$compiled_hooks}, $compiled;
          }
          $self->replace_hook( $position, $compiled_hooks );
      }
  }
  
  sub lexical_prefix {
      my $self   = shift;
      my $prefix = shift;
      my $cb     = shift;
  
      $prefix eq '/' and undef $prefix;
  
      # save the app prefix
      my $app_prefix = $self->prefix;
  
      # alter the prefix for the callback
      my $new_prefix =
          ( defined $app_prefix ? $app_prefix : '' )
        . ( defined $prefix     ? $prefix     : '' );
  
      # if the new prefix is empty, it's a meaningless prefix, just ignore it
      length $new_prefix and $self->prefix($new_prefix);
  
      eval { $cb->() };
      my $e = $@;
  
      # restore app prefix
      $self->prefix($app_prefix);
  
      $e and croak "Unable to run the callback for prefix '$prefix': $e";
  }
  
  sub add_route {
      my $self        = shift;
      my %route_attrs = @_;
  
      my $route =
        Dancer2::Core::Route->new( %route_attrs, prefix => $self->prefix );
  
      my $method = $route->method;
  
      push @{ $self->routes->{$method} }, $route;
  }
  
  sub route_exists {
      my $self  = shift;
      my $route = shift;
  
      my $routes = $self->routes->{ $route->method };
  
      foreach my $existing_route (@$routes) {
          $existing_route->spec_route eq $route->spec_route
              and return 1;
      }
  
      return 0;
  }
  
  sub routes_regexps_for {
      my $self   = shift;
      my $method = shift;
  
      return [ map $_->regexp, @{ $self->routes->{$method} } ];
  }
  
  sub cookie {
      my $self = shift;
  
      @_ == 1 and return $self->request->cookies->{ $_[0] };
  
      # writer
      my ( $name, $value, %options ) = @_;
      my $c =
        Dancer2::Core::Cookie->new( name => $name, value => $value, %options );
      $self->response->push_header( 'Set-Cookie' => $c->to_header );
  }
  
  sub redirect {
      my $self        = shift;
      my $destination = shift;
      my $status      = shift;
  
      # RFC 2616 requires an absolute URI with a scheme,
      # turn the URI into that if it needs it
  
      # Scheme grammar as defined in RFC 2396
      #  scheme = alpha *( alpha | digit | "+" | "-" | "." )
      my $scheme_re = qr{ [a-z][a-z0-9\+\-\.]* }ix;
      if ( $destination !~ m{^ $scheme_re : }x ) {
          $destination = $self->request->uri_for( $destination, {}, 1 );
      }
  
      $self->response->redirect( $destination, $status );
  
      # Short circuit any remaining before hook / route code
      # ('pass' and after hooks are still processed)
      $self->has_with_return
          and $self->with_return->($self->response);
  }
  
  sub halt {
     my $self = shift;
     $self->response->halt( @_ );
  
     # Short citcuit any remaining hook/route code
     $self->has_with_return
         and $self->with_return->($self->response);
  }
  
  sub pass {
     my $self = shift;
     $self->response->pass;
  
     # Short citcuit any remaining hook/route code
     $self->has_with_return
         and $self->with_return->($self->response);
  }
  
  sub forward {
      my $self    = shift;
      my $url     = shift;
      my $params  = shift;
      my $options = shift;
  
      my $new_request = $self->make_forward_to( $url, $params, $options );
  
      $self->has_with_return
          and $self->with_return->($new_request);
  
      # nothing else will run after this
  }
  
  # Create a new request which is a clone of the current one, apart
  # from the path location, which points instead to the new location
  # TODO this could be written in a more clean manner with a clone mechanism
  sub make_forward_to {
      my $self    = shift;
      my $url     = shift;
      my $params  = shift;
      my $options = shift;
  
      my $request = $self->request;
  
      # we clone the env to make sure we don't alter the existing one in $self
      my $env = { %{ $request->env } };
  
      $env->{PATH_INFO} = $url;
  
      my $new_request = Dancer2::Core::Request->new( env => $env, body_is_parsed => 1 );
      my $new_params = _merge_params( scalar( $request->params ), $params || {} );
  
      exists $options->{method} and
          $new_request->env->{'REQUEST_METHOD'} = $options->{method};
  
      # Copy params (these are already decoded)
      $new_request->{_params}       = $new_params;
      $new_request->{_body_params}  = $request->{_body_params};
      $new_request->{_query_params} = $request->{_query_params};
      $new_request->{_route_params} = $request->{_route_params};
      $new_request->{body}          = $request->body;
      $new_request->{headers}       = $request->headers;
  
      # If a session object was created during processing of the original request
      # i.e. a session object exists but no cookie existed
      # add a cookie so the dispatcher can assign the session to the appropriate app
      my $engine = $self->session_engine;
      $engine && $self->_has_session or return $new_request;
      my $name = $engine->cookie_name;
      exists $new_request->cookies->{$name} and return $new_request;
      $new_request->cookies->{$name} =
          Dancer2::Core::Cookie->new( name => $name, value => $self->session->id );
  
      return $new_request;
  }
  
  sub _merge_params {
      my $params = shift;
      my $to_add = shift;
  
      for my $key ( keys %$to_add ) {
          $params->{$key} = $to_add->{$key};
      }
      return $params;
  }
  
  sub app { shift }
  
  # DISPATCHER
  sub to_app {
      my $self = shift;
  
      # build engines
      {
          for ( qw<logger session template> ) {
              my $attr = "${_}_engine";
              $self->$attr;
          }
  
          # the serializer engine does not have a default
          # and is the only engine that can actually not have a value
          if ( $self->config->{'serializer'} ) {
              $self->serializer_engine;
          }
      }
  
      $self->finish;
  
      my $psgi = sub {
          my $env = shift;
  
          # pre-request sanity check
          my $method = uc $env->{'REQUEST_METHOD'};
          $Dancer2::Core::Types::supported_http_methods{$method}
              or return [
                  405,
                  [ 'Content-Type' => 'text/plain' ],
                  [ "Method Not Allowed\n\n$method is not supported." ]
              ];
  
          my $response;
          eval {
              $response = $self->dispatch($env)->to_psgi;
              1;
          } or do {
              return [
                  500,
                  [ 'Content-Type' => 'text/plain' ],
                  [ "Internal Server Error\n\n$@"  ],
              ];
          };
  
          return $response;
      };
  
      # Wrap with common middleware
      # FixMissingBodyInRedirect
      $psgi = Plack::Middleware::FixMissingBodyInRedirect->wrap( $psgi );
  
      # Static content passes through to app on 404, conditionally applied.
      # Construct the statis app to avoid a closure over $psgi
      if ( $self->config->{'static_handler'} ) {
          $psgi = Plack::Middleware::Static->wrap(
              $psgi,
              path => sub { -f path( $self->config->{public_dir}, shift ) },
              root => $self->config->{public_dir},
              content_type => sub { $self->mime_type->for_name(shift) },
          );
      }
  
      # Apply Head. After static so a HEAD request on static content DWIM.
      $psgi = Plack::Middleware::Head->wrap( $psgi );
      return $psgi;
  }
  
  sub dispatch {
      my $self = shift;
      my $env  = shift;
  
      my $runner  = Dancer2::runner();
      my $request = $runner->{'internal_request'} ||
                    $self->build_request($env);
      my $cname   = $self->session_engine->cookie_name;
  
  DISPATCH:
      while (1) {
          my $http_method = lc $request->method;
          my $path_info   =    $request->path_info;
  
          # Add request to app and engines
          $self->set_request($request);
  
          $self->log( core => "looking for $http_method $path_info" );
  
          ROUTE:
          foreach my $route ( @{ $self->routes->{$http_method} } ) {
              #warn "testing route " . $route->regexp . "\n";
              # TODO store in route cache
  
              # go to the next route if no match
              my $match = $route->match($request)
                  or next ROUTE;
  
              $request->_set_route_params($match);
  
              # Add session to app *if* we have a session and the request
              # has the appropriate cookie header for _this_ app.
              if ( my $sess = $runner->{'internal_sessions'}{$cname} ) {
                  $self->set_session($sess);
              }
  
              # calling the actual route
              my $response = Return::MultiLevel::with_return {
                  my ($return) = @_;
  
                  # stash the multilevel return coderef in the app
                  $self->has_with_return
                      or $self->set_with_return($return);
  
                  return $self->_dispatch_route($route);
              };
  
              # ensure we clear the with_return handler
              $self->clear_with_return;
  
              # handle forward requests
              if ( ref $response eq 'Dancer2::Core::Request' ) {
                  # this is actually a request, not response
                  # however, we need to clean up the request & response
                  $self->clear_request;
                  $self->clear_response;
  
                  # this is in case we're asked for an old-style dispatching
                  if ( $runner->{'internal_dispatch'} ) {
                      # Get the session object from the app before we clean up
                      # the request context, so we can propogate this to the
                      # next dispatch cycle (if required).
                      $self->_has_session
                          and $runner->{'internal_sessions'}{$cname} =
                              $self->session;
  
                      $runner->{'internal_forward'} = 1;
                      $runner->{'internal_request'} = $response;
                      return $self->response_not_found($request);
                  }
  
                  $request = $response;
                  next DISPATCH;
              }
  
              # from here we assume the response is a Dancer2::Core::Response
  
              # halted response, don't process further
              if ( $response->is_halted ) {
                  $self->cleanup;
                  delete $runner->{'internal_request'};
                  return $response;
              }
  
              # pass the baton if the response says so...
              if ( $response->has_passed ) {
                  ## A previous route might have used splat, failed
                  ## this needs to be cleaned from the request.
                  exists $request->{_params}{splat}
                      and delete $request->{_params}{splat};
  
                  $response->has_passed(0); # clear for the next round
  
                  # clear the content because if you pass it,
                  # the next route is in charge of catching it
                  $response->clear_content;
                  next ROUTE;
              }
  
              # it's just a regular response
              $self->execute_hook( 'core.app.after_request', $response );
              $self->cleanup;
              delete $runner->{'internal_request'};
  
              return $response;
          }
  
          # we don't actually want to continue the loop
          last;
      }
  
      # No response! ensure Core::Dispatcher recognizes this failure
      # so it can try the next Core::App
      # and set the created request so we don't create it again
      # (this is important so we don't ignore the previous body)
      if ( $runner->{'internal_dispatch'} ) {
          $runner->{'internal_404'}     = 1;
          $runner->{'internal_request'} = $request;
      }
  
      # Render 404 response, cleanup, and return the response.
      my $response = $self->response_not_found($request);
      $self->cleanup;
      return $response;
  }
  
  sub build_request {
      my ( $self, $env ) = @_;
  
      # If we have an app, send the serialization engine
      my $request = Dancer2::Core::Request->new(
            env             => $env,
            is_behind_proxy => $self->settings->{'behind_proxy'} || 0,
  
            $self->has_serializer_engine
                ? ( serializer => $self->serializer_engine )
                : (),
      );
  
      return $request;
  }
  
  # Call any before hooks then the matched route.
  sub _dispatch_route {
      my ( $self, $route ) = @_;
  
      local $@;
      eval { $self->execute_hook( 'core.app.before_request', $self ); 1; }
          or return $self->response_internal_error($@);
      my $response = $self->response;
  
      if ( $response->is_halted ) {
          return $self->_prep_response( $response );
      }
  
      $response = eval {
          $route->execute($self)
      } or return $self->response_internal_error($@);
  
      return $response;
  }
  
  sub _prep_response {
      my ( $self, $response, $content ) = @_;
  
      # The response object has no back references to the content or app
      # Update the default_content_type of the response if any value set in
      # config so it can be applied when the response is encoded/returned.
      my $config = $self->config;
      if ( exists $config->{content_type}
        and my $ct = $config->{content_type} ) {
          $response->default_content_type($ct);
      }
  
      # if we were passed any content, set it in the response
      defined $content && $response->content($content);
      return $response;
  }
  
  sub response_internal_error {
      my ( $self, $error ) = @_;
  
      $self->log( error => "Route exception: $error" );
      $self->execute_hook( 'core.app.route_exception', $self, $error );
  
      local $Dancer2::Core::Route::REQUEST  = $self->request;
      local $Dancer2::Core::Route::RESPONSE = $self->response;
  
      return Dancer2::Core::Error->new(
          app       => $self,
          status    => 500,
          exception => $error,
      )->throw;
  }
  
  sub response_not_found {
      my ( $self, $request ) = @_;
  
      $self->set_request($request);
  
      local $Dancer2::Core::Route::REQUEST  = $self->request;
      local $Dancer2::Core::Route::RESPONSE = $self->response;
  
      my $response = Dancer2::Core::Error->new(
          app    => $self,
          status  => 404,
          message => $request->path,
      )->throw;
  
      $self->cleanup;
  
      return $response;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::App - encapsulation of Dancer2 packages
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  Everything a package that uses Dancer2 does is encapsulated into a
  C<Dancer2::Core::App> instance. This class defines all that can be done in such
  objects.
  
  Mainly, it will contain all the route handlers, the configuration settings and
  the hooks that are defined in the calling package.
  
  Note that with Dancer2, everything that is done within a package is scoped to
  that package, thanks to that encapsulation.
  
  =head1 ATTRIBUTES
  
  =head2 plugins
  
  =head2 runner_config
  
  =head2 default_config
  
  =head2 with_return
  
  Used to cache the coderef from L<Return::MultiLevel> within the dispatcher.
  
  =head2 destroyed_session
  
  We cache a destroyed session here; once this is set we must not attempt to
  retrieve the session from the cookie in the request.  If no new session is
  created, this is set (with expiration) as a cookie to force the browser to
  expire the cookie.
  
  =head1 METHODS
  
  =head2 has_session
  
  Returns true if session engine has been defined and if either a session
  object has been instantiated or if a session cookie was found and not
  subsequently invalidated.
  
  =head2 destroy_session
  
  Destroys the current session and ensures any subsequent session is created
  from scratch and not from the request session cookie
  
  =head2 register_plugin
  
  =head2 redirect($destination, $status)
  
  Sets a redirect in the response object.  If $destination is not an absolute URI, then it will
  be made into an absolute URI, relative to the URI in the request.
  
  =head2 halt
  
  Flag the response object as 'halted'.
  
  If called during request dispatch, immediatly returns the response
  to the dispatcher and after hooks will not be run.
  
  =head2 pass
  
  Flag the response object as 'passed'.
  
  If called during request dispatch, immediatly returns the response
  to the dispatcher.
  
  =head2 forward
  
  Create a new request which is a clone of the current one, apart
  from the path location, which points instead to the new location.
  This is used internally to chain requests using the forward keyword.
  
  This method takes 3 parameters: the url to forward to, followed by an
  optional hashref of parameters added to the current request parameters,
  followed by a hashref of options regarding the redirect, such as
  C<method> to change the request method.
  
  For example:
  
      forward '/login', { login_failed => 1 }, { method => 'GET' });
  
  =head2 lexical_prefix
  
  Allow for setting a lexical prefix
  
      $app->lexical_prefix('/blog', sub {
          ...
      });
  
  All the route defined within the callback will have a prefix appended to the
  current one.
  
  =head2 add_route
  
  Register a new route handler.
  
      $app->add_route(
          method  => 'get',
          regexp  => '/somewhere',
          code    => sub { ... },
          options => $conditions,
      );
  
  =head2 route_exists
  
  Check if a route already exists.
  
      my $route = Dancer2::Core::Route->new(...);
      if ($app->route_exists($route)) {
          ...
      }
  
  =head2 routes_regexps_for
  
  Sugar for getting the ordered list of all registered route regexps by method.
  
      my $regexps = $app->routes_regexps_for( 'get' );
  
  Returns an ArrayRef with the results.
  
  =head2 app
  
  Returns itself. This is simply available as a shim to help transition from
  a previous version in which hooks were sent a context object (originally
  C<Dancer2::Core::Context>) which has since been removed.
  
      # before
      hook before => sub {
          my $ctx = shift;
          my $app = $ctx->app;
      };
  
      # after
      hook before => sub {
          my $app = shift;
      };
  
  This meant that C<< $app->app >> would fail, so this method has been provided
  to make it work.
  
      # now
      hook before => sub {
          my $WannaBeCtx = shift;
          my $app        = $WannaBeContext->app; # works
      };
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_APP

$fatpacked{"Dancer2/Core/Cookie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_COOKIE';
  package Dancer2::Core::Cookie;
  # ABSTRACT: A cookie representing class
  $Dancer2::Core::Cookie::VERSION = '0.162000';
  use Moo;
  use URI::Escape;
  use Dancer2::Core::Types;
  use Dancer2::Core::Time;
  use Carp 'croak';
  use overload '""' => \&_get_value;
  
  sub to_header {
      my $self   = shift;
      my $header = '';
  
      my $value = join( '&', map uri_escape($_), $self->value );
      my $no_httponly = defined( $self->http_only ) && $self->http_only == 0;
  
      my @headers = $self->name . '=' . $value;
      push @headers, "path=" . $self->path       if $self->path;
      push @headers, "expires=" . $self->expires if $self->expires;
      push @headers, "domain=" . $self->domain   if $self->domain;
      push @headers, "Secure"                    if $self->secure;
      push @headers, 'HttpOnly' unless $no_httponly;
  
      return join '; ', @headers;
  }
  
  has value => (
      is       => 'rw',
      isa      => ArrayRef,
      required => 0,
      coerce   => sub {
          my $value = shift;
          my @values =
              ref $value eq 'ARRAY' ? @$value
            : ref $value eq 'HASH'  ? %$value
            :                         ($value);
          return [@values];
      },
  );
  
  around value => sub {
      my $orig  = shift;
      my $self  = shift;
      my $array = $orig->( $self, @_ );
      return wantarray ? @$array : $array->[0];
  };
  
  # this is only for overloading; need a real sub to refer to, as the Moose
  # attribute accessor won't be available at that point.
  sub _get_value { shift->value }
  
  has name => (
      is       => 'rw',
      isa      => Str,
      required => 1,
  );
  
  has expires => (
      is       => 'rw',
      isa      => Str,
      required => 0,
      coerce   => sub {
          Dancer2::Core::Time->new( expression => $_[0] )->gmt_string;
      },
  );
  
  has domain => (
      is       => 'rw',
      isa      => Str,
      required => 0,
  );
  
  has path => (
      is        => 'rw',
      isa       => Str,
      default   => sub {'/'},
      predicate => 1,
  );
  
  has secure => (
      is       => 'rw',
      isa      => Bool,
      required => 0,
      default  => sub {0},
  );
  
  has http_only => (
      is       => 'rw',
      isa      => Bool,
      required => 0,
      default  => sub {0},
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Cookie - A cookie representing class
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
      use Dancer2::Core::Cookie;
  
      my $cookie = Dancer2::Core::Cookie->new(
          name => $cookie_name, value => $cookie_value
      );
  
      my $value = $cookie->value;
  
      print "$cookie"; # objects stringify to their value.
  
  =head1 DESCRIPTION
  
  Dancer2::Core::Cookie provides a HTTP cookie object to work with cookies.
  
  =head1 ATTRIBUTES
  
  =head2 value
  
  The cookie's value.
  
  (Note that cookie objects use overloading to stringify to their value, so if
  you say e.g. return "Hi, $cookie", you'll get the cookie's value there.)
  
  In list context, returns a list of potentially multiple values; in scalar
  context, returns just the first value.  (So, if you expect a cookie to have
  multiple values, use list context.)
  
  =head2 name
  
  The cookie's name.
  
  =head2 expires
  
  The cookie's expiration date.  There are several formats.
  
  Unix epoch time like 1288817656 to mean "Wed, 03-Nov-2010 20:54:16 GMT"
  
  It also supports a human readable offset from the current time such as "2 hours".
  See the documentation of L<Dancer2::Core::Time> for details of all supported
  formats.
  
  =head2 domain
  
  The cookie's domain.
  
  =head2 path
  
  The cookie's path.
  
  =head2 secure
  
  If true, it instructs the client to only serve the cookie over secure
  connections such as https.
  
  =head2 http_only
  
  By default, cookies are created with a property, named C<HttpOnly>,
  that can be used for security, forcing the cookie to be used only by
  the server (via HTTP) and not by any JavaScript code.
  
  If your cookie is meant to be used by some JavaScript code, set this
  attribute to 0.
  
  =head1 METHODS
  
  =head2 my $cookie=Dancer2::Core::Cookie->new(%opts);
  
  Create a new Dancer2::Core::Cookie object.
  
  You can set any attribute described in the I<ATTRIBUTES> section above.
  
  =head2 my $header=$cookie->to_header();
  
  Creates a proper HTTP cookie header from the content.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_COOKIE

$fatpacked{"Dancer2/Core/DSL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_DSL';
  # ABSTRACT: Dancer2's Domain Specific Language (DSL)
  
  package Dancer2::Core::DSL;
  $Dancer2::Core::DSL::VERSION = '0.162000';
  use Moo;
  use Carp;
  use Class::Load 'load_class';
  use Dancer2::Core::Hook;
  use Dancer2::FileUtils;
  use Dancer2::Core::Response::Delayed;
  
  with 'Dancer2::Core::Role::DSL';
  
  sub hook_aliases { +{} }
  sub supported_hooks { () }
  
  sub _add_postponed_plugin_hooks {
      my ( $self, $postponed_hooks) = @_;
  
      $postponed_hooks = $postponed_hooks->{'plugin'};
      return unless defined $postponed_hooks;
  
      for my $plugin ( keys %{$postponed_hooks} ) {
          for my $name ( keys %{$postponed_hooks->{$plugin} } ) {
              my $hook   = $postponed_hooks->{$plugin}{$name}{hook};
              my $caller = $postponed_hooks->{$plugin}{$name}{caller};
  
              $self->has_hook($name)
                or croak "plugin $plugin does not support the hook `$name'. ("
                . join( ", ", @{$caller} ) . ")";
  
              $self->add_hook($hook);
          }
      }
  }
  
  sub dsl_keywords {
  
      # the flag means : 1 = is global, 0 = is not global. global means can be
      # called from anywhere. not global means must be called from within a route
      # handler
      {   any                  => { is_global => 1 },
          app                  => { is_global => 1 },
          captures             => { is_global => 0 },
          config               => { is_global => 1 },
          content              => { is_global => 0 },
          content_type         => { is_global => 0 },
          context              => { is_global => 0 },
          cookie               => { is_global => 0 },
          cookies              => { is_global => 0 },
          dance                => { is_global => 1 },
          dancer_app           => { is_global => 1 },
          dancer_version       => { is_global => 1 },
          dancer_major_version => { is_global => 1 },
          debug                => { is_global => 1 },
          del                  => { is_global => 1 },
          delayed              => {
              is_global => 0, prototype => '&',
          },
          dirname              => { is_global => 1 },
          done                 => { is_global => 0 },
          dsl                  => { is_global => 1 },
          engine               => { is_global => 1 },
          error                => { is_global => 1 },
          false                => { is_global => 1 },
          flush                => { is_global => 0 },
          forward              => { is_global => 0 },
          from_dumper          => { is_global => 1 },
          from_json            => { is_global => 1 },
          from_yaml            => { is_global => 1 },
          get                  => { is_global => 1 },
          halt                 => { is_global => 0 },
          header               => { is_global => 0 },
          headers              => { is_global => 0 },
          hook                 => { is_global => 1 },
          info                 => { is_global => 1 },
          log                  => { is_global => 1 },
          mime                 => { is_global => 1 },
          options              => { is_global => 1 },
          param                => { is_global => 0 },
          params               => { is_global => 0 },
          pass                 => { is_global => 0 },
          patch                => { is_global => 1 },
          path                 => { is_global => 1 },
          post                 => { is_global => 1 },
          prefix               => { is_global => 1 },
          psgi_app             => { is_global => 1 },
          push_header          => { is_global => 0 },
          put                  => { is_global => 1 },
          redirect             => { is_global => 0 },
          request              => { is_global => 0 },
          response             => { is_global => 0 },
          runner               => { is_global => 1 },
          send_error           => { is_global => 0 },
          send_file            => { is_global => 0 },
          session              => { is_global => 0 },
          set                  => { is_global => 1 },
          setting              => { is_global => 1 },
          splat                => { is_global => 0 },
          start                => { is_global => 1 },
          status               => { is_global => 0 },
          template             => { is_global => 0 },
          to_app               => { is_global => 1 },
          to_dumper            => { is_global => 1 },
          to_json              => { is_global => 1 },
          to_yaml              => { is_global => 1 },
          true                 => { is_global => 1 },
          upload               => { is_global => 0 },
          uri_for              => { is_global => 0 },
          var                  => { is_global => 0 },
          vars                 => { is_global => 0 },
          warning              => { is_global => 1 },
      };
  }
  
  sub dancer_app     { shift->app }
  sub dancer_version { Dancer2->VERSION }
  
  sub dancer_major_version {
      return ( split /\./, dancer_version )[0];
  }
  
  sub log     { shift->app->log( @_ ) }
  sub debug   { shift->app->log( debug   => @_ ) }
  sub info    { shift->app->log( info    => @_ ) }
  sub warning { shift->app->log( warning => @_ ) }
  sub error   { shift->app->log( error   => @_ ) }
  
  sub true  {1}
  sub false {0}
  
  sub dirname { shift and Dancer2::FileUtils::dirname(@_) }
  sub path    { shift and Dancer2::FileUtils::path(@_) }
  
  sub config { shift->app->settings }
  
  sub engine { shift->app->engine(@_) }
  
  sub setting { shift->app->setting(@_) }
  
  sub set { shift->setting(@_) }
  
  sub template { shift->app->template(@_) }
  
  sub session {
      my ( $self, $key, $value ) = @_;
  
      # shortcut reads if no session exists, so we don't
      # instantiate sessions for no reason
      if ( @_ == 2 ) {
          return unless $self->app->has_session;
      }
  
      my $session = $self->app->session
          || croak "No session available, a session engine needs to be set";
  
      $self->app->setup_session;
  
      # return the session object if no key
      @_ == 1 and return $session;
  
      # read if a key is provided
      @_ == 2 and return $session->read($key);
  
  
      # write to the session or delete if value is undef
      if ( defined $value ) {
          $session->write( $key => $value );
      }
      else {
          $session->delete($key);
      }
  }
  
  sub send_error { shift->app->send_error(@_) }
  
  sub send_file { shift->app->send_file(@_) }
  
  #
  # route handlers & friends
  #
  
  sub hook {
      my ( $self, $name, $code ) = @_;
      $self->app->add_hook(
          Dancer2::Core::Hook->new( name => $name, code => $code ) );
  }
  
  sub prefix {
      my $app = shift->app;
      @_ == 1
        ? $app->prefix(@_)
        : $app->lexical_prefix(@_);
  }
  
  sub halt { shift->app->halt(@_) }
  
  sub del     { shift->_normalize_route( [qw/delete  /], @_ ) }
  sub get     { shift->_normalize_route( [qw/get head/], @_ ) }
  sub options { shift->_normalize_route( [qw/options /], @_ ) }
  sub patch   { shift->_normalize_route( [qw/patch   /], @_ ) }
  sub post    { shift->_normalize_route( [qw/post    /], @_ ) }
  sub put     { shift->_normalize_route( [qw/put     /], @_ ) }
  
  sub any {
      my $self = shift;
  
      # If they've supplied their own list of methods,
      # expand del, otherwise give them the default list.
      if ( ref $_[0] eq 'ARRAY' ) {
          s/^del$/delete/ for @{ $_[0] };
      }
      else {
          unshift @_, [qw/delete get head options patch post put/];
      }
  
      $self->_normalize_route(@_);
  }
  
  sub _normalize_route {
      my $app     = shift->app;
      my $methods = shift;
      my %args;
  
      # Options are optional, deduce their presence from arg length.
      # @_ = ( REGEXP, OPTIONS, CODE )
      # or
      # @_ = ( REGEXP, CODE )
      @args{qw/regexp options code/} = @_ == 3 ? @_ : ( $_[0], {}, $_[1] );
  
      $app->add_route( %args, method => $_ ) for @{$methods};
  }
  
  #
  # Server startup
  #
  
  # access to the runner singleton
  # will be populated on-the-fly when needed
  # this singleton contains anything needed to start the application server
  sub runner { Dancer2->runner }
  
  # start the server
  sub start { shift->runner->start }
  
  sub dance { shift->start(@_) }
  
  sub psgi_app {
      my $self = shift;
  
      $self->app->to_app;
  }
  
  sub to_app { shift->app->to_app }
  
  #
  # Response alterations
  #
  
  sub status {
      $Dancer2::Core::Route::RESPONSE->status( $_[1] );
  }
  
  sub push_header {
      shift;
      $Dancer2::Core::Route::RESPONSE->push_header(@_);
  }
  
  sub header {
      shift;
      $Dancer2::Core::Route::RESPONSE->header(@_);
  }
  
  sub headers {
      shift;
      $Dancer2::Core::Route::RESPONSE->header(@_);
  }
  
  sub content {
      shift;
  
      # simple synchronous response
      my $responder = $Dancer2::Core::Route::RESPONDER
          or croak 'Cannot use content keyword outside delayed response';
  
      # flush if wasn't flushed before
      if ( !$Dancer2::Core::Route::WRITER ) {
          my $response = $Dancer2::Core::Route::RESPONSE;
          $Dancer2::Core::Route::WRITER = $responder->([
              $response->status, $response->headers_to_array,
          ]);
      }
  
      $Dancer2::Core::Route::WRITER->write(@_);
  }
  
  sub content_type {
      shift;
      $Dancer2::Core::Route::RESPONSE->content_type(@_);
  }
  
  sub delayed {
      my ( $dsl, $cb ) = @_;
  
      # first time, responder doesn't exist yet
      $Dancer2::Core::Route::RESPONDER
          or return Dancer2::Core::Response::Delayed->new(
              cb       => $cb,
              request  => $Dancer2::Core::Route::REQUEST,
              response => $Dancer2::Core::Route::RESPONSE,
          );
  
      # we're in an async request process
      my $request   = $Dancer2::Core::Route::REQUEST;
      my $response  = $Dancer2::Core::Route::RESPONSE;
      my $responder = $Dancer2::Core::Route::RESPONDER;
      my $writer    = $Dancer2::Core::Route::WRITER;
  
      return sub {
          local $Dancer2::Core::Route::REQUEST   = $request;
          local $Dancer2::Core::Route::RESPONSE  = $response;
          local $Dancer2::Core::Route::RESPONDER = $responder;
          local $Dancer2::Core::Route::WRITER    = $writer;
  
          $cb->(@_);
      };
  }
  
  sub flush {
      my $responder = $Dancer2::Core::Route::RESPONDER
          or croak 'flush() called outside streaming response';
  
      my $response = $Dancer2::Core::Route::RESPONSE;
      $Dancer2::Core::Route::WRITER = $responder->([
          $response->status, $response->headers_to_array,
      ]);
  }
  
  sub done {
      my $writer = $Dancer2::Core::Route::WRITER
          or croak 'done() called outside streaming response';
  
      $writer->close;
  }
  
  sub pass         { shift->app->pass }
  
  #
  # Route handler helpers
  #
  
  sub context {
      carp "DEPRECATED: please use the 'app' keyword instead of 'context'";
      shift->app;
  }
  
  sub request { $Dancer2::Core::Route::REQUEST }
  
  sub response { $Dancer2::Core::Route::RESPONSE }
  
  sub upload { shift; $Dancer2::Core::Route::REQUEST->upload(@_); }
  
  sub captures { $Dancer2::Core::Route::REQUEST->captures }
  
  sub uri_for { shift; $Dancer2::Core::Route::REQUEST->uri_for(@_); }
  
  sub splat { $Dancer2::Core::Route::REQUEST->splat }
  
  sub params { shift; $Dancer2::Core::Route::REQUEST->params(@_); }
  
  sub param { shift; $Dancer2::Core::Route::REQUEST->param(@_); }
  
  sub redirect { shift->app->redirect(@_) }
  
  sub forward { shift->app->forward(@_) }
  
  sub vars { $Dancer2::Core::Route::REQUEST->vars }
  
  sub var  { shift; $Dancer2::Core::Route::REQUEST->var(@_); }
  
  sub cookies { $Dancer2::Core::Route::REQUEST->cookies }
  sub cookie { shift->app->cookie(@_) }
  
  sub mime {
      my $self = shift;
      if ( $self->app ) {
          return $self->app->mime_type;
      }
      else {
          my $runner = $self->runner;
          $runner->mime_type->reset_default;
          return $runner->mime_type;
      }
  }
  
  #
  # engines
  #
  
  sub from_json {
      shift; # remove first element
      require Dancer2::Serializer::JSON;
      Dancer2::Serializer::JSON::from_json(@_);
  }
  
  sub to_json {
      shift; # remove first element
      require Dancer2::Serializer::JSON;
      Dancer2::Serializer::JSON::to_json(@_);
  }
  
  sub from_yaml {
      shift; # remove first element
      require Dancer2::Serializer::YAML;
      Dancer2::Serializer::YAML::from_yaml(@_);
  }
  
  sub to_yaml {
      shift; # remove first element
      require Dancer2::Serializer::YAML;
      Dancer2::Serializer::YAML::to_yaml(@_);
  }
  
  sub from_dumper {
      shift; # remove first element
      require Dancer2::Serializer::Dumper;
      Dancer2::Serializer::Dumper::from_dumper(@_);
  }
  
  sub to_dumper {
      shift; # remove first element
      require Dancer2::Serializer::Dumper;
      Dancer2::Serializer::Dumper::to_dumper(@_);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::DSL - Dancer2's Domain Specific Language (DSL)
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 FUNCTIONS
  
  =head2 setting
  
  Lets you define settings and access them:
      setting('foo' => 42);
      setting('foo' => 42, 'bar' => 43);
      my $foo=setting('foo');
  
  If settings were defined returns number of settings.
  
  =head2 set ()
  
  alias for L<setting>:
      set('foo' => '42');
      my $port=set('port');
  
  =head1 SEE ALSO
  
  L<http://advent.perldancer.org/2010/18>
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_DSL

$fatpacked{"Dancer2/Core/Dispatcher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_DISPATCHER';
  package Dancer2::Core::Dispatcher;
  # ABSTRACT: Class for dispatching request to the appropriate route handler
  $Dancer2::Core::Dispatcher::VERSION = '0.162000';
  use Moo;
  
  use Dancer2::Core::Types;
  use Dancer2::Core::Request;
  use Dancer2::Core::Response;
  
  has apps => (
      is      => 'rw',
      isa     => ArrayRef,
      default => sub { [] },
  );
  
  has apps_psgi => (
      is      => 'ro',
      isa     => ArrayRef,
      lazy    => 1,
      builder => '_build_apps_psgi',
  );
  
  sub _build_apps_psgi {
      my $self = shift;
      return [ map +( $_->name, $_->to_app ), @{ $self->apps } ];
  }
  
  sub dispatch {
      my ( $self, $env ) = @_;
      my @apps = @{ $self->apps_psgi };
  
      DISPATCH: while (1) {
          for ( my $i = 0; $i < @apps; $i += 2 ) {
              my ( $app_name, $app ) = @apps[ $i, $i + 1 ];
  
              my $response = $app->($env);
  
              # check for an internal request
              delete Dancer2->runner->{'internal_forward'}
                  and next DISPATCH;
  
              # the app raised a flag saying it couldn't match anything
              # which is different than "I matched and it's a 404"
              delete Dancer2->runner->{'internal_404'}
                  or do {
                      delete Dancer2->runner->{'internal_request'};
                      return $response;
                  };
          }
  
          # don't run anymore
          delete Dancer2->runner->{'internal_request'};
          last;
      } # while
  
      # a 404 on all apps, using the first app
      my $default_app = $self->apps->[0];
      my $request     = $default_app->build_request($env);
      return $default_app->response_not_found($request)->to_psgi;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Dispatcher - Class for dispatching request to the appropriate route handler
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
      use Dancer2::Core::Dispatcher;
  
      # Create an instance of dispatcher
      my $dispatcher = Dancer2::Core::Dispatcher->new( apps => [$app] );
  
      # Dispatch a request
      my $resp = $dispatcher->dispatch($env)->to_psgi;
  
      # Capture internal error of a response (if any) after a dispatch
      $dispatcher->response_internal_error($app, $error);
  
      # Capture response not found for an application the after dispatch
      $dispatcher->response_not_found($env);
  
  =head1 ATTRIBUTES
  
  =head2 apps
  
  The apps is an array reference to L<Dancer2::Core::App>.
  
  =head2 default_content_type
  
  The default_content_type is a string which represents the context of the
  request. This attribute is read-only.
  
  =head1 METHODS
  
  =head2 dispatch
  
  The C<dispatch> method accepts the list of applications, hash reference for
  the B<env> attribute of L<Dancer2::Core::Request> and optionally the request
  object and an env as input arguments.
  
  C<dispatch> returns a response object of L<Dancer2::Core::Response>.
  
  Any before hook and matched route code is wrapped using L<Return::MultiLevel>
  to allow DSL keywords such as forward and redirect to short-circuit remaining code
  without having to throw an exception. L<Return::MultiLevel> will use L<Scope::Upper>
  (an XS module) if it is available.
  
  =head2 response_internal_error
  
  The C<response_internal_error> takes as input the list of applications and
  a variable error and returns an object of L<Dancer2::Core::Error>.
  
  =head2 response_not_found
  
  The C<response_not_found> consumes as input the list of applications and an
  object of type L<Dancer2::Core::App> and returns an object
  L<Dancer2::Core::Error>.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_DISPATCHER

$fatpacked{"Dancer2/Core/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ERROR';
  package Dancer2::Core::Error;
  # ABSTRACT: Class representing fatal errors
  $Dancer2::Core::Error::VERSION = '0.162000';
  use Moo;
  use Carp;
  use Dancer2::Core::Types;
  use Dancer2::Core::HTTP;
  use Data::Dumper;
  use Dancer2::FileUtils qw/path open_file/;
  use Sub::Quote;
  use Safe::Isa;
  
  has app => (
      is        => 'ro',
      isa       => InstanceOf['Dancer2::Core::App'],
      predicate => 'has_app',
  );
  
  has show_errors => (
      is      => 'ro',
      isa     => Bool,
      default => sub {
          my $self = shift;
  
          $self->has_app
              and return $self->app->setting('show_errors');
      },
  );
  
  has charset => (
      is      => 'ro',
      isa     => Str,
      default => sub {'UTF-8'},
  );
  
  has type => (
      is      => 'ro',
      isa     => Str,
      default => sub {'Runtime Error'},
  );
  
  has title => (
      is      => 'ro',
      isa     => Str,
      lazy    => 1,
      builder => '_build_title',
  );
  
  sub _build_title {
      my ($self) = @_;
      my $title = 'Error ' . $self->status;
      if ( my $msg = Dancer2::Core::HTTP->status_message($self->status) ) {
          $title .= ' - ' . $msg;
      }
  
      return $title;
  }
  
  has template => (
      is => 'ro',
  
  #    isa => sub { ref($_[0]) eq 'SCALAR' || ReadableFilePath->(@_) },
      lazy    => 1,
      builder => '_build_error_template',
  );
  
  sub _build_error_template {
      my ($self) = @_;
  
      # look for a template named after the status number.
      # E.g.: views/404.tt  for a TT template
      return $self->status
        if -f $self->app->template_engine
            ->view_pathname( $self->status );
  
      return;
  }
  
  has static_page => (
      is      => 'ro',
      lazy    => 1,
      builder => '_build_static_page',
  );
  
  sub _build_static_page {
      my ($self) = @_;
  
      # TODO there must be a better way to get it
      my $public_dir = $ENV{DANCER_PUBLIC}
        || ( $self->has_app && $self->app->config->{public_dir} );
  
      my $filename = sprintf "%s/%d.html", $public_dir, $self->status;
  
      open my $fh, '<', $filename or return;
  
      local $/ = undef;    # slurp time
  
      return <$fh>;
  }
  
  sub default_error_page {
      my $self = shift;
  
      require Template::Tiny;
  
      my $uri_base = $self->has_app && $self->app->has_request ?
          $self->app->request->uri_base : '';
  
      my $opts = {
          title    => $self->title,
          charset  => $self->charset,
          content  => $self->show_errors ? $self->full_message : $self->message || 'Wooops, something went wrong',
          version  => Dancer2->VERSION,
          uri_base => $uri_base,
      };
  
      Template::Tiny->new->process( \<<"END_TEMPLATE", $opts, \my $output );
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="[% charset %]">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>[% title %]</title>
    <link rel="stylesheet" href="[% uri_base %]/css/error.css">
  </head>
  <body>
  <h1>[% title %]</h1>
  <div id="content">
  [% content %]
  </div>
  <div id="footer">
  Powered by <a href="http://perldancer.org/">Dancer2</a> [% version %]
  </div>
  </body>
  </html>
  END_TEMPLATE
  
      return $output;
  }
  
  has status => (
      is      => 'ro',
      default => sub {500},
      isa     => Num,
  );
  
  has message => (
      is      => 'ro',
      isa     => Str,
      lazy    => 1,
      default => sub { '' },
  );
  
  sub full_message {
      my ($self) = @_;
      my $html_output = "<h2>" . $self->type . "</h2>";
      $html_output .= $self->backtrace;
      $html_output .= $self->environment;
      return $html_output;
  }
  
  has serializer => (
      is        => 'ro',
      isa       => Sub::Quote::quote_sub(q{
          $_[0]
              ? $_[0]->$_DOES('Dancer2::Core::Role::Serializer')
              : 1;
      }),
      builder   => '_build_serializer',
  );
  
  sub _build_serializer {
      my ($self) = @_;
  
      $self->has_app && $self->app->has_serializer_engine
          and return $self->app->serializer_engine;
  
      return;
  }
  
  sub BUILD {
      my ($self) = @_;
  
      $self->has_app &&
        $self->app->execute_hook( 'core.error.init', $self );
  }
  
  has exception => (
      is        => 'ro',
      isa       => Str,
      predicate => 1,
      coerce    => sub {
          # Until we properly support exception objects, we shouldn't barf on
          # them because that hides the actual error, if object overloads "",
          # which most exception objects do, this will result in a nicer string.
          # other references will produce a meaningless error, but that is
          # better than a meaningless stacktrace
          return "$_[0]"
      }
  );
  
  has response => (
      is      => 'rw',
      lazy    => 1,
      default => sub {
          my $self = shift;
          my $serializer = $self->serializer;
          return Dancer2::Core::Response->new(
              ( serializer => $serializer )x!! $serializer
          );
      }
  );
  
  has content_type => (
      is      => 'ro',
      lazy    => 1,
      default => sub {
          my $self = shift;
          $self->serializer
              ? $self->serializer->content_type
              : 'text/html'
      },
  );
  
  has content => (
      is      => 'ro',
      lazy    => 1,
      builder => '_build_content',
  );
  
  sub _build_content {
      my $self = shift;
  
      # return a hashref if a serializer is available
      if ( $self->serializer ) {
          my $content = {
              message => $self->message,
              title   => $self->title,
              status  => $self->status,
          };
          $content->{exception} = $self->exception
            if $self->has_exception;
          return $content;
      }
  
      # otherwise we check for a template, for a static file,
      # for configured error_template, and, if all else fails,
      # the default error page
      if ( $self->has_app and $self->template ) {
          # Render the template using apps' template engine.
          # This may well be what caused the initial error, in which
          # case we fall back to static page if any error was thrown.
          # Note: this calls before/after render hooks.
          my $content = eval {
              $self->app->template(
                  $self->template,
                  {   title     => $self->title,
                      content   => $self->message,
                      exception => $self->exception,
                      status    => $self->status,
                  }
              );
          };
          $@ && $self->app->engine('logger')->log( warning => $@ );
  
          # return rendered content unless there was an error.
          return $content if defined $content;
      }
  
      # It doesn't make sense to return a static page if show_errors is on
      if ( !$self->show_errors && (my $content = $self->static_page) ) {
          return $content;
      }
  
      if ($self->has_app && $self->app->config->{error_template}) {
          my $content = eval {
              $self->app->template(
                  $self->app->config->{error_template},
                  {   title     => $self->title,
                      content   => $self->message,
                      exception => $self->exception,
                      status    => $self->status,
                  }
              );
          };
          $@ && $self->app->engine('logger')->log( warning => $@ );
  
          # return rendered content unless there was an error.
          return $content if defined $content;
      }
  
      return $self->default_error_page;
  }
  
  sub throw {
      my $self = shift;
      $self->response(shift) if @_;
  
      $self->response
          or croak "error has no response to throw at";
  
      $self->has_app &&
          $self->app->execute_hook( 'core.error.before', $self );
  
      my $message = $self->content;
  
      $self->response->status( $self->status );
      $self->response->content_type( $self->content_type );
      $self->response->content($message);
  
      $self->has_app &&
          $self->app->execute_hook('core.error.after', $self->response);
  
      $self->response->is_halted(1);
      return $self->response;
  }
  
  sub backtrace {
      my ($self) = @_;
  
      my $message = $self->message;
      if ($self->exception) {
          $message .= "\n" if $message;
          $message .= $self->exception;
      }
      $message ||= 'Wooops, something went wrong';
  
      $message = '<pre class="error">' . _html_encode($message) . '</pre>';
  
      # the default perl warning/error pattern
      my ( $file, $line ) = ( $message =~ /at (\S+) line (\d+)/ );
  
      # the Devel::SimpleTrace pattern
      ( $file, $line ) = ( $message =~ /at.*\((\S+):(\d+)\)/ )
        unless $file and $line;
  
      # no file/line found, cannot open a file for context
      return $message unless ( $file and $line );
  
      # file and line are located, let's read the source Luke!
      my $fh = eval { open_file( '<', $file ) } or return $message;
      my @lines = <$fh>;
      close $fh;
  
      my $backtrace = $message;
  
      $backtrace
        .= qq|<div class="title">| . "$file around line $line" . "</div>";
  
      $backtrace .= qq|<pre class="content">|;
  
      $line--;
      my $start = ( ( $line - 3 ) >= 0 ) ? ( $line - 3 ) : 0;
      my $stop =
        ( ( $line + 3 ) < scalar(@lines) ) ? ( $line + 3 ) : scalar(@lines);
  
      for ( my $l = $start; $l <= $stop; $l++ ) {
          chomp $lines[$l];
  
          if ( $l == $line ) {
              $backtrace
                .= qq|<span class="nu">|
                . tabulate( $l + 1, $stop + 1 )
                . qq|</span> <span style="color: red;">|
                . _html_encode( $lines[$l] )
                . "</span>\n";
          }
          else {
              $backtrace
                .= qq|<span class="nu">|
                . tabulate( $l + 1, $stop + 1 )
                . "</span> "
                . _html_encode( $lines[$l] ) . "\n";
          }
      }
      $backtrace .= "</pre>";
  
      return $backtrace;
  }
  
  sub tabulate {
      my ( $number, $max ) = @_;
      my $len = length($max);
      return $number if length($number) == $len;
      return " $number";
  }
  
  sub dumper {
      my $obj = shift;
  
      # Take a copy of the data, so we can mask sensitive-looking stuff:
      my %data     = %$obj;
      my $censored = _censor( \%data );
  
      #use Data::Dumper;
      my $dd = Data::Dumper->new( [ \%data ] );
      my $hash_separator = '  @@!%,+$$#._(--  '; # Very unlikely string to exist already
      my $prefix_padding = '  #+#+@%.,$_-!((  '; # Very unlikely string to exist already
      $dd->Terse(1)->Quotekeys(0)->Indent(1)->Sortkeys(1)->Pair($hash_separator)->Pad($prefix_padding);
      my $content = _html_encode( $dd->Dump );
      $content =~ s/^.+//;   # Remove the first line
      $content =~ s/\n.+$//; # Remove the last line
      $content =~ s/^\Q$prefix_padding\E  //gm; # Remove the padding
      $content =~ s{^(\s*)(.+)\Q$hash_separator}{$1<span class="key">$2</span> =&gt; }gm;
      if ($censored) {
          $content
            .= "\n\nNote: Values of $censored sensitive-looking keys hidden\n";
      }
      return $content;
  }
  
  sub environment {
      my ($self) = @_;
  
      my $stack = $self->get_caller;
      my $settings = $self->has_app && $self->app->settings;
      my $session = $self->has_app && $self->app->_has_session && $self->app->session->data;
      my $env = $self->has_app && $self->app->has_request && $self->app->request->env;
  
      # Get a sanitised dump of the settings, session and environment
      $_ = $_ ? dumper($_) : '<i>undefined</i>' for $settings, $session, $env;
  
      return <<"END_HTML";
  <div class="title">Stack</div><pre class="content">$stack</pre>
  <div class="title">Settings</div><pre class="content">$settings</pre>
  <div class="title">Session</div><pre class="content">$session</pre>
  <div class="title">Environment</div><pre class="content">$env</pre>
  END_HTML
  }
  
  sub get_caller {
      my ($self) = @_;
      my @stack;
  
      my $deepness = 0;
      while ( my ( $package, $file, $line ) = caller( $deepness++ ) ) {
          push @stack, "$package in $file l. $line";
      }
  
      return join( "\n", reverse(@stack) );
  }
  
  # private
  
  # Given a hashref, censor anything that looks sensitive.  Returns number of
  # items which were "censored".
  
  sub _censor {
      my $hash = shift;
      if ( !$hash || ref $hash ne 'HASH' ) {
          carp "_censor given incorrect input: $hash";
          return;
      }
  
      my $censored = 0;
      for my $key ( keys %$hash ) {
          if ( ref $hash->{$key} eq 'HASH' ) {
              # Take a copy of the data, so we can hide sensitive-looking stuff:
              $hash->{$key} = { %{ $hash->{$key} } };
              $censored += _censor( $hash->{$key} );
          }
          elsif ( $key =~ /(pass|card?num|pan|secret)/i ) {
              $hash->{$key} = "Hidden (looks potentially sensitive)";
              $censored++;
          }
      }
  
      return $censored;
  }
  
  # Replaces the entities that are illegal in (X)HTML.
  sub _html_encode {
      my $value = shift;
  
      return if !defined $value;
  
      $value =~ s/&/&amp;/g;
      $value =~ s/</&lt;/g;
      $value =~ s/>/&gt;/g;
      $value =~ s/'/&#39;/g;
      $value =~ s/"/&quot;/g;
  
      return $value;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Error - Class representing fatal errors
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
      # taken from send_file:
      use Dancer2::Core::Error;
  
      my $error = Dancer2::Core::Error->new(
          status    => 404,
          message => "No such file: `$path'"
      );
  
      Dancer2::Core::Response->set($error->render);
  
  =head1 DESCRIPTION
  
  With Dancer2::Core::Error you can throw reasonable-looking errors to the user
  instead of crashing the application and filling up the logs.
  
  This is usually used in debugging environments, and it's what Dancer2 uses as
  well under debugging to catch errors and show them on screen.
  
  =head1 ATTRIBUTES
  
  =head2 show_errors
  
  =head2 charset
  
  =head2 type
  
  The error type.
  
  =head2 title
  
  The title of the error page.
  
  This is only an attribute getter, you'll have to set it at C<new>.
  
  =head2 status
  
  The status that caused the error.
  
  This is only an attribute getter, you'll have to set it at C<new>.
  
  =head2 message
  
  The message of the error page.
  
  =head1 METHODS
  
  =head2 my $error=new Dancer2::Core::Error(status    => 404, message => "No such file: `$path'");
  
  Create a new Dancer2::Core::Error object. For available arguments see ATTRIBUTES.
  
  =head2 supported_hooks ();
  
  =head2 throw($response)
  
  Populates the content of the response with the error's information.
  If I<$response> is not given, acts on the I<app>
  attribute's response.
  
  =head2 backtrace
  
  Create a backtrace of the code where the error is caused.
  
  This method tries to find out where the error appeared according to the actual
  error message (using the C<message> attribute) and tries to parse it (supporting
  the regular/default Perl warning or error pattern and the L<Devel::SimpleTrace>
  output) and then returns an error-highlighted C<message>.
  
  =head2 tabulate
  
  Small subroutine to help output nicer.
  
  =head2 environment
  
  A main function to render environment information: the caller (using
  C<get_caller>), the settings and environment (using C<dumper>) and more.
  
  =head2 get_caller
  
  Creates a stack trace of callers.
  
  =head1 FUNCTIONS
  
  =head2 _censor
  
  An private function that tries to censor out content which should be protected.
  
  C<dumper> calls this method to censor things like passwords and such.
  
  =head2 my $string=_html_encode ($string);
  
  Private function that replaces illegal entities in (X)HTML with their
  escaped representations.
  
  html_encode() doesn't do any UTF black magic.
  
  =head2 dumper
  
  This uses L<Data::Dumper> to create nice content output with a few predefined
  options.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ERROR

$fatpacked{"Dancer2/Core/Factory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_FACTORY';
  package Dancer2::Core::Factory;
  # ABSTRACT: Instantiate components by type and name
  $Dancer2::Core::Factory::VERSION = '0.162000';
  use Moo;
  use Dancer2::Core;
  use Class::Load 'try_load_class';
  use Carp 'croak';
  
  sub create {
      my ( $class, $type, $name, %options ) = @_;
  
      $type = Dancer2::Core::camelize($type);
      $name = Dancer2::Core::camelize($name);
      my $component_class = "Dancer2::${type}::${name}";
  
      my ( $ok, $error ) = try_load_class($component_class);
      $ok or croak "Unable to load class for $type component $name: $error";
  
      return $component_class->new(%options);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Factory - Instantiate components by type and name
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_FACTORY

$fatpacked{"Dancer2/Core/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_HTTP';
  # ABSTRACT: helper for rendering HTTP status codes for Dancer2
  
  package Dancer2::Core::HTTP;
  $Dancer2::Core::HTTP::VERSION = '0.162000';
  use strict;
  use warnings;
  
  my $HTTP_CODES = {
  
      # informational
      100 => 'Continue',               # only on HTTP 1.1
      101 => 'Switching Protocols',    # only on HTTP 1.1
      102 => 'Processing',             # WebDAV; RFC 2518
  
      # processed
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information', # only on HTTP 1.1
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',           # WebDAV; RFC 4918
      208 => 'Already Reported',       # WebDAV; RFC 5842
      # 226 => 'IM Used'               # RFC 3229
  
      # redirections
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => '303 See Other',          # only on HTTP 1.1
      304 => 'Not Modified',
      305 => '305 Use Proxy',          # only on HTTP 1.1
      306 => 'Switch Proxy',
      307 => 'Temporary Redirect',     # only on HTTP 1.1
      # 308 => 'Permanent Redirect'    # approved as experimental RFC
  
      # problems with request
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Long',
      415 => 'Unsupported Media Type',
      416 => 'Requested Range Not Satisfiable',
      417 => 'Expectation Failed',
      418 => "I'm a teapot",             # RFC 2324
      # 419 => 'Authentication Timeout', # not in RFC 2616
      420 => 'Enhance Your Calm',
      422 => 'Unprocessable Entity',
      423 => 'Locked',
      424 => 'Failed Dependency',        # Also used for 'Method Failure'
      425 => 'Unordered Collection',
      426 => 'Upgrade Required',
      428 => 'Precondition Required',
      429 => 'Too Many Requests',
      431 => 'Request Header Fields Too Large',
      444 => 'No Response',
      449 => 'Retry With',
      450 => 'Blocked by Windows Parental Controls',
      451 => 'Unavailable For Legal Reasons',
      451 => 'Redirect',
      494 => 'Request Header Too Large',
      495 => 'Cert Error',
      496 => 'No Cert',
      497 => 'HTTP to HTTPS',
      499 => 'Client Closed Request',
  
      # problems with server
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',
      507 => 'Insufficient Storage',
      508 => 'Loop Detected',
      509 => 'Bandwidth Limit Exceeded',
      510 => 'Not Extended',
      511 => 'Network Authentication Required',
      598 => 'Network read timeout error',
      599 => 'Network connect timeout error',
  };
  
  for my $code ( keys %$HTTP_CODES ) {
      my $str_http_code = $HTTP_CODES->{$code};
      $HTTP_CODES->{$str_http_code} = $code;
  
      my $alias = lc join '_', split /\W/, $HTTP_CODES->{$code};
      $HTTP_CODES->{$alias} = $code;
  }
  
  $HTTP_CODES->{error} = $HTTP_CODES->{internal_server_error};
  
  sub status {
      my ( $class, $status ) = @_;
      return if ! defined $status;
      return $status if $status =~ /^\d+$/;
      if ( exists $HTTP_CODES->{$status} ) {
          return $HTTP_CODES->{$status};
      }
      return;
  }
  
  sub status_message {
      my ( $class, $status ) = @_;
      return if ! defined $status;
      my $code = $class->status($status);
      return if ! defined $code || ! exists $HTTP_CODES->{$code};
      return $HTTP_CODES->{ $code };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::HTTP - helper for rendering HTTP status codes for Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 FUNCTIONS
  
  =head2 status(status_code)
  
      Dancer2::Core::HTTP->status(200); # returns 200
  
      Dancer2::Core::HTTP->status('Not Found'); # returns 404
  
      Dancer2::Core::HTTP->status('bad_request'); # 400
  
  Returns a HTTP status code.  If given an integer, it will return the value it
  received, else it will try to find the appropriate alias and return the correct
  status.
  
  =head2 status_message(status_code)
  
      Dancer2::Core::HTTP->status_message(200); # returns 'OK'
  
      Dancer2::Core::HTTP->status_message('error'); # returns 'Internal Server Error'
  
  Returns the HTTP status message for the given status code.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_HTTP

$fatpacked{"Dancer2/Core/Hook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_HOOK';
  package Dancer2::Core::Hook;
  # ABSTRACT: Manipulate hooks with Dancer2
  $Dancer2::Core::Hook::VERSION = '0.162000';
  use Moo;
  use Dancer2::Core::Types;
  use Carp;
  
  has name => (
      is       => 'rw',
      isa      => Str,
      required => 1,
      coerce   => sub {
          my ($hook_name) = @_;
  
          # XXX at the moment, we have a filer position named "before_template".
          # this one is renamed "before_template_render", so we need to alias it.
          # maybe we need to deprecate 'before_template' to enforce the use
          # of 'hook before_template_render => sub {}' ?
          $hook_name = 'before_template_render'
            if $hook_name eq 'before_template';
          return $hook_name;
      },
  );
  
  has code => (
      is       => 'ro',
      isa      => CodeRef,
      required => 1,
      coerce   => sub {
          my ($hook) = @_;
          sub {
              my $res;
              eval { $res = $hook->(@_) };
              croak "Hook error: $@" if $@;
              return $res;
          };
      },
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Hook - Manipulate hooks with Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
    # inside a plugin
    use Dancer2::Hook;
    Dancer2::Core::Hook->register_hooks_name(qw/before_auth after_auth/);
  
  =head1 METHODS
  
  =head2 register_hook ($hook_name, [$properties], $code)
  
      hook 'before', {apps => ['main']}, sub {...};
  
      hook 'before' => sub {...};
  
  Attaches a hook at some point, with a possible list of properties.
  
  Currently supported properties:
  
  =over 4
  
  =item apps
  
      an array reference containing apps name
  
  =back
  
  =head2 register_hooks_name
  
  Add a new hook name, so application developers can insert some code at this point.
  
      package My::Dancer2::Plugin;
      Dancer2::Core::Hook->instance->register_hooks_name(qw/before_auth after_auth/);
  
  =head2 execute_hook
  
  Execute a hooks
  
  =head2 get_hooks_for
  
  Returns the list of coderef registered for a given position
  
  =head2 hook_is_registered
  
  Test if a hook with this name has already been registered.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_HOOK

$fatpacked{"Dancer2/Core/MIME.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_MIME';
  # ABSTRACT: Class to ease manipulation of MIME types
  
  package Dancer2::Core::MIME;
  $Dancer2::Core::MIME::VERSION = '0.162000';
  use Moo;
  
  use Class::Load 'try_load_class';
  use Plack::MIME;
  use Dancer2::Core::Types;
  
  # Initialise MIME::Types at compile time, to ensure it's done before
  # the fork in a preforking webserver like mod_perl or Starman. Not
  # doing this leads to all MIME types being returned as "text/plain",
  # as MIME::Types fails to load its mappings from the DATA handle. See
  # t/04_static_file/003_mime_types_reinit.t and GH#136.
  BEGIN {
      if ( try_load_class('MIME::Types') ) {
          my $mime_types = MIME::Types->new(only_complete => 1);
          Plack::MIME->set_fallback(
              sub {
                  $mime_types->mimeTypeOf($_[0])
              }
          );
      }
  }
  
  has custom_types => (
      is      => 'ro',
      isa     => HashRef,
      default => sub { +{} },
  );
  
  has default => (
      is      => 'rw',
      isa     => Str,
      builder => "reset_default",
  );
  
  sub reset_default {
      my ($self) = @_;
      $self->default("application/data");
  }
  
  sub add_type {
      my ( $self, $name, $type ) = @_;
      $self->custom_types->{$name} = $type;
      return;
  }
  
  sub add_alias {
      my ( $self, $alias, $orig ) = @_;
      my $type = $self->for_name($orig);
      $self->add_type( $alias, $type );
      return $type;
  }
  
  sub for_file {
      my ( $self, $filename ) = @_;
      my ($ext) = $filename =~ /\.([^.]+)$/;
      return $self->default unless $ext;
      return $self->for_name($ext);
  }
  
  sub name_or_type {
      my ( $self, $name ) = @_;
  
      return $name if $name =~ m{/};    # probably a mime type
      return $self->for_name($name);
  }
  
  sub for_name {
      my ( $self, $name ) = @_;
  
      return
           $self->custom_types->{ lc $name }
        || Plack::MIME->mime_type( lc ".$name" )
        || $self->default;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::MIME - Class to ease manipulation of MIME types
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
      use Dancer2::Core::MIME;
  
      my $mime = Dancer::MIME->new();
  
      # get mime type for an alias
      my $type = $mime->for_name('css');
  
      # set a new mime type
      my $type = $mime->add_type( foo => 'text/foo' );
  
      # set a mime type alias
      my $alias = $mime->add_alias( f => 'foo' );
  
      # get mime type for a file (based on extension)
      my $file = $mime->for_file( "foo.bar" );
  
      # set the $thing into a content $type.
      my $type = $mime->name_or_type($thing);
  
      # get current defined default mime type
      my $type = $mime->default;
  
      # set the default mime type using config.yml
      # or using the set keyword
      set default_mime_type => 'text/plain';
  
  =head1 DESCRIPTION
  
  Dancer::MIME is a thin wrapper around L<MIME::Types> providing helpful methods
  for MIME handling.
  
  =head1 ATTRIBUTES
  
  =head2 custom_types
  
  Custom user-defined MIME types that are added the with C<add_type>.
  
  =head2 default
  
  Default MIME type defined by MIME::Types, set to: B<application/data>.
  
  =head1 METHODS
  
  =head2 reset_default
  
  This method resets C<mime_type> to the default type.
  
  =head2 add_type
  
  This method adds the new MIME type.
  
  =head2 add_alias
  
  The C<add_alias> sets a MIME type alias.
  
  =head2 for_name
  
  The method C<for_name> gets MIME type for an alias.
  
  =head2 for_file
  
  This method gets MIME type for a file based on extension.
  
  =head2 name_or_type
  
  This method sets the customized MIME name or default MIME type into a content
  type.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_MIME

$fatpacked{"Dancer2/Core/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_REQUEST';
  package Dancer2::Core::Request;
  # ABSTRACT: Interface for accessing incoming requests
  $Dancer2::Core::Request::VERSION = '0.162000';
  use strict;
  use warnings;
  use parent 'Plack::Request';
  
  use Carp;
  use Encode;
  use HTTP::Body;
  use URI;
  use URI::Escape;
  use Class::Load 'try_load_class';
  use Safe::Isa;
  
  use Dancer2::Core::Types;
  use Dancer2::Core::Request::Upload;
  use Dancer2::Core::Cookie;
  
  # add an attribute for each HTTP_* variables
  # (HOST is managed manually)
  my @http_env_keys = (qw/
      accept_charset
      accept_encoding
      accept_language
      connection
      keep_alive
      x_requested_with
  /);
  
  # apparently you can't eval core functions
  sub accept { $_[0]->env->{'HTTP_ACCEPT'} }
  
  eval << "_EVAL" for @http_env_keys; ## no critic
  sub $_ { \$_[0]->env->{ 'HTTP_' . ( uc $_ ) } }
  _EVAL
  
  # check presence of XS module to speedup request
  our $XS_URL_DECODE         = try_load_class('URL::Encode::XS');
  our $XS_PARSE_QUERY_STRING = try_load_class('CGI::Deurl::XS');
  
  our $_id = 0;
  
  # self->new( env => {}, serializer => $s, is_behind_proxy => 0|1 )
  sub new {
      my ( $class, @args ) = @_;
  
      # even sized list
      @args % 2 == 0
          or croak 'Must provide even sized list';
  
      my %opts = @args;
      my $env  = $opts{'env'};
  
      my $self = $class->SUPER::new($env);
  
      if ( my $s = $opts{'serializer'} ) {
          $s->$_does('Dancer2::Core::Role::Serializer')
              or croak 'Serializer provided not a Serializer object';
  
          $self->{'serializer'} = $s;
      }
  
      # additionally supported attributes
      $self->{'id'}              = ++$_id;
      $self->{'vars'}            = {};
      $self->{'is_behind_proxy'} = !!$opts{'is_behind_proxy'};
  
      $self->init;
  
      return $self;
  }
  
  # a buffer for per-request variables
  sub vars { $_[0]->{'vars'} }
  
  sub var {
      my $self = shift;
      @_ == 2
        ? $self->vars->{ $_[0] } = $_[1]
        : $self->vars->{ $_[0] };
  }
  
  # I don't like this. I know send_file uses this and I wonder
  # if we can remove it.
  #   -- Sawyer
  sub set_path_info { $_[0]->env->{'PATH_INFO'} = $_[1] }
  
  # XXX: incompatible with Plack::Request
  sub body { $_[0]->{'body'} || '' }
  
  sub id { $_id }
  
  # Private 'read-only' attributes for request params. See the params()
  # method for the public interface.
  #
  # _body_params, _query_params and _route_params have setter methods that
  # decode byte string to characters before setting; If you know you have
  # decoded (character) params, such as output from a deserializer, you can
  # set these directly in the request object hash to avoid the decode op.
  sub _params { $_[0]->{'_params'} ||= $_[0]->_build_params }
  
  sub _has_params { defined $_[0]->{'_params'} }
  
  sub _body_params { $_[0]->{'_body_params'} }
  
  sub _set_body_params {
      my ( $self, $params ) = @_;
      $self->{_body_params} = _decode( $params );
  }
  
  sub _query_params { $_[0]->{'_query_params'} }
  
  sub _set_query_params {
      my ( $self, $params ) = @_;
      $self->{_query_params} = _decode( $params );
  }
  
  sub _route_params { $_[0]->{'_route_params'} ||= {} }
  
  sub _set_route_params {
      my ( $self, $params ) = @_;
      $self->{_route_params} = _decode( $params );
      $self->_build_params();
  }
  
  # XXX: incompatible with Plack::Request
  sub uploads { $_[0]->{'uploads'} }
  
  sub body_is_parsed { $_[0]->{'body_is_parsed'} || 0 }
  
  sub is_behind_proxy { $_[0]->{'is_behind_proxy'} || 0 }
  
  sub host {
      my ($self) = @_;
  
      if ( $self->is_behind_proxy and exists $self->env->{'HTTP_X_FORWARDED_HOST'} ) {
          my @hosts = split /\s*,\s*/, $self->env->{'HTTP_X_FORWARDED_HOST'}, 2;
          return $hosts[0];
      } else {
          return $self->env->{'HTTP_HOST'};
      }
  }
  
  # aliases, kept for backward compat
  sub agent                 { shift->user_agent }
  sub remote_address        { shift->address }
  sub forwarded_for_address { shift->env->{'HTTP_X_FORWARDED_FOR'} }
  sub forwarded_host        { shift->env->{'HTTP_X_FORWARDED_HOST'} }
  
  # there are two options
  sub forwarded_protocol    {
      $_[0]->env->{'HTTP_X_FORWARDED_PROTOCOL'} ||
      $_[0]->env->{'HTTP_X_FORWARDED_PROTO'}    ||
      $_[0]->env->{'HTTP_FORWARDED_PROTO'}
  }
  
  sub scheme {
      my ($self) = @_;
      my $scheme = $self->is_behind_proxy
                 ? $self->forwarded_protocol
                 : '';
  
      return $scheme || $self->env->{'psgi.url_scheme'};
  }
  
  sub serializer { $_[0]->{'serializer'} }
  
  sub data { $_[0]->{'data'} ||= &deserialize }
  
  sub deserialize {
      my $self = shift;
  
      my $serializer = $self->serializer
          or return;
  
      # The latest draft of the RFC does not forbid DELETE to have content,
      # rather the behaviour is undefined. Take the most lenient route and
      # deserialize any content on delete as well.
      return
        unless grep { $self->method eq $_ } qw/ PUT POST PATCH DELETE /;
  
      # try to deserialize
      my $body = $self->_read_to_end();
  
      $body && length $body > 0
          or return;
  
      my $data = $serializer->deserialize($self->body);
      return if !defined $data;
  
      # Set _body_params directly rather than using the setter. Deserializiation
      # returns characters and skipping the decode op in the setter ensures
      # that numerical data "stays" numerical; decoding an SV that is an IV
      # converts that to a PVIV. Some serializers are picky (JSON)..
      $self->{_body_params} = $data;
  
      return $data;
  }
  
  sub uri       { $_[0]->request_uri }
  sub is_head   { $_[0]->method eq 'HEAD' }
  sub is_post   { $_[0]->method eq 'POST' }
  sub is_get    { $_[0]->method eq 'GET' }
  sub is_put    { $_[0]->method eq 'PUT' }
  sub is_delete { $_[0]->method eq 'DELETE' }
  sub is_patch  { $_[0]->method eq 'PATCH' }
  
  # public interface compat with CGI.pm objects
  sub request_method { $_[0]->method }
  sub input_handle { $_[0]->env->{'psgi.input'} }
  
  sub init {
      my ($self) = @_;
  
      $self->{_chunk_size}    = 4096;
      $self->{_read_position} = 0;
  
      $self->{_http_body} =
        HTTP::Body->new( $self->content_type || '', $self->content_length );
      $self->{_http_body}->cleanup(1);
  
      $self->data;      # Deserialize body
      $self->_build_uploads();
  }
  
  sub to_string {
      my ($self) = @_;
      return "[#" . $self->id . "] " . $self->method . " " . $self->path;
  }
  
  sub base {
      my $self = shift;
      my $uri  = $self->_common_uri;
  
      return $uri->canonical;
  }
  
  sub _common_uri {
      my $self = shift;
  
      my $path   = $self->env->{SCRIPT_NAME};
      my $port   = $self->env->{SERVER_PORT};
      my $server = $self->env->{SERVER_NAME};
      my $host   = $self->host;
      my $scheme = $self->scheme;
  
      my $uri = URI->new;
      $uri->scheme($scheme);
      $uri->authority( $host || "$server:$port" );
      $uri->path( $path      || '/' );
  
      return $uri;
  }
  
  sub uri_base {
      my $self  = shift;
      my $uri   = $self->_common_uri;
      my $canon = $uri->canonical;
  
      if ( $uri->path eq '/' ) {
          $canon =~ s{/$}{};
      }
  
      return $canon;
  }
  
  sub dispatch_path {
      my $self = shift;
  
      my $path = $self->path;
  
      # Want $self->base->path, without needing the URI object,
      # and trim any trailing '/'.
      my $base = '';
      $base .= $self->script_name if defined $self->script_name;
      $base =~ s|/+$||;
  
      # Remove base from front of path.
      $path =~ s|^(\Q$base\E)?||;
      $path =~ s|^/+|/|;
      # PSGI spec notes that '' should be considered '/'
      $path = '/' if $path eq '';
      return $path;
  }
  
  sub uri_for {
      my ( $self, $part, $params, $dont_escape ) = @_;
  
      $part ||= '';
      my $uri = $self->base;
  
      # Make sure there's exactly one slash between the base and the new part
      my $base = $uri->path;
      $base =~ s|/$||;
      $part =~ s|^/||;
      $uri->path("$base/$part");
  
      $uri->query_form($params) if $params;
  
      return $dont_escape
             ? uri_unescape( ${ $uri->canonical } )
             : ${ $uri->canonical };
  }
  
  sub params {
      my ( $self, $source ) = @_;
  
      return %{ $self->_params } if wantarray && @_ == 1;
      return $self->_params if @_ == 1;
  
      if ( $source eq 'query' ) {
          return %{ $self->_query_params || {} } if wantarray;
          return $self->_query_params;
      }
      elsif ( $source eq 'body' ) {
          return %{ $self->_body_params || {} } if wantarray;
          return $self->_body_params;
      }
      if ( $source eq 'route' ) {
          return %{ $self->_route_params } if wantarray;
          return $self->_route_params;
      }
      else {
          croak "Unknown source params \"$source\".";
      }
  }
  
  sub captures { shift->params->{captures} || {} }
  
  sub splat { @{ shift->params->{splat} || [] } }
  
  # XXX: incompatible with Plack::Request
  sub param { shift->params->{ $_[0] } }
  
  sub _decode {
      my ($h) = @_;
      return if not defined $h;
  
      if ( !ref($h) && !utf8::is_utf8($h) ) {
          return decode( 'UTF-8', $h );
      }
  
      if ( ref($h) eq 'HASH' ) {
          return { map _decode($_), %$h };
      }
  
      if ( ref($h) eq 'ARRAY' ) {
          return [ map _decode($_), @$h ];
      }
  
      return $h;
  }
  
  sub is_ajax {
      my $self = shift;
  
      return 0 unless defined $self->headers;
      return 0 unless defined $self->header('X-Requested-With');
      return 0 if $self->header('X-Requested-With') ne 'XMLHttpRequest';
      return 1;
  }
  
  # XXX incompatible with Plack::Request
  # context-aware accessor for uploads
  sub upload {
      my ( $self, $name ) = @_;
      my $res = $self->{uploads}{$name};
  
      return $res unless wantarray;
      return ()   unless defined $res;
      return ( ref($res) eq 'ARRAY' ) ? @$res : $res;
  }
  
  sub _build_params {
      my ($self) = @_;
  
      # params may have been populated by before filters
      # _before_ we get there, so we have to save it first
      my $previous = $self->_has_params ? $self->_params : {};
  
      # now parse environment params...
      my $get_params = $self->_parse_get_params();
  
      # and merge everything
      $self->{_params} = {
          map +( ref $_ eq 'HASH' ? %{$_} : () ),
          $previous,
          $get_params,
          $self->_route_params,
          $self->_body_params,
      };
  
  }
  
  sub _url_decode {
      my ( $self, $encoded ) = @_;
      return URL::Encode::XS::url_decode($encoded) if $XS_URL_DECODE;
      my $clean = $encoded;
      $clean =~ tr/\+/ /;
      $clean =~ s/%([a-fA-F0-9]{2})/pack "H2", $1/eg;
      return $clean;
  }
  
  sub _parse_post_params {
      my ($self) = @_;
      return $self->_body_params if defined $self->_body_params;
  
      my $body = $self->_read_to_end();
      $self->_set_body_params( $self->{_http_body}->param );
  }
  
  sub _parse_get_params {
      my ($self) = @_;
      return $self->_query_params if defined $self->{_query_params};
  
      my $query_params = {};
  
      my $source = $self->env->{QUERY_STRING};
      return if !defined $source || $source eq '';
  
      if ($XS_PARSE_QUERY_STRING) {
          $self->_set_query_params(
              CGI::Deurl::XS::parse_query_string($source) || {}
          );
          return $self->_query_params;
      }
  
      foreach my $token ( split /[&;]/, $source ) {
          my ( $key, $val ) = split( /=/, $token );
          next unless defined $key;
          $val = ( defined $val ) ? $val : '';
          $key = $self->_url_decode($key);
          $val = $self->_url_decode($val);
  
          # looking for multi-value params
          if ( exists $query_params->{$key} ) {
              my $prev_val = $query_params->{$key};
              if ( ref($prev_val) && ref($prev_val) eq 'ARRAY' ) {
                  push @{ $query_params->{$key} }, $val;
              }
              else {
                  $query_params->{$key} = [ $prev_val, $val ];
              }
          }
  
          # simple value param (first time we see it)
          else {
              $query_params->{$key} = $val;
          }
      }
      $self->_set_query_params( $query_params );
      return $self->_query_params;
  }
  
  sub _read_to_end {
      my ($self) = @_;
  
      my $content_length = $self->content_length;
      return unless $self->_has_something_to_read();
  
      if ( $content_length && $content_length > 0 ) {
          while ( my $buffer = $self->_read() ) {
              $self->{body} .= $buffer;
          }
          $self->{_http_body}->add( $self->{body} );
      }
  
      return $self->{body};
  }
  
  sub _has_something_to_read {
      my ($self) = @_;
      return 0 unless defined $self->input_handle;
  }
  
  # taken from Miyagawa's Plack::Request::BodyParser
  sub _read {
      my ( $self, ) = @_;
      my $remaining = $self->content_length - $self->{_read_position};
      my $maxlength = $self->{_chunk_size};
  
      return if ( $remaining <= 0 );
  
      my $readlen = ( $remaining > $maxlength ) ? $maxlength : $remaining;
      my $buffer;
      my $rc;
  
      $rc = $self->input_handle->read( $buffer, $readlen );
  
      if ( defined $rc ) {
          $self->{_read_position} += $rc;
          return $buffer;
      }
      else {
          croak "Unknown error reading input: $!";
      }
  }
  
  # Taken gently from Plack::Request, thanks to Plack authors.
  sub _build_uploads {
      my ($self) = @_;
  
      if ( $self->body_is_parsed ) {
          $self->{_body_params} ||= {};
      }
      else {
          $self->_parse_post_params();
      }
  
      my $uploads = _decode( $self->{_http_body}->upload );
      my %uploads;
  
      for my $name ( keys %{$uploads} ) {
          my $files = $uploads->{$name};
          $files = ref $files eq 'ARRAY' ? $files : [$files];
  
          my @uploads = map Dancer2::Core::Request::Upload->new(
                                headers  => $_->{headers},
                                tempname => $_->{tempname},
                                size     => $_->{size},
                                filename => $_->{filename},
                        ), @{$files};
  
          $uploads{$name} = @uploads > 1 ? \@uploads : $uploads[0];
  
          # support access to the filename as a normal param
          my @filenames = map $_->{'filename'}, @uploads;
          $self->{_body_params}{$name} =
            @filenames > 1 ? \@filenames : $filenames[0];
      }
  
      $self->{uploads} = \%uploads;
  }
  
  # XXX: incompatible with Plack::Request
  sub cookies { $_[0]->{'cookies'} ||= $_[0]->_build_cookies }
  
  sub _build_cookies {
      my $self    = shift;
      my $cookies = {};
  
      my $http_cookie = $self->header('Cookie');
      return $cookies unless defined $http_cookie; # nothing to do
  
      foreach my $cookie ( split( /[,;]\s/, $http_cookie ) ) {
  
          # here, we don't want more than the 2 first elements
          # a cookie string can contains something like:
          # cookie_name="foo=bar"
          # we want `cookie_name' as the value and `foo=bar' as the value
          my ( $name, $value ) = split( /\s*=\s*/, $cookie, 2 );
          my @values;
          if ( defined $value and $value ne '' ) {
              @values = map uri_unescape($_), split( /[&;]/, $value );
          }
          $cookies->{$name} =
            Dancer2::Core::Cookie->new( name => $name, value => \@values );
      }
      return $cookies;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Request - Interface for accessing incoming requests
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
  In a route handler, the current request object can be accessed by the
  C<request> keyword:
  
      get '/foo' => sub {
          request->params; # request, params parsed as a hash ref
          request->body;   # returns the request body, unparsed
          request->path;   # the path requested by the client
          # ...
      };
  
  =head1 DESCRIPTION
  
  An object representing a Dancer2 request. It aims to provide a proper
  interface to anything you might need from a web request.
  
  =head1 METHODS
  
  =head2 address
  
  Return the IP address of the client.
  
  =head2 base
  
  Returns an absolute URI for the base of the application.  Returns a L<URI>
  object (which stringifies to the URL, as you'd expect).
  
  =head2 body_parameters
  
  Returns a L<Hash::MultiValue> object representing the POST parameters.
  
  =head2 body
  
  Return the raw body of the request, unparsed.
  
  If you need to access the body of the request, you have to use this accessor and
  should not try to read C<psgi.input> by hand. C<Dancer2::Core::Request>
  already did it for you and kept the raw body untouched in there.
  
  =head2 content
  
  Returns the undecoded byte string POST body.
  
  =head2 cookies
  
  Returns a reference to a hash containing cookies, where the keys are the names of the
  cookies and values are L<Dancer2::Core::Cookie> objects.
  
  =head2 data
  
  If the application has a serializer and if the request has serialized
  content, returns the deserialized structure as a hashref.
  
  =head2 dispatch_path
  
  The part of the C<path> after C<base>. This is the path used
  for dispatching the request to routes.
  
  =head2 env
  
  Return the current PSGI environment hash reference.
  
  =head2 header($name)
  
  Return the value of the given header, if present. If the header has multiple
  values, returns an the list of values if called in list context, the first one
  in scalar.
  
  =head2 headers
  
  Returns either an L<HTTP::Headers> or an L<HTTP::Headers::Fast> object
  representing the headers.
  
  =head2 id
  
  The ID of the request. This allows you to trace a specific request in loggers,
  per the string created using C<to_string>.
  
  The ID of the request is essentially the number of requests run in the current
  class.
  
  =head2 input
  
  Alias to C<input_handle> method below.
  
  =head2 input_handle
  
  Alias to the PSGI input handle (C<< <request->env->{psgi.input}> >>)
  
  =head2 is_ajax
  
  Return true if the value of the header C<X-Requested-With> is
  C<XMLHttpRequest>.
  
  =head2 is_delete
  
  Return true if the method requested by the client is 'DELETE'
  
  =head2 is_get
  
  Return true if the method requested by the client is 'GET'
  
  =head2 is_head
  
  Return true if the method requested by the client is 'HEAD'
  
  =head2 is_post
  
  Return true if the method requested by the client is 'POST'
  
  =head2 is_put
  
  Return true if the method requested by the client is 'PUT'
  
  =head2 logger
  
  Returns the C<psgix.logger> code reference, if exists.
  
  =head2 method
  
  Return the HTTP method used by the client to access the application.
  
  While this method returns the method string as provided by the environment, it's
  better to use one of the following boolean accessors if you want to inspect the
  requested method.
  
  =head2 new
  
  The constructor of the class, used internally by Dancer2's core to create request
  objects.
  
  It uses the environment hash table given to build the request object:
  
      Dancer2::Core::Request->new( env => $env );
  
  Two additional parameters for instantiation are C<body_is_parsed> boolean
  (indicating if the request should avoid parsing the body again), and
  C<serializer> which can provide a serializer object to work with when
  reading the request body.
  
  =head2 param($key)
  
  Calls the C<params> method below and fetches the key provided.
  
  =head2 params($source)
  
  Called in scalar context, returns a hashref of params, either from the specified
  source (see below for more info on that) or merging all sources.
  
  So, you can use, for instance:
  
      my $foo = params->{foo}
  
  If called in list context, returns a list of key and value pairs, so you could use:
  
      my %allparams = params;
  
  =head2 parameters
  
  Returns a L<Hash::MultiValue> object with merged GET and POST parameters.
  
  =head2 path
  
  The path requested by the client, normalized. This is effectively
  C<path_info> or a single forward C</>.
  
  =head2 path_info
  
  The raw requested path. This could be empty. Use C<path> instead.
  
  =head2 port
  
  Return the port of the server.
  
  =head2 protocol
  
  Return the protocol (I<HTTP/1.0> or I<HTTP/1.1>) used for the request.
  
  =head2 query_parameters
  
  Returns a L<Hash::MultiValue> parameters object.
  
  =head2 query_string
  
  Returns the portion of the request defining the query itself - this is
  what comes after the C<?> in a URI.
  
  =head2 raw_body
  
  Alias to C<content> method.
  
  =head2 remote_address
  
  Alias for C<address> method.
  
  =head2 remote_host
  
  Return the remote host of the client. This only works with web servers configured
  to do a reverse DNS lookup on the client's IP address.
  
  =head2 request_method
  
  Alias to the C<method> accessor, for backward-compatibility with C<CGI> interface.
  
  =head2 request_uri
  
  Return the raw, undecoded request URI path.
  
  =head2 scheme
  
  Return the scheme of the request
  
  =head2 script_name
  
  Return script_name from the environment.
  
  =head2 secure
  
  Return true or false, indicating whether the connection is secure - this is
  effectively checking if the scheme is I<HTTPS> or not.
  
  =head2 serializer
  
  Returns the optional serializer object used to deserialize request parameters.
  
  =head2 session
  
  Returns the C<psgix.session> hash, if exists.
  
  =head2 session_options
  
  Returns the C<psgix.session.options> hash, if exists.
  
  =head2 to_string
  
  Return a string representing the request object (e.g., C<GET /some/path>).
  
  =head2 upload($name)
  
  Context-aware accessor for uploads. It's a wrapper around an access to the hash
  table provided by C<uploads()>. It looks at the calling context and returns a
  corresponding value.
  
  If you have many file uploads under the same name, and call C<upload('name')> in
  an array context, the accessor will unroll the ARRAY ref for you:
  
      my @uploads = request->upload('many_uploads'); # OK
  
  Whereas with a manual access to the hash table, you'll end up with one element
  in C<@uploads>, being the arrayref:
  
      my @uploads = request->uploads->{'many_uploads'};
      # $uploads[0]: ARRAY(0xXXXXX)
  
  That is why this accessor should be used instead of a manual access to
  C<uploads>.
  
  =head2 uploads
  
  Returns a reference to a hash containing uploads. Values can be either a
  L<Dancer2::Core::Request::Upload> object, or an arrayref of
  L<Dancer2::Core::Request::Upload>
  objects.
  
  You should probably use the C<upload($name)> accessor instead of manually accessing the
  C<uploads> hash table.
  
  =head2 uri
  
  An alias to C<request_uri>.
  
  =head2 uri_base
  
  Same thing as C<base> above, except it removes the last trailing slash in the
  path if it is the only path.
  
  This means that if your base is I<http://myserver/>, C<uri_base> will return
  I<http://myserver> (notice no trailing slash). This is considered very useful
  when using templates to do the following thing:
  
      <link rel="stylesheet" href="[% request.uri_base %]/css/style.css" />
  
  =head2 uri_for(path, params)
  
  Constructs a URI from the base and the passed path. If params (hashref) is
  supplied, these are added to the query string of the URI.
  
  Thus, with the following base:
  
      http://localhost:5000/foo
  
  You get the following behavior:
  
      my $uri = request->uri_for('/bar', { baz => 'baz' });
      print $uri; # http://localhost:5000/foo/bar?baz=baz
  
  C<uri_for> returns a L<URI> object (which can stringify to the value).
  
  =head2 user
  
  Return remote user if defined.
  
  =head2 var
  
  By-name interface to variables stored in this request object.
  
    my $stored = $request->var('some_variable');
  
  returns the value of 'some_variable', while
  
    $request->var('some_variable' => 'value');
  
  will set it.
  
  =head2 vars
  
  Access to the internal hash of variables:
  
      my $value = $request->vars->{'my_key'};
  
  You want to use C<var> above.
  
  =head1 Common HTTP request headers
  
  Commonly used client-supplied HTTP request headers are available through
  specific accessors:
  
  =over 4
  
  =item C<accept>
  
  HTTP header: C<HTTP_ACCEPT>.
  
  =item C<accept_charset>
  
  HTTP header: C<HTTP_ACCEPT_CHARSET>.
  
  =item C<accept_encoding>
  
  HTTP header: C<HTTP_ACCEPT_ENCODING>.
  
  =item C<accept_language>
  
  HTTP header: C<HTTP_ACCEPT_LANGUAGE>.
  
  =item C<agent>
  
  Alias for C<user_agent>) below.
  
  =item C<connection>
  
  HTTP header: C<HTTP_CONNECTION>.
  
  =item C<content_encoding>
  
  HTTP header: C<HTTP_CONTENT_ENCODING>.
  
  =item C<content_length>
  
  HTTP header: C<HTTP_CONTENT_LENGTH>.
  
  =item C<content_type>
  
  HTTP header: C<HTTP_CONTENT_TYPE>.
  
  =item C<forwarded_for_address>
  
  HTTP header: C<HTTP_X_FORWARDED_FOR>.
  
  =item C<forwarded_host>
  
  HTTP header: C<HTTP_X_FORWARDED_HOST>.
  
  =item C<forwarded_protocol>
  
  One of either C<HTTP_X_FORWARDED_PROTOCOL>, C<HTTP_X_FORWARDED_PROTO>, or
  C<HTTP_FORWARDED_PROTO>.
  
  =item C<host>
  
  Checks whether we are behind a proxy using the C<is_behind_proxy>
  configuration option, and if so returns the first
  C<HTTP_X_FORWARDED_HOST>, since this is a comma seperated list.
  
  If you have not configured that you behind a proxy, it returns HTTP
  header C<HTTP_HOST>.
  
  =item C<keep_alive>
  
  HTTP header: C<HTTP_KEEP_ALIVE>.
  
  =item C<referer>
  
  HTTP header: C<HTTP_REFERER>.
  
  =item C<user_agent>
  
  HTTP header: C<HTTP_USER_AGENT>.
  
  =item C<x_requested_with>
  
  HTTP header: C<HTTP_X_REQUESTED_WITH>.
  
  =back
  
  =head1 Fetching only params from a given source
  
  If a required source isn't specified, a mixed hashref (or list of key value
  pairs, in list context) will be returned; this will contain params from all
  sources (route, query, body).
  
  In practical terms, this means that if the param C<foo> is passed both on the
  querystring and in a POST body, you can only access one of them.
  
  If you want to see only params from a given source, you can say so by passing
  the C<$source> param to C<params()>:
  
      my %querystring_params = params('query');
      my %route_params       = params('route');
      my %post_params        = params('body');
  
  If source equals C<route>, then only params parsed from the route pattern
  are returned.
  
  If source equals C<query>, then only params parsed from the query string are
  returned.
  
  If source equals C<body>, then only params sent in the request body will be
  returned.
  
  If another value is given for C<$source>, then an exception is triggered.
  
  =head1 EXTRA SPEED
  
  If L<Dancer2::Core::Request> detects the following modules as installed,
  it will use them to speed things up:
  
  =over 4
  
  =item * L<URL::Encode::XS>
  
  =item * L<CGI::Deurl::XS>
  
  =back
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_REQUEST

$fatpacked{"Dancer2/Core/Request/Upload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_REQUEST_UPLOAD';
  package Dancer2::Core::Request::Upload;
  # ABSTRACT: Class representing file upload requests
  $Dancer2::Core::Request::Upload::VERSION = '0.162000';
  use Moo;
  
  use Carp;
  use File::Spec;
  
  use Dancer2::Core::Types;
  use Dancer2::FileUtils qw(open_file);
  
  has filename => (
      is  => 'ro',
      isa => Str,
  );
  
  has tempname => (
      is  => 'ro',
      isa => Str,
  );
  
  has headers => (
      is  => 'ro',
      isa => HashRef,
  );
  
  has size => (
      is  => 'ro',
      isa => Num,
  );
  
  sub file_handle {
      my ($self) = @_;
      return $self->{_fh} if defined $self->{_fh};
      my $fh = open_file( '<', $self->tempname );
      $self->{_fh} = $fh;
  }
  
  sub copy_to {
      my ( $self, $target ) = @_;
      require File::Copy;
      File::Copy::copy( $self->tempname, $target );
  }
  
  sub link_to {
      my ( $self, $target ) = @_;
      CORE::link( $self->tempname, $target );
  }
  
  sub content {
      my ( $self, $layer ) = @_;
      return $self->{_content}
        if defined $self->{_content};
  
      $layer = ':raw' unless $layer;
  
      my $content = undef;
      my $handle  = $self->file_handle;
  
      binmode( $handle, $layer );
  
      while ( $handle->read( my $buffer, 8192 ) ) {
          $content .= $buffer;
      }
  
      $self->{_content} = $content;
  }
  
  sub basename {
      my ($self) = @_;
      require File::Basename;
      File::Basename::basename( $self->filename );
  }
  
  sub type {
      my $self = shift;
      return $self->headers->{'Content-Type'};
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Request::Upload - Class representing file upload requests
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This class implements a representation of file uploads for Dancer2.
  These objects are accessible within route handlers via the request->uploads
  keyword. See L<Dancer2::Core::Request> for details.
  
  =head1 ATTRIBUTES
  
  =head2 filename
  
  Filename as sent by client. optional. May not be undef.
  
  =head2 tempname
  
  The name of the temporary file the data has been saved to. Optional. May not be undef.
  
  =head2 headers
  
  A hash ref of the headers associated with this upload. optional. is read-write and a HashRef.
  
  =head2 size
  
  The size of the upload, in bytes. Optional.
  
  =head1 METHODS
  
  =head2 my $filename=$upload->filename;
  
  Returns the filename (full path) as sent by the client.
  
  =head2 my $tempname=$upload->tempname;
  
  Returns the name of the temporary file the data has been saved to.
  
  For example, in directory /tmp, and given a random name, with no file extension.
  
  =head2 my $href=$upload->headers;
  
  Returns a hashRef of the headers associated with this upload.
  
  =head2 my $fh=$upload->file_handle;
  
  Returns a read-only file handle on the temporary file.
  
  =head2 $upload->copy_to('/path/to/target')
  
  Copies the temporary file using File::Copy. Returns true for success,
  false for failure.
  
  =head2 $upload->link_to('/path/to/target');
  
  Creates a hard link to the temporary file. Returns true for success,
  false for failure.
  
  =head2 my $content=$upload->content;
  
  Returns a scalar containing the contents of the temporary file.
  
  =head2 my $basename=$upload->basename;
  
  Returns basename for "filename".
  
  =head2 $upload->type
  
  Returns the Content-Type of this upload.
  
  =head1 SEE ALSO
  
  L<Dancer2>
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_REQUEST_UPLOAD

$fatpacked{"Dancer2/Core/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_RESPONSE';
  # ABSTRACT: Response object for Dancer2
  
  package Dancer2::Core::Response;
  $Dancer2::Core::Response::VERSION = '0.162000';
  use Moo;
  
  use Encode;
  use Dancer2::Core::Types;
  
  use Dancer2 ();
  use Dancer2::Core::HTTP;
  
  use HTTP::Headers::Fast;
  use Scalar::Util qw(blessed);
  use Plack::Util;
  use Safe::Isa;
  use Sub::Quote ();
  
  use overload
    '@{}' => sub { $_[0]->to_psgi },
    '""'  => sub { $_[0] };
  
  has headers => (
      is     => 'ro',
      isa    => Sub::Quote::quote_sub(q{
          $_[0]->$_isa('ARRAY')          ||
          $_[0]->$_DOES('HTTP::Headers') ||
          $_[0]->$_DOES('HTTP::Headers::Fast')
      }),
      lazy   => 1,
      coerce => sub {
          my ($value) = @_;
          # HTTP::Headers::Fast reports that it isa 'HTTP::Headers',
          # but there is no actual inheritance.
          return $value if blessed($value) && $value->isa('HTTP::Headers');
          HTTP::Headers::Fast->new( @{$value} );
      },
      default => sub {
          HTTP::Headers::Fast->new();
      },
      handles => [qw<header push_header>],
  );
  
  sub headers_to_array {
      my $self    = shift;
      my $headers = shift || $self->headers;
  
      my @hdrs;
      $headers->scan( sub {
          my ( $k, $v ) = @_;
           $v =~ s/\015\012[\040|\011]+/chr(32)/ge; # replace LWS with a single SP
           $v =~ s/\015|\012//g; # remove CR and LF since the char is invalid here
          push @hdrs, $k => $v;
      });
  
      return \@hdrs;
  }
  
  # boolean to tell if the route passes or not
  has has_passed => (
      is      => 'rw',
      isa     => Bool,
      default => sub {0},
  );
  
  sub pass { shift->has_passed(1) }
  
  has serializer => (
      is  => 'ro',
      isa => ConsumerOf ['Dancer2::Core::Role::Serializer'],
  );
  
  has is_encoded => (
      is      => 'rw',
      isa     => Bool,
      default => sub {0},
  );
  
  has is_halted => (
      is      => 'rw',
      isa     => Bool,
      default => sub {0},
  );
  
  sub halt {
      my ( $self, $content ) = @_;
      $self->content( $content ) if @_ > 1;
      $self->is_halted(1);
  }
  
  has status => (
      is      => 'rw',
      isa     => Num,
      default => sub {200},
      lazy    => 1,
      coerce  => sub { Dancer2::Core::HTTP->status(shift) },
  );
  
  has content => (
      is        => 'rw',
      isa       => Str,
      predicate => 'has_content',
      clearer   => 'clear_content',
  );
  
  around content => sub {
      my ( $orig, $self, $content ) = @_;
  
      @_ == 2 and return $self->$orig;
  
      $self->serializer
          or return $self->$orig( $self->encode_content($content) );
  
      $content = $self->serialize($content);
      $self->is_encoded(1); # All serializers return byte strings
      return $self->$orig( defined $content ? $content : '' );
  };
  
  has default_content_type => (
      is      => 'rw',
      isa     => Str,
      default => sub {'text/html'},
  );
  
  sub encode_content {
      my ( $self, $content ) = @_;
  
      return $content if $self->is_encoded;
  
      # Apply default content type if none set.
      my $ct = $self->content_type ||
               $self->content_type( $self->default_content_type );
  
      return $content if $ct !~ /^text/;
  
      # we don't want to encode an empty string, it will break the output
      $content or return $content;
  
      $self->content_type("$ct; charset=UTF-8")
        if $ct !~ /charset/;
  
      $self->is_encoded(1);
      return Encode::encode( 'UTF-8', $content );
  }
  
  sub new_from_plack {
      my ($self, $psgi_res) = @_;
  
      return Dancer2::Core::Response->new(
          status  => $psgi_res->status,
          headers => $psgi_res->headers,
          content => $psgi_res->body,
      );
  }
  
  sub new_from_array {
      my ($self, $arrayref) = @_;
  
      return Dancer2::Core::Response->new(
          status  => $arrayref->[0],
          headers => $arrayref->[1],
          content => $arrayref->[2][0],
      );
  }
  
  sub to_psgi {
      my ($self) = @_;
  
      Dancer2::runner()->config->{'no_server_tokens'}
          or $self->header( 'Server' => "Perl Dancer2 " . Dancer2->VERSION );
  
      my $headers = $self->headers;
      my $status  = $self->status;
  
      Plack::Util::status_with_no_entity_body($status)
          and return [ $status, $self->headers_to_array($headers), [] ];
  
      # It is possible to have no content and/or no content type set
      # e.g. if all routes 'pass'. Apply defaults here..
      my $content = defined $self->content ? $self->content : '';
  
      if ( !$headers->header('Content-Length')    &&
           !$headers->header('Transfer-Encoding') &&
           defined( my $content_length = length $content ) ) {
           $headers->push_header( 'Content-Length' => $content_length );
      }
  
      # More defaults
      $self->content_type or $self->content_type($self->default_content_type);
      return [ $status, $self->headers_to_array($headers), [ $content ], ];
  }
  
  # sugar for accessing the content_type header, with mimetype care
  sub content_type {
      my $self = shift;
  
      if ( scalar @_ > 0 ) {
          my $runner   = Dancer2::runner();
          my $mimetype = $runner->mime_type->name_or_type(shift);
          $self->header( 'Content-Type' => $mimetype );
          return $mimetype;
      }
      else {
          return $self->header('Content-Type');
      }
  }
  
  has _forward => (
      is  => 'rw',
      isa => HashRef,
  );
  
  sub forward {
      my ( $self, $uri, $params, $opts ) = @_;
      $self->_forward( { to_url => $uri, params => $params, options => $opts } );
  }
  
  sub is_forwarded {
      my $self = shift;
      $self->_forward;
  }
  
  sub redirect {
      my ( $self, $destination, $status ) = @_;
      $self->status( $status || 302 );
  
      # we want to stringify the $destination object (URI object)
      $self->header( 'Location' => "$destination" );
  }
  
  sub error {
      my $self = shift;
  
      my $error = Dancer2::Core::Error->new(
          response => $self,
          @_,
      );
  
      $error->throw;
      return $error;
  }
  
  sub serialize {
      my ($self, $content) = @_;
  
      my $serializer = $self->serializer
          or return;
  
      $content = $serializer->serialize($content)
          or return;
  
      $self->content_type( $serializer->content_type );
      return $content;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Response - Response object for Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 ATTRIBUTES
  
  =head2 is_encoded
  
  Flag to tell if the content has already been encoded.
  
  =head2 is_halted
  
  Flag to tell whether or not the response should continue to be processed.
  
  =head2 status
  
  The HTTP status for the response.
  
  =head2 content
  
  The content for the response, stored as a string.  If a reference is passed, the
  response will try coerce it to a string via double quote interpolation.
  
  =head2 default_content_type
  
  Default mime type to use for the response Content-Type header
  if nothing was specified
  
  =head2 headers
  
  The attribute that store the headers in a L<HTTP::Headers::Fast> object.
  
  That attribute coerces from ArrayRef and defaults to an empty L<HTTP::Headers::Fast>
  instance.
  
  =head1 METHODS
  
  =head2 pass
  
  Set has_passed to true.
  
  =head2 serializer()
  
  Returns the optional serializer object used to deserialize request parameters
  
  =head2 halt
  
  Shortcut to halt the current response by setting the is_halted flag.
  
  =head2 encode_content
  
  Encodes the stored content according to the stored L<content_type>.  If the content_type
  is a text format C<^text>, then no encoding will take place.
  
  Interally, it uses the L<is_encoded> flag to make sure that content is not encoded twice.
  
  If it encodes the content, then it will return the encoded content.  In all other
  cases it returns C<false>.
  
  =head2 new_from_plack
  
  Creates a new response object from a L<Plack::Response> object.
  
  =head2 new_from_array
  
  Creates a new response object from a PSGI arrayref.
  
  =head2 to_psgi
  
  Converts the response object to a PSGI array.
  
  =head2 content_type($type)
  
  A little sugar for setting or accessing the content_type of the response, via the headers.
  
  =head2 redirect ($destination, $status)
  
  Sets a header in this response to give a redirect to $destination, and sets the
  status to $status.  If $status is omitted, or false, then it defaults to a status of
  302.
  
  =head2 error( @args )
  
      $response->error( message => "oops" );
  
  Creates a L<Dancer2::Core::Error> object with the given I<@args> and I<throw()>
  it against the response object. Returns the error object.
  
  =head2 serialize( $content )
  
      $response->serialize( $content );
  
  Serialize and return $content with the response's serializer.
  set content-type accordingly.
  
  =head2 header($name)
  
  Return the value of the given header, if present. If the header has multiple
  values, returns the list of values if called in list context, the first one
  if in scalar context.
  
  =head2 push_header
  
  Add the header no matter if it already exists or not.
  
      $self->push_header( 'X-Wing' => '1' );
  
  It can also be called with multiple values to add many times the same header
  with different values:
  
      $self->push_header( 'X-Wing' => 1, 2, 3 );
  
  =head2 headers_to_array($headers)
  
  Convert the C<$headers> to a PSGI ArrayRef.
  
  If no C<$headers> are provided, it will use the current response headers.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_RESPONSE

$fatpacked{"Dancer2/Core/Response/Delayed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_RESPONSE_DELAYED';
  package Dancer2::Core::Response::Delayed;
  # ABSTRACT: Delayed responses
  $Dancer2::Core::Response::Delayed::VERSION = '0.162000';
  use Moo;
  use MooX::Types::MooseLike::Base qw<CodeRef InstanceOf>;
  
  has request => (
      is       => 'ro',
      isa      => InstanceOf['Dancer2::Core::Request'],
      required => 1,
  );
  
  has response => (
      is       => 'ro',
      isa      => InstanceOf['Dancer2::Core::Response'],
      required => 1,
      handles => [qw/status headers/],
  );
  
  has cb => (
      is       => 'ro',
      isa      => CodeRef,
      required => 1,
  );
  
  sub is_halted()  {0}
  sub has_passed() {0}
  
  sub to_psgi {
      my $self = shift;
      return sub {
          my $responder = shift;
  
          local $Dancer2::Core::Route::REQUEST   = $self->request;
          local $Dancer2::Core::Route::RESPONSE  = $self->response;
          local $Dancer2::Core::Route::RESPONDER = $responder;
          local $Dancer2::Core::Route::WRITER;
  
          $self->cb->();
      };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Response::Delayed - Delayed responses
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
      my $response = Dancer2::Core::Response::Delayed->new(
          request   => Dancer2::Core::Request->new(...),
          response  => Dancer2::Core::Response->new(...),
          cb        => sub {...},
      );
  
  =head1 DESCRIPTION
  
  This object represents a delayed (asynchronous) response for L<Dancer2>.
  It can be used via the C<delayed> keyword.
  
  It keeps references to a request and a response in order to avoid
  keeping a reference ot the application.
  
  =head1 ATTRIBUTES
  
  =head2 request
  
  Contains a request the delayed response uses.
  
  In the context of a web request, this will be the request that existed
  when the delayed response has been created.
  
  =head2 response
  
  Contains a response the delayed response uses.
  
  In the context of a web request, this will be the response that existed
  when the delayed response has been created.
  
  =head2 cb
  
  The code that will be run asynchronously.
  
  =head1 METHODS
  
  =head2 is_halted
  
  A method indicating whether the response has halted.
  
  This is useless in the context of an asynchronous request so it simply
  returns no.
  
  This method is likely going away.
  
  =head2 has_passed
  
  A method indicating whether the response asked to skip the current
  response.
  
  This is useless in the context of an asynchronous request so it simply
  returns no.
  
  This method is likely going away.
  
  =head2 to_psgi
  
  Create a PSGI response. The way it works is by returning a proper PSGI
  response subroutine which localizes the request and response (in case
  the callback wants to edit them without a reference to them), and then
  calls the callback.
  
  Finally, when the callback is done, it asks the response (whether it
  was changed or not) to create its own PSGI response (calling C<to_psgi>)
  and sends that to the callback it receives as a delayed response.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_RESPONSE_DELAYED

$fatpacked{"Dancer2/Core/Role/ConfigReader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_CONFIGREADER';
  # ABSTRACT: Config role for Dancer2 core objects
  package Dancer2::Core::Role::ConfigReader;
  $Dancer2::Core::Role::ConfigReader::VERSION = '0.162000';
  use Moo::Role;
  
  use File::Spec;
  use Config::Any;
  use Hash::Merge::Simple;
  use Carp 'croak';
  
  use Dancer2::Core::Factory;
  use Dancer2::Core;
  use Dancer2::Core::Types;
  use Dancer2::FileUtils 'path';
  
  with 'Dancer2::Core::Role::HasLocation';
  
  has default_config => (
      is      => 'ro',
      isa     => HashRef,
      lazy    => 1,
      builder => '_build_default_config',
  );
  
  has config_location => (
      is      => 'ro',
      isa     => ReadableFilePath,
      lazy    => 1,
      default => sub { $ENV{DANCER_CONFDIR} || $_[0]->location },
  );
  
  # The type for this attribute is Str because we don't require
  # an existing directory with configuration files for the
  # environments.  An application without environments is still
  # valid and works.
  has environments_location => (
      is      => 'ro',
      isa     => Str,
      lazy    => 1,
      default => sub {
          $ENV{DANCER_ENVDIR}
            || File::Spec->catdir( $_[0]->config_location, 'environments' )
            || File::Spec->catdir( $_[0]->location,        'environments' );
      },
  );
  
  has config => (
      is      => 'ro',
      isa     => HashRef,
      lazy    => 1,
      builder => '_build_config',
  );
  
  has environment => (
      is      => 'ro',
      isa     => Str,
      lazy    => 1,
      builder => '_build_environment',
  );
  
  has config_files => (
      is      => 'ro',
      lazy    => 1,
      isa     => ArrayRef,
      builder => '_build_config_files',
  );
  
  has local_triggers => (
      is      => 'ro',
      isa     => HashRef,
      default => sub { +{} },
  );
  
  has global_triggers => (
      is      => 'ro',
      isa     => HashRef,
      default => sub {
          my $triggers = {
              traces => sub {
                  my ( $self, $traces ) = @_;
                  # Carp is already a dependency
                  $Carp::Verbose = $traces ? 1 : 0;
              },
          };
  
          my $runner_config = defined $Dancer2::runner
                              ? Dancer2->runner->config
                              : {};
  
          for my $global ( keys %$runner_config ) {
              next if exists $triggers->{$global};
              $triggers->{$global} = sub {
                  my ($self, $value) = @_;
                  Dancer2->runner->config->{$global} = $value;
              }
          }
  
          return $triggers;
      },
  );
  
  sub _build_default_config { +{} }
  
  sub _build_environment { 'development' }
  
  sub _build_config_files {
      my ($self) = @_;
  
      my $location = $self->config_location;
      # an undef location means no config files for the caller
      return [] unless defined $location;
  
      my $running_env = $self->environment;
      my @exts = Config::Any->extensions;
      my @files;
  
      foreach my $ext (@exts) {
          foreach my $file ( [ $location, "config.$ext" ],
              [ $self->environments_location, "$running_env.$ext" ] )
          {
              my $path = path( @{$file} );
              next if !-r $path;
  
              push @files, $path;
          }
      }
  
      return [ sort @files ];
  }
  
  sub _build_config {
      my ($self) = @_;
  
      my $location = $self->config_location;
      my $default  = $self->default_config;
  
      my $config = Hash::Merge::Simple->merge(
          $default,
          map +( $self->load_config_file($_) ), @{ $self->config_files }
      );
  
      $config = $self->_normalize_config($config);
      return $config;
  }
  
  sub _set_config_entries {
      my ( $self, @args ) = @_;
      my $no = scalar @args;
      while (@args) {
          $self->_set_config_entry( shift(@args), shift(@args) );
      }
      return $no;
  }
  
  sub _set_config_entry {
      my ( $self, $name, $value ) = @_;
  
      $value = $self->_normalize_config_entry( $name, $value );
      $value = $self->_compile_config_entry( $name, $value, $self->config );
      $self->config->{$name} = $value;
  }
  
  sub _normalize_config {
      my ( $self, $config ) = @_;
  
      foreach my $key ( keys %{$config} ) {
          my $value = $config->{$key};
          $config->{$key} = $self->_normalize_config_entry( $key, $value );
      }
      return $config;
  }
  
  sub _compile_config {
      my ( $self, $config ) = @_;
  
      foreach my $key ( keys %{$config} ) {
          my $value = $config->{$key};
          $config->{$key} =
            $self->_compile_config_entry( $key, $value, $config );
      }
      return $config;
  }
  
  sub settings { shift->config }
  
  sub setting {
      my $self = shift;
      my @args = @_;
  
      return ( scalar @args == 1 )
        ? $self->settings->{ $args[0] }
        : $self->_set_config_entries(@args);
  }
  
  sub has_setting {
      my ( $self, $name ) = @_;
      return exists $self->config->{$name};
  }
  
  sub load_config_file {
      my ( $self, $file ) = @_;
      my $config;
  
      eval {
          my @files = ($file);
          my $tmpconfig =
            Config::Any->load_files( { files => \@files, use_ext => 1 } )->[0];
          ( $file, $config ) = %{$tmpconfig} if defined $tmpconfig;
      };
      if ( my $err = $@ || ( !$config ) ) {
          croak "Unable to parse the configuration file: $file: $@";
      }
  
      # TODO handle mergeable entries
      return $config;
  }
  
  # private
  
  my $_normalizers = {
      charset => sub {
          my ($charset) = @_;
          return $charset if !length( $charset || '' );
  
          require Encode;
          my $encoding = Encode::find_encoding($charset);
          croak
            "Charset defined in configuration is wrong : couldn't identify '$charset'"
            unless defined $encoding;
          my $name = $encoding->name;
  
          # Perl makes a distinction between the usual perl utf8, and the strict
          # utf8 charset. But we don't want to make this distinction
          $name = 'utf-8' if $name eq 'utf-8-strict';
          return $name;
      },
  };
  
  sub _normalize_config_entry {
      my ( $self, $name, $value ) = @_;
      $value = $_normalizers->{$name}->($value)
        if exists $_normalizers->{$name};
      return $value;
  }
  
  sub _compile_config_entry {
      my ( $self, $name, $value, $config ) = @_;
  
      my $trigger = exists $self->local_triggers->{$name} ?
                           $self->local_triggers->{$name} :
                           $self->global_triggers->{$name};
  
      defined $trigger or return $value;
  
      return $trigger->( $self, $value, $config );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::ConfigReader - Config role for Dancer2 core objects
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  Provides a C<config> attribute that feeds itself by finding and parsing
  configuration files.
  
  Also provides a C<setting()> method which is supposed to be used by externals to
  read/write config entries.
  
  =head1 ATTRIBUTES
  
  =head2 location
  
  Absolute path to the directory where the server started.
  
  =head2 config_location
  
  Gets the location from the configuration. Same as C<< $object->location >>.
  
  =head2 environments_location
  
  Gets the directory were the environment files are stored.
  
  =head2 config
  
  Returns the whole configuration.
  
  =head2 environments
  
  Returns the name of the environment.
  
  =head2 config_files
  
  List of all the configuration files.
  
  =head1 ATTRIBUTES
  
  =head1 METHODS
  
  =head2 settings
  
  Alias for config. Equivalent to <<$object->config>>.
  
  =head2 setting
  
  Get or set an element from the configuration.
  
  =head2 has_setting
  
  Verifies that a key exists in the configuration.
  
  =head2 load_config_file
  
  Load the configuration files.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_CONFIGREADER

$fatpacked{"Dancer2/Core/Role/DSL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_DSL';
  package Dancer2::Core::Role::DSL;
  # ABSTRACT: Role for DSL
  $Dancer2::Core::Role::DSL::VERSION = '0.162000';
  use Moo::Role;
  use Dancer2::Core::Types;
  use Carp 'croak';
  use Scalar::Util qw();
  
  with 'Dancer2::Core::Role::Hookable';
  
  has app => ( is => 'ro', required => 1 );
  
  has keywords => (
      is      => 'rw',
      isa     => HashRef,
      lazy    => 1,
      builder => '_build_dsl_keywords',
  );
  
  sub _build_dsl_keywords {
      my ($self) = @_;
      $self->can('dsl_keywords')
        ? $self->dsl_keywords
        : {};
  }
  
  sub register {
      my ( $self, $keyword, $is_global ) = @_;
      my $keywords = $self->keywords;
      my $pkg = ref($self);
      $pkg =~ s/__WITH__.+$//;
  
      if ( exists $keywords->{$keyword} ) {
          my $reg_pkg = $keywords->{$keyword}{'pkg'};
          $reg_pkg =~ s/__WITH__.+$//;
          $reg_pkg eq $pkg and return;
  
          croak "[$pkg] Keyword $keyword already registered by $reg_pkg";
      }
  
      $keywords->{$keyword} = { is_global => $is_global, pkg => $pkg };
  }
  
  sub dsl { $_[0] }
  
  # exports new symbol to caller
  sub export_symbols_to {
      my ( $self, $caller, $args ) = @_;
      my $exports = $self->_construct_export_map($args);
  
      ## no critic
      foreach my $export ( keys %{$exports} ) {
          no strict 'refs'; ## no critic (TestingAndDebugging::ProhibitNoStrict)
          my $existing = *{"${caller}::${export}"}{CODE};
  
          next if defined $existing;
  
          *{"${caller}::${export}"} = $exports->{$export};
      }
      ## use critic
  
      return keys %{$exports};
  }
  
  # private
  
  sub _compile_keyword {
      my ( $self, $keyword, $opts ) = @_;
  
      my $code = $opts->{is_global}
                 ? sub { $self->$keyword(@_) }
                 : sub {
              croak "Function '$keyword' must be called from a route handler"
                  unless defined $Dancer2::Core::Route::REQUEST;
  
              $self->$keyword(@_)
          };
  
      return $self->_apply_prototype($code, $opts);
  }
  
  sub _apply_prototype {
      my ($self, $code, $opts) = @_;
  
      # set prototype if one is defined for the keyword. undef => no prototype
      my $prototype;
      exists $opts->{'prototype'} and $prototype = $opts->{'prototype'};
      return Scalar::Util::set_prototype( \&$code, $prototype );
  }
  
  sub _construct_export_map {
      my ( $self, $args ) = @_;
      my $keywords = $self->keywords;
      my %map;
      foreach my $keyword ( keys %$keywords ) {
          # check if the keyword were excluded from importation
          $args->{ '!' . $keyword } and next;
          $map{$keyword} = $self->_compile_keyword( $keyword, $keywords->{$keyword} );
      }
      return \%map;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::DSL - Role for DSL
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_DSL

$fatpacked{"Dancer2/Core/Role/Engine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_ENGINE';
  package Dancer2::Core::Role::Engine;
  # ABSTRACT: Role for engines
  $Dancer2::Core::Role::Engine::VERSION = '0.162000';
  use Moo::Role;
  use Dancer2::Core::Types;
  
  with 'Dancer2::Core::Role::Hookable';
  
  has session => (
      is        => 'ro',
      isa       => InstanceOf['Dancer2::Core::Session'],
      writer    => 'set_session',
      clearer   => 'clear_session',
      predicate => 'has_session',
  );
  
  has config => (
      is      => 'ro',
      isa     => HashRef,
      default => sub { {} },
  );
  
  has request => (
      is        => 'ro',
      isa       => InstanceOf['Dancer2::Core::Request'],
      writer    => 'set_request',
      clearer   => 'clear_request',
      predicate => 'has_request',
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::Engine - Role for engines
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This role is intended to be consumed by all engine roles. It contains all the
  shared logic for engines.
  
  This role consumes the L<Dancer2::Core::Role::Hookable> role.
  
  =head1 ATTRIBUTES
  
  =head2 config
  
  An HashRef that hosts the configuration bits for the engine.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_ENGINE

$fatpacked{"Dancer2/Core/Role/Handler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_HANDLER';
  package Dancer2::Core::Role::Handler;
  # ABSTRACT: Role for Handlers
  $Dancer2::Core::Role::Handler::VERSION = '0.162000';
  use Moo::Role;
  use Dancer2::Core::Types;
  
  requires 'register';
  
  has app => (
      is  => 'ro',
      isa => InstanceOf ['Dancer2::Core::App'],
      weak_ref => 1,
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::Handler - Role for Handlers
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 ATTRIBUTES
  
  =head2 app
  
  Contain an object of class L<Dancer2::Core::App>.
  
  =head1 REQUIREMENTS
  
  This role requires the method C<register> to be implemented.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_HANDLER

$fatpacked{"Dancer2/Core/Role/HasLocation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_HASLOCATION';
  package Dancer2::Core::Role::HasLocation;
  # ABSTRACT: Role for application location "guessing"
  $Dancer2::Core::Role::HasLocation::VERSION = '0.162000';
  use Moo::Role;
  use Dancer2::Core::Types;
  use Dancer2::FileUtils;
  use File::Spec;
  use Sub::Quote 'quote_sub';
  
  # the path to the caller script/app
  # Note: to remove any ambiguity between the accessor for the
  # 'caller' attribute and the core function caller(), explictly
  # specify we want the function 'CORE::caller' as the default for
  # the attribute.
  has caller => (
      is      => 'ro',
      isa     => Str,
      default => quote_sub( q{
          my ( $caller, $script ) = CORE::caller;
          $script = File::Spec->abs2rel( $script ) if File::Spec->file_name_is_absolute( $script );
          $script;
      } ),
  );
  
  has location => (
      is      => 'ro',
      builder => '_build_location',
  );
  
  # FIXME: i hate you most of all -- Sawyer X
  sub _build_location {
      my $self   = shift;
      my $script = $self->caller;
  
      # default to the dir that contains the script...
      my $location = Dancer2::FileUtils::dirname($script);
  
      #we try to find bin and lib
      my $subdir       = $location;
      my $subdir_found = 0;
  
      #maximum of 10 iterations, to prevent infinite loop
      for ( 1 .. 10 ) {
  
          #try to find libdir and bindir to determine the root of dancer app
          my $libdir = Dancer2::FileUtils::path( $subdir, 'lib' );
          my $bindir = Dancer2::FileUtils::path( $subdir, 'bin' );
  
          #try to find .dancer_app file to determine the root of dancer app
          my $dancerdir = Dancer2::FileUtils::path( $subdir, '.dancer' );
  
          # if one of them is found, keep that; but skip ./blib since both lib and bin exist
          # under it, but views and public do not.
          if (
              ( $subdir !~ m![\\/]blib[\\/]?$! && -d $libdir && -d $bindir ) ||
              ( -f $dancerdir )
          ) {
              $subdir_found = 1;
              last;
          }
  
          $subdir = Dancer2::FileUtils::path( $subdir, '..' ) || '.';
          last if File::Spec->rel2abs($subdir) eq File::Spec->rootdir;
  
      }
  
      my $path = $subdir_found ? $subdir : $location;
  
      # return if absolute
      File::Spec->file_name_is_absolute($path)
          and return $path;
  
      # convert relative to absolute
      return File::Spec->rel2abs($path);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::HasLocation - Role for application location "guessing"
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_HASLOCATION

$fatpacked{"Dancer2/Core/Role/Hookable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_HOOKABLE';
  package Dancer2::Core::Role::Hookable;
  # ABSTRACT: Role for hookable objects
  $Dancer2::Core::Role::Hookable::VERSION = '0.162000';
  use Moo::Role;
  use Dancer2::Core;
  use Dancer2::Core::Types;
  use Carp 'croak';
  use Safe::Isa;
  
  requires 'supported_hooks', 'hook_aliases';
  
  # The hooks registry
  has hooks => (
      is      => 'ro',
      isa     => HashRef,
      builder => '_build_hooks',
      lazy    => 1,
  );
  
  sub BUILD { }
  
  # after a hookable object is built, we go over its postponed hooks and register
  # them if any.
  after BUILD => sub {
      my ( $self, $args ) = @_;
      $self->_add_postponed_hooks($args)
        if defined $args->{postponed_hooks};
  };
  
  sub _add_postponed_hooks {
      my ( $self, $args ) = @_;
      my $postponed_hooks = $args->{postponed_hooks};
  
      # find the internal name of the hooks, from the caller name
      my $caller = ref($self);
      my ( $dancer, $h_type, $h_name, @rest ) = map lc, split /::/, $caller;
      $h_name = $rest[0] if $h_name eq 'role';
      if ( $h_type =~ /(template|logger|serializer|session)/ ) {
          $h_name = $h_type;
          $h_type = 'engine';
      }
  
      # keep only the hooks we want
      $postponed_hooks = $postponed_hooks->{$h_type}{$h_name};
      return unless defined $postponed_hooks;
  
      foreach my $name ( keys %{$postponed_hooks} ) {
          my $hook   = $postponed_hooks->{$name}{hook};
          my $caller = $postponed_hooks->{$name}{caller};
  
          $self->has_hook($name)
            or croak "$h_name $h_type does not support the hook `$name'. ("
            . join( ", ", @{$caller} ) . ")";
  
          $self->add_hook($hook);
      }
  }
  
  # mst++ for the hint
  sub _build_hooks {
      my ($self) = @_;
      my %hooks = map +( $_ => [] ), $self->supported_hooks;
      return \%hooks;
  }
  
  # This binds a coderef to an installed hook if not already
  # existing
  sub add_hook {
      my ( $self, $hook ) = @_;
      my $name = $hook->name;
      my $code = $hook->code;
  
      croak "Unsupported hook '$name'"
        unless $self->has_hook($name);
  
      push @{ $self->hooks->{$name} }, $code;
  }
  
  # allows the caller to replace the current list of hooks at the given position
  # this is useful if the object where this role is composed wants to compile the
  # hooks.
  sub replace_hook {
      my ( $self, $position, $hooks ) = @_;
  
      croak "Hook '$position' must be installed first"
        unless $self->has_hook($position);
  
      $self->hooks->{$position} = $hooks;
  }
  
  # Boolean flag to tells if the hook is registered or not
  sub has_hook {
      my ( $self, $hook_name ) = @_;
      return exists $self->hooks->{$hook_name};
  }
  
  # Execute the hook at the given position
  sub execute_hook {
      my ( $self, $name, @args ) = @_;
  
      croak "execute_hook needs a hook name"
        if !defined $name || !length($name);
  
      $name = $self->hook_aliases->{$name}
        if exists $self->hook_aliases->{$name};
  
      croak "Hook '$name' does not exist"
        if !$self->has_hook($name);
  
      $self->$_isa('Dancer2::Core::App') &&
        $self->log( core => "Entering hook $name" );
  
      for my $hook ( @{ $self->hooks->{$name} } ) {
          $hook->(@args);
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::Hookable - Role for hookable objects
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_HOOKABLE

$fatpacked{"Dancer2/Core/Role/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_LOGGER';
  package Dancer2::Core::Role::Logger;
  # ABSTRACT: Role for logger engines
  $Dancer2::Core::Role::Logger::VERSION = '0.162000';
  use Dancer2::Core::Types;
  
  use Moo::Role;
  use POSIX 'strftime';
  use Data::Dumper;
  
  with 'Dancer2::Core::Role::Engine';
  
  sub hook_aliases { +{} }
  sub supported_hooks {
      qw(
        engine.logger.before
        engine.logger.after
      );
  }
  
  sub _build_type {'Logger'}
  
  # This is the only method to implement by logger engines.
  # It receives the following arguments:
  # $msg_level, $msg_content, it gets called only if the configuration allows
  # a message of the given level to be logged.
  requires 'log';
  
  has auto_encoding_charset => (
      is  => 'ro',
      isa => Str,
  );
  
  has app_name => (
      is      => 'ro',
      isa     => Str,
      default => sub {'-'},
  );
  
  has log_format => (
      is      => 'rw',
      isa     => Str,
      default => sub {'[%a:%P] %L @%T> %m in %f l. %l'},
  );
  
  my $_levels = {
  
      # levels < 0 are for core only
      core => -10,
  
      # levels > 0 are for end-users only
      debug   => 1,
      info    => 2,
      warn    => 3,
      warning => 3,
      error   => 4,
  };
  
  has log_level => (
      is  => 'rw',
      isa => sub {
          grep {/$_[0]/} keys %{$_levels};
      },
      default => sub {'debug'},
  );
  
  sub _should {
      my ( $self, $msg_level ) = @_;
      my $conf_level = $self->log_level;
      return $_levels->{$conf_level} <= $_levels->{$msg_level};
  }
  
  sub format_message {
      my ( $self, $level, $message ) = @_;
      chomp $message;
  
      $message = Encode::encode( $self->auto_encoding_charset, $message )
        if $self->auto_encoding_charset;
  
      my @stack = caller(5);
      my $request = $self->request;
      my $config = $self->config;
  
      my $block_handler = sub {
          my ( $block, $type ) = @_;
          if ( $type eq 't' ) {
              return Encode::decode(
                  $config->{'charset'} || 'UTF-8',
                  POSIX::strftime( $block, localtime(time) )
              );
          }
          elsif ( $type eq 'h' ) {
              return ( $request && $request->header($block) ) || '-';
          }
          else {
              Carp::carp("{$block}$type not supported");
              return "-";
          }
      };
  
      my $chars_mapping = {
          a => sub { $self->app_name },
          t => sub {
              Encode::decode(
                  $config->{'charset'} || 'UTF-8',
                  POSIX::strftime( "%d/%b/%Y %H:%M:%S", localtime(time) )
              );
          },
          T => sub { POSIX::strftime( "%Y-%m-%d %H:%M:%S", localtime(time) ) },
          u => sub {
              Encode::decode(
                  $config->{'charset'} || 'UTF-8',
                  POSIX::strftime( "%d/%b/%Y %H:%M:%S", gmtime(time) )
              );
          },
          U => sub { POSIX::strftime( "%Y-%m-%d %H:%M:%S", gmtime(time) ) },
          P => sub {$$},
          L => sub {$level},
          m => sub {$message},
          f => sub { $stack[1] || '-' },
          l => sub { $stack[2] || '-' },
          h => sub {
              ( $request && ( $request->remote_host || $request->address ) ) || '-'
          },
          i => sub { ( $request && $request->id ) || '-' },
      };
  
      my $char_mapping = sub {
          my $char = shift;
  
          my $cb = $chars_mapping->{$char};
          if ( !$cb ) {
              Carp::carp "\%$char not supported.";
              return "-";
          }
          $cb->($char);
      };
  
      my $fmt = $self->log_format;
  
      $fmt =~ s/
          (?:
              \%\{(.+?)\}([a-z])|
              \%([a-zA-Z])
          )
      / $1 ? $block_handler->($1, $2) : $char_mapping->($3) /egx;
  
      return $fmt . "\n";
  }
  
  sub _serialize {
      my @vars = @_;
  
      return join q{}, map +(
          ref $_
            ? Data::Dumper->new( [$_] )->Terse(1)->Purity(1)->Indent(0)
            ->Sortkeys(1)->Dump()
            : ( defined($_) ? $_ : 'undef' )
      ), @vars;
  }
  
  sub core {
      my ( $self, @args ) = @_;
      $self->_should('core') and $self->log( 'core', _serialize(@args) );
  }
  
  sub debug {
      my ( $self, @args ) = @_;
      $self->_should('debug') and $self->log( 'debug', _serialize(@args) );
  }
  
  sub info {
      my ( $self, @args ) = @_;
      $self->_should('info') and $self->log( 'info', _serialize(@args) );
  }
  
  sub warning {
      my ( $self, @args ) = @_;
      $self->_should('warning') and $self->log( 'warning', _serialize(@args) );
  }
  
  sub error {
      my ( $self, @args ) = @_;
      $self->_should('error') and $self->log( 'error', _serialize(@args) );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::Logger - Role for logger engines
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  Any class that consumes this role will be able to implement to write log messages.
  
  In order to implement this role, the consumer B<must> implement the C<log>
  method. This method will receives as argument the C<level> and the C<message>.
  
  =head1 ATTRIBUTES
  
  =head2 auto_encoding_charset
  
  Charset to use when writing a message.
  
  =head2 app_name
  
  Name of the application. Can be used in the message.
  
  =head2 log_format
  
  This is a format string (or a preset name) to specify the log format.
  
  The possible values are:
  
  =over 4
  
  =item %h
  
  host emitting the request
  
  =item %t
  
  date (local timezone, formatted like %d/%b/%Y %H:%M:%S)
  
  =item %T
  
  date (local timezone, formatted like %Y-%m-%d %H:%M:%S)
  
  =item %u
  
  date (UTC timezone, formatted like %d/%b/%Y %H:%M:%S)
  
  =item %U
  
  date (UTC timezone, formatted like %Y-%m-%d %H:%M:%S)
  
  =item %P
  
  PID
  
  =item %L
  
  log level
  
  =item %D
  
  timer
  
  =item %m
  
  message
  
  =item %f
  
  file name that emit the message
  
  =item %l
  
  line from the file
  
  =item %i
  
  request ID
  
  =item %{$fmt}t
  
  timer formatted with a valid time format
  
  =item %{header}h
  
  header value
  
  =back
  
  =head2 log_level
  
  Level to use by default.
  
  =head1 METHODS
  
  =head2 core
  
  Log messages as B<core>.
  
  =head2 debug
  
  Log messages as B<debug>.
  
  =head2 info
  
  Log messages as B<info>.
  
  =head2 warning
  
  Log messages as B<warning>.
  
  =head2 error
  
  Log messages as B<error>.
  
  =head2 format_message
  
  Provides a common message formatting.
  
  =head1 CONFIGURATION
  
  The B<logger> configuration variable tells Dancer2 which engine to use.
  
  You can change it either in your config.yml file:
  
      # logging to console
      logger: "console"
  
  The log format can also be configured,
  please see L<Dancer2::Core::Role::Logger/"log_format"> for details.
  
  =head1 METHODS
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_LOGGER

$fatpacked{"Dancer2/Core/Role/Serializer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_SERIALIZER';
  package Dancer2::Core::Role::Serializer;
  # ABSTRACT: Role for Serializer engines
  $Dancer2::Core::Role::Serializer::VERSION = '0.162000';
  use Moo::Role;
  use Dancer2::Core::Types;
  use Scalar::Util 'blessed';
  
  with 'Dancer2::Core::Role::Engine';
  
  sub hook_aliases {
      {
          before_serializer => 'engine.serializer.before',
          after_serializer  => 'engine.serializer.after',
      }
  }
  
  sub supported_hooks { values %{ shift->hook_aliases } }
  
  sub _build_type {'Serializer'}
  
  requires 'serialize';
  requires 'deserialize';
  
  has log_cb => (
      is      => 'ro',
      isa     => CodeRef,
      default => sub { sub {1} },
  );
  
  has content_type => (
      is       => 'ro',
      isa      => Str,
      required => 1,
      writer   => 'set_content_type'
  );
  
  around serialize => sub {
      my ( $orig, $self, $content, $options ) = @_;
  
      $content && length $content > 0
          or return $content;
  
      blessed $self && $self->execute_hook( 'engine.serializer.before', $content );
  
      my $data;
      eval {
          $data = $self->$orig( $content, $options );
          blessed $self
              and $self->execute_hook( 'engine.serializer.after', $data );
          1;
      } or do {
          my $error = $@ || 'Zombie Error';
          blessed $self
              and $self->log_cb->( core => "Failed to serialize the request: $error" );
      };
  
      return $data;
  };
  
  around deserialize => sub {
      my ( $orig, $self, $content, $options ) = @_;
  
      $content && length $content > 0
          or return $content;
  
      my $data;
      eval {
          $data = $self->$orig($content, $options);
          1;
      } or do {
          my $error = $@ || 'Zombie Error';
          $self->log_cb->( core => "Failed to deserialize the request: $error" );
      };
  
      return $data;
  };
  
  # most serializer don't have to overload this one
  sub support_content_type {
      my ( $self, $ct ) = @_;
      return unless $ct;
  
      my @toks = split ';', $ct;
      $ct = lc( $toks[0] );
      return $ct eq $self->content_type;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::Serializer - Role for Serializer engines
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  Any class that consumes this role will be able to be used as a
  serializer under Dancer2.
  
  In order to implement this role, the consumer B<must> implement the
  methods C<serialize> and C<deserialize>, and should define
  the C<content_type> attribute value.
  
  =head1 ATTRIBUTES
  
  =head2 content_type
  
  The I<content type> of the object after being serialized. For example,
  a JSON serializer would have a I<application/json> content type
  defined.
  
  =head1 METHODS
  
  =head2 serialize($content, [\%options])
  
  The serialize method need to be implemented by the consumer. It
  receives the serializer class object and a reference to the object to
  be serialized. Should return the object after being serialized, in the
  content type defined by the C<content_type> attribute.
  
  A third optional argument is a hash reference of options to the
  serializer.
  
  The serialize method must return bytes and therefore has to handle any
  encoding.
  
  =head2 deserialize($content, [\%options])
  
  The inverse method of C<serialize>. Receives the serializer class
  object and a string that should be deserialized. The method should
  return a reference to the deserialized Perl data structure.
  
  A third optional argument is a hash reference of options to the
  serializer.
  
  The deserialize method receives encoded bytes and must therefore
  handle any decoding required.
  
  =head1 METHODS
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_SERIALIZER

$fatpacked{"Dancer2/Core/Role/SessionFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_SESSIONFACTORY';
  package Dancer2::Core::Role::SessionFactory;
  # ABSTRACT: Role for session factories
  $Dancer2::Core::Role::SessionFactory::VERSION = '0.162000';
  use Moo::Role;
  with 'Dancer2::Core::Role::Engine';
  
  use Carp 'croak';
  use Class::Load 'try_load_class';
  use Dancer2::Core::Session;
  use Dancer2::Core::Types;
  use Digest::SHA 'sha1';
  use List::Util 'shuffle';
  use MIME::Base64 'encode_base64url';
  
  sub hook_aliases { +{} }
  sub supported_hooks {
      qw/
        engine.session.before_retrieve
        engine.session.after_retrieve
  
        engine.session.before_create
        engine.session.after_create
  
        engine.session.before_destroy
        engine.session.after_destroy
  
        engine.session.before_flush
        engine.session.after_flush
        /;
  }
  
  sub _build_type {
      'SessionFactory';
  }    # XXX vs 'Session'?  Unused, so I can't tell -- xdg
  
  has log_cb => (
      is      => 'ro',
      isa     => CodeRef,
      default => sub { sub {1} },
  );
  
  has cookie_name => (
      is      => 'ro',
      isa     => Str,
      default => sub {'dancer.session'},
  );
  
  has cookie_domain => (
      is        => 'ro',
      isa       => Str,
      predicate => 1,
  );
  
  has cookie_path => (
      is      => 'ro',
      isa     => Str,
      default => sub {"/"},
  );
  
  has cookie_duration => (
      is        => 'ro',
      isa       => Str,
      predicate => 1,
  );
  
  has session_duration => (
      is        => 'ro',
      isa       => Num,
      predicate => 1,
  );
  
  has is_secure => (
      is      => 'rw',
      isa     => Bool,
      default => sub {0},
  );
  
  has is_http_only => (
      is      => 'rw',
      isa     => Bool,
      default => sub {1},
  );
  
  sub create {
      my ($self) = @_;
  
      my %args = ( id => $self->generate_id, );
  
      $args{expires} = $self->cookie_duration
        if $self->has_cookie_duration;
  
      my $session = Dancer2::Core::Session->new(%args);
  
      $self->execute_hook( 'engine.session.before_create', $session );
  
      # XXX why do we _flush now?  Seems unnecessary -- xdg, 2013-03-03
      eval { $self->_flush( $session->id, $session->data ) };
      croak "Unable to create a new session: $@"
        if $@;
  
      $self->execute_hook( 'engine.session.after_create', $session );
      return $session;
  }
  
  {
      my $COUNTER     = 0;
      my $CPRNG_AVAIL = try_load_class('Math::Random::ISAAC::XS') &&
                        try_load_class('Crypt::URandom');
  
      # don't initialize until generate_id is called so the ISAAC algorithm
      # is seeded after any pre-forking
      my $CPRNG;
  
      # prepend epoch seconds so session ID is roughly monotonic
      sub generate_id {
          my ($self) = @_;
  
          if ($CPRNG_AVAIL) {
              $CPRNG ||= Math::Random::ISAAC::XS->new(
                  map { unpack( "N", Crypt::URandom::urandom(4) ) } 1 .. 256 );
  
              # include $$ to ensure $CPRNG wasn't forked by accident
              return encode_base64url(
                  pack(
                      "N6",
                      time,          $$,            $CPRNG->irand,
                      $CPRNG->irand, $CPRNG->irand, $CPRNG->irand
                  )
              );
          }
          else {
              my $seed = (
                  rand(1_000_000_000)   # a random number
                    . __FILE__          # the absolute path as a secret key
                    . $COUNTER++        # impossible to have two consecutive dups
                    . $$         # the process ID as another private constant
                    . "$self"    # the instance's memory address for more entropy
                    . join( '', shuffle( 'a' .. 'z', 'A' .. 'Z', 0 .. 9 ) )
  
                    # a shuffled list of 62 chars, another random component
              );
              return encode_base64url( pack( "Na*", time, sha1($seed) ) );
          }
  
      }
  }
  
  requires '_retrieve';
  
  sub retrieve {
      my ( $self, %params ) = @_;
      my $id = $params{id};
  
      $self->execute_hook( 'engine.session.before_retrieve', $id );
  
      my $data = eval { $self->_retrieve($id) };
      croak "Unable to retrieve session with id '$id'"
        if $@;
  
      my %args = ( id => $id, );
  
      $args{data} = $data
        if $data and ref $data eq 'HASH';
  
      $args{expires} = $self->cookie_duration
        if $self->has_cookie_duration;
  
      my $session = Dancer2::Core::Session->new(%args);
  
      $self->execute_hook( 'engine.session.after_retrieve', $session );
      return $session;
  }
  
  requires '_destroy';
  
  sub destroy {
      my ( $self, %params ) = @_;
      my $id = $params{id};
      $self->execute_hook( 'engine.session.before_destroy', $id );
  
      eval { $self->_destroy($id) };
      croak "Unable to destroy session with id '$id': $@"
        if $@;
  
      $self->execute_hook( 'engine.session.after_destroy', $id );
      return $id;
  }
  
  requires '_flush';
  
  sub flush {
      my ( $self, %params ) = @_;
      my $session = $params{session};
      $self->execute_hook( 'engine.session.before_flush', $session );
  
      eval { $self->_flush( $session->id, $session->data ) };
      croak "Unable to flush session: $@"
        if $@;
  
      $self->execute_hook( 'engine.session.after_flush', $session );
      return $session->id;
  }
  
  sub set_cookie_header {
      my ( $self, %params ) = @_;
      $params{response}->push_header(
          'Set-Cookie',
          $self->cookie( session => $params{session} )->to_header
      );
  }
  
  sub cookie {
      my ( $self, %params ) = @_;
      my $session = $params{session};
      croak "cookie() requires a valid 'session' parameter"
        unless ref($session) && $session->isa("Dancer2::Core::Session");
  
      my %cookie = (
          value     => $session->id,
          name      => $self->cookie_name,
          path      => $self->cookie_path,
          secure    => $self->is_secure,
          http_only => $self->is_http_only,
      );
  
      $cookie{domain} = $self->cookie_domain
        if $self->has_cookie_domain;
  
      if ( my $expires = $session->expires ) {
          $cookie{expires} = $expires;
      }
  
      return Dancer2::Core::Cookie->new(%cookie);
  }
  
  requires '_sessions';
  
  sub sessions {
      my ($self) = @_;
      my $sessions = $self->_sessions;
  
      croak "_sessions() should return an array ref"
        if ref($sessions) ne ref( [] );
  
      return $sessions;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::SessionFactory - Role for session factories
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  Any class that consumes this role will be able to store, create, retrieve and
  destroy session objects.
  
  The default values for attributes can be overridden in your Dancer2
  configuration. See L<Dancer2::Config/Session-engine>.
  
  =head1 ATTRIBUTES
  
  =head2 cookie_name
  
  The name of the cookie to create for storing the session key
  
  Defaults to C<dancer.session>
  
  =head2 cookie_domain
  
  The domain of the cookie to create for storing the session key.
  Defaults to the empty string and is unused as a result.
  
  =head2 cookie_path
  
  The path of the cookie to create for storing the session key.
  Defaults to "/".
  
  =head2 cookie_duration
  
  Default duration before session cookie expiration.  If set, the
  L<Dancer2::Core::Session> C<expires> attribute will be set to the current time
  plus this duration (expression parsed by L<Dancer2::Core::Time>).
  
  =head2 session_duration
  
  Duration in seconds before sessions should expire, regardless of cookie
  expiration.  If set, then SessionFactories should use this to enforce a limit
  on session validity.
  
  =head2 is_secure
  
  Boolean flag to tell if the session cookie is secure or not.
  
  Default is false.
  
  =head2 is_http_only
  
  Boolean flag to tell if the session cookie is http only.
  
  Default is true.
  
  =head1 INTERFACE
  
  Following is the interface provided by this role. When specified the required
  methods to implement are described.
  
  =head2 create
  
  Create a brand new session object and store it. Returns the newly created
  session object.
  
  Triggers an exception if the session is unable to be created.
  
      my $session = MySessionFactory->create();
  
  This method does not need to be implemented in the class.
  
  =head2 generate_id
  
  Returns a randomly-generated, guaranteed-unique string.
  By default, it is a 32-character, URL-safe, Base64 encoded combination
  of a 32 bit timestamp and a 160 bit SHA1 digest of random seed data.
  The timestamp ensures that session IDs are generally monotonic.
  
  The default algorithm is not guaranteed cryptographically secure, but it's
  still reasonably strong for general use.
  
  If you have installed L<Math::Random::ISAAC::XS> and L<Crypt::URandom>,
  the seed data will be generated from a cryptographically-strong
  random number generator.
  
  This method is used internally by create() to set the session ID.
  
  This method does not need to be implemented in the class unless an
  alternative method for session ID generation is desired.
  
  =head2 retrieve
  
  Return the session object corresponding to the session ID given. If none is
  found, triggers an exception.
  
      my $session = MySessionFactory->retrieve(id => $id);
  
  The method C<_retrieve> must be implemented.  It must take C<$id> as a single
  argument and must return a hash reference of session data.
  
  =head2 destroy
  
  Purges the session object that matches the ID given. Returns the ID of the
  destroyed session if succeeded, triggers an exception otherwise.
  
      MySessionFactory->destroy(id => $id);
  
  The C<_destroy> method must be implemented. It must take C<$id> as a single
  argument and destroy the underlying data.
  
  =head2 flush
  
  Make sure the session object is stored in the factory's backend. This method is
  called to notify the backend about the change in the session object.
  
  The Dancer application will not call flush unless the session C<is_dirty>
  attribute is true to avoid unnecessary writes to the database when no
  data has been modified.
  
  An exception is triggered if the session is unable to be updated in the backend.
  
      MySessionFactory->flush(session => $session);
  
  The C<_flush> method must be implemented.  It must take two arguments: the C<$id>
  and a hash reference of session data.
  
  =head2 set_cookie_header
  
  Sets the session cookie into the response object
  
      MySessionFactory->set_cookie_header(
          response  => $response,
          session   => $session,
          destroyed => undef,
      );
  
  The C<response> parameter contains a L<Dancer2::Core::Response> object.
  The C<session> parameter contains a L<Dancer2::Core::Session> object.
  
  The C<destroyed> parameter is optional.  If true, it indicates the
  session was marked destroyed by the request context.  The default
  C<set_cookie_header> method doesn't need that information, but it is
  included in case a SessionFactory must handle destroyed sessions
  differently (such as signalling to middleware).
  
  =head2 cookie
  
  Coerce a session object into a L<Dancer2::Core::Cookie> object.
  
      MySessionFactory->cookie(session => $session);
  
  =head2 sessions
  
  Return a list of all session IDs stored in the backend.
  Useful to create cleaning scripts, in conjunction with session's creation time.
  
  The C<_sessions> method must be implemented.  It must return an array reference
  of session IDs (or an empty array reference).
  
  =head1 CONFIGURATION
  
  If there are configuration values specific to your session factory in your config.yml or
  environment, those will be passed to the constructor of the session factory automatically.
  In order to accept and store them, you need to define accessors for them.
  
      engines:
        session:
          Example:
            database_connection: "some_data"
  
  In your session factory:
  
      package Dancer2::Session::Example;
      use Moo;
      with "Dancer2::Core::Role::SessionFactory";
  
      has database_connection => ( is => "ro" );
  
  You need to do this for every configuration key. The ones that do not have accessors
  defined will just go to the void.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_SESSIONFACTORY

$fatpacked{"Dancer2/Core/Role/SessionFactory/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_SESSIONFACTORY_FILE';
  package Dancer2::Core::Role::SessionFactory::File;
  # ABSTRACT: Role for file-based session factories
  $Dancer2::Core::Role::SessionFactory::File::VERSION = '0.162000';
  use Moo::Role;
  with 'Dancer2::Core::Role::SessionFactory';
  
  use Carp 'croak';
  use Dancer2::Core::Types;
  use Dancer2::FileUtils qw(path set_file_mode escape_filename);
  use Fcntl ':flock';
  
  #--------------------------------------------------------------------------#
  # Required by classes consuming this role
  #--------------------------------------------------------------------------#
  
  requires '_suffix';              # '.yml', '.json', etc.
  requires '_thaw_from_handle';    # given handle, return session 'data' field
  requires '_freeze_to_handle';    # given handle and data, serialize it
  
  
  #--------------------------------------------------------------------------#
  # Attributes and methods
  #--------------------------------------------------------------------------#
  
  has session_dir => (
      is      => 'ro',
      isa     => Str,
      default => sub { path( '.', 'sessions' ) },
  );
  
  sub BUILD {
      my $self = shift;
  
      if ( !-d $self->session_dir ) {
          mkdir $self->session_dir
            or croak "Unable to create session dir : "
            . $self->session_dir . ' : '
            . $!;
      }
  }
  
  sub _sessions {
      my ($self) = @_;
      my $sessions = [];
  
      opendir( my $dh, $self->session_dir )
        or croak "Unable to open directory " . $self->session_dir . " : $!";
  
      my $suffix = $self->_suffix;
  
      while ( my $file = readdir($dh) ) {
          next if $file eq '.' || $file eq '..';
          if ( $file =~ /(\w+)\Q$suffix\E/ ) {
              push @{$sessions}, $1;
          }
      }
      closedir($dh);
  
      return $sessions;
  }
  
  sub _retrieve {
      my ( $self, $id ) = @_;
      my $session_file = path( $self->session_dir, escape_filename($id) . $self->_suffix );
  
      return unless -f $session_file;
  
      open my $fh, '+<', $session_file or die "Can't open '$session_file': $!\n";
      flock $fh, LOCK_SH or die "Can't lock file '$session_file': $!\n";
      my $data = $self->_thaw_from_handle($fh);
      close $fh or die "Can't close '$session_file': $!\n";
  
      return $data;
  }
  
  sub _destroy {
      my ( $self, $id ) = @_;
      my $session_file = path( $self->session_dir, escape_filename($id) . $self->_suffix );
      return if !-f $session_file;
  
      unlink $session_file;
  }
  
  sub _flush {
      my ( $self, $id, $data ) = @_;
      my $session_file = path( $self->session_dir, escape_filename($id) . $self->_suffix );
  
      open my $fh, '>', $session_file or die "Can't open '$session_file': $!\n";
      flock $fh, LOCK_EX or die "Can't lock file '$session_file': $!\n";
      seek $fh, 0, 0 or die "Can't seek in file '$session_file': $!\n";
      truncate $fh, 0 or die "Can't truncate file '$session_file': $!\n";
      set_file_mode($fh);
      $self->_freeze_to_handle( $fh, $data );
      close $fh or die "Can't close '$session_file': $!\n";
  
      return $data;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::SessionFactory::File - Role for file-based session factories
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This is a specialized SessionFactory role for storing session
  data in files.
  
  This role manages the files.  Classes consuming it only need to handle
  serialization and deserialization.
  
  Classes consuming this must satisfy three requirements: C<_suffix>,
  C<_freeze_to_handle> and C<_thaw_from_handle>.
  
      package Dancer2::SessionFactory::XYX
  
      use Moo;
  
      has _suffix => (
          is      => 'ro',
          isa     => 'Str',
          default => sub { '.xyz' },
      );
  
      with 'Dancer2::Core::Role::SessionFactory::File';
  
      sub _freeze_to_handle {
          my ($self, $fh, $data) = @_;
  
          # ... do whatever to get data into $fh
  
          return;
      }
  
      sub _thaw_from_handle {
          my ($self, $fh) = @_;
          my $data;
  
          # ... do whatever to get data from $fh
  
          return $data;
      }
  
      1;
  
  =head1 ATTRIBUTES
  
  =head2 session_dir
  
  Where to store the session files.  Defaults to "./sessions".
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_SESSIONFACTORY_FILE

$fatpacked{"Dancer2/Core/Role/StandardResponses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_STANDARDRESPONSES';
  package Dancer2::Core::Role::StandardResponses;
  # ABSTRACT: Role to provide commonly used responses
  $Dancer2::Core::Role::StandardResponses::VERSION = '0.162000';
  use Moo::Role;
  use Dancer2::Core::HTTP;
  
  sub response {
      my ( $self, $app, $code, $message ) = @_;
      $app->response->status($code);
      $app->response->header( 'Content-Type', 'text/plain' );
      return $message;
  }
  
  sub standard_response {
      my ( $self, $app, $status_code ) = @_;
  
      return $self->response(
          $app,
          $status_code,
          Dancer2::Core::HTTP->status_message($status_code),
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::StandardResponses - Role to provide commonly used responses
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 METHODS
  
  =head2 response
  
  Generic method that produces a custom response given with a code and a message:
  
      $self->response( $app, 404, 'Not Found' );
  
  This could be used to create your own, which is separate from the standard one:
  
      $self->response( $app, 404, 'File missing in action' );
  
  =head2 standard_response
  
  Produces a standard response using the code.
  
      # first example can be more easily written as
      $self->standard_response( $app, 404 );
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_STANDARDRESPONSES

$fatpacked{"Dancer2/Core/Role/Template.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROLE_TEMPLATE';
  # ABSTRACT: Role for template engines
  
  package Dancer2::Core::Role::Template;
  $Dancer2::Core::Role::Template::VERSION = '0.162000';
  use Dancer2::Core::Types;
  use Dancer2::FileUtils qw'path';
  use Carp 'croak';
  
  use Data::Dumper;
  use Moo::Role;
  with 'Dancer2::Core::Role::Engine';
  
  sub hook_aliases {
      {
          before_template_render => 'engine.template.before_render',
          after_template_render  => 'engine.template.after_render',
          before_layout_render   => 'engine.template.before_layout_render',
          after_layout_render    => 'engine.template.after_layout_render',
      }
  }
  
  sub supported_hooks { values %{ shift->hook_aliases } }
  
  sub _build_type {'Template'}
  
  requires 'render';
  
  has log_cb => (
      is      => 'ro',
      isa     => CodeRef,
      default => sub { sub {1} },
  );
  
  has name => (
      is      => 'ro',
      lazy    => 1,
      builder => 1,
  );
  
  sub _build_name {
      ( my $name = ref shift ) =~ s/^Dancer2::Template:://;
      $name;
  }
  
  has charset => (
      is      => 'ro',
      isa     => Str,
      default => sub {'UTF-8'},
  );
  
  has default_tmpl_ext => (
      is      => 'ro',
      isa     => Str,
      default => sub { shift->config->{extension} || 'tt' },
  );
  
  has views => (
      is  => 'rw',
      isa => Maybe [Str],
  );
  
  has layout => (
      is  => 'rw',
      isa => Maybe [Str],
  );
  
  has engine => (
      is      => 'ro',
      isa     => Object,
      lazy    => 1,
      builder => 1,
  );
  
  has settings => (
      is      => 'ro',
      isa     => HashRef,
      lazy    => 1,
      default => sub { +{} },
      writer  => 'set_settings',
  );
  
  has layout_dir => (
      is      => 'ro',
      isa     => Str,
      default => sub {'layouts'},
  );
  
  sub _template_name {
      my ( $self, $view ) = @_;
      my $def_tmpl_ext = $self->default_tmpl_ext();
      $view .= ".$def_tmpl_ext" if $view !~ /\.\Q$def_tmpl_ext\E$/;
      return $view;
  }
  
  sub view_pathname {
      my ( $self, $view ) = @_;
  
      $view = $self->_template_name($view);
      return path( $self->views, $view );
  }
  
  sub layout_pathname {
      my ( $self, $layout ) = @_;
  
      return path(
          $self->views,
          $self->layout_dir,
          $self->_template_name($layout),
      );
  }
  
  sub render_layout {
      my ( $self, $layout, $tokens, $content ) = @_;
  
      $layout = $self->layout_pathname($layout);
  
      # FIXME: not sure if I can "just call render"
      $self->render( $layout, { %$tokens, content => $content } );
  }
  
  sub apply_renderer {
      my ( $self, $view, $tokens ) = @_;
      $view = $self->view_pathname($view) if !ref $view;
      $tokens = $self->_prepare_tokens_options( $tokens );
  
      $self->execute_hook( 'engine.template.before_render', $tokens );
  
      my $content = $self->render( $view, $tokens );
      $self->execute_hook( 'engine.template.after_render', \$content );
  
      # make sure to avoid ( undef ) in list context return
      defined $content and return $content;
      return;
  }
  
  sub apply_layout {
      my ( $self, $content, $tokens, $options ) = @_;
  
      $tokens = $self->_prepare_tokens_options( $tokens );
  
     # If 'layout' was given in the options hashref, use it if it's a true value,
     # or don't use a layout if it was false (0, or undef); if layout wasn't
     # given in the options hashref, go with whatever the current layout setting
     # is.
      my $layout =
        exists $options->{layout}
        ? ( $options->{layout} ? $options->{layout} : undef )
        : ( $self->layout || $self->config->{layout} );
  
      # that should only be $self->config, but the layout ain't there ???
  
      defined $content or return;
      defined $layout  or return $content;
  
      $self->execute_hook(
          'engine.template.before_layout_render',
          $tokens, \$content
      );
  
      my $full_content = $self->render_layout( $layout, $tokens, $content );
  
      $self->execute_hook( 'engine.template.after_layout_render',
          \$full_content );
  
      # make sure to avoid ( undef ) in list context return
      defined $full_content and return $full_content;
      return;
  }
  
  sub _prepare_tokens_options {
      my ( $self, $tokens ) = @_;
  
      # these are the default tokens provided for template processing
      $tokens ||= {};
      $tokens->{perl_version}   = $];
      $tokens->{dancer_version} = Dancer2->VERSION;
  
      $tokens->{settings} = $self->settings;
      $tokens->{request}  = $self->request;
      $tokens->{params}   = $self->request->params;
      $tokens->{vars}     = $self->request->vars;
  
      $tokens->{session} = $self->session->data
        if $self->has_session;
  
      return $tokens;
  }
  
  sub process {
      my ( $self, $view, $tokens, $options ) = @_;
      my ( $content, $full_content );
  
      # it's important that $tokens is not undef, so that things added to it via
      # a before_template in apply_renderer survive to the apply_layout. GH#354
      $tokens  ||= {};
      $options ||= {};
  
      ## FIXME - Look into PR 654 so we fix the problem here as well!
  
      $content =
          $view
        ? $self->apply_renderer( $view, $tokens )
        : delete $options->{content};
  
      defined $content
        and $full_content = $self->apply_layout( $content, $tokens, $options );
  
      defined $full_content
        and return $full_content;
  
      croak "Template did not produce any content";
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Role::Template - Role for template engines
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  Any class that consumes this role will be able to be used as a template engine
  under Dancer2.
  
  In order to implement this role, the consumer B<must> implement the method C<render>. This method will receive three arguments:
  
  =over 4
  
  =item $self
  
  =item $template
  
  =item $tokens
  
  =back
  
  Any template receives the following tokens, by default:
  
  =over 4
  
  =item * C<perl_version>
  
  Current version of perl, effectively C<$]>.
  
  =item * C<dancer_version>
  
  Current version of Dancer2, effectively C<<Dancer2->VERSION>>.
  
  =item * C<settings>
  
  A hash of the application configuration.
  
  =item * C<request>
  
  The current request object.
  
  =item * C<params>
  
  A hash reference of all the parameters.
  
  Currently the equivalent of C<< $request->params >>.
  
  =item * C<vars>
  
  The list of request variables, which is what you would get if you
  called the C<vars> keyword.
  
  =item * C<session>
  
  The current session data, if a session exists.
  
  =back
  
  =head1 ATTRIBUTES
  
  =head2 name
  
  The name of the template engine (e.g.: Simple).
  
  =head2 charset
  
  The charset.  The default value is B<UTF-8>.
  
  =head2 default_tmpl_ext
  
  The default file extension.  If not provided, B<tt> is used.
  
  =head2 views
  
  Path to the directory containing the views.
  
  =head2 layout
  
  Path to the directory containing the layouts.
  
  =head2 layout_dir
  
  Relative path to the layout directory.
  
  Default: B<layouts>.
  
  =head2 engine
  
  Contains the engine.
  
  =head1 METHODS
  
  =head2 view_pathname($view)
  
  Returns the full path to the requested view.
  
  =head2 layout_pathname($layout)
  
  Returns the full path to the requested layout.
  
  =head2 render_layout($layout, \%tokens, \$content)
  
  Render the layout with the applied tokens
  
  =head2 apply_renderer($view, \%tokens)
  
  =head2 apply_layout($content, \%tokens, \%options)
  
  =head2 process($view, \%tokens, \%options)
  
  =head1 METHODS
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROLE_TEMPLATE

$fatpacked{"Dancer2/Core/Route.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_ROUTE';
  package Dancer2::Core::Route;
  # ABSTRACT: Dancer2's route handler
  $Dancer2::Core::Route::VERSION = '0.162000';
  use Moo;
  use Dancer2::Core::Types;
  use Carp 'croak';
  use Scalar::Util 'blessed';
  
  our ( $REQUEST, $RESPONSE, $RESPONDER, $WRITER );
  
  has method => (
      is       => 'ro',
      isa      => Dancer2Method,
      required => 1,
  );
  
  has code => (
      is       => 'ro',
      required => 1,
      isa      => CodeRef,
  );
  
  has regexp => (
      is       => 'ro',
      required => 1,
  );
  
  has spec_route => ( is => 'ro' );
  
  has prefix => (
      is        => 'ro',
      isa       => Maybe [Dancer2Prefix],
      predicate => 1,
  );
  
  has options => (
      is        => 'ro',
      isa       => HashRef,
      trigger   => \&_check_options,
      predicate => 1,
  );
  
  sub _check_options {
      my ( $self, $options ) = @_;
      return 1 unless defined $options;
  
      my @supported_options = (
          qw/content_type agent user_agent content_length
            path_info/
      );
      for my $opt ( keys %{$options} ) {
          croak "Not a valid option for route matching: `$opt'"
            if not( grep {/^$opt$/} @supported_options );
      }
      return 1;
  }
  
  # private attributes
  
  has _should_capture => (
      is  => 'ro',
      isa => Bool,
  );
  
  has _match_data => (
      is      => 'rw',
      isa     => HashRef,
  );
  
  has _params => (
      is      => 'ro',
      isa     => ArrayRef,
      default => sub { [] },
  );
  
  sub match {
      my ( $self, $request ) = @_;
  
      if ( $self->has_options ) {
          return unless $self->validate_options($request);
      }
  
      my @values = $request->dispatch_path =~ $self->regexp;
  
      # if some named captures are found, return captures
      # no warnings is for perl < 5.10
      if (my %captures =
          do { no warnings; %+ }
        )
      {
          return $self->_match_data( { captures => \%captures } );
      }
  
      return unless @values;
  
      # regex comments are how we know if we captured a token,
      # splat or a megasplat
      my @token_or_splat = $self->regexp =~ /\(\?#([token|(?:mega)?splat]+)\)/g;
      if (@token_or_splat) {
          # our named tokens
          my @tokens = @{ $self->_params };
  
          my %params;
          my @splat;
          for ( my $i = 0; $i < @values; $i++ ) {
              # Is this value from a token?
              if ( $token_or_splat[$i] eq 'token' ) {
                  $params{ shift @tokens } = $values[$i];
                   next;
              }
  
              # megasplat values are split on '/'
              if ($token_or_splat[$i] eq 'megasplat') {
                  $values[$i] = [ split '/' => $values[$i] ];
              }
              push @splat, $values[$i];
          }
          return $self->_match_data( {
              %params,
              (splat => \@splat)x!! @splat,
          });
      }
  
      if ( $self->_should_capture ) {
          return $self->_match_data( { splat => \@values } );
      }
  
      return $self->_match_data( {} );
  }
  
  sub execute {
      my ( $self, $app, @args ) = @_;
      local $REQUEST  = $app->request;
      local $RESPONSE = $app->response;
  
      my $content = $self->code->( $app, @args );
  
      # users may set content in the response. If the response has
      # content, and the returned value from the route code is not
      # an object (well, reference) we ignore the returned value
      # and use the existing content in the response instead.
      $RESPONSE->has_content && !ref $content
          and return $app->_prep_response( $RESPONSE );
  
      my $type = blessed($content)
          or return $app->_prep_response( $RESPONSE, $content );
  
      # Plack::Response: proper ArrayRef-style response
      $type eq 'Plack::Response'
          and $RESPONSE = Dancer2::Core::Response->new_from_plack($RESPONSE);
  
      # CodeRef: raw PSGI response
      # do we want to allow it and forward it back?
      # do we want to upgrade it to an asynchronous response?
      $type eq 'CODE'
          and die "We do not support returning code references from routes.\n";
  
      # Dancer2::Core::Response, Dancer2::Core::Response::Delayed:
      # proper responses
      $type eq 'Dancer2::Core::Response'
          and return $RESPONSE;
  
      $type eq 'Dancer2::Core::Response::Delayed'
          and return $content;
  
      # we can't handle arrayref or hashref
      # because those might be serialized back
      die "Unrecognized response type from route: $type.\n";
  }
  
  # private subs
  
  sub BUILDARGS {
      my ( $class, %args ) = @_;
  
      my $prefix = $args{prefix};
      my $regexp = $args{regexp};
  
      # init prefix
      if ( $prefix ) {
          $args{regexp} =
              ref($regexp) eq 'Regexp' ? qr{^\Q${prefix}\E${regexp}$} :
              $prefix . $regexp;
      }
      elsif ( ref($regexp) ne 'Regexp' ) {
          # No prefix, so ensure regexp begins with a '/'
          index( $regexp, '/', 0 ) == 0 or $args{regexp} = "/$regexp";
      }
  
      # init regexp
      $regexp = $args{regexp}; # updated value
      $args{spec_route} = $regexp;
  
      if ( ref($regexp) eq 'Regexp') {
          $args{_should_capture} = 1;
      }
      else {
          @args{qw/ regexp _params _should_capture/} =
              @{ _build_regexp_from_string($regexp) };
      }
  
      return \%args;
  }
  
  sub _build_regexp_from_string {
      my ($string) = @_;
  
      my $capture = 0;
      my @params;
  
      # look for route with tokens [aka params] (/hello/:foo)
      if ( $string =~ /:/ ) {
          @params = $string =~ /:([^\/\.\?]+)/g;
          if (@params) {
              $string =~ s!(:[^\/\.\?]+)!(?#token)([^/]+)!g;
              $capture = 1;
          }
      }
  
      # parse megasplat
      # we use {0,} instead of '*' not to fall in the splat rule
      # same logic for [^\n] instead of '.'
      $capture = 1 if $string =~ s!\Q**\E!(?#megasplat)([^\n]+)!g;
  
      # parse wildcards
      $capture = 1 if $string =~ s!\*!(?#splat)([^/]+)!g;
  
      # escape dots
      $string =~ s/\./\\\./g if $string =~ /\./;
  
      # escape slashes
      $string =~ s/\//\\\//g;
  
      return [ "^$string\$", \@params, $capture ];
  }
  
  sub validate_options {
      my ( $self, $request ) = @_;
  
      for my $option ( keys %{ $self->options } ) {
          return 0
            if (
              ( not $request->$option )
              || ( $request->$option !~ $self->options->{ $option } )
            )
      }
      return 1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Route - Dancer2's route handler
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 ATTRIBUTES
  
  =head2 method
  
  The HTTP method of the route (lowercase). Required.
  
  =head2 code
  
  The code reference to execute when the route is ran. Required.
  
  =head2 regexp
  
  The regular expression that defines the path of the route.
  Required. Coerce from Dancer2's route I<patterns>.
  
  =head2 prefix
  
  The prefix to prepend to the C<regexp>. Optional.
  
  =head2 options
  
  A HashRef of conditions on which the matching will depend. Optional.
  
  =head1 METHODS
  
  =head2 match
  
  Try to match the route with a given pair of method/path.
  Returns the hash of matching data if success (captures and values of the route
  against the path) or undef if not.
  
      my $match = $route->match( get => '/hello/sukria' );
  
  =head2 execute
  
  Runs the coderef of the route.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_ROUTE

$fatpacked{"Dancer2/Core/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_RUNNER';
  package Dancer2::Core::Runner;
  # ABSTRACT: Top-layer class to start a dancer app
  $Dancer2::Core::Runner::VERSION = '0.162000';
  use Moo;
  use Carp 'croak';
  use Dancer2::Core::MIME;
  use Dancer2::Core::Types;
  use Dancer2::Core::Dispatcher;
  use Plack::Builder qw();
  
  # Hashref of configurable items for the runner.
  # Defaults come from ENV vars. Updated via global triggers
  # from app configs.
  has config => (
      is      => 'ro',
      isa     => HashRef,
      lazy    => 1,
      builder => '_build_config',
  );
  
  # FIXME: i hate this
  has mime_type => (
      is      => 'ro',
      isa     => InstanceOf ['Dancer2::Core::MIME'],
      default => sub { Dancer2::Core::MIME->new(); },
  );
  
  has server => (
      is      => 'ro',
      isa     => InstanceOf['HTTP::Server::PSGI'],
      lazy    => 1,
      builder => '_build_server',
      handles => ['run'],
  );
  
  has apps => (
      is      => 'ro',
      isa     => ArrayRef,
      default => sub { [] },
  );
  
  has postponed_hooks => (
      is      => 'ro',
      isa     => HashRef,
      default => sub { +{} },
  );
  
  has environment => (
      is       => 'ro',
      isa      => Str,
      required => 1,
      default  => sub {
          $ENV{DANCER_ENVIRONMENT} || $ENV{PLACK_ENV} || 'development'
      },
  );
  
  has host => (
      is      => 'ro',
      lazy    => 1,
      default => sub { $_[0]->config->{'host'} },
  );
  
  has port => (
      is      => 'ro',
      lazy    => 1,
      default => sub { $_[0]->config->{'port'} },
  );
  
  has timeout => (
      is      => 'ro',
      lazy    => 1,
      default => sub { $_[0]->config->{'timeout'} },
  );
  
  sub _build_server {
      my $self = shift;
  
      require HTTP::Server::PSGI;
      HTTP::Server::PSGI->new(
          host            => $self->host,
          port            => $self->port,
          timeout         => $self->timeout,
          server_software => "Perl Dancer2 " . Dancer2->VERSION,
      );
  }
  
  sub _build_config {
      my $self = shift;
  
      $ENV{PLACK_ENV}
        and $ENV{DANCER_APPHANDLER} = 'PSGI';
  
      return {
          behind_proxy     => 0,
          apphandler       => ( $ENV{DANCER_APPHANDLER} || 'Standalone' ),
          traces           => ( $ENV{DANCER_TRACES}     || 0 ),
          host             => ( $ENV{DANCER_SERVER}     || '0.0.0.0' ),
          port             => ( $ENV{DANCER_PORT}       || '3000' ),
          no_server_tokens => ( defined $ENV{DANCER_NO_SERVER_TOKENS} ?
                                $ENV{DANCER_NO_SERVER_TOKENS}         :
                                0 ),
          startup_info     => ( defined $ENV{DANCER_STARTUP_INFO} ?
                                $ENV{DANCER_STARTUP_INFO}         :
                                1 ),
      };
  }
  
  sub BUILD {
      my $self = shift;
  
      # Enable traces if set by ENV var.
      if (my $traces = $self->config->{traces} ) {
          require Carp;
          $Carp::Verbose = $traces ? 1 : 0;
      };
  
      # set the global runner object if one doesn't exist yet
      # this can happen if you create one without going through Dancer2
      # which doesn't trigger the import that creates it
      defined $Dancer2::runner
          or $Dancer2::runner = $self;
  }
  
  sub register_application {
      my $self = shift;
      my $app  = shift;
  
      push @{ $self->apps }, $app;
  
      # add postponed hooks to our psgi app
      $self->add_postponed_hooks( $app->name, $app->postponed_hooks );
  }
  
  sub add_postponed_hooks {
      my $self  = shift;
      my $name  = shift;
      my $hooks = shift;
  
      # merge postponed hooks
      @{ $self->{'postponed_hooks'}{$name} }{ keys %{$hooks} } = values %{$hooks};
  }
  
  # decide what to start
  # do we just return a PSGI app
  # or do we actually start a development standalone server?
  sub start {
      my $self = shift;
      my $app  = $self->psgi_app;
  
      # we decide whether we return a PSGI coderef
      # or spin a local development PSGI server
      $self->config->{'apphandler'} eq 'PSGI'
          and return $app;
  
      # FIXME: this should not include the server tokens
      # since those are already added to the server itself
      $self->start_server($app);
  }
  
  sub start_server {
      my $self = shift;
      my $app  = shift;
  
      # does not return
      $self->print_banner;
      $self->server->run($app);
  }
  
  sub psgi_app {
      my ($self, $apps) = @_;
  
      if ( $apps && @{$apps} ) {
          my @found_apps = ();
  
          foreach my $app_req ( @{$apps} ) {
              if ( ref $app_req eq 'Regexp' ) {
                  # find it in the apps registry
                  push @found_apps,
                      grep +( $_->name =~ $app_req ), @{ $self->apps };
              } elsif ( ref $app_req eq 'Dancer2::Core::App' ) {
                  # use it directly
                  push @found_apps, $app_req;
              } elsif ( ! ref $app_req ) {
                  # find it in the apps registry
                  push @found_apps,
                      grep +( $_->name eq $app_req ), @{ $self->apps };
              } else {
                  croak "Invalid input to psgi_app: $app_req";
              }
          }
  
          $apps = \@found_apps;
      } else {
          # dispatch over all apps by default
          $apps = $self->apps;
      }
  
      my $dispatcher = Dancer2::Core::Dispatcher->new( apps => $apps );
  
      # initialize psgi_apps
      # (calls ->finish on the apps and create their PSGI apps)
      # the dispatcher caches that in the attribute
      # so ->finish isn't actually called again if you run this method
      $dispatcher->apps_psgi;
  
      return sub {
          my $env = shift;
  
          # mark it as an old-style dispatching
          $self->{'internal_dispatch'} = 1;
  
          my $response = $dispatcher->dispatch($env);
  
          # unmark it
          delete $self->{'internal_dispatch'};
  
          # cleanup
          delete $self->{'internal_sessions'};
  
          return $response;
      };
  }
  
  sub print_banner {
      my $self = shift;
      my $pid  = $$;
  
      # we only print the info if we need to
      $self->config->{'startup_info'} or return;
  
      # bare minimum
      print STDERR ">> Dancer2 v" . Dancer2->VERSION . " server $pid listening "
        . 'on http://'
        . $self->host . ':'
        . $self->port . "\n";
  
      # all loaded plugins
      foreach my $module ( grep { $_ =~ m{^Dancer2/Plugin/} } keys %INC ) {
          $module =~ s{/}{::}g;     # change / to ::
          $module =~ s{\.pm$}{};    # remove .pm at the end
          my $version = $module->VERSION;
  
          defined $version or $version = 'no version number defined';
          print STDERR ">> $module ($version)\n";
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Runner - Top-layer class to start a dancer app
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_RUNNER

$fatpacked{"Dancer2/Core/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_SESSION';
  package Dancer2::Core::Session;
  # ABSTRACT: class to represent any session object
  $Dancer2::Core::Session::VERSION = '0.162000';
  use Moo;
  use Dancer2::Core::Types;
  use Dancer2::Core::Time;
  
  has id => (
      # for some specific plugins this should be rw.
      # refer to https://github.com/PerlDancer/Dancer2/issues/460
      is       => 'rw',
      isa      => Str,
      required => 1,
  );
  
  has data => (
      is      => 'ro',
      lazy    => 1,
      default => sub { {} },
  );
  
  has expires => (
      is     => 'rw',
      isa    => Str,
      coerce => sub {
          my $value = shift;
          $value += time if $value =~ /^[\-\+]?\d+$/;
          Dancer2::Core::Time->new( expression => $value )->epoch;
      },
  );
  
  has is_dirty => (
      is      => 'rw',
      isa     => Bool,
      default => sub {0},
  );
  
  
  sub read {
      my ( $self, $key ) = @_;
      return $self->data->{$key};
  }
  
  
  sub write {
      my ( $self, $key, $value ) = @_;
      $self->is_dirty(1);
      $self->data->{$key} = $value;
  }
  
  sub delete {
      my ( $self, $key, $value ) = @_;
      $self->is_dirty(1);
      delete $self->data->{$key};
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Session - class to represent any session object
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  A session object encapsulates anything related to a specific session: its ID,
  its data, and its expiration.
  
  It is completely agnostic of how it will be stored, this is the role of
  a factory that consumes L<Dancer2::Core::Role::SessionFactory> to know about that.
  
  Generally, session objects should not be created directly.  The correct way to
  get a new session object is to call the C<create()> method on a session engine
  that implements the SessionFactory role.  This is done automatically by the
  app object if a session engine is defined.
  
  =head1 ATTRIBUTES
  
  =head2 id
  
  The identifier of the session object. Required. By default,
  L<Dancer2::Core::Role::SessionFactory> sets this to a randomly-generated,
  guaranteed-unique string.
  
  This attribute can be modified if your Session implementation requires this.
  
  =head2 data
  
  Contains the data of the session (Hash).
  
  =head2 expires
  
  Number of seconds for the expiry of the session cookie. Don't add the current
  timestamp to it, will be done automatically.
  
  Default is no expiry (session cookie will leave for the whole browser's
  session).
  
  For a lifetime of one hour:
  
    expires => 3600
  
  =head2 is_dirty
  
  Boolean value for whether data in the session has been modified.
  
  =head1 METHODS
  
  =head2 read
  
  Reader on the session data
  
      my $value = $session->read('something');
  
  Returns C<undef> if the key does not exist in the session.
  
  =head2 write
  
  Writer on the session data
  
    $session->write('something', $value);
  
  Sets C<is_dirty> to true. Returns C<$value>.
  
  =head2 delete
  
  Deletes a key from session data
  
    $session->delete('something');
  
  Sets C<is_dirty> to true. Returns the value deleted from the session.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_SESSION

$fatpacked{"Dancer2/Core/Time.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_TIME';
  package Dancer2::Core::Time;
  # ABSTRACT: class to handle common helpers for time manipulations
  $Dancer2::Core::Time::VERSION = '0.162000';
  use Moo;
  
  has seconds => (
      is      => 'ro',
      lazy    => 1,
      builder => '_build_seconds',
  );
  
  sub _build_seconds {
      my ($self) = @_;
      my $seconds = $self->expression;
  
      return $seconds
          if $seconds =~ /^\d+$/;
  
      return $self->_parse_duration($seconds)
  }
  
  has epoch => (
      is      => 'ro',
      lazy    => 1,
      builder => '_build_epoch',
  );
  
  sub _build_epoch {
      my ($self) = @_;
      return $self->seconds if $self->seconds !~ /^[\-\+]?\d+$/;
      $self->seconds + time;
  }
  
  has gmt_string => (
      is      => 'ro',
      builder => '_build_gmt_string',
      lazy    => 1,
  );
  
  sub _build_gmt_string {
      my ($self) = @_;
      my $epoch = $self->epoch;
      return $epoch if $epoch !~ /^\d+$/;
  
      my ( $sec, $min, $hour, $mday, $mon, $year, $wday ) = gmtime($epoch);
      my @months = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
      my @days   = qw(Sun Mon Tue Wed Thu Fri Sat);
  
      return sprintf "%s, %02d-%s-%d %02d:%02d:%02d GMT",
        $days[$wday],
        $mday,
        $months[$mon],
        ( $year + 1900 ),
        $hour, $min, $sec;
  }
  
  has expression => (
      is       => 'ro',
      required => 1,
  );
  
  sub BUILDARGS {
      my ($class, %args) = @_;
  
      $args{epoch} = $args{expression}
          if $args{expression} =~ /^\d+$/;
  
      return \%args;
  }
  
  # private
  
  # This map is taken from Cache and Cache::Cache
  # map of expiration formats to their respective time in seconds
  #<<< no perl tidy
  my %Units = ( map(($_,             1), qw(s second seconds sec secs)),
                map(($_,            60), qw(m minute minutes min mins)),
                map(($_,         60*60), qw(h hr hour hours)),
                map(($_,      60*60*24), qw(d day days)),
                map(($_,    60*60*24*7), qw(w week weeks)),
                map(($_,   60*60*24*30), qw(M month months)),
                map(($_,  60*60*24*365), qw(y year years)) );
  #>>>
  
  # This code is taken from Time::Duration::Parse, except if it isn't
  # understood it just passes it through and it adds the current time.
  sub _parse_duration {
      my ( $self, $timespec ) = @_;
      my $orig_timespec = $timespec;
  
      # Treat a plain number as a number of seconds (and parse it later)
      if ( $timespec =~ /^\s*([-+]?\d+(?:[.,]\d+)?)\s*$/ ) {
          $timespec = "$1s";
      }
  
      # Convert hh:mm(:ss)? to something we understand
      $timespec =~ s/\b(\d+):(\d\d):(\d\d)\b/$1h $2m $3s/g;
      $timespec =~ s/\b(\d+):(\d\d)\b/$1h $2m/g;
  
      my $duration = 0;
      while ( $timespec
          =~ s/^\s*([-+]?\d+(?:[.,]\d+)?)\s*([a-zA-Z]+)(?:\s*(?:,|and)\s*)*//i )
      {
          my ( $amount, $unit ) = ( $1, $2 );
          $unit = lc($unit) unless length($unit) == 1;
  
          if ( my $value = $Units{$unit} ) {
              $amount =~ s/,/./;
              $duration += $amount * $value;
          }
          else {
              return $orig_timespec;
          }
      }
  
      if ( $timespec =~ /\S/ ) {
          return $orig_timespec;
      }
  
      return sprintf "%.0f", $duration;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Time - class to handle common helpers for time manipulations
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
      my $time = Dancer2::Core::Time->new( expression => "1h" );
      $time->seconds; # return 3600
  
  =head1 DESCRIPTION
  
  For consistency, whenever something needs to work with time, it
  needs to be expressed in seconds, with a timestamp. Although it's very
  convenient for the machine and calculations, it's not very handy for a
  human-being, for instance in a configuration file.
  
  This class provides everything needed to translate any human-understandable
  expression into a number of seconds.
  
  =head1 ATTRIBUTES
  
  =head2 seconds
  
  Number of seconds represented by the object. Defaults to 0.
  
  =head2 epoch
  
  The current epoch to handle. Defaults to seconds + time.
  
  =head2 gmt_string
  
  Convert the current value in epoch as a GMT string.
  
  =head2 expression
  
  Required. A human readable expression representing the number of seconds to provide.
  
  The format supported is a number followed by an expression. It currently
  understands:
  
      s second seconds sec secs
      m minute minutes min mins
      h hr hour hours
      d day days
      w week weeks
      M month months
      y year years
  
  Months and years are currently fixed at 30 and 365 days.  This may change.
  Anything else is used verbatim as the expression of a number of seconds.
  
  Example:
  
      2 hours, 3 days, 3d, 1 week, 3600, etc...
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_TIME

$fatpacked{"Dancer2/Core/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_CORE_TYPES';
  package Dancer2::Core::Types;
  # ABSTRACT: Moo types for Dancer2 core.
  $Dancer2::Core::Types::VERSION = '0.162000';
  use strict;
  use warnings;
  use Scalar::Util 'blessed', 'looks_like_number';
  use MooX::Types::MooseLike 0.16 'exception_message';
  use MooX::Types::MooseLike::Base qw/:all/;
  
  use Exporter 'import';
  our @EXPORT;
  our @EXPORT_OK;
  
  our %supported_http_methods = map +( $_ => 1 ), qw<
      GET HEAD POST PUT DELETE OPTIONS PATCH
  >;
  
  my $single_part = qr/
      [A-Za-z]              # must start with letter
      (?: [A-Za-z0-9_]+ )? # can continue with letters, numbers or underscore
  /x;
  
  my $namespace = qr/
      ^
      $single_part                    # first part
      (?: (?: \:\: $single_part )+ )? # optional part starting with double colon
      $
  /x;
  
  my $definitions = [
      {   name => 'ReadableFilePath',
          test => sub { -e $_[0] && -r $_[0] },
          message =>
            sub { return exception_message( $_[0], 'ReadableFilePath' ) },
          inflate => 0,
      },
      {   name => 'WritableFilePath',
          test => sub { -e $_[0] && -w $_[0] },
          message =>
            sub { return exception_message( $_[0], 'WritableFilePath' ) },
          inflate => 0,
      },
  
      # Dancer2-specific types
      {   name       => 'Dancer2Prefix',
          subtype_of => 'Str',
          from       => 'MooX::Types::MooseLike::Base',
          test       => sub {
  
              # a prefix must start with the char '/'
              # index is much faster than =~ /^\//
              index( $_[0], '/' ) == 0;
          },
          message =>
            sub { return exception_message( $_[0], 'a Dancer2Prefix' ) },
          inflate => 0,
      },
      {   name       => 'Dancer2AppName',
          subtype_of => 'Str',
          from       => 'MooX::Types::MooseLike::Base',
          test       => sub {
  
              # TODO need a real check of valid app names
              $_[0] =~ $namespace;
          },
          message => sub {
              return exception_message(
                  ($_[0] && length( $_[0] )) ? $_[0] : 'Empty string',
                  'a Dancer2AppName'
              );
          },
          inflate => 0,
      },
      {   name       => 'Dancer2Method',
          subtype_of => 'Str',
          from       => 'MooX::Types::MooseLike::Base',
          test       => sub {
              grep {/^$_[0]$/} map +( lc ), keys %supported_http_methods
          },
          message =>
            sub { return exception_message( $_[0], 'a Dancer2Method' ) },
          inflate => 0,
      },
      {   name       => 'Dancer2HTTPMethod',
          subtype_of => 'Str',
          from       => 'MooX::Types::MooseLike::Base',
          test       => sub {
              grep {/^$_[0]$/} keys %supported_http_methods
          },
          message =>
            sub { return exception_message( $_[0], 'a Dancer2HTTPMethod' ) },
          inflate => 0,
      },
  ];
  
  # generate abbreviated class types for core dancer objects
  for my $type (
      qw/
      App
      Context
      Cookie
      DSL
      Dispatcher
      Error
      Hook
      MIME
      Request
      Response
      Role
      Route
      Runner
      Server
      Session
      Types
      /
    )
  {
      push @$definitions, {
          name => $type,
          test => sub {
              return
                   $_[0]
                && blessed( $_[0] )
                && ref( $_[0] ) eq 'Dancer2::Core::' . $type;
          },
          message =>
            sub {"The value `$_[0]' does not pass the constraint check."},
          inflate => 0,
      };
  }
  
  MooX::Types::MooseLike::register_types( $definitions, __PACKAGE__ );
  
  # Export everything by default.
  @EXPORT = ( @MooX::Types::MooseLike::Base::EXPORT_OK, @EXPORT_OK );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Core::Types - Moo types for Dancer2 core.
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  Type definitions for Moo attributes. These are defined as subroutines.
  
  =head1 MOO TYPES
  
  =head2 ReadableFilePath($value)
  
  A readable file path.
  
  =head2 WritableFilePath($value)
  
  A writable file path.
  
  =head2 Dancer2Prefix($value)
  
  A proper Dancer2 prefix, which is basically a prefix that starts with a I</>
  character.
  
  =head2 Dancer2AppName($value)
  
  A proper Dancer2 application name.
  
  Currently this only checks for I<\w+>.
  
  =head2 Dancer2Method($value)
  
  An acceptable method supported by Dancer2.
  
  Currently this includes: I<get>, I<head>, I<post>, I<put>, I<delete> and
  I<options>.
  
  =head2 Dancer2HTTPMethod($value)
  
  An acceptable HTTP method supported by Dancer2.
  
  Current this includes: I<GET>, I<HEAD>, I<POST>, I<PUT>, I<DELETE>
  and I<OPTIONS>.
  
  =head1 SEE ALSO
  
  L<MooX::Types::MooseLike> for more available types
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_CORE_TYPES

$fatpacked{"Dancer2/FileUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_FILEUTILS';
  package Dancer2::FileUtils;
  # ABSTRACT: File utility helpers
  $Dancer2::FileUtils::VERSION = '0.162000';
  use strict;
  use warnings;
  
  use File::Basename ();
  use File::Spec;
  use Carp;
  use Cwd 'realpath';
  
  use Exporter 'import';
  our @EXPORT_OK = qw(
    dirname open_file path read_file_content read_glob_content
    path_or_empty set_file_mode normalize_path escape_filename
  );
  
  
  sub path {
      my @parts = @_;
      my $path  = File::Spec->catfile(@parts);
  
      return normalize_path($path);
  }
  
  sub path_or_empty {
      my @parts = @_;
      my $path  = path(@parts);
  
      # return empty if it doesn't exist
      return -e $path ? $path : '';
  }
  
  sub dirname { File::Basename::dirname(@_) }
  
  sub set_file_mode {
      my $fh      = shift;
      my $charset = 'utf-8';
      binmode $fh, ":encoding($charset)";
      return $fh;
  }
  
  sub open_file {
      my ( $mode, $filename ) = @_;
  
      open my $fh, $mode, $filename
        or croak "Can't open '$filename' using mode '$mode'";
  
      return set_file_mode($fh);
  }
  
  sub read_file_content {
      my $file = shift or return;
      my $fh = open_file( '<', $file );
  
      return wantarray
        ? read_glob_content($fh)
        : scalar read_glob_content($fh);
  }
  
  sub read_glob_content {
      my $fh = shift;
  
      my @content = <$fh>;
      close $fh;
  
      return wantarray ? @content : join '', @content;
  }
  
  sub normalize_path {
  
      # this is a revised version of what is described in
      # http://www.linuxjournal.com/content/normalizing-path-names-bash
      # by Mitch Frazier
      my $path = shift or return;
      my $seqregex = qr{
          [^/]*       # anything without a slash
          /\.\.(/|\z) # that is accompanied by two dots as such
      }x;
  
      $path =~ s{/\./}{/}g;
      $path =~ s{$seqregex}{}g;
      $path =~ s{$seqregex}{};
  
      #see https://rt.cpan.org/Public/Bug/Display.html?id=80077
      $path =~ s{^//}{/};
      return $path;
  }
  
  sub escape_filename {
      my $filename = shift or return;
  
      # based on escaping used in CHI::Driver. Our use-case is one-way,
      # so we allow utf8 chars to be escaped, but NEVER do the inverse
      # operation.
      $filename =~ s/([^A-Za-z0-9_\=\-\~])/sprintf("+%02x", ord($1))/ge;
      return $filename;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::FileUtils - File utility helpers
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
      use Dancer2::FileUtils qw/dirname path path_or_empty/;
  
      # for 'path/to/file'
      my $dir  = dirname($path); # returns 'path/to'
      my $path = path($path);    # returns '/abs/path/to/file'
      my $path = path_or_empty($path);    # returns '' if file doesn't exist
  
  
      use Dancer2::FileUtils qw/path read_file_content/;
  
      my $content = read_file_content( path( 'folder', 'folder', 'file' ) );
      my @content = read_file_content( path( 'folder', 'folder', 'file' ) );
  
  
      use Dancer2::FileUtils qw/read_glob_content set_file_mode/;
  
      open my $fh, '<', $file or die "$!\n";
      set_file_mode($fh);
      my @content = read_glob_content($fh);
      my $content = read_glob_content($fh);
  
  
      use Dancer2::FileUtils qw/open_file/;
  
      my $fh = open_file('<', $file) or die $message;
  
  
      use Dancer2::FileUtils 'set_file_mode';
  
      set_file_mode($fh);
  
  =head1 DESCRIPTION
  
  Dancer2::FileUtils includes a few file related utilities that Dancer2
  uses internally. Developers may use it instead of writing their own
  file reading subroutines or using additional modules.
  
  =head1 FUNCTIONS
  
  =head2 my $path = path( 'folder', 'folder', 'filename');
  
  Provides comfortable path resolution, internally using L<File::Spec>. 'path'
  does not verify paths, it just normalizes the path.
  
  =head2 my $path = path_or_empty('folder, 'folder','filename');
  
  Like path, but returns '' if path doesn't exist.
  
  =head2 dirname
  
      use Dancer2::FileUtils 'dirname';
  
      my $dir = dirname($path);
  
  Exposes L<File::Basename>'s I<dirname>, to allow fetching a directory name from
  a path. On most OS, returns all but last level of file path. See
  L<File::Basename> for details.
  
  =head2 set_file_mode($fh);
  
      use Dancer2::FileUtils 'set_file_mode';
  
      set_file_mode($fh);
  
  Applies charset setting from Dancer2's configuration. Defaults to utf-8 if no
  charset setting.
  
  =head2 my $fh = open_file('<', $file) or die $message;
  
      use Dancer2::FileUtils 'open_file';
      my $fh = open_file('<', $file) or die $message;
  
  Calls open and returns a filehandle. Takes in account the 'charset' setting
  from Dancer2's configuration to open the file in the proper encoding (or
  defaults to utf-8 if setting not present).
  
  =head2 my $content = read_file_content($file);
  
      use Dancer2::FileUtils 'read_file_content';
  
      my @content = read_file_content($file);
      my $content = read_file_content($file);
  
  Returns either the content of a file (whose filename is the input), or I<undef>
  if the file could not be opened.
  
  In array context it returns each line (as defined by $/) as a separate element;
  in scalar context returns the entire contents of the file.
  
  =head2 my $content = read_glob_content($fh);
  
      use Dancer2::FileUtils 'read_glob_content';
  
      open my $fh, '<', $file or die "$!\n";
      binmode $fh, ':encoding(utf-8)';
      my @content = read_glob_content($fh);
      my $content = read_glob_content($fh);
  
  Similar to I<read_file_content>, only it accepts a file handle. It is
  assumed that the appropriate PerlIO layers are applied to the file handle.
  Returns the content and B<closes the file handle>.
  
  =head2 my $norm_path=normalize_path ($path);
  
  =head2 my $escaped_filename = escape_filename( $filename );
  
  Escapes characters in a filename that may alter a path when concatenated.
  
    use Dancer2::FileUtils 'escape_filename';
  
    my $safe = escape_filename( "a/../b.txt" ); # a+2f+2e+2e+2fb+2etxt
  
  =head1 EXPORT
  
  Nothing by default. You can provide a list of subroutines to import.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_FILEUTILS

$fatpacked{"Dancer2/Handler/AutoPage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_HANDLER_AUTOPAGE';
  package Dancer2::Handler::AutoPage;
  # ABSTRACT: Class for handling the AutoPage feature
  $Dancer2::Handler::AutoPage::VERSION = '0.162000';
  use Moo;
  use Carp 'croak';
  use Dancer2::Core::Types;
  
  with qw<
      Dancer2::Core::Role::Handler
      Dancer2::Core::Role::StandardResponses
  >;
  
  sub register {
      my ( $self, $app ) = @_;
  
      return unless $app->config->{auto_page};
  
      $app->add_route(
          method => $_,
          regexp => $self->regexp,
          code   => $self->code,
      ) for $self->methods;
  }
  
  sub code {
      sub {
          my $app    = shift;
          my $prefix = shift;
  
          my $template = $app->template_engine;
          if ( !defined $template ) {
              $app->response->has_passed(1);
              return;
          }
  
          my $page       = $app->request->path;
          my $layout_dir = $template->layout_dir;
          if ( $page =~ m{^/\Q$layout_dir\E/} ) {
              $app->response->has_passed(1);
              return;
          }
  
          my $view_path = $template->view_pathname($page);
  
          if ( !-f $view_path ) {
              $app->response->has_passed(1);
              return;
          }
  
          my $ct = $template->process( $page );
          $app->response->header( 'Content-Length', length($ct) );
          return ( $app->request->method eq 'GET' ) ? $ct : '';
      };
  }
  
  sub regexp {'/**'}
  
  sub methods {qw(head get)}
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Handler::AutoPage - Class for handling the AutoPage feature
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  The AutoPage feature is a Handler (turned off by default) that is
  responsible for serving pages that match an existing template. If a
  view exists with a name that matches the requested path, Dancer2
  processes the request using the Autopage handler.
  
  To turn it add to your config file:
  
        auto_page: 1
  
  This allows you to easily serve simple pages without having to write a
  route definition for them.
  
  If there's no view with the name request, the route passes, allowing
  other matching routes to be dispatched.
  
  =head1 METHODS
  
  =head2 register
  
  Creates the routes.
  
  =head2 code
  
  A code reference that processes the route request.
  
  =head2 methods
  
  The methods that should be served for autopages.
  
  Default: B<head>, B<get>.
  
  =head2 regexp
  
  The regexp (path) we want to match.
  
  Default: B</:page>.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_HANDLER_AUTOPAGE

$fatpacked{"Dancer2/Handler/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_HANDLER_FILE';
  package Dancer2::Handler::File;
  # ABSTRACT: class for handling file content rendering
  $Dancer2::Handler::File::VERSION = '0.162000';
  use Carp 'croak';
  use Moo;
  use HTTP::Date;
  use Dancer2::FileUtils 'path', 'open_file', 'read_glob_content';
  use Dancer2::Core::MIME;
  use Dancer2::Core::Types;
  use File::Spec;
  
  with qw<
      Dancer2::Core::Role::Handler
      Dancer2::Core::Role::StandardResponses
      Dancer2::Core::Role::Hookable
  >;
  
  sub hook_aliases {
      {
          before_file_render => 'handler.file.before_render',
          after_file_render  => 'handler.file.after_render',
      }
  }
  
  sub supported_hooks { values %{ shift->hook_aliases } }
  
  has mime => (
      is      => 'ro',
      isa     => InstanceOf ['Dancer2::Core::MIME'],
      default => sub { Dancer2::Core::MIME->new },
  );
  
  has encoding => (
      is      => 'ro',
      default => sub {'utf-8'},
  );
  
  has public_dir => (
      is      => 'ro',
      lazy    => 1,
      builder => '_build_public_dir',
  );
  
  has regexp => (
      is      => 'ro',
      default => sub {'/**'},
  );
  
  sub _build_public_dir {
      my $self = shift;
      return $self->app->config->{public_dir}
          || $ENV{DANCER_PUBLIC}
          || path( $self->app->location, 'public' );
  }
  
  sub register {
      my ( $self, $app ) = @_;
  
      # don't register the handler if no valid public dir
      return if !-d $self->public_dir;
  
      $app->add_route(
          method => $_,
          regexp => $self->regexp,
          code   => $self->code( $app->prefix ),
      ) for $self->methods;
  }
  
  sub methods { ( 'head', 'get' ) }
  
  sub code {
      my ( $self, $prefix ) = @_;
  
      sub {
          my $app    = shift;
          my $prefix = shift;
          my $path   = $app->request->path_info;
  
          if ( $path =~ /\0/ ) {
              return $self->standard_response( $app, 400 );
          }
  
          if ( $prefix && $prefix ne '/' ) {
              $path =~ s/^\Q$prefix\E//;
          }
  
          my $file_path = $self->merge_paths( $path, $self->public_dir );
          return $self->standard_response( $app, 403 ) if !defined $file_path;
  
          if ( !-f $file_path ) {
              $app->response->has_passed(1);
              return;
          }
  
          if ( !-r $file_path ) {
              return $self->standard_response( $app, 403 );
          }
  
          # Now we are sure we can render the file...
          $self->execute_hook( 'handler.file.before_render', $file_path );
  
          # Read file content as bytes
          my $fh = open_file( "<", $file_path );
          binmode $fh;
          my $content = read_glob_content($fh);
  
          # Assume m/^text/ mime types are correctly encoded
          my $content_type = $self->mime->for_file($file_path) || 'text/plain';
          if ( $content_type =~ m!^text/! ) {
              $content_type .= "; charset=" . ( $self->encoding || "utf-8" );
          }
  
          my @stat = stat $file_path;
  
          $app->response->header('Content-Type')
            or $app->response->header( 'Content-Type', $content_type );
  
          $app->response->header('Content-Length')
            or $app->response->header( 'Content-Length', $stat[7] );
  
          $app->response->header('Last-Modified')
            or $app->response->header(
              'Last-Modified',
              HTTP::Date::time2str( $stat[9] )
            );
  
          $app->response->content($content);
          $app->response->is_encoded(1);    # bytes are already encoded
          $self->execute_hook( 'handler.file.after_render', $app->response );
          return ( $app->request->method eq 'GET' ) ? $content : '';
      };
  }
  
  sub merge_paths {
      my ( undef, $path, $public_dir ) = @_;
  
      my ( $volume, $dirs, $file ) = File::Spec->splitpath( $path );
      my @tokens = File::Spec->splitdir( "$dirs$file" );
      my $updir = File::Spec->updir;
      return if grep $_ eq $updir, @tokens;
  
      my ( $pub_vol, $pub_dirs, $pub_file ) = File::Spec->splitpath( $public_dir );
      my @pub_tokens = File::Spec->splitdir( "$pub_dirs$pub_file" );
      return if length $volume and length $pub_vol and $volume ne $pub_vol;
  
      my @final_vol = ( length $pub_vol ? $pub_vol : length $volume ? $volume : () );
      my @file_path = ( @final_vol, @pub_tokens, @tokens );
      my $file_path = path( @file_path );
      return $file_path;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Handler::File - class for handling file content rendering
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_HANDLER_FILE

$fatpacked{"Dancer2/Logger/Capture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_LOGGER_CAPTURE';
  package Dancer2::Logger::Capture;
  # ABSTRACT: Capture dancer logs
  $Dancer2::Logger::Capture::VERSION = '0.162000';
  use Moo;
  use Dancer2::Logger::Capture::Trap;
  
  with 'Dancer2::Core::Role::Logger';
  
  has trapper => (
      is      => 'ro',
      lazy    => 1,
      builder => '_build_trapper',
  );
  
  sub _build_trapper { Dancer2::Logger::Capture::Trap->new }
  
  sub log {
      my ( $self, $level, $message ) = @_;
  
      $self->trapper->store(
          $level, $message, $self->format_message( $level => $message )
      );
  
      return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Logger::Capture - Capture dancer logs
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
  The basics:
  
      set logger => "capture";
  
      my $trap = dancer_app->logger_engine->trapper;
      my $logs = $trap->read;
  
  A worked-out real-world example:
  
      use Test::More tests => 2;
      use Dancer2;
  
      set logger => 'capture';
  
      warning "Danger!  Warning!";
      debug   "I like pie.";
  
      my $trap = dancer_app->logger_engine->trapper;
  
      is_deeply $trap->read, [
          { level => "warning", message => "Danger!  Warning!" },
          { level => "debug",   message => "I like pie.", }
      ];
  
      # each call to read cleans the trap
      is_deeply $trap->read, [];
  
  =head1 DESCRIPTION
  
  This is a logger class for L<Dancer2> which captures all logs to an object.
  
  It's primary purpose is for testing. Here is an example of a test:
  
      use strict;
      use warnings;
      use Test::More;
      use Plack::Test;
      use HTTP::Request::Common;
  
      {
          package App;
          use Dancer2;
  
          set log       => 'debug';
          set logger    => 'capture';
  
          get '/' => sub {
              log(debug => 'this is my debug message');
              log(core  => 'this should not be logged');
              log(info  => 'this is my info message');
          };
      }
  
      my $app = Dancer2->psgi_app;
      is( ref $app, 'CODE', 'Got app' );
  
      test_psgi $app, sub {
          my $cb = shift;
  
          my $res = $cb->( GET '/' );
  
          my $trap = App->dancer_app->logger_engine->trapper;
  
          is_deeply $trap->read, [
              { level => 'debug', message => 'this is my debug message' },
              { level => 'info',  message => 'this is my info message' },
          ];
  
          is_deeply $trap->read, [];
      };
  
      done_testing;
  
  =head1 METHODS
  
  =head2 trapper
  
  Returns the L<Dancer2::Logger::Capture::Trap> object used to capture
  and read logs.
  
  =head1 SEE ALSO
  
  L<Dancer2::Core::Role::Logger>, L<Dancer2::Logger::Capture::Trap>
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_LOGGER_CAPTURE

$fatpacked{"Dancer2/Logger/Capture/Trap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_LOGGER_CAPTURE_TRAP';
  package Dancer2::Logger::Capture::Trap;
  # ABSTRACT: a place to store captured Dancer2 logs
  $Dancer2::Logger::Capture::Trap::VERSION = '0.162000';
  use Moo;
  use Dancer2::Core::Types;
  
  has storage => (
      is      => 'rw',
      isa     => ArrayRef,
      default => sub { [] },
  );
  
  sub store {
      my ( $self, $level, $message, $fmt_string ) = @_;
      push @{ $self->storage }, {
          level     => $level,
          message   => $message,
          formatted => $fmt_string,
      };
  }
  
  sub read {
      my $self = shift;
  
      my $logs = $self->storage;
      $self->storage( [] );
      return $logs;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Logger::Capture::Trap - a place to store captured Dancer2 logs
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
      my $trap = Dancer2::Logger::Capture::Trap->new;
      $trap->store( $level, $message );
      my $logs = $trap->read;
  
  =head1 DESCRIPTION
  
  This is a place to store and retrieve capture Dancer2 logs used by
  L<Dancer2::Logger::Capture>.
  
  =head2 Methods
  
  =head3 new
  
  =head3 store
  
      $trap->store($level, $message);
  
  Stores a log $message and its $level.
  
  =head3 read
  
      my $logs = $trap->read;
  
  Returns the logs stored as an array ref and clears the storage.
  
  For example...
  
      [{ level => "warning", message => "Danger! Warning! Dancer2!" },
       { level => "error",   message => "You fail forever" }
      ];
  
  =head1 SEE ALSO
  
  L<Dancer2::Logger::Capture>
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_LOGGER_CAPTURE_TRAP

$fatpacked{"Dancer2/Logger/Console.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_LOGGER_CONSOLE';
  package Dancer2::Logger::Console;
  # ABSTRACT: Console logger
  $Dancer2::Logger::Console::VERSION = '0.162000';
  use Moo;
  
  with 'Dancer2::Core::Role::Logger';
  
  sub log {
      my ( $self, $level, $message ) = @_;
      print STDERR $self->format_message( $level => $message );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Logger::Console - Console logger
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This is a logging engine that allows you to print debug messages on the
  standard error output.
  
  =head1 METHODS
  
  =head2 log
  
  Writes the log message to the console.
  
  =head1 CONFIGURATION
  
  The setting C<logger> should be set to C<console> in order to use this logging
  engine in a Dancer2 application.
  
  There is no additional setting available with this engine.
  
  =head1 METHODS
  
  =head1 SEE ALSO
  
  L<Dancer2::Core::Role::Logger>
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_LOGGER_CONSOLE

$fatpacked{"Dancer2/Logger/Diag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_LOGGER_DIAG';
  package Dancer2::Logger::Diag;
  # ABSTRACT: Test::More diag() logging engine for Dancer2
  $Dancer2::Logger::Diag::VERSION = '0.162000';
  use Moo;
  use Test::More;
  
  with 'Dancer2::Core::Role::Logger';
  
  sub log {
      my ( $self, $level, $message ) = @_;
  
      Test::More::diag( $self->format_message( $level => $message ) );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Logger::Diag - Test::More diag() logging engine for Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This logging engine uses L<Test::More>'s diag() to output as TAP comments.
  
  This is very useful in case you're writing a test and want to have logging
  messages as part of your TAP.
  
  =head1 METHODS
  
  =head2 log
  
  Use Test::More's diag() to output the log message.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_LOGGER_DIAG

$fatpacked{"Dancer2/Logger/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_LOGGER_FILE';
  package Dancer2::Logger::File;
  # ABSTRACT: file-based logging engine for Dancer2
  $Dancer2::Logger::File::VERSION = '0.162000';
  use Carp 'carp';
  use Moo;
  use Dancer2::Core::Types;
  
  with 'Dancer2::Core::Role::Logger';
  
  use File::Spec;
  use Fcntl qw(:flock SEEK_END);
  use Dancer2::FileUtils qw(open_file);
  use IO::File;
  
  has environment => (
      is       => 'ro',
      required => 1,
  );
  
  has location => (
      is       => 'ro',
      required => 1,
  );
  
  has log_dir => (
      is      => 'rw',
      isa     => sub {
          my $dir = shift;
  
          if ( !-d $dir && !mkdir $dir ) {
              die "log directory \"$dir\" does not exist and unable to create it.";
          }
          if ( !-w $dir ) {
              die "log directory \"$dir\" is not writable."
          }
      },
      lazy    => 1,
      builder => '_build_log_dir',
  );
  
  has file_name => (
      is      => 'ro',
      isa     => Str,
      builder => '_build_file_name',
      lazy    => 1
  );
  
  has log_file => (
      is      => 'ro',
      isa     => Str,
      lazy    => 1,
      builder => '_build_log_file',
  );
  
  has fh => (
      is      => 'ro',
      lazy    => 1,
      builder => '_build_fh',
  );
  
  sub _build_log_dir { File::Spec->catdir( $_[0]->location, 'logs' ) }
  
  sub _build_file_name {$_[0]->environment . ".log"}
  
  sub _build_log_file {
      my $self = shift;
      return File::Spec->catfile( $self->log_dir, $self->file_name );
  }
  
  sub _build_fh {
      my $self    = shift;
      my $logfile = $self->log_file;
  
      my $fh;
      unless ( $fh = open_file( '>>', $logfile ) ) {
          carp "unable to create or append to $logfile";
          return;
      }
  
      $fh->autoflush;
  
      return $fh;
  }
  
  sub log {
      my ( $self, $level, $message ) = @_;
      my $fh = $self->fh;
  
      return unless ( ref $fh && $fh->opened );
  
      flock( $fh, LOCK_EX )
        or carp "locking logfile $self->{logfile} failed: $!";
      seek( $fh, 0, SEEK_END );
      $fh->print( $self->format_message( $level => $message ) )
        or carp "writing to logfile $self->{logfile} failed";
      flock( $fh, LOCK_UN )
        or carp "unlocking logfile $self->{logfile} failed: $!";
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Logger::File - file-based logging engine for Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This is a logging engine that allows you to save your logs to files on disk.
  
  Logs are not automatically rotated.  Use a log rotation tool like
  C<logrotate> in C<copytruncate> mode.
  
  =head1 METHODS
  
  =head2 log($level, $message)
  
  Writes the log message to the file.
  
  =head1 CONFIGURATION
  
  The setting C<logger> should be set to C<File> in order to use this logging
  engine in a Dancer2 application.
  
  The follow attributes are supported:
  
  =for :list * log_dir -- directory path to hold log files. Defaults to F<logs> in the application directory
  * file_name -- the name of the log file. Defaults to the environment name with a F<.log> suffix
  
  Here is an example configuration that use this logger and stores logs in F</var/log/myapp>:
  
    logger: "File"
  
    engines:
      logger:
        File:
          log_dir: "/var/log/myapp"
          file_name: "myapp.log"
  
  =head1 METHODS
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_LOGGER_FILE

$fatpacked{"Dancer2/Logger/Note.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_LOGGER_NOTE';
  package Dancer2::Logger::Note;
  # ABSTRACT: Test::More note() logging engine for Dancer2
  $Dancer2::Logger::Note::VERSION = '0.162000';
  use Moo;
  use Test::More;
  
  with 'Dancer2::Core::Role::Logger';
  
  sub log {
      my ( $self, $level, $message ) = @_;
  
      Test::More::note( $self->format_message( $level => $message ) );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Logger::Note - Test::More note() logging engine for Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This logging engine uses L<Test::More>'s note() to output as TAP comments.
  
  This is very useful in case you're writing a test and want to have logging
  messages as part of your TAP.
  
  "Like C<diag()>, except the message will not be seen when the test is run in a
  harness. It will only be visible in the verbose TAP stream." -- Test::More.
  
  =head1 METHODS
  
  =head2 log
  
  Use Test::More's note() to output the log message.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_LOGGER_NOTE

$fatpacked{"Dancer2/Logger/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_LOGGER_NULL';
  package Dancer2::Logger::Null;
  # ABSTRACT: Blackhole-like silent logging engine for Dancer2
  $Dancer2::Logger::Null::VERSION = '0.162000';
  use Moo;
  with 'Dancer2::Core::Role::Logger';
  
  sub log {1}
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Logger::Null - Blackhole-like silent logging engine for Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This logger acts as a blackhole (or /dev/null, if you will) that discards all
  the log messages instead of displaying them anywhere.
  
  =head1 METHODS
  
  =head2 log
  
  Discards the message.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_LOGGER_NULL

$fatpacked{"Dancer2/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_PLUGIN';
  package Dancer2::Plugin;
  # ABSTRACT: Extending Dancer2's DSL with plugins
  $Dancer2::Plugin::VERSION = '0.162000';
  use Moo::Role;
  use Carp 'croak', 'carp';
  use Dancer2::Core::DSL;
  use Scalar::Util qw();
  
  # singleton for storing all keywords,
  # their code and the plugin they come from
  my $_keywords = {};
  
  # singleton for storing all hooks and their aliases
  my $_hooks = {};
  
  # singleton for applying code-blocks at import time
  # so their code gets the callers DSL
  my $_on_import = {};
  
  sub register {
      my $plugin = caller;
      my $caller = caller(1);
      my ( $keyword, $code, $options ) = @_;
      $options ||= { is_global => 1 };
  
      $keyword =~ /^[a-zA-Z_]+[a-zA-Z0-9_]*$/
        or croak "You can't use '$keyword', it is an invalid name"
        . " (it should match ^[a-zA-Z_]+[a-zA-Z0-9_]*\$ )";
  
      if (grep { $_ eq $keyword }
          keys %{ Dancer2::Core::DSL->dsl_keywords }
        )
      {
          croak "You can't use '$keyword', this is a reserved keyword";
      }
  
      while ( my ( $plugin, $keywords ) = each %$_keywords ) {
          if ( grep { $_->[0] eq $keyword } @$keywords ) {
              croak "You can't use $keyword, "
                . "this is a keyword reserved by $plugin";
          }
      }
  
      $_keywords->{$plugin} ||= [];
      push @{ $_keywords->{$plugin} },
        [ $keyword, $code, $options ];
  }
  
  sub on_plugin_import(&) {
      my $code   = shift;
      my $plugin = caller;
      $_on_import->{$plugin} ||= [];
      push @{ $_on_import->{$plugin} }, $code;
  }
  
  sub register_plugin {
      my $plugin = caller;
      my $caller = caller(1);
      my %params = @_;
  
      # if the caller has no dsl method, we cant register the plugin
      return if !$caller->can('dsl');
  
      # the plugin consumes the DSL role
      Moo::Role->apply_role_to_package( $plugin, 'Dancer2::Core::Role::DSL' );
  
      # bind all registered keywords to the plugin
      my $dsl = $caller->dsl;
      for my $k ( @{ $_keywords->{$plugin} } ) {
          my ( $keyword, $code, $options ) = @{$k};
          {
              no strict 'refs';
              *{"${plugin}::${keyword}"} = $dsl->_apply_prototype($code, $options);
          }
      }
  
  # create the import method of the caller (the actual plugin) in order to make it
  # imports all the DSL's keyword when it's used.
      my $import = sub {
          my $plugin = shift;
  
          # caller(1) because our import method is wrapped, see below
          my $caller = caller(1);
  
          for my $k ( @{ $_keywords->{$plugin} } ) {
              my ( $keyword, $code, $options ) = @{$k};
              my $is_global = exists $options->{is_global} && $options->{is_global};
              $caller->dsl->register( $keyword, $is_global );
          }
  
          Moo::Role->apply_roles_to_object( $caller->dsl, $plugin );
          $caller->dsl->export_symbols_to($caller);
          $caller->dsl->dancer_app->register_plugin( $caller->dsl );
  
          # add hooks
          my $current_hooks = [ $caller->dsl->supported_hooks ];
          my $current_aliases = $caller->dsl->hook_aliases;
          for my $h ( keys %{ $_hooks->{$plugin} } ) {
              push @$current_hooks, $h;
              $current_aliases->{ $_hooks->{$plugin}->{$h} } = $h;
  			# If the hooks atttribute has already been constructed,
  			# add an entry so has_hook() finds these hooks.
              $caller->dsl->hooks->{$h} = []
                  if ! exists $caller->dsl->hooks->{$h};
          }
          my $target = ref $caller->dsl;
          {
              no strict 'refs';
              no warnings 'redefine';
              *{"${target}::supported_hooks"} = sub {@$current_hooks};
              *{"${target}::hook_aliases"}    = sub {$current_aliases};
          }
  
          for my $sub ( @{ $_on_import->{$plugin} } ) {
              $sub->( $caller->dsl );
          }
      };
      my $app_caller = caller();
      {
          no strict 'refs';
          no warnings 'redefine';
          my $original_import = *{"${app_caller}::import"}{CODE};
          $original_import ||= sub { };
          *{"${app_caller}::import"} = sub {
              $original_import->(@_);
              $import->(@_);
          };
      }
      return 1;    #as in D1
  
      # The plugin is ready now.
  }
  
  sub plugin_args {@_}
  
  sub plugin_setting {
      my $plugin = caller;
      my $dsl    = _get_dsl()
          or croak 'No DSL object found';
  
      ( my $plugin_name = $plugin ) =~ s/Dancer2::Plugin:://;
  
      return $dsl->app->config->{'plugins'}->{$plugin_name} ||= {};
  }
  
  sub register_hook {
      my (@hooks) = @_;
  
      my $caller = caller;
      my $plugin = $caller;
  
      $plugin =~ s/^Dancer2::Plugin:://;
      $plugin =~ s/::/_/g;
  
      my $base_name = "plugin." . lc($plugin);
      for my $hook (@hooks) {
          my $hook_name = "${base_name}.$hook";
          $_hooks->{$caller}->{$hook_name} = $hook;
      }
  }
  
  sub execute_hook {
      my $position = shift;
      my $dsl      = _get_dsl();
      croak "No DSL object found" if !defined $dsl;
      $dsl->execute_hook( $position, @_ );
  }
  
  # private
  
  my $dsl_deprecation_wrapper = 0;
  sub import {
      my $class  = shift;
      my $plugin = caller;
  
      # First, export Dancer2::Plugins symbols
      my @export = qw(
        execute_hook
        register_hook
        register_plugin
        register
        on_plugin_import
        plugin_setting
        plugin_args
      );
  
      for my $symbol (@export) {
          no strict 'refs';
          *{"${plugin}::${symbol}"} = *{"Dancer2::Plugin::${symbol}"};
      }
  
      my $dsl = _get_dsl();
      return if !defined $dsl;
  
  # DEPRECATION NOTICE
  # We expect plugin to be written with a $dsl object now, so
  # this keywords will trigger a deprecation notice and will be removed in a later
  # version of Dancer2.
  
   # Support for Dancer 1 syntax for plugin.
   # Then, compile Dancer 2's DSL keywords into self-contained keywords for the
   # plugin (actually, we call all the symbols by giving them $caller->dsl as
   # their first argument).
   # These modified versions of the DSL are then exported in the namespace of the
   # plugin.
      if (! grep { $_ eq ':no_dsl' } @_) {
          for my $symbol ( keys %{ $dsl->keywords } ) {
  
              # get the original symbol from the real DSL
              no strict 'refs';
              no warnings qw( redefine once );
              my $code = *{"Dancer2::Core::DSL::$symbol"}{CODE};
  
              # compile it with $caller->dsl
              my $compiled = sub {
                  carp
                    "DEPRECATED: $plugin calls '$symbol' instead of '\$dsl->$symbol'.";
                  $code->( $dsl, @_ );
              };
  
              # Bind the newly compiled symbol to the caller's namespace.
              # As this may redefine a symbol, ensure the new coderef has
              # the same prototype signature.
              my $existing = *{"${plugin}::${symbol}"};
              my $prototype = prototype \&$existing;
              *{"${plugin}::${symbol}"} = Scalar::Util::set_prototype( \&$compiled, $prototype );
  
              $dsl_deprecation_wrapper = $compiled if $symbol eq 'dsl';
          }
      }
  
      # Finally, make sure our caller becomes a Moo::Role
      # Perl 5.8.5+ mandatory for that trick
      @_ = ('Moo::Role');
      goto &Moo::Role::import;
  }
  
  sub _get_dsl {
      my $dsl;
      my $deep = 2;
      while ( my $caller = caller( $deep++ ) ) {
          my $caller_dsl = $caller->can('dsl');
          next if ! $caller_dsl || $caller_dsl == $dsl_deprecation_wrapper;
          $dsl = $caller->dsl;
          last if defined $dsl && length( ref($dsl) );
      }
  
      return $dsl;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Plugin - Extending Dancer2's DSL with plugins
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  You can extend Dancer2 by writing your own plugin. A plugin is a module that
  exports a bunch of symbols to the current namespace (the caller will see all
  the symbols defined via C<register>).
  
  Note that you have to C<use> the plugin wherever you want to use its symbols.
  For instance, if you have Webapp::App1 and Webapp::App2, both loaded from your
  main application, they both need to C<use FooPlugin> if they want to use the
  symbols exported by C<FooPlugin>.
  
  For a more gentle introduction to Dancer2 plugins, see L<Dancer2::Plugins>.
  
  =head1 METHODS
  
  =head2 register
  
      register 'my_keyword' => sub { ... } => \%options;
  
  Allows the plugin to define a keyword that will be exported to the caller's
  namespace.
  
  The first argument is the symbol name, the second one the coderef to execute
  when the symbol is called.
  
  The coderef receives as its first argument the Dancer2::Core::DSL object.
  
  Plugins B<must> use the DSL object to access application components and work
  with them directly.
  
      sub {
          my $dsl = shift;
          my @args = @_;
  
          my $app     = $dsl->app;
          my $request = $app->request;
  
          if ( $app->session->read('logged_in') ) {
              ...
          }
      };
  
  As an optional third argument, it's possible to give a hash ref to C<register>
  in order to set some options.
  
  The option C<is_global> (boolean) is used to declare a global/non-global keyword
  (by default all keywords are global). A non-global keyword must be called from
  within a route handler (eg: C<session> or C<param>) whereas a global one can be
  called from everywhere (eg: C<dancer_version> or C<setting>).
  
      register my_symbol_to_export => sub {
          # ... some code
      }, { is_global => 1} ;
  
  =head2 on_plugin_import
  
  Allows the plugin to take action each time it is imported.
  It is prototyped to take a single code block argument, which will be called
  with the DSL object of the package importing it.
  
  For example, here is a way to install a hook in the importing app:
  
      on_plugin_import {
          my $dsl = shift;
          $dsl->app->add_hook(
              Dancer2::Core::Hook->new(
                  name => 'before',
                  code => sub { ... },
              )
          );
      };
  
  =head2 register_plugin
  
  A Dancer2 plugin must end with this statement. This lets the plugin register all
  the symbols defined with C<register> as exported symbols:
  
      register_plugin;
  
  Register_plugin returns 1 on success and undef if it fails.
  
  =head3 Deprecation note
  
  Earlier version of Dancer2 needed the keyword <for_version> to indicate for
  which version of Dancer the plugin was written, e.g.
  
      register_plugin for_versions => [ 2 ];
  
  Today, plugins for Dancer2 are only expected to work for Dancer2 and the
  C<for_versions> keyword is ignored. If you try to load a plugin for Dancer2
  that does not meet the requirements of a Dancer2 plugin, you will get an error
  message.
  
  =head2 plugin_args
  
  Simple method to retrieve the parameters or arguments passed to a
  plugin-defined keyword. Although not relevant for Dancer 1 only, or
  Dancer 2 only, plugins, it is useful for universal plugins.
  
    register foo => sub {
       my ($dsl, @args) = plugin_args(@_);
       ...
    }
  
  Note that Dancer 1 will return undef as the DSL object.
  
  =head2 plugin_setting
  
  If C<plugin_setting> is called inside a plugin, the appropriate configuration
  will be returned. The C<plugin_name> should be the name of the package, or,
  if the plugin name is under the B<Dancer2::Plugin::> namespace (which is
  recommended), the remaining part of the plugin name.
  
  Configuration for plugin should be structured like this in the config.yml of
  the application:
  
    plugins:
      plugin_name:
        key: value
  
  Enclose the remaining part in quotes if it contains ::, e.g.
  for B<Dancer2::Plugin::Foo::Bar>, use:
  
    plugins:
      "Foo::Bar":
        key: value
  
  =head2 register_hook
  
  Allows a plugin to declare a list of supported hooks. Any hook declared like so
  can be executed by the plugin with C<execute_hook>.
  
      register_hook 'foo';
      register_hook 'foo', 'bar', 'baz';
  
  =head2 execute_hook
  
  Allows a plugin to execute the hooks attached at the given position
  
      execute_hook 'some_hook';
  
  Arguments can be passed which will be received by handlers attached to that
  hook:
  
      execute_hook 'some_hook', $some_args, ... ;
  
  The hook must have been registered by the plugin first, with C<register_hook>.
  
  =head1 EXAMPLE PLUGIN
  
  The following code is a dummy plugin that provides a keyword 'logout' that
  destroys the current session and redirects to a new URL specified in
  the config file as C<after_logout>.
  
    package Dancer2::Plugin::Logout;
    use Dancer2::Plugin;
  
    register logout => sub {
      my $dsl  = shift;
      my $app  = $dsl->app;
      my $conf = plugin_setting();
  
      $app->destroy_session;
  
      return $app->redirect( $conf->{after_logout} );
    };
  
    register_plugin for_versions => [ 2 ] ;
  
    1;
  
  And in your application:
  
      package My::Webapp;
  
      use Dancer2;
      use Dancer2::Plugin::Logout;
  
      get '/logout' => sub { logout };
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_PLUGIN

$fatpacked{"Dancer2/Serializer/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_SERIALIZER_DUMPER';
  # ABSTRACT: Serializer for handling Dumper data
  
  package Dancer2::Serializer::Dumper;
  $Dancer2::Serializer::Dumper::VERSION = '0.162000';
  use Moo;
  use Carp 'croak';
  use Data::Dumper;
  use Safe;
  
  with 'Dancer2::Core::Role::Serializer';
  
  has '+content_type' => ( default => sub {'text/x-data-dumper'} );
  
  # helpers
  sub from_dumper { __PACKAGE__->deserialize(@_) }
  
  sub to_dumper { __PACKAGE__->serialize(@_) }
  
  # class definition
  sub serialize {
      my ( $self, $entity ) = @_;
  
      {
          local $Data::Dumper::Purity = 1;
          return Dumper($entity);
      }
  }
  
  sub deserialize {
      my ( $self, $content ) = @_;
  
      my $cpt = Safe->new;
  
      my $res = $cpt->reval("my \$VAR1; $content");
      croak "unable to deserialize : $@" if $@;
      return $res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Serializer::Dumper - Serializer for handling Dumper data
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This is a serializer engine that allows you to turn Perl data structures  into
  L<Data::Dumper> output and vice-versa.
  
  =head1 ATTRIBUTES
  
  =head2 content_type
  
  Returns 'text/x-data-dumper'
  
  =head1 METHODS
  
  =head2 serialize($content)
  
  Serializes a Perl data structure into a Dumper string.
  
  =head2 deserialize($content)
  
  Deserialize a Dumper string into a Perl data structure.
  
  =head1 FUNCTIONS
  
  =head2 from_dumper($content)
  
  This is an helper available to transform a L<Data::Dumper> output to a Perl
  data structures.
  
  =head2 to_dumper($content)
  
  This is an helper available to transform a Perl data structures to a
  L<Data::Dumper> output.
  
  Calling this function will B<not> trigger the serialization's hooks.
  
  =head1 METHODS
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_SERIALIZER_DUMPER

$fatpacked{"Dancer2/Serializer/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_SERIALIZER_JSON';
  package Dancer2::Serializer::JSON;
  # ABSTRACT: Serializer for handling JSON data
  $Dancer2::Serializer::JSON::VERSION = '0.162000';
  use Moo;
  use JSON ();
  use Scalar::Util 'blessed';
  
  with 'Dancer2::Core::Role::Serializer';
  
  has '+content_type' => ( default => sub {'application/json'} );
  
  # helpers
  sub from_json { __PACKAGE__-> deserialize(@_) }
  
  sub to_json { __PACKAGE__->serialize(@_) }
  
  # class definition
  sub serialize {
      my ( $self, $entity, $options ) = @_;
  
      my $config = blessed $self ? $self->config : {};
  
      foreach (keys %$config) {
          $options->{$_} = $config->{$_} unless exists $options->{$_};
      }
  
      $options->{utf8} = 1 if !defined $options->{utf8};
  
      JSON::to_json( $entity, $options );
  }
  
  sub deserialize {
      my ( $self, $entity, $options ) = @_;
  
      $options->{utf8} = 1 if !defined $options->{utf8};
      JSON::from_json( $entity, $options );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Serializer::JSON - Serializer for handling JSON data
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This is a serializer engine that allows you to turn Perl data structures into
  JSON output and vice-versa.
  
  =head1 ATTRIBUTES
  
  =head2 content_type
  
  Returns 'application/json'
  
  =head1 METHODS
  
  =head2 serialize($content)
  
  Serializes a Perl data structure into a JSON string.
  
  =head2 deserialize($content)
  
  Deserializes a JSON string into a Perl data structure.
  
  =head1 FUNCTIONS
  
  =head2 from_json($content, \%options)
  
  This is an helper available to transform a JSON data structure to a Perl data structures.
  
  =head2 to_json($content, \%options)
  
  This is an helper available to transform a Perl data structure to JSON.
  
  Calling this function will B<not> trigger the serialization's hooks.
  
  =head1 METHODS
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_SERIALIZER_JSON

$fatpacked{"Dancer2/Serializer/Mutable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_SERIALIZER_MUTABLE';
  package Dancer2::Serializer::Mutable;
  # ABSTRACT: Serialize and deserialize content based on HTTP header
  $Dancer2::Serializer::Mutable::VERSION = '0.162000';
  use Moo;
  use Carp 'croak';
  use Encode;
  with 'Dancer2::Core::Role::Serializer';
  
  has '+content_type' => ( default => sub {'application/json'} );
  
  my $formats = {
      'text/x-yaml'        => 'YAML',
      'text/html'          => 'YAML',
      'text/x-data-dumper' => 'Dumper',
      'text/x-json'        => 'JSON',
      'application/json'   => 'JSON',
  };
  
  my $serializer = {
      'YAML'   => {
          to      => sub { Dancer2::Core::DSL::to_yaml(@_)   },
          from    => sub { Dancer2::Core::DSL::from_yaml(@_) },
      },
      'Dumper' => {
          to      => sub { Dancer2::Core::DSL::to_dumper(@_)   },
          from    => sub { Dancer2::Core::DSL::from_dumper(@_) },
      },
      'JSON'   => {
          to      => sub { Dancer2::Core::DSL::to_json(@_)   },
          from    => sub { Dancer2::Core::DSL::from_json(@_) },
      },
  };
  
  sub support_content_type {
      my ( $self, $ct ) = @_;
  
      # FIXME: are we getting full content type?
  
      if ( $ct && grep +( $_ eq $ct ), keys %{$formats} ) {
          $self->set_content_type($ct);
  
          return 1;
      }
  
      return 0;
  }
  
  sub serialize {
      my ( $self, $entity ) = @_;
  
      # Look for valid format in the headers
      my $format = $self->_get_content_type();
  
      # Match format with a serializer and return
      $format and return $serializer->{$format}{'to'}->(
          $self, $entity
      );
  
      # If none is found then just return the entity without change
      return $entity;
  }
  
  sub deserialize {
      my ( $self, $content ) = @_;
  
      # The right content type should already be set
      my $format = $formats->{$self->content_type};
  
      $format and return $serializer->{$format}{'from'}->( $self, $content );
  
      return $content;
  }
  
  sub _get_content_type {
      my $self    = shift;
      $self->has_request or return;
  
      # Search for the first HTTP header variable which
      # specifies supported content.
      foreach my $method ( qw<content_type accept> ) {
          if ( my $value = $self->request->header($method) ) {
              if ( exists $formats->{$value} ) {
                  $self->set_content_type($value);
                  return $formats->{$value};
              }
          }
      }
  
      # If none if found, return undef.
      return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Serializer::Mutable - Serialize and deserialize content based on HTTP header
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
      # in config.yml
      serializer: Mutable
  
      # in the app
      put '/something' => sub {
          # deserialized from request
          my $name = param( 'name' );
  
          ...
  
          # will be serialized to the most
          # fitting format
          return { message => "user $name added" };
      };
  
  =head1 DESCRIPTION
  
  This serializer will try find the best (de)serializer for a given request.
  For this, it will pick the first valid content type found from the following list
  and use its related serializer.
  
  =over
  
  =item
  
  The B<content_type> from the request headers
  
  =item
  
  the B<accept> from the request headers
  
  =item
  
  The default is B<application/json>
  
  =back
  
  The content-type/serializer mapping that C<Dancer2::Serializer::Mutable>
  uses is
  
      serializer                  | content types
      ----------------------------------------------------------
      Dancer2::Serializer::YAML   | text/x-yaml, text/html
      Dancer2::Serializer::Dumper | text/x-data-dumper
      Dancer2::Serializer::JSON   | text/x-json, application/json
  
  =head2 INTERNAL METHODS
  
  The following methods are used internally by C<Dancer2> and are not made
  accessible via the DSL.
  
  =head2 serialize
  
  Serialize a data structure. The format it is serialized to is determined
  automatically as described above. It can be one of YAML, Dumper, JSON, defaulting
  to JSON if there's no clear preference from the request.
  
  =head2 deserialize
  
  Deserialize the provided serialized data to a data structure.  The type of
  serialization format depends on the request's content-type. For now, it can
  be one of YAML, Dumper, JSON.
  
  =head2 content_type
  
  Returns the content-type that was used during the last C<serialize> /
  C<deserialize> call. B<WARNING> : you must call C<serialize> / C<deserialize>
  before calling C<content_type>. Otherwise the return value will be C<undef>.
  
  =head1 NAME
  
  Dancer2::Serializer::Mutable - Serialize and deserialize content using the appropriate HTTP header
  (ported from Dancer)
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_SERIALIZER_MUTABLE

$fatpacked{"Dancer2/Serializer/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_SERIALIZER_YAML';
  package Dancer2::Serializer::YAML;
  # ABSTRACT: Serializer for handling YAML data
  $Dancer2::Serializer::YAML::VERSION = '0.162000';
  use Moo;
  use Carp 'croak';
  use Encode;
  use Class::Load 'load_class';
  
  with 'Dancer2::Core::Role::Serializer';
  
  has '+content_type' => ( default => sub {'text/x-yaml'} );
  
  # helpers
  sub from_yaml { __PACKAGE__->deserialize(@_) }
  
  sub to_yaml { __PACKAGE__->serialize(@_) }
  
  # class definition
  sub BUILD { load_class('YAML') }
  
  sub serialize {
      my ( $self, $entity ) = @_;
      encode('UTF-8', YAML::Dump($entity));
  }
  
  sub deserialize {
      my ( $self, $content ) = @_;
      YAML::Load(decode('UTF-8', $content));
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Serializer::YAML - Serializer for handling YAML data
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This is a serializer engine that allows you to turn Perl data structures into
  YAML output and vice-versa.
  
  =head1 ATTRIBUTES
  
  =head2 content_type
  
  Returns 'text/x-yaml'
  
  =head1 METHODS
  
  =head2 serialize($content)
  
  Serializes a data structure to a YAML structure.
  
  =head2 deserialize($content)
  
  Deserializes a YAML structure to a data structure.
  
  =head1 FUNCTIONS
  
  =head2 fom_yaml($content)
  
  This is an helper available to transform a YAML data structure to a Perl data structures.
  
  =head2 to_yaml($content)
  
  This is an helper available to transform a Perl data structure to YAML.
  
  Calling this function will B<not> trigger the serialization's hooks.
  
  =head1 METHODS
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_SERIALIZER_YAML

$fatpacked{"Dancer2/Session/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_SESSION_SIMPLE';
  package Dancer2::Session::Simple;
  # ABSTRACT: in-memory session backend for Dancer2
  $Dancer2::Session::Simple::VERSION = '0.162000';
  use Moo;
  use Dancer2::Core::Types;
  use Carp;
  
  with 'Dancer2::Core::Role::SessionFactory';
  
  # The singleton that contains all the session objects created
  my $SESSIONS = {};
  
  sub _sessions {
      my ($self) = @_;
      return [ keys %{$SESSIONS} ];
  }
  
  sub _retrieve {
      my ( $class, $id ) = @_;
      my $s = $SESSIONS->{$id};
  
      croak "Invalid session ID: $id"
        if !defined $s;
  
      return $s;
  }
  
  sub _destroy {
      my ( $class, $id ) = @_;
      delete $SESSIONS->{$id};
  }
  
  sub _flush {
      my ( $class, $id, $data ) = @_;
      $SESSIONS->{$id} = $data;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Session::Simple - in-memory session backend for Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This module implements a very simple session backend, holding all session data
  in memory.  This means that sessions are volatile, and no longer exist when the
  process exits.  This module is likely to be most useful for testing purposes.
  
  =head1 DISCLAIMER
  
  This session factory should not be used in production and is only for
  single-process application workers. As the sessions objects are stored
  in-memory, they cannot be shared among multiple workers.
  
  =head1 CONFIGURATION
  
  The setting B<session> should be set to C<Simple> in order to use this session
  engine in a Dancer2 application.
  
  =head1 SEE ALSO
  
  See L<Dancer2::Core::Session> for details about session usage in route handlers.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_SESSION_SIMPLE

$fatpacked{"Dancer2/Session/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_SESSION_YAML';
  package Dancer2::Session::YAML;
  $Dancer2::Session::YAML::VERSION = '0.162000';
  # ABSTRACT: YAML-file-based session backend for Dancer2
  
  use Moo;
  use Dancer2::Core::Types;
  use YAML;
  
  has _suffix => (
      is      => 'ro',
      isa     => Str,
      default => sub {'.yml'},
  );
  
  with 'Dancer2::Core::Role::SessionFactory::File';
  
  sub _freeze_to_handle {
      my ( $self, $fh, $data ) = @_;
      print {$fh} YAML::Dump($data);
      return;
  }
  
  sub _thaw_from_handle {
      my ( $self, $fh ) = @_;
      return YAML::LoadFile($fh);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Session::YAML - YAML-file-based session backend for Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 DESCRIPTION
  
  This module implements a session engine based on YAML files. Session are stored
  in a I<session_dir> as YAML files. The idea behind this module was to provide a
  human-readable session storage for the developer.
  
  This backend is intended to be used in development environments, when digging
  inside a session can be useful.
  
  This backend can perfectly be used in production environments, but two things
  should be kept in mind: The content of the session files is in plain text, and
  the session files should be purged by a CRON job.
  
  =head1 CONFIGURATION
  
  The setting B<session> should be set to C<YAML> in order to use this session
  engine in a Dancer2 application.
  
  Files will be stored to the value of the setting C<session_dir>, whose default
  value is C<appdir/sessions>.
  
  Here is an example configuration that use this session engine and stores session
  files in /tmp/dancer-sessions
  
      session: "YAML"
  
      engines:
        session:
          YAML:
            session_dir: "/tmp/dancer-sessions"
            cookie_duration: 3600    # Default cookie timeout in seconds
  
  =head1 DEPENDENCY
  
  This module depends on L<YAML>.
  
  =head1 SEE ALSO
  
  See L<Dancer2::Core::Session> for details about session usage in route handlers.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_SESSION_YAML

$fatpacked{"Dancer2/Template/Implementation/ForkedTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_TEMPLATE_IMPLEMENTATION_FORKEDTINY';
  package Dancer2::Template::Implementation::ForkedTiny;
  $Dancer2::Template::Implementation::ForkedTiny::VERSION = '0.162000';
  # ABSTRACT: Dancer2 own implementation of Template::Tiny
  
  use 5.00503;
  use strict;
  no warnings;
  
  # Evaluatable expression
  my $EXPR = qr/ [a-z_][\w.]* /xs;
  
  sub new {
      my $self = bless {
          start_tag => '[%',
          end_tag   => '%]',
          @_[ 1 .. $#_ ]
        },
        $_[0];
  
  # Opening tag including whitespace chomping rules
      my $LEFT = $self->{LEFT} = qr/
      (?:
          (?: (?:^|\n) [ \t]* )? \Q$self->{start_tag}\E\-
          |
          \Q$self->{start_tag}\E \+?
      ) \s*
  /xs;
  
  # Closing %] tag including whitespace chomping rules
      my $RIGHT = $self->{RIGHT} = qr/
      \s* (?:
          \+? \Q$self->{end_tag}\E
          |
          \-\Q$self->{end_tag}\E (?: [ \t]* \n )?
      )
  /xs;
  
  # Preparsing run for nesting tags
      $self->{PREPARSE} = qr/
      $LEFT ( IF | UNLESS | FOREACH ) \s+
          (
              (?: \S+ \s+ IN \s+ )?
          \S+ )
      $RIGHT
      (?!
          .*?
          $LEFT (?: IF | UNLESS | FOREACH ) \b
      )
      ( .*? )
      (?:
          $LEFT ELSE $RIGHT
          (?!
              .*?
              $LEFT (?: IF | UNLESS | FOREACH ) \b
          )
          ( .+? )
      )?
      $LEFT END $RIGHT
  /xs;
  
      $self->{CONDITION} = qr/
      \Q$self->{start_tag}\E\s
          ( ([IUF])\d+ ) \s+
          (?:
              ([a-z]\w*) \s+ IN \s+
          )?
          ( $EXPR )
      \s\Q$self->{end_tag}\E
      ( .*? )
      (?:
          \Q$self->{start_tag}\E\s \1 \s\Q$self->{end_tag}\E
          ( .+? )
      )?
      \Q$self->{start_tag}\E\s \1 \s\Q$self->{end_tag}\E
  /xs;
  
      $self;
  }
  
  # Copy and modify
  sub preprocess {
      my $self = shift;
      my $text = shift;
      $self->_preprocess( \$text );
      return $text;
  }
  
  sub process {
      my $self  = shift;
      my $copy  = ${ shift() };
      my $stash = shift || {};
  
      local $@  = '';
      local $^W = 0;
  
      # Preprocess to establish unique matching tag sets
      $self->_preprocess( \$copy );
  
      # Process down the nested tree of conditions
      my $result = $self->_process( $stash, $copy );
      if (@_) {
          ${ $_[0] } = $result;
      }
      elsif ( defined wantarray ) {
          require Carp;
          Carp::carp(
              'Returning of template results is deprecated in Template::Tiny 0.11'
          );
          return $result;
      }
      else {
          print $result;
      }
  }
  
  
  ######################################################################
  # Support Methods
  
  # The only reason this is a standalone is so we can
  # do more in-depth testing.
  sub _preprocess {
      my $self = shift;
      my $copy = shift;
  
      # Preprocess to establish unique matching tag sets
      my $id = 0;
      1 while $$copy =~ s/
          $self->{PREPARSE}
      /
          my $tag = substr($1, 0, 1) . ++$id;
          "\[\% $tag $2 \%\]$3\[\% $tag \%\]"
          . (defined($4) ? "$4\[\% $tag \%\]" : '');
      /sex;
  }
  
  sub _process {
      my ( $self, $stash, $text ) = @_;
  
      $text =~ s/
          $self->{CONDITION}
      /
          ($2 eq 'F')
              ? $self->_foreach($stash, $3, $4, $5)
              : eval {
                  $2 eq 'U'
                  xor
                  !! # Force boolification
                  $self->_expression($stash, $4)
              }
                  ? $self->_process($stash, $5)
                  : $self->_process($stash, $6)
      /gsex;
  
      # Resolve expressions
      $text =~ s/
          $self->{LEFT} ( $EXPR ) $self->{RIGHT}
      /
          eval {
              $self->_expression($stash, $1)
              . '' # Force stringification
          }
      /gsex;
  
      # Trim the document
      $text =~ s/^\s*(.+?)\s*\z/$1/s if $self->{TRIM};
  
      return $text;
  }
  
  # Special handling for foreach
  sub _foreach {
      my ( $self, $stash, $term, $expr, $text ) = @_;
  
      # Resolve the expression
      my $list = $self->_expression( $stash, $expr );
      if ( ref $list ne 'ARRAY' ) {
          return '';
      }
  
      # Iterate
      return join '',
        map { $self->_process( { %$stash, $term => $_ }, $text ) } @$list;
  }
  
  # Evaluates a stash expression
  sub _expression {
      my $cursor = $_[1];
      my @path = split /\./, $_[2];
      foreach (@path) {
  
          # Support for private keys
          return if substr( $_, 0, 1 ) eq '_';
  
          # Split by data type
          my $type = ref $cursor;
          if ( $type eq 'ARRAY' ) {
              return '' unless /^(?:0|[0-9]\d*)\z/;
              $cursor = $cursor->[$_];
          }
          elsif ( $type eq 'HASH' ) {
              $cursor = $cursor->{$_};
          }
          elsif ($type) {
              $cursor = $cursor->$_();
          }
          else {
              return '';
          }
      }
  
      # If the last expression is a CodeRef, execute it
      ref($cursor) eq 'CODE'
        and $cursor = $cursor->();
      return $cursor;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Template::Implementation::ForkedTiny - Dancer2 own implementation of Template::Tiny
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
    my $template = Dancer2::Template::Implementation::ForkedTiny->new(
        TRIM => 1,
    );
  
    # Print the template results to STDOUT
    $template->process( <<'END_TEMPLATE', { foo => 'World' } );
    Hello [% foo %]!
    END_TEMPLATE
  
  =head1 DESCRIPTION
  
  B<Dancer2::Template::Implementation::ForkedTiny> is a reimplementation of a subset of the functionality from
  L<Template> Toolkit in as few lines of code as possible.
  
  It is intended for use in light-usage, low-memory, or low-cpu templating
  situations, where you may need to upgrade to the full feature set in the
  future, or if you want the retain the familiarity of TT-style templates.
  
  For the subset of functionality it implements, it has fully-compatible template
  and stash API. All templates used with B<Dancer2::Template::Implementation::ForkedTiny> should be able to be
  transparently upgraded to full Template Toolkit.
  
  Unlike Template Toolkit, B<Dancer2::Template::Implementation::ForkedTiny> will process templates without a
  compile phase (but despite this is still quicker, owing to heavy use of
  the Perl regular expression engine.
  
  =head2 SUPPORTED USAGE
  
  By default, the C<[% %]> tag style is used. You can change the start tag and
  end tag by specifying them at object creation :
  
    my $template = Dancer2::Template::Implementation::ForkedTiny->new(
        start_tag => '<%',
        end_tag => '%>,
    );
  
  In the rest of the documentation, C<[% %]> will be used, but it can be of
  course your specified start / end tags.
  
  Both the C<[%+ +%]> style explicit whitespace and the C<[%- -%]> style
  explicit chomp B<are> support, although the C<[%+ +%]> version is unneeded
  in practice as B<Dancer2::Template::Implementation::ForkedTiny> does not support default-enabled C<PRE_CHOMP>
  or C<POST_CHOMP>.
  
  Variable expressions in the form C<[% foo.bar.baz %]> B<are> supported.
  
  Appropriate simple behaviours for C<ARRAY> references, C<HASH> references and
  objects are supported. "VMethods" such as [% array.length %] are B<not>
  supported at this time.
  
  If the resulting expression is a CodeRef, it'll be evaluated.
  
  C<IF>, C<ELSE> and C<UNLESS> conditional blocks B<are> supported, but only with
  simple C<[% foo.bar.baz %]> conditions.
  
  Support for looping (or rather iteration) is available in simple
  C<[% FOREACH item IN list %]> form B<is> supported. Other loop structures are
  B<not> supported. Because support for arbitrary or infinite looping is not
  available, B<Dancer2::Template::Implementation::ForkedTiny> templates are not turing complete. This is
  intentional.
  
  All of the four supported control structures C<IF>/C<ELSE>/C<UNLESS>/C<FOREACH>
  can be nested to arbitrary depth.
  
  The treatment of C<_private> hash and method keys is compatible with
  L<Template> Toolkit, returning null or false rather than the actual content
  of the hash key or method.
  
  Anything beyond the above is currently out of scope.
  
  =head1 NAME
  
  Dancer2::Template::Implementation::ForkedTiny - Template Toolkit reimplemented in as little code as possible, forked from Template::Tiny
  
  =head1 METHODS
  
  =head2 new
  
    my $template = Dancer2::Template::Implementation::ForkedTiny->new(
        TRIM => 1,
    );
  
  The C<new> constructor is provided for compatibility with Template Toolkit.
  
  The only parameter it currently supports is C<TRIM> (which removes leading
  and trailing whitespace from processed templates).
  
  Additional parameters can be provided without error, but will be ignored.
  
  =head2 process
  
    # DEPRECATED: Return template results (emits a warning)
    my $text = $template->process( \$input, $vars );
  
    # Print template results to STDOUT
    $template->process( \$input, $vars );
  
    # Generate template results into a variable
    my $output = '';
    $template->process( \$input, $vars, \$output );
  
  The C<process> method is called to process a template.
  
  The first parameter is a reference to a text string containing the template
  text. A reference to a hash may be passed as the second parameter containing
  definitions of template variables.
  
  If a third parameter is provided, it must be a scalar reference to be
  populated with the output of the template.
  
  For a limited amount of time, the old deprecated interface will continue to
  be supported. If C<process> is called without a third parameter, and in
  scalar or list contest, the template results will be returned to the caller.
  
  If C<process> is called without a third parameter, and in void context, the
  template results will be C<print()>ed to the currently selected file handle
  (probably C<STDOUT>) for compatibility with L<Template>.
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Template-Tiny>
  
  For other issues, or commercial enhancement or support, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Forked and improved by Damien Krotkine E<lt>dams@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Config::Tiny>, L<CSS::Tiny>, L<YAML::Tiny>
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Adam Kennedy.
  Copyright 2012 Damien Krotkine.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_TEMPLATE_IMPLEMENTATION_FORKEDTINY

$fatpacked{"Dancer2/Template/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_TEMPLATE_SIMPLE';
  package Dancer2::Template::Simple;
  # ABSTRACT: Pure Perl 5 template engine for Dancer2
  $Dancer2::Template::Simple::VERSION = '0.162000';
  use Moo;
  use Dancer2::FileUtils 'read_file_content';
  
  with 'Dancer2::Core::Role::Template';
  
  has start_tag => (
      is      => 'rw',
      default => sub {'<%'},
  );
  
  has stop_tag => (
      is      => 'rw',
      default => sub {'%>'},
  );
  
  sub BUILD {
      my $self     = shift;
      my $settings = $self->config;
  
      $settings->{$_} and $self->$_( $settings->{$_} )
        for qw/ start_tag stop_tag /;
  }
  
  sub render {
      my ( $self, $template, $tokens ) = @_;
      my $content;
  
      $content = read_file_content($template);
      $content = $self->parse_branches( $content, $tokens );
  
      return $content;
  }
  
  sub parse_branches {
      my ( $self, $content, $tokens ) = @_;
      my ( $start, $stop ) = ( $self->start_tag, $self->stop_tag );
  
      my @buffer;
      my $prefix             = "";
      my $should_bufferize   = 1;
      my $bufferize_if_token = 0;
  
  #    $content =~ s/\Q${start}\E(\S)/${start} $1/sg;
  #    $content =~ s/(\S)\Q${stop}\E/$1 ${stop}/sg;
  
      # we get here a list of tokens without the start/stop tags
      my @full = split( /\Q$start\E\s*(.*?)\s*\Q$stop\E/, $content );
  
      # and here a list of tokens without variables
      my @flat = split( /\Q$start\E\s*.*?\s*\Q$stop\E/, $content );
  
      # eg: for 'foo=<% var %>'
      #   @full = ('foo=', 'var')
      #   @flat = ('foo=')
  
      my $flat_index = 0;
      my $full_index = 0;
      for my $word (@full) {
  
          # flat word, nothing to do
          if ( defined $flat[$flat_index]
              && ( $flat[$flat_index] eq $full[$full_index] ) )
          {
              push @buffer, $word if $should_bufferize;
              $flat_index++;
              $full_index++;
              next;
          }
  
          my @to_parse = ($word);
          @to_parse = split( /\s+/, $word ) if $word =~ /\s+/;
  
          for my $w (@to_parse) {
  
              if ( $w eq 'if' ) {
                  $bufferize_if_token = 1;
              }
              elsif ( $w eq 'else' ) {
                  $should_bufferize = !$should_bufferize;
              }
              elsif ( $w eq 'end' ) {
                  $should_bufferize = 1;
              }
              elsif ($bufferize_if_token) {
                  my $bool = _find_value_from_token_name( $w, $tokens );
                  $should_bufferize = _interpolate_value($bool) ? 1 : 0;
                  $bufferize_if_token = 0;
              }
              elsif ($should_bufferize) {
                  my $val =
                    _interpolate_value(
                      _find_value_from_token_name( $w, $tokens ) );
                  push @buffer, $val;
              }
          }
  
          $full_index++;
      }
  
      return join "", @buffer;
  }
  
  
  sub _find_value_from_token_name {
      my ( $key, $tokens ) = @_;
      my $value = undef;
  
      my @elements = split /\./, $key;
      foreach my $e (@elements) {
          if ( not defined $value ) {
              $value = $tokens->{$e};
          }
          elsif ( ref($value) eq 'HASH' ) {
              $value = $value->{$e};
          }
          elsif ( ref($value) ) {
              local $@;
              eval { $value = $value->$e };
              $value = "" if $@;
          }
      }
      return $value;
  }
  
  sub _interpolate_value {
      my ($value) = @_;
      if ( ref($value) eq 'CODE' ) {
          local $@;
          eval { $value = $value->() };
          $value = "" if $@;
      }
      elsif ( ref($value) eq 'ARRAY' ) {
          $value = "@{$value}";
      }
  
      $value = "" if not defined $value;
      return $value;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Template::Simple - Pure Perl 5 template engine for Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
  To use this engine, you may configure L<Dancer2> via C<config.yaml>:
  
      template: simple
  
  =head1 DESCRIPTION
  
  This template engine is provided as a default one for the Dancer2 micro
  framework.
  
  This template engine should be fine for development purposes but is not a
  powerful one, it's written in pure Perl and has no C bindings to accelerate the
  template processing.
  
  If you want to power an application with Dancer2 in production environment, it's
  strongly advised to switch to L<Dancer2::Template::TemplateToolkit>.
  
  =head1 METHODS
  
  =head2 render($template, \%tokens)
  
  Renders the template.  The first arg is a filename for the template file
  or a reference to a string that contains the template.  The second arg
  is a hashref for the tokens that you wish to pass to
  L<Template::Toolkit> for rendering.
  
  =head1 SYNTAX
  
  A template written for C<Dancer2::Template::Simple> should be working just fine
  with L<Dancer2::Template::TemplateToolkit>. The opposite is not true though.
  
  =over 4
  
  =item B<variables>
  
  To interpolate a variable in the template, use the following syntax:
  
      <% var1 %>
  
  If B<var1> exists in the tokens hash given, its value will be written there.
  
  =back
  
  =head1 SEE ALSO
  
  L<Dancer2>, L<Dancer2::Core::Role::Template>,
  L<Dancer2::Template::TemplateToolkit>.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_TEMPLATE_SIMPLE

$fatpacked{"Dancer2/Template/TemplateToolkit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_TEMPLATE_TEMPLATETOOLKIT';
  # ABSTRACT: Template toolkit engine for Dancer2
  
  package Dancer2::Template::TemplateToolkit;
  $Dancer2::Template::TemplateToolkit::VERSION = '0.162000';
  use Moo;
  use Carp qw/croak/;
  use Dancer2::Core::Types;
  use Template;
  
  with 'Dancer2::Core::Role::Template';
  
  has '+engine' => ( isa => InstanceOf ['Template'], );
  
  sub _build_engine {
      my $self      = shift;
      my $charset   = $self->charset;
      my %tt_config = (
          ANYCASE  => 1,
          ABSOLUTE => 1,
          length($charset) ? ( ENCODING => $charset ) : (),
          %{ $self->config },
      );
  
      my $start_tag = $self->config->{'start_tag'};
      my $stop_tag = $self->config->{'stop_tag'} || $self->config->{end_tag};
      $tt_config{'START_TAG'} = $start_tag
        if defined $start_tag && $start_tag ne '[%';
      $tt_config{'END_TAG'} = $stop_tag
        if defined $stop_tag && $stop_tag ne '%]';
  
      $tt_config{'INCLUDE_PATH'} ||= $self->views;
  
      return Template->new(%tt_config);
  }
  
  sub render {
      my ( $self, $template, $tokens ) = @_;
  
      ( ref $template || -f $template )
        or croak "Failed to render template: $template is not a regular file or reference";
  
      my $content = '';
      my $charset = $self->charset;
      my @options = length($charset) ? ( binmode => ":encoding($charset)" ) : ();
      $self->engine->process( $template, $tokens, \$content, @options )
        or croak 'Failed to render template: ' . $self->engine->error;
  
      return $content;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Template::TemplateToolkit - Template toolkit engine for Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
  To use this engine, you may configure L<Dancer2> via C<config.yaml>:
  
      template:   "template_toolkit"
  
  Or you may also change the rendering engine on a per-route basis by
  setting it manually with C<set>:
  
      # code code code
      set template => 'template_toolkit';
  
  =head1 DESCRIPTION
  
  This template engine allows you to use L<Template::Toolkit> in L<Dancer2>.
  
  =head1 METHODS
  
  =head2 render($template, \%tokens)
  
  Renders the template.  The first arg is a filename for the template file
  or a reference to a string that contains the template.  The second arg
  is a hashref for the tokens that you wish to pass to
  L<Template::Toolkit> for rendering.
  
  =head1 SEE ALSO
  
  L<Dancer2>, L<Dancer2::Core::Role::Template>, L<Template::Toolkit>.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_TEMPLATE_TEMPLATETOOLKIT

$fatpacked{"Dancer2/Template/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_TEMPLATE_TINY';
  package Dancer2::Template::Tiny;
  # ABSTRACT: Template::Tiny engine for Dancer2
  $Dancer2::Template::Tiny::VERSION = '0.162000';
  use Moo;
  use Carp qw/croak/;
  use Dancer2::Core::Types;
  use Dancer2::Template::Implementation::ForkedTiny;
  use Dancer2::FileUtils 'read_file_content';
  
  with 'Dancer2::Core::Role::Template';
  
  has '+engine' => (
      isa => InstanceOf ['Dancer2::Template::Implementation::ForkedTiny']
  );
  
  sub _build_engine {
      Dancer2::Template::Implementation::ForkedTiny->new( %{ $_[0]->config } );
  }
  
  sub render {
      my ( $self, $template, $tokens ) = @_;
  
      ( ref $template || -f $template )
        or croak "$template is not a regular file or reference";
  
      my $template_data =
        ref $template
        ? ${$template}
        : read_file_content($template);
  
      my $content;
  
      $self->engine->process( \$template_data, $tokens, \$content, )
        or die "Could not process template file '$template'";
  
      return $content;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Template::Tiny - Template::Tiny engine for Dancer2
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
  This template engine allows you to use L<Template::Tiny> in L<Dancer2>.
  
  L<Template::Tiny> is an implementation of a subset of L<Template::Toolkit> (the
  major parts) which takes much less memory and is faster. If you're only using
  the main functions of Template::Toolkit, you could use Template::Tiny. You can
  also seamlessly move back to Template::Toolkit whenever you want.
  
  However, Dancer2 uses a modified version of L<Template::Tiny>, which is L<Dancer2::Template::Implementation::ForkedTiny>. It adds 2 features :
  
  =over
  
  =item *
  
  opening and closing tag are now configurable
  
  =item *
  
  CodeRefs are evaluated and their results is inserted in the result.
  
  =back
  
  You can read more on L<Dancer2::Template::Implementation::ForkedTiny>.
  
  To use this engine, all you need to configure in your L<Dancer2>'s
  C<config.yaml>:
  
      template: "tiny"
  
  Of course, you can also set this B<while> working using C<set>:
  
      # code code code
      set template => 'tiny';
  
  Since L<Dancer2> has internal support for a wrapper-like option with the
  C<layout> configuration option, you can have a L<Template::Toolkit>-like WRAPPER
  even though L<Template::Tiny> doesn't really support it.
  
  =head1 METHODS
  
  =head2 render($template, \%tokens)
  
  Renders the template.  The first arg is a filename for the template file
  or a reference to a string that contains the template.  The second arg
  is a hashref for the tokens that you wish to pass to
  L<Template::Toolkit> for rendering.
  
  =head1 SEE ALSO
  
  L<Dancer2>, L<Dancer2::Core::Role::Template>, L<Template::Tiny>,
  L<Dancer2::Template::Implementation::ForkedTiny>.
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_TEMPLATE_TINY

$fatpacked{"Dancer2/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_TEST';
  package Dancer2::Test;
  # ABSTRACT: Useful routines for testing Dancer2 apps
  $Dancer2::Test::VERSION = '0.162000';
  use strict;
  use warnings;
  
  use Carp qw<carp croak>;
  use Test::More;
  use Test::Builder;
  use URI::Escape;
  use Data::Dumper;
  use File::Temp;
  
  use parent 'Exporter';
  our @EXPORT = qw(
    dancer_response
  
    response_content_is
    response_content_isnt
    response_content_is_deeply
    response_content_like
    response_content_unlike
  
    response_status_is
    response_status_isnt
  
    response_headers_include
    response_headers_are_deeply
  
    response_is_file
  
    route_exists
    route_doesnt_exist
  
    is_pod_covered
    route_pod_coverage
  
  );
  
  #dancer1 also has read_logs, response_redirect_location_is
  #cf. https://github.com/PerlDancer2/Dancer22/issues/25
  
  use Dancer2::Core::Dispatcher;
  use Dancer2::Core::Request;
  
  # singleton to store all the apps
  my $_dispatcher = Dancer2::Core::Dispatcher->new;
  
  # prevent deprecation warnings
  our $NO_WARN = 0;
  
  # can be called with the ($method, $path, $option) triplet,
  # or can be fed a request object directly, or can be fed
  # a single string, assumed to be [ GET => $string ]
  # or can be fed a response (which is passed through without
  # any modification)
  sub dancer_response {
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
  
      _find_dancer_apps_for_dispatcher();
  
      # useful for the high-level tests
      return $_[0] if ref $_[0] eq 'Dancer2::Core::Response';
  
      my ( $request, $env ) =
        ref $_[0] eq 'Dancer2::Core::Request'
        ? _build_env_from_request(@_)
        : _build_request_from_env(@_);
  
      # override the set_request so it actually sets our request instead
      {
          no warnings qw<redefine once>;
          *Dancer2::Core::App::set_request = sub {
              my $self = shift;
              $self->_set_request( $request );
              $_->set_request( $request ) for @{ $self->defined_engines };
          };
      }
  
      # since the response is a PSGI response
      # we create a Response object which was originally expected
      my $psgi_response = $_dispatcher->dispatch($env);
      return Dancer2::Core::Response->new(
          status  => $psgi_response->[0],
          headers => $psgi_response->[1],
          content => $psgi_response->[2][0],
      );
  }
  
  
  
  sub _build_request_from_env {
  
      # arguments can be passed as the triplet
      # or as a arrayref, or as a simple string
      my ( $method, $path, $options ) =
          @_ > 1 ? @_
        : ref $_[0] eq 'ARRAY' ? @{ $_[0] }
        :                        ( GET => $_[0], {} );
  
      my $env = {
          %ENV,
          REQUEST_METHOD    => uc($method),
          PATH_INFO         => $path,
          QUERY_STRING      => '',
          'psgi.url_scheme' => 'http',
          SERVER_PROTOCOL   => 'HTTP/1.0',
          SERVER_NAME       => 'localhost',
          SERVER_PORT       => 3000,
          HTTP_HOST         => 'localhost',
          HTTP_USER_AGENT   => "Dancer2::Test simulator v " . Dancer2->VERSION,
      };
  
      if ( defined $options->{params} ) {
          my @params;
          while ( my ( $p, $value ) = each %{ $options->{params} } ) {
              if ( ref($value) eq 'ARRAY' ) {
                  for my $v (@$value) {
                      push @params,
                        uri_escape_utf8($p) . '=' . uri_escape_utf8($v);
                  }
              }
              else {
                  push @params,
                    uri_escape_utf8($p) . '=' . uri_escape_utf8($value);
              }
          }
          $env->{QUERY_STRING} = join( '&', @params );
      }
  
      my $request = Dancer2::Core::Request->new( env => $env );
  
      # body
      $request->body( $options->{body} ) if exists $options->{body};
  
      # headers
      if ( $options->{headers} ) {
          for my $header ( @{ $options->{headers} } ) {
              my ( $name, $value ) = @{$header};
              $request->header( $name => $value );
          }
      }
  
      # files
      if ( $options->{files} ) {
          for my $file ( @{ $options->{files} } ) {
              my $headers = $file->{headers};
              $headers->{'Content-Type'} ||= 'text/plain';
  
              my $temp = File::Temp->new();
              if ( $file->{data} ) {
                  print $temp $file->{data};
                  close($temp);
              }
              else {
                  require File::Copy;
                  File::Copy::copy( $file->{filename}, $temp );
              }
  
              my $upload = Dancer2::Core::Request::Upload->new(
                  filename => $file->{filename},
                  size     => -s $temp->filename,
                  tempname => $temp->filename,
                  headers  => $headers,
              );
  
              ## keep temp_fh in scope so it doesn't get deleted too early
              ## But will get deleted by the time the test is finished.
              $upload->{temp_fh} = $temp;
  
              $request->uploads->{ $file->{name} } = $upload;
          }
      }
  
      # content-type
      if ( $options->{content_type} ) {
          $request->content_type( $options->{content_type} );
      }
  
      return ( $request, $env );
  }
  
  sub _build_env_from_request {
      my ($request) = @_;
  
      my $env = {
          REQUEST_METHOD    => $request->method,
          PATH_INFO         => $request->path,
          QUERY_STRING      => '',
          'psgi.url_scheme' => 'http',
          SERVER_PROTOCOL   => 'HTTP/1.0',
          SERVER_NAME       => 'localhost',
          SERVER_PORT       => 3000,
          HTTP_HOST         => 'localhost',
          HTTP_USER_AGENT   => "Dancer2::Test simulator v" . Dancer2->VERSION,
      };
  
      # TODO
      if ( my $params = $request->{_query_params} ) {
          my @params;
          while ( my ( $p, $value ) = each %{$params} ) {
              if ( ref($value) eq 'ARRAY' ) {
                  for my $v (@$value) {
                      push @params,
                        uri_escape_utf8($p) . '=' . uri_escape_utf8($v);
                  }
              }
              else {
                  push @params,
                    uri_escape_utf8($p) . '=' . uri_escape_utf8($value);
              }
          }
          $env->{QUERY_STRING} = join( '&', @params );
      }
  
      # TODO files
  
      return ( $request, $env );
  }
  
  sub response_status_is {
      my ( $req, $status, $test_name ) = @_;
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
  
      $test_name ||= "response status is $status for " . _req_label($req);
  
      my $response = dancer_response($req);
  
      my $tb = Test::Builder->new;
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      $tb->is_eq( $response->[0], $status, $test_name );
  }
  
  sub _find_route_match {
      my ( $request, $env ) =
        ref $_[0] eq 'Dancer2::Core::Request'
        ? _build_env_from_request(@_)
        : _build_request_from_env(@_);
  
      for my $app (@{$_dispatcher->apps}) {
          for my $route (@{$app->routes->{lc($request->method)}}) {
              if ( $route->match($request) ) {
                  return 1;
              }
          }
      }
      return 0;
  }
  
  sub route_exists {
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
  
      my $tb = Test::Builder->new;
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      $tb->ok( _find_route_match($_[0]), $_[1]);
  }
  
  sub route_doesnt_exist {
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
  
      my $tb = Test::Builder->new;
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      $tb->ok( !_find_route_match($_[0]), $_[1]);
  }
  
  sub response_status_isnt {
      my ( $req, $status, $test_name ) = @_;
  
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
  
      $test_name ||= "response status is not $status for " . _req_label($req);
  
      my $response = dancer_response($req);
  
      my $tb = Test::Builder->new;
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      $tb->isnt_eq( $response->[0], $status, $test_name );
  }
  
  {
      # Map comparison operator names to human-friendly ones
      my %cmp_name = (
          is_eq   => "is",
          isnt_eq => "is not",
          like    => "matches",
          unlike  => "doesn't match",
      );
  
      sub _cmp_response_content {
          my ( $req, $want, $test_name, $cmp ) = @_;
  
          if ( @_ == 3 ) {
              $cmp       = $test_name;
              $test_name = $cmp_name{$cmp};
              $test_name =
                "response content $test_name $want for " . _req_label($req);
          }
  
          my $response = dancer_response($req);
  
          my $tb = Test::Builder->new;
          local $Test::Builder::Level = $Test::Builder::Level + 1;
          $tb->$cmp( $response->[2][0], $want, $test_name );
      }
  }
  
  sub response_content_is {
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      _cmp_response_content( @_, 'is_eq' );
  }
  
  sub response_content_isnt {
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      _cmp_response_content( @_, 'isnt_eq' );
  }
  
  sub response_content_like {
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      _cmp_response_content( @_, 'like' );
  }
  
  sub response_content_unlike {
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      _cmp_response_content( @_, 'unlike' );
  }
  
  sub response_content_is_deeply {
      my ( $req, $matcher, $test_name ) = @_;
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
      $test_name ||= "response content looks good for " . _req_label($req);
  
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      my $response = _req_to_response($req);
      is_deeply $response->[2][0], $matcher, $test_name;
  }
  
  sub response_is_file {
      my ( $req, $test_name ) = @_;
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
      $test_name ||= "a file is returned for " . _req_label($req);
  
      my $response = _get_file_response($req);
      my $tb       = Test::Builder->new;
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      return $tb->ok( defined($response), $test_name );
  }
  
  sub response_headers_are_deeply {
      my ( $req, $expected, $test_name ) = @_;
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
      $test_name ||= "headers are as expected for " . _req_label($req);
  
      local $Test::Builder::Level = $Test::Builder::Level + 1;
      my $response = dancer_response( _expand_req($req) );
  
      is_deeply(
          _sort_headers( $response->[1] ),
          _sort_headers($expected), $test_name
      );
  }
  
  sub response_headers_include {
      my ( $req, $expected, $test_name ) = @_;
      carp 'Dancer2::Test is deprecated, please use Plack::Test instead'
          unless $NO_WARN;
      $test_name ||= "headers include expected data for " . _req_label($req);
      my $tb = Test::Builder->new;
  
      my $response = dancer_response($req);
      local $Test::Builder::Level = $Test::Builder::Level + 1;
  
      print STDERR "Headers are: "
        . Dumper( $response->[1] )
        . "\n Expected to find header: "
        . Dumper($expected)
        if !$tb->ok(
          _include_in_headers( $response->[1], $expected ),
          $test_name
        );
  }
  
  sub route_pod_coverage {
  
      require Pod::Simple::Search;
      require Pod::Simple::SimpleTree;
  
      my $all_routes = {};
  
      foreach my $app ( @{ $_dispatcher->apps } ) {
          my $routes           = $app->routes;
          my $available_routes = [];
          foreach my $method ( sort { $b cmp $a } keys %$routes ) {
              foreach my $r ( @{ $routes->{$method} } ) {
  
                  # we don't need pod coverage for head
                  next if $method eq 'head';
                  push @$available_routes, $method . ' ' . $r->spec_route;
              }
          }
          ## copy dereferenced array
          $all_routes->{ $app->name }{routes} = [@$available_routes]
            if @$available_routes;
  
          # Pod::Simple v3.30 excluded the current directory even when in @INC.
          # include the current directory as a search path; its backwards compatible
          # with previous version.
          my $undocumented_routes = [];
          my $file                = Pod::Simple::Search->new->find( $app->name, '.' );
          if ($file) {
              $all_routes->{ $app->name }{has_pod} = 1;
              my $parser       = Pod::Simple::SimpleTree->new->parse_file($file);
              my $pod_dataref  = $parser->root;
              my $found_routes = {};
              for ( my $i = 0; $i < @$available_routes; $i++ ) {
  
                  my $r          = $available_routes->[$i];
                  my $app_string = lc $r;
                  $app_string =~ s/\*/_REPLACED_STAR_/g;
  
                  for ( my $idx = 0; $idx < @$pod_dataref; $idx++ ) {
                      my $pod_part = $pod_dataref->[$idx];
  
                      next if ref $pod_part ne 'ARRAY';
                      foreach my $ref_part (@$pod_part) {
                          if ( ref($ref_part) eq "ARRAY" ) {
                              push @$pod_dataref, $ref_part;
                          }
                      }
  
                      my $pod_string = lc $pod_part->[2];
                      $pod_string =~ s/['|"|\s]+/ /g;
                      $pod_string =~ s/\s$//g;
                      $pod_string =~ s/\*/_REPLACED_STAR_/g;
                      if ( $pod_string =~ m/^$app_string$/ ) {
                          $found_routes->{$app_string} = 1;
                          next;
                      }
                  }
                  if ( !$found_routes->{$app_string} ) {
                      push @$undocumented_routes, $r;
                  }
              }
          }
          else {    ### no POD found
              $all_routes->{ $app->name }{has_pod} = 0;
          }
          if (@$undocumented_routes) {
              $all_routes->{ $app->name }{undocumented_routes} =
                $undocumented_routes;
          }
          elsif ( !$all_routes->{ $app->name }{has_pod}
              && @{ $all_routes->{ $app->name }{routes} } )
          {
              ## copy dereferenced array
              $all_routes->{ $app->name }{undocumented_routes} =
                [ @{ $all_routes->{ $app->name }{routes} } ];
          }
      }
  
      return $all_routes;
  }
  
  sub is_pod_covered {
      my ($test_name) = @_;
  
      $test_name ||= "is pod covered";
      my $route_pod_coverage = route_pod_coverage();
  
      my $tb = Test::Builder->new;
      local $Test::Builder::Level = $Test::Builder::Level + 1;
  
      foreach my $app ( @{ $_dispatcher->apps } ) {
          my %undocumented_route =
            ( map { $_ => 1 }
                @{ $route_pod_coverage->{ $app->name }{undocumented_routes} } );
          $tb->subtest(
              $app->name . $test_name,
              sub {
                  foreach my $route (
                      @{ $route_pod_coverage->{ $app->name }{routes} } )
                  {
                      ok( !$undocumented_route{$route}, "$route is documented" );
                  }
              }
          );
      }
  }
  
  sub import {
      my ( $class, %options ) = @_;
  
      my @applications;
      if ( ref $options{apps} eq ref( [] ) ) {
          @applications = @{ $options{apps} };
      }
      else {
          my ( $caller, $script ) = caller;
  
          # if no app is passed, assume the caller is one.
          @applications = ($caller) if $caller->can('dancer_app');
      }
  
      # register the apps to the test dispatcher
      $_dispatcher->apps( [ map {
          $_->dancer_app->finish();
          $_->dancer_app;
      } @applications ] );
  
      $class->export_to_level( 1, $class, @EXPORT );
  }
  
  # private
  
  sub _req_label {
      my $req = shift;
  
      return
          ref $req eq 'Dancer2::Core::Response' ? 'response object'
        : ref $req eq 'Dancer2::Core::Request'
        ? join( ' ', map { $req->$_ } qw/ method path / )
        : ref $req eq 'ARRAY' ? join( ' ', @$req )
        :                       "GET $req";
  }
  
  sub _expand_req {
      my $req = shift;
      return ref $req eq 'ARRAY' ? @$req : ( 'GET', $req );
  }
  
  # Sort arrayref of headers (turn it into a list of arrayrefs, sort by the header
  # & value, then turn it back into an arrayref)
  sub _sort_headers {
      my @originalheaders = @{ shift() };    # take a copy we can modify
      my @headerpairs;
      while ( my ( $header, $value ) = splice @originalheaders, 0, 2 ) {
          push @headerpairs, [ $header, $value ];
      }
  
      # We have an array of arrayrefs holding header => value pairs; sort them by
      # header then value, and return them flattened back into an arrayref
      return [
          map {@$_}
          sort { $a->[0] cmp $b->[0] || $a->[1] cmp $b->[1] } @headerpairs
      ];
  }
  
  # make sure the given header sublist is included in the full headers array
  sub _include_in_headers {
      my ( $full_headers, $expected_subset ) = @_;
  
      # walk through all the expected header pairs, make sure
      # they exist with the same value in the full_headers list
      # return false as soon as one is not.
      for ( my $i = 0; $i < scalar(@$expected_subset); $i += 2 ) {
          my ( $name, $value ) =
            ( $expected_subset->[$i], $expected_subset->[ $i + 1 ] );
          return 0
            unless _check_header( $full_headers, $name, $value );
      }
  
      # we've found all the expected pairs in the $full_headers list
      return 1;
  }
  
  sub _check_header {
      my ( $headers, $key, $value ) = @_;
      for ( my $i = 0; $i < scalar(@$headers); $i += 2 ) {
          my ( $name, $val ) = ( $headers->[$i], $headers->[ $i + 1 ] );
          return 1 if $name eq $key && $value eq $val;
      }
      return 0;
  }
  
  sub _req_to_response {
      my $req = shift;
  
      # already a response object
      return $req if ref $req eq 'Dancer2::Core::Response';
  
      return dancer_response( ref $req eq 'ARRAY' ? @$req : ( 'GET', $req ) );
  }
  
  # make sure we have at least one app in the dispatcher, and if not,
  # we must have at this point an app within the caller
  sub _find_dancer_apps_for_dispatcher {
      return if scalar( @{ $_dispatcher->apps } );
  
      for ( my $deep = 0; $deep < 5; $deep++ ) {
          my $caller = caller($deep);
          next if !$caller || !$caller->can('dancer_app');
  
          return $_dispatcher->apps( [ $caller->dancer_app ] );
      }
  
      croak "Unable to find a Dancer2 app, did you use Dancer2 in your test?";
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Dancer2::Test - Useful routines for testing Dancer2 apps
  
  =head1 VERSION
  
  version 0.162000
  
  =head1 SYNOPSIS
  
      use Test::More;
      use Plack::Test;
      use HTTP::Request::Common; # install separately
  
      use YourDancerApp;
  
      my $app  = YourDancerApp->to_app;
      my $test = Plack::Test->create($app);
  
      my $res = $test->request( GET '/' );
      is( $res->code, 200, '[GET /] Request successful' );
      like( $res->content, qr/hello, world/, '[GET /] Correct content';
  
      done_testing;
  
  =head1 DESCRIPTION
  
  B<DEPRECATED>.  Please use L<Plack::Test> instead as shown in the SYNOPSIS!
  
  This module will warn for a while until we actually remove it. This is to
  provide enough time to fully remove it from your system.
  
  If you need to remove the warnings, for now, you can set:
  
      $Dancer::Test::NO_WARN = 1;
  
  This module provides useful routines to test Dancer2 apps. They are, however,
  buggy and unnecessary. L<Plack::Test> is advised instead.
  
  $test_name is always optional.
  
  =head1 FUNCTIONS
  
  =head2 dancer_response ($method, $path, $params, $arg_env);
  
  Returns a Dancer2::Core::Response object for the given request.
  
  Only $method and $path are required.
  
  $params is a hashref with 'body' as a string; 'headers' can be an arrayref or
  a HTTP::Headers object, 'files' can be arrayref of hashref, containing some
  files to upload:
  
      dancer_response($method, $path,
          {
              params => $params,
              body => $body,
              headers => $headers,
              files => [ { filename => '/path/to/file', name => 'my_file' } ],
          }
      );
  
  A good reason to use this function is for testing POST requests. Since POST
  requests may not be idempotent, it is necessary to capture the content and
  status in one shot. Calling the response_status_is and response_content_is
  functions in succession would make two requests, each of which could alter the
  state of the application and cause Schrodinger's cat to die.
  
      my $response = dancer_response POST => '/widgets';
      is $response->status, 202, "response for POST /widgets is 202";
      is $response->content, "Widget #1 has been scheduled for creation",
          "response content looks good for first POST /widgets";
  
      $response = dancer_response POST => '/widgets';
      is $response->status, 202, "response for POST /widgets is 202";
      is $response->content, "Widget #2 has been scheduled for creation",
          "response content looks good for second POST /widgets";
  
  It's possible to test file uploads:
  
      post '/upload' => sub { return upload('image')->content };
  
      $response = dancer_response(POST => '/upload', {files => [{name => 'image', filename => '/path/to/image.jpg'}]});
  
  In addition, you can supply the file contents as the C<data> key:
  
      my $data  = 'A test string that will pretend to be file contents.';
      $response = dancer_response(POST => '/upload', {
          files => [{name => 'test', filename => "filename.ext", data => $data}]
      });
  
  You can also supply a hashref of headers:
  
      headers => { 'Content-Type' => 'text/plain' }
  
  =head2 response_status_is ($request, $expected, $test_name);
  
  Asserts that Dancer2's response for the given request has a status equal to the
  one given.
  
      response_status_is [GET => '/'], 200, "response for GET / is 200";
  
  =head2 route_exists([$method, $path], $test_name)
  
  Asserts that the given request matches a route handler in Dancer2's
  registry. If the route would have returned a 404, the route still exists
  and this test will pass.
  
  Note that because Dancer2 uses the default route handler
  L<Dancer2::Handler::File> to match files in the public folder when
  no other route matches, this test will always pass.
  You can disable the default route handlers in the configs but you probably
  want L<Dancer2::Test/response_status_is> or L<Dancer2::Test/dancer_response>
  
      route_exists [GET => '/'], "GET / is handled";
  
  =head2 route_doesnt_exist([$method, $path], $test_name)
  
  Asserts that the given request does not match any route handler
  in Dancer2's registry.
  
  Note that this test is likely to always fail as any route not matched will
  be handled by the default route handler in L<Dancer2::Handler::File>.
  This can be disabled in the configs.
  
      route_doesnt_exist [GET => '/bogus_path'], "GET /bogus_path is not handled";
  
  =head2 response_status_isnt([$method, $path], $status, $test_name)
  
  Asserts that the status of Dancer2's response is not equal to the
  one given.
  
      response_status_isnt [GET => '/'], 404, "response for GET / is not a 404";
  
  =head2 response_content_is([$method, $path], $expected, $test_name)
  
  Asserts that the response content is equal to the C<$expected> string.
  
   response_content_is [GET => '/'], "Hello, World",
          "got expected response content for GET /";
  
  =head2 response_content_isnt([$method, $path], $not_expected, $test_name)
  
  Asserts that the response content is not equal to the C<$not_expected> string.
  
      response_content_isnt [GET => '/'], "Hello, World",
          "got expected response content for GET /";
  
  =head2 response_content_like([$method, $path], $regexp, $test_name)
  
  Asserts that the response content for the given request matches the regexp
  given.
  
      response_content_like [GET => '/'], qr/Hello, World/,
          "response content looks good for GET /";
  
  =head2 response_content_unlike([$method, $path], $regexp, $test_name)
  
  Asserts that the response content for the given request does not match the regexp
  given.
  
      response_content_unlike [GET => '/'], qr/Page not found/,
          "response content looks good for GET /";
  
  =head2 response_content_is_deeply([$method, $path], $expected_struct, $test_name)
  
  Similar to response_content_is(), except that if response content and
  $expected_struct are references, it does a deep comparison walking each data
  structure to see if they are equivalent.
  
  If the two structures are different, it will display the place where they start
  differing.
  
      response_content_is_deeply [GET => '/complex_struct'],
          { foo => 42, bar => 24},
          "got expected response structure for GET /complex_struct";
  
  =head2 response_is_file ($request, $test_name);
  
  =head2 response_headers_are_deeply([$method, $path], $expected, $test_name)
  
  Asserts that the response headers data structure equals the one given.
  
      response_headers_are_deeply [GET => '/'], [ 'X-Powered-By' => 'Dancer2 1.150' ];
  
  =head2 response_headers_include([$method, $path], $expected, $test_name)
  
  Asserts that the response headers data structure includes some of the defined ones.
  
      response_headers_include [GET => '/'], [ 'Content-Type' => 'text/plain' ];
  
  =head2 route_pod_coverage()
  
  Returns a structure describing pod coverage in your apps
  
  for one app like this:
  
      package t::lib::TestPod;
      use Dancer2;
  
      =head1 NAME
  
      TestPod
  
      =head2 ROUTES
  
      =over
  
      =cut
  
      =item get "/in_testpod"
  
      testpod
  
      =cut
  
      get '/in_testpod' => sub {
          return 'get in_testpod';
      };
  
      get '/hello' => sub {
          return "hello world";
      };
  
      =item post '/in_testpod/*'
  
      post in_testpod
  
      =cut
  
      post '/in_testpod/*' => sub {
          return 'post in_testpod';
      };
  
      =back
  
      =head2 SPECIALS
  
      =head3 PUBLIC
  
      =over
  
      =item get "/me:id"
  
      =cut
  
      get "/me:id" => sub {
          return "ME";
      };
  
      =back
  
      =head3 PRIVAT
  
      =over
  
      =item post "/me:id"
  
      post /me:id
  
      =cut
  
      post "/me:id" => sub {
          return "ME";
      };
  
      =back
  
      =cut
  
      1;
  
  route_pod_coverage;
  
  would return something like:
  
      {
          't::lib::TestPod' => {
              'has_pod'             => 1,
              'routes'              => [
                  "post /in_testpod/*",
                  "post /me:id",
                  "get /in_testpod",
                  "get /hello",
                  "get /me:id"
              ],
              'undocumented_routes' => [
                  "get /hello"
              ]
          }
      }
  
  =head2 is_pod_covered('is pod covered')
  
  Asserts that your apps have pods for all routes
  
      is_pod_covered 'is pod covered'
  
  to avoid test failures, you should document all your routes with one of the following:
  head1, head2,head3,head4, item.
  
      ex:
  
      =item get '/login'
  
      route to login
  
      =cut
  
      if you use:
  
      any '/myaction' => sub {
          # code
      }
  
      or
  
      any ['get', 'post'] => '/myaction' => sub {
          # code
      };
  
      you need to create pods for each one of the routes created there.
  
  =head2 import
  
  When Dancer2::Test is imported, it should be passed all the
  applications that are supposed to be tested.
  
  If none passed, then the caller is supposed to be the sole application
  to test.
  
      # t/sometest.t
  
      use t::lib::Foo;
      use t::lib::Bar;
  
      use Dancer2::Test apps => ['t::lib::Foo', 't::lib::Bar'];
  
  =head1 AUTHOR
  
  Dancer Core Developers
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2015 by Alexis Sukrieh.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DANCER2_TEST

$fatpacked{"Devel/OverloadInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_OVERLOADINFO';
  package Devel::OverloadInfo;
  $Devel::OverloadInfo::VERSION = '0.004';
  # ABSTRACT: introspect overloaded operators
  
  #pod =head1 DESCRIPTION
  #pod
  #pod Devel::OverloadInfo returns information about L<overloaded|overload>
  #pod operators for a given class (or object), including where in the
  #pod inheritance hierarchy the overloads are declared and where the code
  #pod implementing it is.
  #pod
  #pod =cut
  
  use strict;
  use warnings;
  use overload ();
  use Scalar::Util qw(blessed);
  use Sub::Identify qw(sub_fullname);
  use Package::Stash 0.14;
  use MRO::Compat;
  
  use Exporter 5.57 qw(import);
  our @EXPORT_OK = qw(overload_info is_overloaded);
  
  sub stash_with_symbol {
      my ($class, $symbol) = @_;
  
      for my $package (@{mro::get_linear_isa($class)}) {
          my $stash = Package::Stash->new($package);
          my $value_ref = $stash->get_symbol($symbol);
          return ($stash, $value_ref) if $value_ref;
      }
      return;
  }
  
  #pod =func is_overloaded
  #pod
  #pod    if (is_overloaded($class_or_object)) { ... }
  #pod
  #pod Returns a boolean indicating whether the given class or object has any
  #pod overloading declared.  Note that a bare C<use overload;> with no
  #pod actual operators counts as being overloaded.
  #pod
  #pod Equivalent to
  #pod L<overload::Overloaded()|overload/overload::Overloaded(arg)>, but
  #pod doesn't trigger various bugs associated with it in versions of perl
  #pod before 5.16.
  #pod
  #pod =cut
  
  sub is_overloaded {
      my $class = blessed($_[0]) || $_[0];
  
      # Perl before 5.16 seems to corrupt inherited overload info if
      # there's a lone dereference overload and overload::Overloaded()
      # is called before any object has been blessed into the class.
      return !!("$]" >= 5.016
          ? overload::Overloaded($class)
          : stash_with_symbol($class, '&()')
      );
  }
  
  #pod =func overload_info
  #pod
  #pod     my $info = overload_info($class_or_object);
  #pod
  #pod Returns a hash reference with information about all the overloaded
  #pod operators of the argument, which can be either a class name or a blessed
  #pod object. The keys are the overloaded operators, as specified in
  #pod C<%overload::ops> (see L<overload/Overloadable Operations>).
  #pod
  #pod =over
  #pod
  #pod =item class
  #pod
  #pod The name of the class in which the operator overloading was declared.
  #pod
  #pod =item code
  #pod
  #pod A reference to the function implementing the overloaded operator.
  #pod
  #pod =item code_name
  #pod
  #pod The name of the function implementing the overloaded operator, as
  #pod returned by C<sub_fullname> in L<Sub::Identify>.
  #pod
  #pod =item method_name (optional)
  #pod
  #pod The name of the method implementing the overloaded operator, if the
  #pod overloading was specified as a named method, e.g. C<< use overload $op
  #pod => 'method'; >>.
  #pod
  #pod =item code_class (optional)
  #pod
  #pod The name of the class in which the method specified by C<method_name>
  #pod was found.
  #pod
  #pod =item value (optional)
  #pod
  #pod For the special C<fallback> key, the value it was given in C<class>.
  #pod
  #pod =back
  #pod
  #pod =cut
  
  sub overload_info {
      my $class = blessed($_[0]) || $_[0];
  
      return {} unless is_overloaded($class);
  
      my (%overloaded);
      for my $op (map split(/\s+/), values %overload::ops) {
          my $op_method = $op eq 'fallback' ? "()" : "($op";
          my ($stash, $func) = stash_with_symbol($class, "&$op_method")
              or next;
          my $info = $overloaded{$op} = {
              class => $stash->name,
          };
          if ($func == \&overload::nil) {
              # Named method or fallback, stored in the scalar slot
              if (my $value_ref = $stash->get_symbol("\$$op_method")) {
                  my $value = $$value_ref;
                  if ($op eq 'fallback') {
                      $info->{value} = $value;
                  } else {
                      $info->{method_name} = $value;
                      if (my ($impl_stash, $impl_func) = stash_with_symbol($class, "&$value")) {
                          $info->{code_class} = $impl_stash->name;
                          $info->{code} = $impl_func;
                      }
                  }
              }
          } else {
              $info->{code} = $func;
          }
          $info->{code_name} = sub_fullname($info->{code})
              if exists $info->{code};
      }
      return \%overloaded;
  }
  
  #pod =head1 CAVEATS
  #pod
  #pod Whether the C<fallback> key exists when it has its default value of
  #pod C<undef> varies between perl versions: Before 5.18 it's there, in
  #pod later versions it's not.
  #pod
  #pod =cut
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Devel::OverloadInfo - introspect overloaded operators
  
  =head1 VERSION
  
  version 0.004
  
  =head1 DESCRIPTION
  
  Devel::OverloadInfo returns information about L<overloaded|overload>
  operators for a given class (or object), including where in the
  inheritance hierarchy the overloads are declared and where the code
  implementing it is.
  
  =head1 FUNCTIONS
  
  =head2 is_overloaded
  
     if (is_overloaded($class_or_object)) { ... }
  
  Returns a boolean indicating whether the given class or object has any
  overloading declared.  Note that a bare C<use overload;> with no
  actual operators counts as being overloaded.
  
  Equivalent to
  L<overload::Overloaded()|overload/overload::Overloaded(arg)>, but
  doesn't trigger various bugs associated with it in versions of perl
  before 5.16.
  
  =head2 overload_info
  
      my $info = overload_info($class_or_object);
  
  Returns a hash reference with information about all the overloaded
  operators of the argument, which can be either a class name or a blessed
  object. The keys are the overloaded operators, as specified in
  C<%overload::ops> (see L<overload/Overloadable Operations>).
  
  =over
  
  =item class
  
  The name of the class in which the operator overloading was declared.
  
  =item code
  
  A reference to the function implementing the overloaded operator.
  
  =item code_name
  
  The name of the function implementing the overloaded operator, as
  returned by C<sub_fullname> in L<Sub::Identify>.
  
  =item method_name (optional)
  
  The name of the method implementing the overloaded operator, if the
  overloading was specified as a named method, e.g. C<< use overload $op
  => 'method'; >>.
  
  =item code_class (optional)
  
  The name of the class in which the method specified by C<method_name>
  was found.
  
  =item value (optional)
  
  For the special C<fallback> key, the value it was given in C<class>.
  
  =back
  
  =head1 CAVEATS
  
  Whether the C<fallback> key exists when it has its default value of
  C<undef> varies between perl versions: Before 5.18 it's there, in
  later versions it's not.
  
  =head1 AUTHOR
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Dagfinn Ilmari Mannsåker.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DEVEL_OVERLOADINFO

$fatpacked{"Domo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DOMO';
  package Domo;
  # This program is free software; you can redistribute it and/or
  # modify it under the terms of the GNU General Public License
  # version 2 as published by the Free Software Foundation.
  # Author: epierre <epierre@e-nef.com>
  
  use Dancer ':syntax';
  use File::Slurp;
  use File::Spec;
  use LWP::UserAgent;
  use Crypt::SSLeay;
  use utf8;
  use Encode qw/ encode decode /;
  use Time::Piece;
  use DateTime;
  use feature     qw< unicode_strings >;
  use POSIX qw(ceil);
  #use JSON;
  use warnings;
  use strict;
  use Audio::MPD;
  
  
  our $VERSION = '0.12';
  set warnings => 0;
  my %device_tab;
  my %device_list;
  my $last_version;    #last version in github
  my $last_version_dt; # last version text in github
  
  
  hook(
     after_serializer => sub {
         my $response = shift;
         $response->{encoded} = 1;
     }
  );
  
  set serializer => 'JSON'; 
  set 'database'     => File::Spec->catfile( config->{domo_db});
  prefix undef;
  
  my $mpd_host=config->{volumio_path};
  my $mpd;
  
  get '/' => sub {
      template 'index';
  };
  
  get '/rooms' => sub {
         #Room list
    return {"rooms" => [ 
  		{ "id"=> "Switches", "name"=> "Switches" },
  		{ "id"=> "Scenes", "name"=> "Scenes" },
  		{ "id"=> "Temp", "name"=> "Weather" },
  		{ "id"=> "Utility", "name"=> "Utility" },
  #		{ "id"=> "Volumio", "name"=> "Volumio" },
  			]};
  };
  
  get '/system' => sub {
   return {"id"=> "MyDomoAtHome","apiversion"=> 1};
  };
  
  get '/devices/:deviceId/:paramKey/histo/:startdate/:enddate' => sub {
  	my $deviceId = params->{deviceId};
  	my $paramKey = params->{paramKey}||"";
  	my $startdate = params->{startdate}||"";
  	my $enddate = params->{enddate}||"";
  
  	my $type=lc(&getDeviceType($deviceId));
  	my $ptype=$type;
  debug("TYPE:$type\n");
  	if (($type eq "lux")||($type eq "energy")) {$type="counter";}
  	if ($type eq "air quality") {$type="counter";}
  	if (($ptype eq "general")) {$type="Percentage";}
  	if (($paramKey eq "hygro")) {$type="temp";}
  	if (($paramKey eq "temp")) {$type="temp";}
  
  	my $feed={ "values" => []};
  	my $url=config->{domo_path}."/json.htm?type=graph&sensor=$type&idx=$deviceId&range=day";
  	my $decoded;
  	my @results=();
  debug($url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			my $f={};
  			foreach $f ( @results ) {
  					my $dt = Time::Piece->strptime($f->{"d"},"%Y-%m-%d %H:%M:%SS");
  					#print $dt->epoch." \n";
  					if ((($paramKey eq "temp")&&($f->{"te"}))||($type eq "temp")) {
  							my $value=$f->{"te"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ((($paramKey eq "hygro")&&($f->{"hu"}))||($type eq "Humidity")) {
  							my $value=$f->{"hu"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif (($ptype eq "air quality")) {
  							my $value=$f->{"co2"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif (($type eq "counter")||($type eq "Percentage")) {
  							my $value=$f->{"v"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"mm"}) {
  						my $value=$f->{"mm"};
  						my $date=$dt->epoch*1000;
  						my $feeds={"date" => "$date", "value" => "$value"};
  						push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"uvi"}) {
  						my $value=$f->{"uvi"};
  						my $date=$dt->epoch*1000;
  						my $feeds={"date" => "$date", "value" => "$value"};
  						push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"v"}) {
  						my $value=$f->{"v"};
  						my $date=$dt->epoch*1000;
  						my $feeds={"date" => "$date", "value" => "$value"};
  						push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"sp"}) {
  						my $value=$f->{"sp"};
  						my $date=$dt->epoch*1000;
  						my $feeds={"date" => "$date", "value" => "$value"};
  						push (@{$feed->{'values'}}, $feeds );
  					}
  					#di direction
  					#gu gust
  					#v counter percentage
  					#
  				}
  			return to_json($feed, { utf8 => 1} );
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false};
  		}
  	} else {
  		status 'error';
  		return { success => false};
  	}
  };
  
  get '/devices/:deviceId/action/:actionName/?:actionParam?' => sub {
  my $deviceId = params->{deviceId};
  my $actionName = params->{actionName};
  my $actionParam = params->{actionParam}||"";
  
  if ($actionName eq 'setStatus') {
  debug("actionParam=".$actionParam."\n");
          #setStatus	0/1
  	my $action;
  	if ($actionParam) {
  		$action="On";
  	} else {
  		$action="Off";
  	}
  	my $url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=$action&level=0&passcode=";
  debug($url);
  	my $browser = LWP::UserAgent->new;
  	my $response = $browser->get($url);
  	if ($response->is_success){ 
  		return { success => true};
  	} else {
  		status 'error';
  		return { success => false, errormsg => $response->status_line};
  	}
  } elsif ($actionName eq 'setArmed') {
  	#setArmed	0/1
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
  } elsif ($actionName eq 'setAck') {
  	#setAck	
  		my $url=config->{domo_path}."/json.htm?type=command&param=resetsecuritystatus&idx=$deviceId&switchcmd=Normal";
  	debug($url);
  		my $browser = LWP::UserAgent->new;
  		my $response = $browser->get($url);
  		if ($response->is_success){ 
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false, errormsg => $response->status_line};
  		}
  } elsif ($actionName eq 'setLevel') {
  	#/json.htm?type=command&param=switchlight&idx=&switchcmd=Set%20Level&level=6
  	my $url;
  	if (($device_tab{$deviceId}->{"Action"}==2)or($device_tab{$deviceId}->{"Action"}==3)) {
  		if ($actionParam eq "100") {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=$actionParam&passcode=";
  		} else {
  			my $setLevel=ceil($actionParam*$device_tab{$deviceId}->{"MaxDimLevel"}/100);
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$setLevel&passcode=";
  		}
  	} elsif (($device_tab{$deviceId}->{"Action"}==5)) {
  		#Blinds inverted
  		if ($actionParam eq "100") {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=0&passcode=";
  		} else {
  			my $setLevel=ceil($actionParam*$device_tab{$deviceId}->{"MaxDimLevel"}/100);
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$setLevel&passcode=";
  		}
  	} elsif (($device_tab{$deviceId}->{"Action"}==6)) {
  		#Blinds -> On for Closed, Off for Open 
  		if ($actionParam eq "100") {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=0&passcode=";
  		} else {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=0&passcode=";
  		}
  	} else {
  		if ($actionParam eq "1") {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$actionParam&passcode=";
  		} elsif ($actionParam eq "0") {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=$actionParam&passcode=";
  
  		} else {
  			my $setLevel=ceil($actionParam*$device_tab{$deviceId}->{"MaxDimLevel"}/100);
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Set%20Level&level=$setLevel&passcode=";
  		}
  	}
  
  	debug($url);
  		my $browser = LWP::UserAgent->new;
  		my $response = $browser->get($url);
  		if ($response->is_success){ 
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false, errormsg => $response->status_line};
  		}
  	} elsif ($actionName eq 'stopShutter') {
  		#stopShutter (Venetian store)
  		my $url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Stop&level=0&passcode=";
  debug($url);
  		my $browser = LWP::UserAgent->new;
  		my $response = $browser->get($url);
  		if ($response->is_success){ 
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false, errormsg => $response->status_line};
  		}
  		return { success => true};
  	} elsif ($actionName eq 'pulseShutter') {
  		#pulseShutter	up/down
  		status 'error';
  		return { success => false, errormsg => "not implemented"};
  	} elsif ($actionName eq 'setSetPoint') {
  		#DevThermostat
  		my $url=config->{domo_path}."/json.htm?type=setused&idx=$deviceId&used=true&setpoint=$actionParam";
  debug($url);
  		my $browser = LWP::UserAgent->new;
  		my $response = $browser->get($url);
  		if ($response->is_success){ 
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false, errormsg => $response->status_line};
  		}
  		return { success => true};
  	} elsif ($actionName eq 'launchScene') {
  		#launchScene
  		#/json.htm?type=command&param=switchscene&idx=&switchcmd=
  		my $url=config->{domo_path}."/json.htm?type=command&param=switchscene&idx=$deviceId&switchcmd=On&passcode=";
  	debug($url);
  		my $browser = LWP::UserAgent->new;
  		my $response = $browser->get($url);
  		if ($response->is_success){ 
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false, errormsg => $response->status_line};
  		}
  		return { success => true};
  	} elsif ($actionName eq 'setColor') {
  			my $url=config->{domo_path}."/json.htm?type=command&param=setcolorbrightnessvalue&idx=$deviceId&passcode=";
  		debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  	} elsif ($actionName eq 'setChoice') {
  		if ($deviceId=~/^S/) {
  			my ($sc)=$deviceId=~/S(\d+)/;
  			my $url=config->{domo_path}."/json.htm?type=command&param=switchscene&idx=$sc&switchcmd=$actionParam&passcode=";
  		debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  		} elsif ($deviceId=~/^V/) {
  			my ($sc)=$deviceId=~/V(\d+)/;
  			if ($actionParam eq "play") {
  				$mpd->play;
  			}elsif ($actionParam eq "pause") {
  				$mpd->pause;
  			}elsif ($actionParam eq "stop") {
  				$mpd->stop;
  			}elsif ($actionParam eq "next") {
  				$mpd->next;
  			}elsif ($actionParam eq "prev") {
  				$mpd->next;
  			}elsif ($actionParam eq "volumeUP") {
  				$mpd->volume("+1");
  			}elsif ($actionParam eq "volumeDOWN") {
  				$mpd->volume("-1");
  			}
  		} else {
  			status 'error';
  			return { success => false, errormsg => "not implemented"};
  		}
  	} elsif ($actionName eq 'setMode') {
  		#setChoice string
  		status 'error';
  		return { success => false, errormsg => "not implemented"};
      } else {
          status 'not_found';
          return "What?";
     }
  };
  
  get '/devices' => sub {
  	my $feed={ "devices" => []};
  	my $t_unit="°C";
  	my $system_url = config->{domo_path}."/json.htm?type=devices&filter=all&used=true&order=Name";
  	my $decoded;
  	my @results;
  	my @unk_dev;         # list of unknown devices
  debug($system_url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $system_url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			#Own device version
  			my $feeds={"id" => "S0", "name" => "MyDomoAtHome", "type" => "DevGenericSensor",  params =>[]};
  			my $ver="$VERSION";
  			push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$ver", "unit"=> "", "graphable" => "false"} );
  			push (@{$feed->{'devices'}}, $feeds );
  			#Check for new version
  			my @and=&getLastVersion();
  			my $an1;my $an2;
  			if (($ver ne $and[0])&&($and[0] ne "err")) {
  				my $feeds={"id" => "S1", "name" => "New version found", "type" => "DevGenericSensor",  params =>[]};
  				$an1=$and[0];
  				push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$an1", "unit"=> "", "graphable" => "false"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			}
  			#
  			#Parse the devices tree
  			#
  			foreach my $f ( @results ) {
  					my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  					my $name=$f->{"Name"};
  					#$name=~s/\s/_/;
  					#$name=~s/\s/_/;
  					#$name=~s/\//_/; 
  					$name=~s/%/P/;
  				 if ($f->{"SwitchType"}) {			
  					#print $f->{"idx"} . " " . $f->{"Name"} . " " . $f->{"Status"} . $f->{"LastUpdate"}."\n";
  					#$name.="_E";
  					my $bl=$f->{"Status"};my $rbl;
  					if ($bl eq "On") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=1;}
  					elsif ($bl eq "Off") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=1;}
  					elsif ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=2;}
  					elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=2;}
  					elsif ($bl eq "Panic") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=3;}
  					elsif ($bl eq "Normal") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=3;}
  					else { $rbl=$bl;}
  
  					if (((($f->{"SwitchType"} eq "On/Off")||($f->{"SwitchType"} eq "Lighting Limitless/Applamp"))and($f->{"SubType"} ne "RGBW"))or($f->{"SwitchType"} eq "Contact")or($f->{"SwitchType"} eq "Dusk Sensor")) {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSwitch", "room" => "Switches", params =>[]};
  						push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SwitchType"} eq "Push On Button")or($f->{"SwitchType"} eq "Push Off Button")) {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSwitch", "room" => "Switches", params =>[]};
  						if ($f->{"SwitchType"} eq "Push Off Button") {$rbl="0"};
  						if ($f->{"SwitchType"} eq "Push On Button") {$rbl="1"};
  						push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  						#push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"1"} );
  						#push (@{$feeds->{'params'}}, {"key" => "Level", "value" =>"$rbl"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SubType"} eq "RGBW")) {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevRGBLight", "room" => "Switches", params =>[]};
  						if ($rbl=~/Set Level/) {$rbl=1;
  							$device_tab{$f->{"idx"}}->{"MaxDimLevel"} = $f->{"MaxDimLevel"};
  							push (@{$feeds->{'params'}}, {"key" => "dimmable", "value" => "1" } );
  							push (@{$feeds->{'params'}}, {"key" => "Level", "value" => $f->{"Level"} } );
  						}
  
  						push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SwitchType"} eq "Dimmer")||($f->{"SwitchType"} eq "Doorbell")) {
  						#DevDimmer	Dimmable light
  						#Status	Current status : 1 = On / 0 = Off	N/A
  						#Level	Current dim level (0-100)	%
  						#"idx" : "3", "Name" : "Alerte",  "Level" : 0,  "SwitchType" : "Dimmer",  "Status" : "Off","LastUpdate" : "2014-03-18 22:17:18"
  						if ($rbl=~/Set Level/) {$rbl=1;}
  						$device_tab{$f->{"idx"}}->{"MaxDimLevel"} = $f->{"MaxDimLevel"};
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDimmer", "room" => "Switches", params =>[]};
  
  						push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => $f->{"Level"} } );
  
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"SwitchType"} eq "Blinds Inverted") {
  						#DevShutter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  						my $v;
  						if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  						my $bl=$f->{"Status"};my $rbl;
  						if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=5;}
  						elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=5;};
  						push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SwitchType"} eq "Unknown")||($f->{"SwitchTypeVal"} eq "16")) {
  						#DevShutter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  						my $v=$f->{"Level"};
  
  						push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"SwitchType"} eq "Blinds Percentage") {
  						#DevShutter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  						my $v;
  						if ($f->{"Status"} eq "Open") {$v=100;} else {$v=$f->{"Level"}};
  						my $bl=$f->{"Status"};my $rbl;
  						if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  						elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  
  						push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SwitchType"} eq "Blinds")&&($f->{"SubType"} ne "RollerTrol, Hasta new")) {
  						#DevShutter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  						my $v;
  						if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  						my $bl=$f->{"Status"};my $rbl;
  						if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  						elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  						push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SwitchType"} eq "Venetian Blinds EU")||($f->{"SwitchType"} eq "Venetian Blinds US")||($f->{"SubType"} eq "RollerTrol, Hasta new")) {
  						#DevShutter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  						my $v;
  						if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  						my $bl=$f->{"Status"};my $rbl;
  						if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  						elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  						push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"1"} );
  						push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"SwitchType"} eq "Motion Sensor") {
  						#DevMotion	Motion security sensor
  						#Status	CM180 status : 1 = On / 0 = Off	N/A
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevMotion", "room" => "Switches", params =>[]};
  						push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  						push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"SwitchType"} eq "Door Lock") {
  						#DevLock	Door / window lock
  						#Status	CM180 status : 1 = On / 0 = Off	N/A
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDoor", "room" => "Switches", params =>[]};
  						push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  						push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  						push (@{$feed->{'devices'}}, $feeds );
  					}elsif ($f->{"SwitchType"} eq "Smoke Detector") {
  						#DevSmoke	Smoke security sensor
  						#Armable	Ability to arm the device : 1 = Yes / 0 = No	N/A
  						#Ackable	Ability to acknowledge alerts : 1 = Yes / 0 = No	N/A
  						#Armed	Current arming status : 1 = On / 0 = Off	N/A
  						#Tripped	Is the sensor tripped ? (0 = No - 1 = Tripped)	N/A				
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSmoke", "room" => "Switches", params =>[]};
  						push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  						if ($f->{"Type"} eq "Security") {
  							push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "1" } );
  						} else {
  							push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  						}
  						push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  						push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  						#"GET http://192.168.0.24:8080/json.htm?type=command&param=resetsecuritystatus&idx=202&switchcmd=Normal"
  						push (@{$feed->{'devices'}}, $feeds );				
  					}
  					#DevDoor	Door / window security sensor
  					#DevFlood	Flood security sensor
  					#DevCO2Alert	CO2 Alert sensor	
  				} else {
  					if ((($f->{"Type"} eq "P1 Smart Meter") and ($f->{"SubType"} eq "Energy")) or (($f->{"Type"} eq "YouLess Meter") and ($f->{"SubType"} eq "YouLess counter")) ) {
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#ConsoTotal     Current total consumption       kWh
  						#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						my $usage;
  						if ($f->{"Usage"}) {
  							($usage)= ($f->{"Usage"} =~ /(\d+) Watt/);
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W", "graphable" => "true"} );
  						} elsif ($f->{"Counter"}) {
  							($usage)= ($f->{"Counter"} =~ /(\d+) Watt/);
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W", "graphable" => "true"} );
  						}
  						my ($total)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$total=ceil($total);
  						push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "kWh"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"Type"} eq "P1 Smart Meter") and ($f->{"SubType"} eq "Gas"))  {
  						# (Dutch)P1 Gas Meter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						my ($usage)= ($f->{"CounterToday"} =~ /(\d+) m3/);
  						my ($total)= ($f->{"Counter"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "m3"} );
  						push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "m3"} );
  						push (@{$feed->{'devices'}}, $feeds );
  						
  						# Generic Sensor showing today's value
  						my ($usage_today)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$feeds={"id" => $f->{"idx"}."_today", "name" => $name."_today", "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$usage_today", "unit"=> "m3", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Energy") {
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#ConsoTotal     Current total consumption       kWh
  						#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						#if ($f->{"Usage"}) {
  							my $usage;
  							($usage)= ($f->{"Usage"} =~ /(\d+) Watt/);
  							if (!$usage) {$usage="0";}
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W"} );#}
  						my ($total)= ($f->{"Data"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$total=ceil($total);
  						 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "kWh", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Usage") {
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#"Type" : "Usage", "SubType" : "Electric", "Data" : "122.3 Watt"
  						my ($total)= ($f->{"Data"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$total=ceil($total);
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$total", "unit" => "W"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Current/Energy") {
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#ConsoTotal     Current total consumption       kWh
  						#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  						my ($L1,$L2,$L3,$tot)= split(/,/,$f->{"Data"});
  						my ($l1)= ($L1 =~ /(\d+) Watt/);
  						my ($l2)= ($L2 =~ /(\d+) Watt/);
  						my ($l3)= ($L3 =~ /(\d+) Watt/);
  						if ($l1) {	
  							my $feeds={"id" => $f->{"idx"}."_L1", "name" => $name." L1", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l1", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  						if ($l2) {	
  							my $feeds={"id" => $f->{"idx"}."_L2", "name" => $name." L2", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l2", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  						if ($l3) {	
  							my $feeds={"id" => $f->{"idx"}."_L3", "name" => $name." L3", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l3", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  					}  elsif (($f->{"Type"} =~ "Temp")||($f->{"Type"} =~ "Humidity"))  {
  						if (($f->{"Type"} =~ "Temp")&&($f->{"Type"} =~ "Humidity")) {
  							my $feeds;
  							$feeds={params =>[],"room" => "Temp","type" => "DevTempHygro","name" => $name, "id" => $f->{"idx"}};
  
  							my $v=$f->{"Temp"};
  							push (@{$feeds->{'params'}}, {"key" => "temp", "value" => "$v", "unit" => $t_unit, "graphable" => "true"} );
  							my $vh=$f->{"Humidity"};
  							push (@{$feeds->{'params'}}, {"key" => "hygro", "value" => "$vh", "unit" => "%", "graphable" => "true" });
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"Type"} eq "Temp") {
  							#DevTemperature Temperature sensor
  							#Value  Current temperature     *C
  							#"Temp" : 21.50,  "Type" : "Temp + Humidity" / Type" : "Temp",
  							$device_tab{$f->{"idx"}}->{"graph"} = 'te';
  							my $feeds;
  							$feeds={params =>[],"room" => "Temp","type" => "DevTemperature","name" => $name, "id" => $f->{"idx"}};
  							my $v=$f->{"Temp"};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => $t_unit, "graphable" => "true"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"Type"} eq "Humidity") {
  							#DevHygrometry  Hygro sensor
  							#Value  Current hygro value     %
  							# "Humidity" : 52  "Type" : "Temp + Humidity" / Type" : "Humidity",
  							$device_tab{$f->{"idx"}}->{"graph"} = 'hu';
  
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevHygrometry", "room" => "Temp", params =>[]};
  							my $v=$f->{"Humidity"};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "%", "graphable" => "true" });
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  					 	if ($f->{"Type"} =~ "Baro") {
  							#DevPressure    Pressure sensor
  							#Value  Current pressure        mbar
  							#"Barometer" : 1022, "Type" : "Temp + Humidity + Baro"
  							my $idx=$f->{"idx"};
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							if ($f->{"Type"} eq "Temp + Humidity + Baro") {$idx=$idx."_1"};
  							my $feeds={"id" => $idx, "name" => $name, "type" => "DevPressure", "room" => "Temp", params =>[]};
  							my $v=$f->{"Barometer"};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "mbar"} );
  								push (@{$feed->{'devices'}}, $feeds );
  						}
  					}  elsif ($f->{"Type"} eq "Rain")  {
  						#DevRain        Rain sensor
  						#Value  Current instant rain value      mm/h
  						#Accumulation   Total rain accumulation mm
  						#"Rain" : "0.0", "RainRate" : "0.0", "Type" : "Rain"
  						$device_tab{$f->{"idx"}}->{"graph"} = 'mm';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevRain", "room" => "Temp", params =>[]};
  						my $v0=$f->{"RainRate"};
  						my $v1=$f->{"Rain"};
  						push (@{$feeds->{'params'}}, {"key" => "Accumulation", "value" => "$v1", "unit" => "mm", "graphable" => "true"} );
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v0", "unit" => "mm/h"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "UV")  {
  						#DevUV  UV sensor
  						#Value  Current UV index        index
  						# "Type" : "UV","UVI" : "6.0"
  						$device_tab{$f->{"idx"}}->{"graph"} = 'uvi';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevUV", "room" => "Temp", params =>[]};
  						my $v=$f->{"UVI"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Lux")  {
  						#DevLux  Lux sensor
  						#Value  Current Lux value        index
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevLuminosity", "room" => "Temp", params =>[]};
  						my ($v)=($f->{"Data"}=~/(\d+) Lux/);
  						$device_tab{$f->{"idx"}}->{"graph"} = 'uvi';
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Air Quality")  {
  						#DevCO2  CO2 sensor
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevCO2", "room" => "Temp", params =>[]};
  						my ($v)=($f->{"Data"}=~/(\d+) ppm/);
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "ppm", "graphable" => "true"});
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Wind")  {
  						#DevWind wind
  						$device_tab{$f->{"idx"}}->{"graph"} = 'sp';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevWind", "room" => "Temp", params =>[]};
  						my ($dir)=($f->{"Direction"}=~/(\d+)/);
  						my ($speed)=($f->{"Speed"}=~/(\d+)/);
  						push (@{$feeds->{'params'}}, {"key" => "Speed", "value" => "$speed", "unit" => "km/h", "graphable" => "true"});
  						push (@{$feeds->{'params'}}, {"key" => "Direction", "value" => "$dir", "unit" => "°"});
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "RFXMeter")  {
  						if ($f->{"SwitchTypeVal"} eq "1") {
  							#Gas
  							my ($usage)= ($f->{"CounterToday"} =~ /(\d+) m3/);
  							my ($total)= ($f->{"Counter"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  							$total=ceil($total);
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$usage, "unit" => "m3"} );
  							 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>$total, "unit" => "m3"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SwitchTypeVal"} eq "2") {
  							#Water
  							my ($usage)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  							my ($total)= ($f->{"Counter"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							my $totalm3=ceil($total);
  							my $usagem3=ceil($usage/1000);
  							my $feeds={"id" => $f->{"idx"}, "name" => "$name", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usagem3", "unit" => "m3", "graphable" => "true"} );
  							 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$totalm3", "unit" => "m3"} );
  							push (@{$feed->{'devices'}}, $feeds );
  							#Water by liter
  							my $usage2=$usage; #move to liters
  							$feeds={"id" => $f->{"idx"}."_l", "name" => $name."_l", "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$usage2", "unit"=> "L"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif (($f->{"SwitchTypeVal"} eq "3")||($f->{"SubType"} eq "RFXMeter counter")) {
  							#Counter
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							my ($v)=($f->{"Counter"}=~/^([^\s]+)/);
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" => "$v"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} else {
  							push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  						}
  					} elsif ($f->{"Type"} eq "General")  {
  							if ($f->{"SubType"} eq "Percentage") {
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "%", "graphable" => "true"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "Voltage") {
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "V"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "kWh") {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						my $usage;
  						($usage)= ($f->{"Usage"} =~ /^(\d+\.\d+) Watt/);
  						push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "kWh", "graphable" => "false"} );
  						push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "Pressure") {
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevPressure", "room" => "Temp", params =>[]};
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "mbar", "graphable" => "true"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "Visibility") {
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Temp", params =>[]};
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "km"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "Solar Radiation") {
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Temp", params =>[]};
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "Watt/m2"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif (($f->{"SubType"} eq "Text")||($f->{"SubType"} eq "Alert")||($f->{"SubType"} eq "Unknown")) {	   
  	    						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  							my $v= $f->{"Data"};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => ""} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "Sound Level") {	   
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+) dB/);
  	    						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevNoise", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "dB", graphable => "true"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} else { 
  							push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  						}
  					} elsif (($f->{"SubType"})&&($f->{"SubType"} eq "SetPoint")) {
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevThermostat", "room" => "Temp", params =>[]};
  							my ($v)= ($f->{"SetPoint"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "cursetpoint", "value" => "$v"});
  							push (@{$feeds->{'params'}}, {"key" => "curtemp", "value" => "$v", "unit"=>$t_unit} );
  							push (@{$feeds->{'params'}}, {"key" => "step", "value" => "0.5"} );
  							push (@{$feeds->{'params'}}, {"key" => "curmode", "value" => "default"} );
  							push (@{$feeds->{'params'}}, {"key" => "availablemodes", "value" => "default"} );
  							push (@{$feed->{'devices'}}, $feeds );
  					} else {
  						#catchall
  						if ($f->{"idx"}>5) {push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};}					}
  				}
  			}; 
  		}
  
  		#Unknown device list
  		my $ind_unk=2;
  		foreach my $devt ( @unk_dev)  {
  			my $feeds={"id" => "S".$ind_unk++, "name" => "$devt", "type" => "DevGenericSensor", "room" => "noroom", params =>[]};
  			push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"unk", "unit"=> "", "graphable" => "false"} );
  			push (@{$feed->{'devices'}}, $feeds );
  		}
  	} else {
  		my $feeds={"id" => "S00", "name" => "Unable to connect to Domoticz", "type" => "DevGenericSensor",  params =>[]};
  		my $ver=config->{domo_path};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$ver", "unit"=> "", "graphable" => "false"} );
  		push (@{$feed->{'devices'}}, $feeds );
  		$feeds={"id" => "S01", "name" => "Please add this gateway in Setup/settings/Local Networks", "type" => "DevGenericSensor",  params =>[]};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"", "unit"=> "", "graphable" => "false"} );
  		push (@{$feed->{'devices'}}, $feeds );
  	}
  
  	#MPD
  	if ($mpd_host ne '') {
  		$mpd=Audio::MPD->new ( host => $mpd_host);
  	}
  	#Status
  	if ($mpd_host) {
  		my $status = $mpd->status;
  		my $song = $mpd->current;
  		my $feeds={"id" => "V2", "name" => $song->artist." - ".$song->album, "type" => "DevMultiSwitch", "room" => "Volumio", params =>[]};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>$status->state, "unit"=> "", "graphable" => "false"} );
  		push (@{$feeds->{'params'}}, {"key" => "Choices", "value" => "play,stop,pause,next,prev,volumeUP,volumeDOWN"});
  		push (@{$feed->{'devices'}}, $feeds );
  	}
  
  	#Get Scenes
  	$system_url=config->{domo_path}."/json.htm?type=scenes";
  	$json = $ua->get( $system_url );
  	#warn "Could not get $system_url!" unless defined $json;
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  					my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  	#	debug($dt->strftime("%Y-%m-%d %H:%M:%S"));
  					my $name=$f->{"Name"};
  					$name=~s/%/P/;
  					#DevScene       Scene (launchable)
  					#LastRun        Date of last run        N/A
  					#"idx" : "3", "Name" : "Alerte", "Type" : "Scenes", "LastUpdate" : "2014-03-18 22:17:18"
  					if ($f->{"Type"} eq "Group") {
  						my $feeds={"id" => "S".$f->{"idx"}, "name" => $name, "type" => "DevMultiSwitch", "room" => "Scenes", params =>[]};
  						my $v=$dt->strftime("%Y-%m-%d %H:%M:%S");
  						push (@{$feeds->{'params'}}, {"key" => "LastRun", "value" => "$v"} );
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => $f->{"Status"}} );
  						push (@{$feeds->{'params'}}, {"key" => "Choices", "value" => "Mixed,On,Off"} );
  						push (@{$feed->{'devices'}}, $feeds );
  
  					} else {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevScene", "room" => "Scenes", params =>[]};
  						my $v=$dt->strftime("%Y-%m-%d %H:%M:%S");
  						push (@{$feeds->{'params'}}, {"key" => "LastRun", "value" => "$v"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  			}
  		}
  	}
  	#Get Camera
  	$system_url=config->{domo_path}."/json.htm?type=cameras";
  debug($system_url);
  	$json = $ua->get( $system_url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  					my $name=$f->{"Name"};
  					$name=~s/\s/_/;
  					$name=~s/\s/_/;
  					$name=~s/\//_/;
  					$name=~s/%/P/;
  					my $feeds={"id" => $f->{"idx"}."_cam", "name" => $name, "type" => "DevCamera", "room" => "Switches", params =>[]};
  					my $v=$f->{"ImageURL"};my $v2=config->{external_url_camera};my $v3=$f->{"VideoURL"};
  					if ($v =~ /^http/) {
  						push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  					} else {
  						if ($f->{"Username"}) {
  							$v="http://".$f->{"Username"}.":".$f->{"Password"}."@".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"ImageURL"};
  							push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  						} else {
  							$v="http://".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"ImageURL"};
  							push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  	
  						}
  					}
  					if ($v2) {push (@{$feeds->{'params'}}, {"key" => "remotejpegurl", "value" => "$v2"} );}
  					push (@{$feed->{'devices'}}, $feeds );
  					# Now if VideoURL
  					if ($v3) {
  						my $feeds2={"id" => $f->{"idx"}."_video", "name" => $name, "type" => "DevCamera", "room" => "Switches", params =>[]};
  						if ($f->{"Username"}) {
  							$v="http://".$f->{"Username"}.":".$f->{"Password"}."@".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"VideoURL"};
  							push (@{$feeds2->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  							} else {
  							$v="http://".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"VideoURL"};
  							push (@{$feeds2->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  							}
  						push (@{$feed->{'devices'}}, $feeds2 );
  						}
  			}
  		}
  	}
  	#DevGenericSensor      Generic sensor (any value)
  	#Value  Current value   N/A
  
  
  	
  	return to_json($feed, { utf8 => 1} );
  	return { success => true};
  };
  
  sub getDeviceType($) {
  	my ($deviceId)=@_;
  	my $url=config->{domo_path}."/json.htm?type=devices&rid=$deviceId";
  	my $decoded;
  	my @results;
  debug($url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  				if ($f->{SubType} eq "RFXMeter counter") {
  					return("counter");
  				} else {
  					return($f->{Type});
  				}
  			}
  		}
  	}
  }
  sub getLastVersion() {
  	my $dt = DateTime->now();
  	if ($last_version_dt < $dt->add( hours => 4 )) {
  		my @res;
  		push @res,$last_version;
  		push @res,"";
  		return(@res);
  	} else {
  		my $url="https://api.github.com/repos/empierre/MyDomoAtHome/releases/latest";
  		my $decoded;
  		my @results;
  	debug($url);
  		my $ua = LWP::UserAgent->new();
  		$ua->agent("MyDomoREST/$VERSION");
  		my $json = $ua->get( $url );
  		if ($json->is_success) {
  			# Decode the entire JSON
  			$decoded = JSON->new->utf8(0)->decode( $json->decoded_content );
  			if ($decoded) {
  				my @res;
  				push @res,$decoded->{tag_name};
  				push @res,$decoded->{body};
  				$last_version_dt=DateTime->now;
  				$last_version=$decoded->{tag_name};
  				return(@res);
  			}
  		} else {return "err";}
  	}
  }
  1;
DOMO

$fatpacked{"Domo2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DOMO2';
  package Domo2;
  # This program is free software; you can redistribute it and/or
  # modify it under the terms of the GNU General Public License
  # version 2 as published by the Free Software Foundation.
  # Author: epierre <epierre@e-nef.com>
  use Dancer2 appname => 'Domo';
  use File::Slurp;
  use File::Spec;
  use DateTime;
  use LWP::UserAgent;
  use Crypt::SSLeay;
  use utf8;
  use Encode qw/ encode decode /;
  use Time::Piece;
  use feature     qw< unicode_strings >;
  use POSIX qw(ceil);
  use Audio::MPD;
  use Switch;
  use Plack::Builder;
  use warnings;
  use strict;
  
  our $VERSION = '0.13';
  set warnings => 0;
  my %device_tab;
  my %room_tab;
  my %device_list;
  my $last_version;    #last version in github
  my $last_version_dt; # last version text in github
  
  set serializer => 'JSON'; 
  set 'database'     => File::Spec->catfile( config->{domo_db});
  prefix undef;
  
  my $mpd_host=config->{volumio_path};
  my $mpd;
  
  get '/' => sub {
      template 'index2';
  };
  
  get '/rooms' => sub {
      #Room list
  	my @room={};
  	my $feed={ "rooms" => []};
  	foreach my $key (keys %room_tab) {
  		print "ROOM: $key\n";
  		push (@{$feed->{'rooms'}}, { "id"=> "$key", "name"=> "$key" });	 
  	}
  	return($feed);
  
  };
  
  get '/system' => sub {
   return {"id"=> "MyDomoAtHome","apiversion"=> 1};
  };
  
  get '/devices/:deviceId/:paramKey/histo/:startdate/:enddate' => sub {
  	my $deviceId = params->{deviceId};
  	my $paramKey = params->{paramKey}||"";
  	my $startdate = params->{startdate}||"";
  	my $enddate = params->{enddate}||"";
  
  	my $type=lc(&getDeviceType($deviceId));
  	my $ptype=$type;
  debug("TYPE:$type\n");
  	if (($type eq "lux")||($type eq "energy")) {$type="counter";}
  	if ($type eq "air quality") {$type="counter";}
  	if (($ptype eq "general")) {$type="Percentage";}
  	if (($paramKey eq "hygro")) {$type="temp";}
  	if (($paramKey eq "temp")) {$type="temp";}
  
  	my $feed={ "values" => []};
  	my $url=config->{domo_path}."/json.htm?type=graph&sensor=$type&idx=$deviceId&range=day";
  	my $decoded;
  	my @results=();
  debug($url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			my $f={};
  			foreach $f ( @results ) {
  					my $dt = Time::Piece->strptime($f->{"d"},"%Y-%m-%d %H:%M:%SS");
  					#print $dt->epoch." \n";
  					if ((($paramKey eq "temp")&&($f->{"te"}))||($type eq "temp")) {
  							my $value=$f->{"te"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ((($paramKey eq "hygro")&&($f->{"hu"}))||($type eq "Humidity")) {
  							my $value=$f->{"hu"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif (($ptype eq "air quality")) {
  							my $value=$f->{"co2"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif (($type eq "counter")||($type eq "Percentage")) {
  							my $value=$f->{"v"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"mm"}) {
  							my $value=$f->{"mm"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"uvi"}) {
  							my $value=$f->{"uvi"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"v"}) {
  							my $value=$f->{"v"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"sp"}) {
  							my $value=$f->{"sp"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					}
  					#di direction
  					#gu gust
  					#v counter percentage
  					#
  				}
  			return to_json($feed, { utf8 => 1} );
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false};
  		}
  	} else {
  		status 'error';
  		return { success => false};
  	}
  };
  
  get '/devices/:deviceId/action/:actionName/?:actionParam?' => sub {
  	my $deviceId = params->{deviceId};
  	my $actionName = params->{actionName};
  	my $actionParam = params->{actionParam}||"";
  
  	switch($actionName) {
  		case "setStatus" {
  			debug("actionParam=".$actionParam."\n");
  			#setStatus	0/1
  			my $action;
  			if ($actionParam) {
  				$action="On";
  			} else {
  				$action="Off";
  			}
  			my $url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=$action&level=0&passcode=";
  			debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  		}
  		case "setArmed" {
  			#setArmed	0/1
  			status 'error';
  			return { success => false, errormsg => "not implemented"};
  		}
  		case "setAck" {
  			#setAck	
  			my $url=config->{domo_path}."/json.htm?type=command&param=resetsecuritystatus&idx=$deviceId&switchcmd=Normal";
  		debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  		}
  		case "setLevel" {
  			#/json.htm?type=command&param=switchlight&idx=&switchcmd=Set%20Level&level=6
  			my $url;
  			if (($device_tab{$deviceId}->{"Action"}==2)or($device_tab{$deviceId}->{"Action"}==3)) {
  				if ($actionParam eq "100") {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=$actionParam&passcode=";
  				} else {
  					my $setLevel=ceil($actionParam*($device_tab{$deviceId}->{"MaxDimLevel"})/100);
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$setLevel&passcode=";
  				}
  			} elsif (($device_tab{$deviceId}->{"Action"}==5)) {
  				#Blinds inverted
  				if ($actionParam eq "100") {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=0&passcode=";
  				} else {
  					my $setLevel=ceil($actionParam*$device_tab{$deviceId}->{"MaxDimLevel"}/100);
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$setLevel&passcode=";
  				}
  			} elsif (($device_tab{$deviceId}->{"Action"}==6)) {
  				#Blinds -> On for Closed, Off for Open 
  				if ($actionParam eq "100") {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=0&passcode=";
  				} else {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=0&passcode=";
  				}
  			} else {
  				if ($actionParam eq "1") {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$actionParam&passcode=";
  				} elsif ($actionParam eq "0") {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=$actionParam&passcode=";
  
  				} else {
  					my $setLevel=ceil($actionParam*$device_tab{$deviceId}->{"MaxDimLevel"}/100);
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Set%20Level&level=$setLevel&passcode=";
  				}
  			}
  
  				debug($url);
  				my $browser = LWP::UserAgent->new;
  				my $response = $browser->get($url);
  				if ($response->is_success){ 
  					return { success => true};
  				} else {
  					status 'error';
  					return { success => false, errormsg => $response->status_line};
  				}
  		} 
  		case "stopShutter"{
  			#stopShutter (Venetian store)
  			my $url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Stop&level=0&passcode=";
  		debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  			return { success => true};
  		}
  		case "pulseShutter" {
  				#pulseShutter	up/down
  				status 'error';
  				return { success => false, errormsg => "not implemented"};
  		}
  		case "setSetPoint" {
  			#DevThermostat
  			my $url=config->{domo_path}."/json.htm?type=setused&idx=$deviceId&used=true&setpoint=$actionParam";
  			debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  			return { success => true};
  		}
  		case 'launchScene' {
  			#launchScene
  			#/json.htm?type=command&param=switchscene&idx=&switchcmd=
  			my $url=config->{domo_path}."/json.htm?type=command&param=switchscene&idx=$deviceId&switchcmd=On&passcode=";
  		debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  			return { success => true};
  		}
  		case 'setColor' {
  			my $url=config->{domo_path}."/json.htm?type=command&param=setcolorbrightnessvalue&idx=$deviceId&passcode=";
  			debug($url);
  				my $browser = LWP::UserAgent->new;
  				my $response = $browser->get($url);
  				if ($response->is_success){ 
  					return { success => true};
  				} else {
  					status 'error';
  					return { success => false, errormsg => $response->status_line};
  				}
  		}
  		case 'setChoice' {
  			if ($deviceId=~/^S/) {
  				my ($sc)=$deviceId=~/S(\d+)/;
  				my $url=config->{domo_path}."/json.htm?type=command&param=switchscene&idx=$sc&switchcmd=$actionParam&passcode=";
  			debug($url);
  				my $browser = LWP::UserAgent->new;
  				my $response = $browser->get($url);
  				if ($response->is_success){ 
  					return { success => true};
  				} else {
  					status 'error';
  					return { success => false, errormsg => $response->status_line};
  				}
  			} elsif ($deviceId=~/^V/) {
  				my ($sc)=$deviceId=~/V(\d+)/;
  				if ($actionParam eq "play") {
  					$mpd->play;
  				}elsif ($actionParam eq "pause") {
  					$mpd->pause;
  				}elsif ($actionParam eq "stop") {
  					$mpd->stop;
  				}elsif ($actionParam eq "next") {
  					$mpd->next;
  				}elsif ($actionParam eq "prev") {
  					$mpd->next;
  				}elsif ($actionParam eq "volumeUP") {
  					$mpd->volume("+1");
  				}elsif ($actionParam eq "volumeDOWN") {
  					$mpd->volume("-1");
  				}
  			} else {
  				status 'error';
  				return { success => false, errormsg => "not implemented"};
  			}
  		}
  		case 'setMode' {
  				#setChoice string
  				status 'error';
  				return { success => false, errormsg => "not implemented"};
  			}
  		else {
  				status 'not_found';
  				return "What?";
  	   }
  	}
  };
  
  get '/devices' => sub {
  	my $feed={ "devices" => []};
  	my $t_unit="°C";
  	my $system_url = config->{domo_path}."/json.htm?type=devices&filter=all&used=true&order=Name";
  	my $decoded;
  	my @results;
  	my @unk_dev;         # list of unknown devices
  debug($system_url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $system_url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			#Own device version
  			my $feeds={"id" => "S0", "name" => "MyDomoAtHome", "type" => "DevGenericSensor",  params =>[]};
  			my $ver="$VERSION";
  			push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$ver", "unit"=> "", "graphable" => "false"} );
  			push (@{$feed->{'devices'}}, $feeds );
  			#Check for new version
  			my @and=&getLastVersion();
  			my $an1;my $an2;
  			if (($ver ne $and[0])&&($and[0] ne "err")) {
  				my $feeds={"id" => "S1", "name" => "New version found", "type" => "DevGenericSensor",  params =>[]};
  				$an1=$and[0];
  				push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$an1", "unit"=> "", "graphable" => "false"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			}
  			#
  			#Parse the devices tree
  			#
  			foreach my $f ( @results ) {
  				my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  				my $name=$f->{"Name"};
  				#$name=~s/\s/_/;
  				#$name=~s/\s/_/;
  				#$name=~s/\//_/; 
  				$name=~s/%/P/;
  				my $rbl;
  				 if ($f->{"SwitchType"}) {			
  					#print $f->{"idx"} . " " . $f->{"Name"} . " " . $f->{"Status"} . $f->{"LastUpdate"}."\n";
  					#$name.="_E";
  					my $bl=$f->{"Status"};
  					if ($bl eq "On") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=1;}
  					elsif ($bl eq "Off") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=1;}
  					elsif ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=2;}
  					elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=2;}
  					elsif ($bl eq "Panic") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=3;}
  					elsif ($bl eq "Normal") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=3;}
  					else { $rbl=$bl;}
  				}
  				switch($f->{"Type"}) {
  					case /Lighting/ {
  						$room_tab{"Switches"}=1;
  						switch($f->{"SwitchType"}) {
  							case ["On/Off","Lighting Limitless/Applamp","Contact","Dusk Sensor"] {
  								if ($f->{"SubType"} ne "RGBW") {
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSwitch", "room" => "Switches", params =>[]};
  									push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  									push (@{$feed->{'devices'}}, $feeds );
  								} else {
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevRGBLight", "room" => "Switches", params =>[]};
  									if ($rbl=~/Set Level/) {
  										$rbl=1;
  										$device_tab{$f->{"idx"}}->{"MaxDimLevel"} = $f->{"MaxDimLevel"};
  										push (@{$feeds->{'params'}}, {"key" => "dimmable", "value" => "1" } );
  										push (@{$feeds->{'params'}}, {"key" => "Level", "value" => $f->{"Level"} } );
  									}
  									push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  									push (@{$feed->{'devices'}}, $feeds );
  								}
  							}
  							case ["Push On Button","Push Off Button"] {
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSwitch", "room" => "Switches", params =>[]};
  								if ($f->{"SwitchType"} eq "Push Off Button") {$rbl="0"};
  								if ($f->{"SwitchType"} eq "Push On Button") {$rbl="1"};
  								push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  								#push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"1"} );
  								#push (@{$feeds->{'params'}}, {"key" => "Level", "value" =>"$rbl"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case ["Dimmer","Doorbell"] {
  								#DevDimmer	Dimmable light
  								#Status	Current status : 1 = On / 0 = Off	N/A
  								#Level	Current dim level (0-100)	%
  								#"idx" : "3", "Name" : "Alerte",  "Level" : 0,  "SwitchType" : "Dimmer",  "Status" : "Off","LastUpdate" : "2014-03-18 22:17:18"
  								if ($rbl=~/Set Level/) {$rbl=1;}
  								$device_tab{$f->{"idx"}}->{"MaxDimLevel"} = $f->{"MaxDimLevel"};
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDimmer", "room" => "Switches", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  								push (@{$feeds->{'params'}}, {"key" => "Level", "value" => $f->{"Level"} } );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case ["Blinds Inverted"] {
  								#DevShutter
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  								my $v;
  								if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  								my $bl=$f->{"Status"};my $rbl;
  								if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=5;}
  								elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=5;};
  								push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  								push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  								push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case ["Unknown"] {
  								if ($f->{"SwitchTypeVal"} eq "16") {
  									#DevShutter
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  									my $v=$f->{"Level"};
  
  									push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  									push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  									push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  
  									push (@{$feed->{'devices'}}, $feeds );
  								} else {print STDERR "Unknown !";}
  							}
  							case "Blinds Percentage" {
  								#DevShutter
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  								my $v;
  								if ($f->{"Status"} eq "Open") {$v=100;} else {$v=$f->{"Level"}};
  								my $bl=$f->{"Status"};my $rbl;
  								if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  								elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  								push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  								push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  								push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case ["Blinds","Venetian Blinds EU","Venetian Blinds US"] {
  								if ($f->{"SubType"} ne "RollerTrol, Hasta new") {
  									#DevShutter
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  									my $v;
  									if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  									my $bl=$f->{"Status"};my $rbl;
  									if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  									elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  									push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  									push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  									push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  									push (@{$feed->{'devices'}}, $feeds );
  								} else {
  									# "RollerTrol, Hasta new"
  									#DevShutter
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  									my $v;
  									if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  									my $bl=$f->{"Status"};my $rbl;
  									if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  									elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  									push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"1"} );
  									push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  									push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  									push (@{$feed->{'devices'}}, $feeds );
  								}
  							}
  							case "Motion Sensor" {
  								#DevMotion	Motion security sensor
  								#Status	CM180 status : 1 = On / 0 = Off	N/A
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevMotion", "room" => "Switches", params =>[]};
  								push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  								push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  								push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  								push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "Door Lock" {
  								#DevLock	Door / window lock
  								#Status	CM180 status : 1 = On / 0 = Off	N/A
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDoor", "room" => "Switches", params =>[]};
  								push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  								push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  								push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  								push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							#DevDoor	Door / window security sensor
  							#DevFlood	Flood security sensor
  							#DevCO2Alert	CO2 Alert sensor
  						}
  					}
  					case "Security" {
  						#DevSmoke	Smoke security sensor
  						#Armable	Ability to arm the device : 1 = Yes / 0 = No	N/A
  						#Ackable	Ability to acknowledge alerts : 1 = Yes / 0 = No	N/A
  						#Armed	Current arming status : 1 = On / 0 = Off	N/A
  						#Tripped	Is the sensor tripped ? (0 = No - 1 = Tripped)	N/A				
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSmoke", "room" => "Switches", params =>[]};
  						push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "1" } );
  						push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  						push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  						#"GET http://192.168.0.24:8080/json.htm?type=command&param=resetsecuritystatus&idx=202&switchcmd=Normal"
  						push (@{$feed->{'devices'}}, $feeds );				
  					}
  
  					case ["P1 Smart Meter","YouLess Meter"] {
  						$room_tab{"Utility"}=1;
  						switch($f->{"SubType"}) {
  							case ["Energy","YouLess counter"] {
  								#DevElectricity Electricity consumption sensor
  								#Watts  Current consumption     Watt
  								#ConsoTotal     Current total consumption       kWh
  								#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  								my $usage;
  								if ($f->{"Usage"}) {
  									($usage)= ($f->{"Usage"} =~ /(\d+) Watt/);
  									push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W", "graphable" => "true"} );
  								} elsif ($f->{"Counter"}) {
  									($usage)= ($f->{"Counter"} =~ /(\d+) Watt/);
  									push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W", "graphable" => "true"} );
  								}
  								my ($total)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  								$total=ceil($total);
  								push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "kWh"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case"Gas" {
  								# (Dutch)P1 Gas Meter
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  								my ($usage)= ($f->{"CounterToday"} =~ /(\d+) m3/);
  								my ($total)= ($f->{"Counter"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "m3"} );
  								push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "m3"} );
  								push (@{$feed->{'devices'}}, $feeds );							
  								# Generic Sensor showing today's value
  								my ($usage_today)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  								$feeds={"id" => $f->{"idx"}."_today", "name" => $name."_today", "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$usage_today", "unit"=> "m3", "graphable" => "true"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  						}
  					}
  					case "Energy" {
  						$room_tab{"Utility"}=1;
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#ConsoTotal     Current total consumption       kWh
  						#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						#if ($f->{"Usage"}) {
  							my $usage;
  							($usage)= ($f->{"Usage"} =~ /(\d+) Watt/);
  							if (!$usage) {$usage="0";}
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W"} );#}
  						my ($total)= ($f->{"Data"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$total=ceil($total);
  						 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "kWh", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Usage" {
  						$room_tab{"Utility"}=1;
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#"Type" : "Usage", "SubType" : "Electric", "Data" : "122.3 Watt"
  						my ($total)= ($f->{"Data"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$total=ceil($total);
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$total", "unit" => "W"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Current/Energy" {
  						$room_tab{"Utility"}=1;
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#ConsoTotal     Current total consumption       kWh
  						#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  						my ($L1,$L2,$L3,$tot)= split(/,/,$f->{"Data"});
  						my ($l1)= ($L1 =~ /(\d+) Watt/);
  						my ($l2)= ($L2 =~ /(\d+) Watt/);
  						my ($l3)= ($L3 =~ /(\d+) Watt/);
  						if ($l1) {	
  							my $feeds={"id" => $f->{"idx"}."_L1", "name" => $name." L1", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l1", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  						if ($l2) {	
  							my $feeds={"id" => $f->{"idx"}."_L2", "name" => $name." L2", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l2", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  						if ($l3) {	
  							my $feeds={"id" => $f->{"idx"}."_L3", "name" => $name." L3", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l3", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  					}
  					case "Temp + Humidity"  {
  						$room_tab{"Temp"}=1;
  						my $feeds;
  						$feeds={params =>[],"room" => "Temp","type" => "DevTempHygro","name" => $name, "id" => $f->{"idx"}};
  						my $v=$f->{"Temp"};
  						push (@{$feeds->{'params'}}, {"key" => "temp", "value" => "$v", "unit" => $t_unit, "graphable" => "true"} );
  						my $vh=$f->{"Humidity"};
  						push (@{$feeds->{'params'}}, {"key" => "hygro", "value" => "$vh", "unit" => "%", "graphable" => "true" });
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Temp + Humidity + Baro"  {
  						$room_tab{"Temp"}=1;
  						my $feeds;
  						$feeds={params =>[],"room" => "Temp","type" => "DevTempHygro","name" => $name, "id" => $f->{"idx"}};
  						my $v=$f->{"Temp"};
  						push (@{$feeds->{'params'}}, {"key" => "temp", "value" => "$v", "unit" => $t_unit, "graphable" => "true"} );
  						my $vh=$f->{"Humidity"};
  						push (@{$feeds->{'params'}}, {"key" => "hygro", "value" => "$vh", "unit" => "%", "graphable" => "true" });
  						push (@{$feed->{'devices'}}, $feeds );
  						if ($f->{"Type"} =~ "Baro") {
  							#DevPressure    Pressure sensor
  							#Value  Current pressure        mbar
  							#"Barometer" : 1022, "Type" : "Temp + Humidity + Baro"
  							my $idx=$f->{"idx"};
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							if ($f->{"Type"} eq "Temp + Humidity + Baro") {$idx=$idx."_1"};
  							my $feeds={"id" => $idx, "name" => $name, "type" => "DevPressure", "room" => "Temp", params =>[]};
  							my $v=$f->{"Barometer"};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "mbar"} );
  								push (@{$feed->{'devices'}}, $feeds );
  						}
  					}
  					case "Temp" {
  						#DevTemperature Temperature sensor
  						#Value  Current temperature     *C
  						#"Temp" : 21.50,  "Type" : "Temp + Humidity" / Type" : "Temp",
  						$device_tab{$f->{"idx"}}->{"graph"} = 'te';
  						my $feeds;
  						$feeds={params =>[],"room" => "Temp","type" => "DevTemperature","name" => $name, "id" => $f->{"idx"}};
  						my $v=$f->{"Temp"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => $t_unit, "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Humidity" {
  						#DevHygrometry  Hygro sensor
  						#Value  Current hygro value     %
  						# "Humidity" : 52  "Type" : "Temp + Humidity" / Type" : "Humidity",
  						$device_tab{$f->{"idx"}}->{"graph"} = 'hu';
  
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevHygrometry", "room" => "Temp", params =>[]};
  						my $v=$f->{"Humidity"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "%", "graphable" => "true" });
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Rain"  {
  						$room_tab{"Temp"}=1;
  						#DevRain        Rain sensor
  						#Value  Current instant rain value      mm/h
  						#Accumulation   Total rain accumulation mm
  						#"Rain" : "0.0", "RainRate" : "0.0", "Type" : "Rain"
  						$device_tab{$f->{"idx"}}->{"graph"} = 'mm';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevRain", "room" => "Temp", params =>[]};
  						my $v0=$f->{"RainRate"};
  						my $v1=$f->{"Rain"};
  						push (@{$feeds->{'params'}}, {"key" => "Accumulation", "value" => "$v1", "unit" => "mm", "graphable" => "true"} );
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v0", "unit" => "mm/h"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "UV"  {
  						$room_tab{"Temp"}=1;
  						#DevUV  UV sensor
  						#Value  Current UV index        index
  						# "Type" : "UV","UVI" : "6.0"
  						$device_tab{$f->{"idx"}}->{"graph"} = 'uvi';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevUV", "room" => "Temp", params =>[]};
  						my $v=$f->{"UVI"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Lux"  {
  						$room_tab{"Utility"}=1;
  						#DevLux  Lux sensor
  						#Value  Current Lux value        index
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevLuminosity", "room" => "Temp", params =>[]};
  						my ($v)=($f->{"Data"}=~/(\d+) Lux/);
  						$device_tab{$f->{"idx"}}->{"graph"} = 'uvi';
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Air Quality"  {
  						$room_tab{"Utility"}=1;
  						#DevCO2  CO2 sensor
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevCO2", "room" => "Temp", params =>[]};
  						my ($v)=($f->{"Data"}=~/(\d+) ppm/);
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "ppm", "graphable" => "true"});
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Wind"  {
  						$room_tab{"Temp"}=1;
  						#DevWind wind
  						$device_tab{$f->{"idx"}}->{"graph"} = 'sp';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevWind", "room" => "Temp", params =>[]};
  						my ($dir)=($f->{"Direction"}=~/(\d+)/);
  						my ($speed)=($f->{"Speed"}=~/(\d+)/);
  						push (@{$feeds->{'params'}}, {"key" => "Speed", "value" => "$speed", "unit" => "km/h", "graphable" => "true"});
  						push (@{$feeds->{'params'}}, {"key" => "Direction", "value" => "$dir", "unit" => "°"});
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "RFXMeter"  {
  						$room_tab{"Utility"}=1;
  						switch($f->{"SwitchTypeVal"}) {
  							case "1" {
  								#Gas
  								my ($usage)= ($f->{"CounterToday"} =~ /(\d+) m3/);
  								my ($total)= ($f->{"Counter"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  								$total=ceil($total);
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$usage, "unit" => "m3"} );
  								 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>$total, "unit" => "m3"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "2" {
  								#Water
  								my ($usage)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  								my ($total)= ($f->{"Counter"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								my $totalm3=ceil($total);
  								my $usagem3=ceil($usage/1000);
  								my $feeds={"id" => $f->{"idx"}, "name" => "$name", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usagem3", "unit" => "m3", "graphable" => "true"} );
  								 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$totalm3", "unit" => "m3"} );
  								push (@{$feed->{'devices'}}, $feeds );
  								#Water by liter
  								my $usage2=$usage; #move to liters
  								$feeds={"id" => $f->{"idx"}."_l", "name" => $name."_l", "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$usage2", "unit"=> "L"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "3" {
  								if ($f->{"SubType"} eq "RFXMeter counter") {
  									#Counter
  									$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  									my ($v)=($f->{"Counter"}=~/^([^\s]+)/);
  									push (@{$feeds->{'params'}}, {"key" => "Watts", "value" => "$v"} );
  									push (@{$feed->{'devices'}}, $feeds );
  								} else {
  									push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  								}
  							}
  							else {
  								push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  							}
  						}
  					}
  					case "General"  {
  						$room_tab{"Utility"}=1;
  						switch($f->{"SubType"}) {
  							case "Percentage" {
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "%", "graphable" => "true"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "Voltage" {
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "V"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "kWh" {
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  								my $usage;
  								($usage)= ($f->{"Usage"} =~ /^(\d+\.\d+) Watt/);
  								push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "kWh", "graphable" => "false"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "Pressure" {
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevPressure", "room" => "Temp", params =>[]};
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "mbar", "graphable" => "true"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							} 
  							case "Visibility" {
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Temp", params =>[]};
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "km"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							} 
  							case "Solar Radiation" {
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Temp", params =>[]};
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "Watt/m2"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case ["Text","Alert","Unknown"] {	   
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  									my $v= $f->{"Data"};
  									push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => ""} );
  									push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "Sound Level" {	   
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+) dB/);
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevNoise", "room" => "Utility", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "dB", graphable => "true"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							else { 
  								push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  							}
  						}
  					}
  					case "Thermostat" {
  						$room_tab{"Temp"}=1;
  						if ($f->{"SubType"} eq "SetPoint") {
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevThermostat", "room" => "Temp", params =>[]};
  							my ($v)= ($f->{"SetPoint"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "cursetpoint", "value" => "$v"});
  							push (@{$feeds->{'params'}}, {"key" => "curtemp", "value" => "$v", "unit"=>$t_unit} );
  							push (@{$feeds->{'params'}}, {"key" => "step", "value" => "0.5"} );
  							push (@{$feeds->{'params'}}, {"key" => "curmode", "value" => "default"} );
  							push (@{$feeds->{'params'}}, {"key" => "availablemodes", "value" => "default"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} else {
  							push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  						}
  					} 
  					else {
  						#catchall
  						if ($f->{"idx"}>5) {push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  						}					
  					}
  				}
  			}
  
  			#Unknown device list
  			my $ind_unk=2;
  			foreach my $devt ( @unk_dev)  {
  				my $feeds={"id" => "S".$ind_unk++, "name" => "$devt", "type" => "DevGenericSensor", "room" => "", params =>[]};
  				push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"unk", "unit"=> "", "graphable" => "false"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			}
  		} else {
  			my $feeds={"id" => "S00", "name" => "Unable to decode URL", "type" => "DevGenericSensor",  params =>[]};
  			my $ver=config->{domo_path};
  			push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$ver", "unit"=> "", "graphable" => "false"} );
  			push (@{$feed->{'devices'}}, $feeds );
  			$feeds={"id" => "S01", "name" => "Please add this gateway in Setup/settings/Local Networks", "type" => "DevGenericSensor",  params =>[]};
  			push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"", "unit"=> "", "graphable" => "false"} );
  			push (@{$feed->{'devices'}}, $feeds );
  		}
  	} else {
  		my $feeds={"id" => "S00", "name" => "Unable to connect to Domoticz", "type" => "DevGenericSensor",  params =>[]};
  		my $ver=config->{domo_path};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$ver", "unit"=> "", "graphable" => "false"} );
  		push (@{$feed->{'devices'}}, $feeds );
  		$feeds={"id" => "S01", "name" => "Please add this gateway in Setup/settings/Local Networks", "type" => "DevGenericSensor",  params =>[]};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"", "unit"=> "", "graphable" => "false"} );
  		push (@{$feed->{'devices'}}, $feeds );
  	}
  
  	#MPD
  	if ($mpd_host ne '') {
  		$mpd=Audio::MPD->new ( host => $mpd_host);
  		$room_tab{"Music"}=1;
  	}
  	#Status
  	if ($mpd_host) {
  		my $status = $mpd->status;
  		my $song = $mpd->current;
  		my $feeds={"id" => "V2", "name" => $song->artist." - ".$song->album, "type" => "DevMultiSwitch", "room" => "Volumio", params =>[]};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>$status->state, "unit"=> "", "graphable" => "false"} );
  		push (@{$feeds->{'params'}}, {"key" => "Choices", "value" => "play,stop,pause,next,prev,volumeUP,volumeDOWN"});
  		push (@{$feed->{'devices'}}, $feeds );
  	}
  
  	#Get Scenes
  	$system_url=config->{domo_path}."/json.htm?type=scenes";
  	$json = $ua->get( $system_url );
  	#warn "Could not get $system_url!" unless defined $json;
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			$room_tab{"Scene"}=1;
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  					my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  	#	debug($dt->strftime("%Y-%m-%d %H:%M:%S"));
  					my $name=$f->{"Name"};
  					$name=~s/%/P/;
  					#DevScene       Scene (launchable)
  					#LastRun        Date of last run        N/A
  					#"idx" : "3", "Name" : "Alerte", "Type" : "Scenes", "LastUpdate" : "2014-03-18 22:17:18"
  					if ($f->{"Type"} eq "Group") {
  						my $feeds={"id" => "S".$f->{"idx"}, "name" => $name, "type" => "DevMultiSwitch", "room" => "Scenes", params =>[]};
  						my $v=$dt->strftime("%Y-%m-%d %H:%M:%S");
  						push (@{$feeds->{'params'}}, {"key" => "LastRun", "value" => "$v"} );
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => $f->{"Status"}} );
  						push (@{$feeds->{'params'}}, {"key" => "Choices", "value" => "Mixed,On,Off"} );
  						push (@{$feed->{'devices'}}, $feeds );
  
  					} else {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevScene", "room" => "Scenes", params =>[]};
  						my $v=$dt->strftime("%Y-%m-%d %H:%M:%S");
  						push (@{$feeds->{'params'}}, {"key" => "LastRun", "value" => "$v"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  			}
  		}
  	}
  	#Get Camera
  	$system_url=config->{domo_path}."/json.htm?type=cameras";
  debug($system_url);
  	$json = $ua->get( $system_url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  					my $name=$f->{"Name"};
  					$name=~s/\s/_/;
  					$name=~s/\s/_/;
  					$name=~s/\//_/;
  					$name=~s/%/P/;
  					my $feeds={"id" => $f->{"idx"}."_cam", "name" => $name, "type" => "DevCamera", "room" => "Switches", params =>[]};
  					my $v=$f->{"ImageURL"};my $v2=config->{external_url_camera};my $v3=$f->{"VideoURL"};
  					if ($v =~ /^http/) {
  						push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  					} else {
  						if ($f->{"Username"}) {
  							$v="http://".$f->{"Username"}.":".$f->{"Password"}."@".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"ImageURL"};
  							push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  						} else {
  							$v="http://".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"ImageURL"};
  							push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  	
  						}
  					}
  					if ($v2) {push (@{$feeds->{'params'}}, {"key" => "remotejpegurl", "value" => "$v2"} );}
  					push (@{$feed->{'devices'}}, $feeds );
  					# Now if VideoURL
  					if ($v3) {
  						my $feeds2={"id" => $f->{"idx"}."_video", "name" => $name, "type" => "DevCamera", "room" => "Switches", params =>[]};
  						if ($f->{"Username"}) {
  							$v="http://".$f->{"Username"}.":".$f->{"Password"}."@".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"VideoURL"};
  							push (@{$feeds2->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  							} else {
  							$v="http://".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"VideoURL"};
  							push (@{$feeds2->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  							}
  						push (@{$feed->{'devices'}}, $feeds2 );
  						}
  			}
  		}
  	}
  	#DevGenericSensor      Generic sensor (any value)
  	#Value  Current value   N/A
  
  	return to_json($feed, { utf8 => 0} );
  	return { success => true};
  };
  
  sub getDeviceType($) {
  	my ($deviceId)=@_;
  	my $url=config->{domo_path}."/json.htm?type=devices&rid=$deviceId";
  	my $decoded;
  	my @results;
  debug($url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  				if ($f->{SubType} eq "RFXMeter counter") {
  					return("counter");
  				} else {
  					return($f->{Type});
  				}
  			}
  		}
  	}
  }
  sub getLastVersion() {
  	my $dt = DateTime->now;
  	if ($last_version_dt < $dt->add( hours => 4 )) {
  		my @res;
  		push @res,$last_version;
  		push @res,"";
  		return(@res);
  	} else {
  		my $url="https://api.github.com/repos/empierre/MyDomoAtHome/releases/latest";
  		my $decoded;
  		my @results;
  	debug($url);
  		my $ua = LWP::UserAgent->new();
  		$ua->agent("MyDomoREST/$VERSION");
  		my $json = $ua->get( $url );
  		if ($json->is_success) {
  			# Decode the entire JSON
  			$decoded = JSON->new->utf8(0)->decode( $json->decoded_content );
  			if ($decoded) {
  				my @res;
  				push @res,$decoded->{tag_name};
  				push @res,$decoded->{body};
  				$last_version_dt=DateTime->now;
  				$last_version=$decoded->{tag_name};
  				return(@res);
  			}
  		} else {return "err";}
  	}
  }
  1;
DOMO2

$fatpacked{"HTTP/Headers/Fast.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_HEADERS_FAST';
  package HTTP::Headers::Fast;
  use strict;
  use warnings;
  use 5.00800;
  use Carp ();
  
  our $VERSION = '0.19';
  
  our $TRANSLATE_UNDERSCORE = 1;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  # yappo says "Readonly sucks".
  my $OP_GET    = 0;
  my $OP_SET    = 1;
  my $OP_INIT   = 2;
  my $OP_PUSH   = 3;
  
  my @general_headers = qw(
    Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
    Via Warning
  );
  
  my @request_headers = qw(
    Accept Accept-Charset Accept-Encoding Accept-Language
    Authorization Expect From Host
    If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
    Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
    Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
    Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
    Allow Content-Encoding Content-Language Content-Length Content-Location
    Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order =
    ( @general_headers, @request_headers, @response_headers, @entity_headers, );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  our %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
          my $lc = lc $_;
          $header_order{$lc}  = ++$i;
          $standard_case{$lc} = $_;
      }
  }
  
  sub new {
      my ($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_;    # set up initial headers
      $self;
  }
  
  sub isa {
      my ($self, $klass) = @_;
      my $proto = ref $self || $self;
      return ($proto eq $klass || $klass eq 'HTTP::Headers') ? 1 : 0;
  }
  
  sub header {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my (@old);
  
      if (@_ == 1) {
          @old = $self->_header_get(@_);
      } elsif( @_ == 2 ) {
          @old = $self->_header_set(@_);
      } else {
          my %seen;
          while (@_) {
              my $field = shift;
              if ( $seen{ lc $field }++ ) {
                  @old = $self->_header_push($field, shift);
              } else {
                  @old = $self->_header_set($field, shift);
              }
          }
      }
      return @old    if wantarray;
      return $old[0] if @old <= 1;
      join( ", ", @old );
  }
  
  sub clear {
      my $self = shift;
      %$self = ();
  }
  
  sub push_header {
      my $self = shift;
  
      if (@_ == 2) {
          my ($field, $val) = @_;
          $field = _standardize_field_name($field) unless $field =~ /^:/;
  
          my $h = $self->{$field};
          if (!defined $h) {
              $h = [];
              $self->{$field} = $h;
          } elsif (ref $h ne 'ARRAY') {
              $h = [ $h ];
              $self->{$field} = $h;
          }
      
          push @$h, ref $val ne 'ARRAY' ? $val : @$val;
      } else {
          while ( my ($field, $val) = splice( @_, 0, 2 ) ) {
              $field = _standardize_field_name($field) unless $field =~ /^:/;
  
              my $h = $self->{$field};
              if (!defined $h) {
                  $h = [];
                  $self->{$field} = $h;
              } elsif (ref $h ne 'ARRAY') {
                  $h = [ $h ];
                  $self->{$field} = $h;
              }
      
              push @$h, ref $val ne 'ARRAY' ? $val : @$val;
          }
      }
      return ();
  }
  
  sub init_header {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header( @_, $OP_INIT );
  }
  
  sub remove_header {
      my ( $self, @fields ) = @_;
      my $field;
      my @values;
      for my $field (@fields) {
          $field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
          my $v = delete $self->{ lc $field };
          push( @values, ref($v) eq 'ARRAY' ? @$v : $v ) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers {
      my $self = shift;
      unless ( defined(wantarray) ) {
  
          # fast branch that does not create return object
          delete @$self{ grep $entity_header{$_} || /^content-/, keys %$self };
          return;
      }
  
      my $c = ref($self)->new;
      for my $f ( grep $entity_header{$_} || /^content-/, keys %$self ) {
          $c->{$f} = delete $self->{$f};
      }
      $c;
  }
  
  my %field_name;
  sub _standardize_field_name {
      my $field = shift;
  
      $field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
      if (my $cache = $field_name{$field}) {
          return $cache;
      }
  
      my $old = $field;
      $field = lc $field;
      unless ( defined $standard_case{$field} ) {
          # generate a %standard_case entry for this field
          $old =~ s/\b(\w)/\u$1/g;
          $standard_case{$field} = $old;
      }
      $field_name{$old} = $field;
      return $field;
  }
  
  sub _header_get {
      my ($self, $field, $skip_standardize) = @_;
  
      $field = _standardize_field_name($field) unless $skip_standardize || $field =~ /^:/;
  
      my $h = $self->{$field};
      return (ref($h) eq 'ARRAY') ? @$h : ( defined($h) ? ($h) : () );
  }
  
  sub _header_set {
      my ($self, $field, $val) = @_;
  
      $field = _standardize_field_name($field) unless $field =~ /^:/;
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : ( defined($h) ? ($h) : () );
      if ( defined($val) ) {
          if (ref $val eq 'ARRAY' && scalar(@$val) == 1) {
              $val = $val->[0];
          }
          $self->{$field} = $val;
      } else {
          delete $self->{$field};
      }
      return @old;
  }
  
  sub _header_push {
      my ($self, $field, $val) = @_;
  
      $field = _standardize_field_name($field) unless $field =~ /^:/;
  
      my $h = $self->{$field};
      if (ref($h) eq 'ARRAY') {
          my @old = @$h;
          push @$h, ref $val ne 'ARRAY' ? $val : @$val;
          return @old;
      } elsif (defined $h) {
          $self->{$field} = [$h, ref $val ne 'ARRAY' ? $val : @$val ];
          return ($h);
      } else {
          $self->{$field} = ref $val ne 'ARRAY' ? $val : @$val;
          return ();
      }
  }
  
  sub _header {
      my ($self, $field, $val, $op) = @_;
  
      $field = _standardize_field_name($field) unless $field =~ /^:/;
  
      $op ||= defined($val) ? $OP_SET : $OP_GET;
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : ( defined($h) ? ($h) : () );
  
      unless ( $op == $OP_GET || ( $op == $OP_INIT && @old ) ) {
          if ( defined($val) ) {
              my @new = ( $op == $OP_PUSH ) ? @old : ();
              if ( ref($val) ne 'ARRAY' ) {
                  push( @new, $val );
              }
              else {
                  push( @new, @$val );
              }
              $self->{$field} = @new > 1 ? \@new : $new[0];
          }
          elsif ( $op != $OP_PUSH ) {
              delete $self->{$field};
          }
      }
      @old;
  }
  
  sub _sorted_field_names {
      my $self = shift;
      return [ sort {
          ( $header_order{$a} || 999 ) <=> ( $header_order{$b} || 999 )
            || $a cmp $b
      } keys %$self ];
  }
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $_, @{ $self->_sorted_field_names }
        if wantarray;
      return keys %$self;
  }
  
  sub scan {
      my ( $self, $sub ) = @_;
      for my $key (@{ $self->_sorted_field_names }) {
          next if substr($key, 0, 1) eq '_';
          my $vals = $self->{$key};
          if ( ref($vals) eq 'ARRAY' ) {
              for my $val (@$vals) {
                  $sub->( $standard_case{$key} || $key, $val );
              }
          }
          else {
              $sub->( $standard_case{$key} || $key, $vals );
          }
      }
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # intial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  sub _as_string {
      my ($self, $endl, $fieldnames) = @_;
  
      my @result;
      for my $key ( @$fieldnames ) {
          next if index($key, '_') == 0;
          my $vals = $self->{$key};
          if ( ref($vals) eq 'ARRAY' ) {
              for my $val (@$vals) {
                  my $field = $standard_case{$key} || $key;
                  $field =~ s/^://;
                  if ( index($val, "\n") >= 0 ) {
                      $val = _process_newline($val, $endl);
                  }
                  push @result, $field . ': ' . $val;
              }
          } else {
              my $field = $standard_case{$key} || $key;
              $field =~ s/^://;
              if ( index($vals, "\n") >= 0 ) {
                  $vals = _process_newline($vals, $endl);
              }
              push @result, $field . ': ' . $vals;
          }
      }
  
      join( $endl, @result, '' );
  }
  
  sub as_string {
      my ( $self, $endl ) = @_;
      $endl = "\n" unless defined $endl;
      $self->_as_string($endl, $self->_sorted_field_names);
  }
  
  sub as_string_without_sort {
      my ( $self, $endl ) = @_;
      $endl = "\n" unless defined $endl;
      $self->_as_string($endl, [keys(%$self)]);
  }
  
  {
      my $storable_required;
      sub clone {
          unless ($storable_required) {
              require Storable;
              $storable_required++;
          }
          goto &Storable::dclone;
      }
  }
  
  sub _date_header {
      require HTTP::Date;
      my ( $self, $header, $time ) = @_;
      my $old;
      if ( defined $time ) {
          ($old) = $self->_header_set( $header, HTTP::Date::time2str($time) );
      } else {
          ($old) = $self->_header_get($header, 1);
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  sub date                { shift->_date_header( 'date',                @_ ); }
  sub expires             { shift->_date_header( 'expires',             @_ ); }
  sub if_modified_since   { shift->_date_header( 'if-modified-since',   @_ ); }
  sub if_unmodified_since { shift->_date_header( 'if-unmodified-since', @_ ); }
  sub last_modified       { shift->_date_header( 'last-modified',       @_ ); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date { shift->_date_header( 'client-date', @_ ); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type {
      my $self = shift;
      my $ct   = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split( /;\s*/, $ct, 2 );
      for ( $ct[0] ) {
          s/\s+//g;
          $_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = _split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
  
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml"
        || $ct   eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer {
      my $self = shift;
      if ( @_ && $_[0] =~ /#/ ) {
  
          # Strip fragment per RFC 2616, section 14.36.
          my $uri = shift;
          if ( ref($uri) ) {
              $uri = $uri->clone;
              $uri->fragment(undef);
          }
          else {
              $uri =~ s/\#.*//;
          }
          unshift @_, $uri;
      }
      ( $self->_header( 'Referer', @_ ) )[0];
  }
  *referrer = \&referer;    # on tchrist's request
  
  for my $key (qw/content-length content-language content-encoding title user-agent server from warnings www-authenticate authorization proxy-authenticate proxy-authorization/) {
      no strict 'refs';
      (my $meth = $key) =~ s/-/_/g;
      *{$meth} = sub {
          my $self = shift;
          if (@_) {
              ( $self->_header_set( $key, @_ ) )[0]
          } else {
              my $h = $self->{$key};
              (ref($h) eq 'ARRAY') ? $h->[0] : $h;
          }
      };
  }
  
  sub authorization_basic { shift->_basic_auth( "Authorization", @_ ) }
  sub proxy_authorization_basic {
      shift->_basic_auth( "Proxy-Authorization", @_ );
  }
  
  sub _basic_auth {
      require MIME::Base64;
      my ( $self, $h, $user, $passwd ) = @_;
      my ($old) = $self->_header($h);
      if ( defined $user ) {
          Carp::croak("Basic authorization user name can't contain ':'")
            if $user =~ /:/;
          $passwd = '' unless defined $passwd;
          $self->_header(
              $h => 'Basic ' . MIME::Base64::encode( "$user:$passwd", '' ) );
      }
      if ( defined $old && $old =~ s/^\s*Basic\s+// ) {
          my $val = MIME::Base64::decode($old);
          return $val unless wantarray;
          return split( /:/, $val, 2 );
      }
      return;
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  HTTP::Headers::Fast - faster implementation of HTTP::Headers
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Fast;
    # and, same as HTTP::Headers.
  
  =head1 DESCRIPTION
  
  HTTP::Headers::Fast is a perl class for parsing/writing HTTP headers.
  
  The interface is same as HTTP::Headers.
  
  =head1 WHY YET ANOTHER ONE?
  
  HTTP::Headers is a very good. But I needed a faster implementation, fast  =)
  
  =head1 ADDITIONAL METHODS
  
  =over 4
  
  =item as_string_without_sort
  
  as_string method sorts the header names.But, sorting is bit slow.
  
  In this method, stringify the instance of HTTP::Headers::Fast without sorting.
  
  =back
  
  =head1 @ISA HACK
  
  If you want HTTP::Headers::Fast to pretend like it's really HTTP::Headers, you can try the following hack:
  
      unshift @HTTP::Headers::Fast::ISA, 'HTTP::Headers';
  
  =head1 BENCHMARK
  
      HTTP::Headers 5.818, HTTP::Headers::Fast 0.01
  
      -- push_header
              Rate orig fast
      orig 144928/s   -- -20%
      fast 181818/s  25%   --
  
      -- push_header_many
              Rate orig fast
      orig 74627/s   -- -16%
      fast 89286/s  20%   --
  
      -- get_date
              Rate orig fast
      orig 34884/s   -- -14%
      fast 40541/s  16%   --
  
      -- set_date
              Rate orig fast
      orig 21505/s   -- -19%
      fast 26525/s  23%   --
  
      -- scan
              Rate orig fast
      orig 57471/s   --  -1%
      fast 57803/s   1%   --
  
      -- get_header
              Rate orig fast
      orig 120337/s   -- -24%
      fast 157729/s  31%   --
  
      -- set_header
              Rate orig fast
      orig  79745/s   -- -30%
      fast 113766/s  43%   --
  
      -- get_content_length
              Rate orig fast
      orig 182482/s   -- -77%
      fast 793651/s 335%   --
  
      -- as_string
              Rate orig fast
      orig 23753/s   -- -41%
      fast 40161/s  69%   --
  
  =head1 AUTHOR
  
      Tokuhiro Matsuno E<lt>tokuhirom@gmail.comE<gt>
      Daisuke Maki
  
  And HTTP::Headers' originally written by Gisle Aas.
  
  =head1 THANKS TO
  
  Markstos
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
HTTP_HEADERS_FAST

$fatpacked{"HTTP/Message/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_MESSAGE_PSGI';
  package HTTP::Message::PSGI;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw( req_to_psgi res_from_psgi );
  
  use Carp ();
  use HTTP::Status qw(status_message);
  use URI::Escape ();
  use Plack::Util;
  use Try::Tiny;
  
  my $TRUE  = (1 == 1);
  my $FALSE = !$TRUE;
  
  sub req_to_psgi {
      my $req = shift;
  
      unless (try { $req->isa('HTTP::Request') }) {
          Carp::croak("Request is not HTTP::Request: $req");
      }
  
      # from HTTP::Request::AsCGI
      my $host = $req->header('Host');
      my $uri  = $req->uri->clone;
      $uri->scheme('http')    unless $uri->scheme;
      $uri->host('localhost') unless $uri->host;
      $uri->port(80)          unless $uri->port;
      $uri->host_port($host)  unless !$host || ( $host eq $uri->host_port );
  
      my $input;
      my $content = $req->content;
      if (ref $content eq 'CODE') {
          if (defined $req->content_length) {
              $input = HTTP::Message::PSGI::ChunkedInput->new($content);
          } else {
              $req->header("Transfer-Encoding" => "chunked");
              $input = HTTP::Message::PSGI::ChunkedInput->new($content, 1);
          }
      } else {
          open $input, "<", \$content;
          $req->content_length(length $content)
              unless defined $req->content_length;
      }
  
      my $env = {
          PATH_INFO         => URI::Escape::uri_unescape($uri->path || '/'),
          QUERY_STRING      => $uri->query || '',
          SCRIPT_NAME       => '',
          SERVER_NAME       => $uri->host,
          SERVER_PORT       => $uri->port,
          SERVER_PROTOCOL   => $req->protocol || 'HTTP/1.1',
          REMOTE_ADDR       => '127.0.0.1',
          REMOTE_HOST       => 'localhost',
          REMOTE_PORT       => int( rand(64000) + 1000 ),                   # not in RFC 3875
          REQUEST_URI       => $uri->path_query || '/',                     # not in RFC 3875
          REQUEST_METHOD    => $req->method,
          'psgi.version'      => [ 1, 1 ],
          'psgi.url_scheme'   => $uri->scheme eq 'https' ? 'https' : 'http',
          'psgi.input'        => $input,
          'psgi.errors'       => *STDERR,
          'psgi.multithread'  => $FALSE,
          'psgi.multiprocess' => $FALSE,
          'psgi.run_once'     => $TRUE,
          'psgi.streaming'    => $TRUE,
          'psgi.nonblocking'  => $FALSE,
          @_,
      };
  
      for my $field ( $req->headers->header_field_names ) {
          my $key = uc("HTTP_$field");
          $key =~ tr/-/_/;
          $key =~ s/^HTTP_// if $field =~ /^Content-(Length|Type)$/;
  
          unless ( exists $env->{$key} ) {
              $env->{$key} = $req->headers->header($field);
          }
      }
  
      if ($env->{SCRIPT_NAME}) {
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E/\//;
          $env->{PATH_INFO} =~ s/^\/+/\//;
      }
  
      if (!defined($env->{HTTP_HOST}) && $req->uri->can('host')) {
          $env->{HTTP_HOST} = $req->uri->host;
          $env->{HTTP_HOST} .= ':' . $req->uri->port
              if $req->uri->port ne $req->uri->default_port;
      }
  
      return $env;
  }
  
  sub res_from_psgi {
      my ($psgi_res) = @_;
  
      require HTTP::Response;
  
      my $res;
      if (ref $psgi_res eq 'ARRAY') {
          _res_from_psgi($psgi_res, \$res);
      } elsif (ref $psgi_res eq 'CODE') {
          $psgi_res->(sub {
              _res_from_psgi($_[0], \$res);
          });
      } else {
          Carp::croak("Bad response: ", defined $psgi_res ? $psgi_res : 'undef');
      }
  
      return $res;
  }
  
  sub _res_from_psgi {
      my ($status, $headers, $body) = @{+shift};
      my $res_ref = shift;
  
      my $convert_resp = sub {
          my $res = HTTP::Response->new($status);
          $res->message(status_message($status));
          $res->headers->header(@$headers) if @$headers;
  
          if (ref $body eq 'ARRAY') {
              $res->content(join '', grep defined, @$body);
          } else {
              local $/ = \4096;
              my $content = '';
              while (defined(my $buf = $body->getline)) {
                  $content .= $buf;
              }
              $body->close;
              $res->content($content);
          }
  
          ${ $res_ref } = $res;
  
          return;
      };
  
      if (!defined $body) {
          my $o = Plack::Util::inline_object
              write => sub { push @{ $body ||= [] }, @_ },
              close => $convert_resp;
  
          return $o;
      }
  
      $convert_resp->();
  }
  
  sub HTTP::Request::to_psgi {
      req_to_psgi(@_);
  }
  
  sub HTTP::Response::from_psgi {
      my $class = shift;
      res_from_psgi(@_);
  }
  
  package
      HTTP::Message::PSGI::ChunkedInput;
  
  sub new {
      my($class, $content, $chunked) = @_;
  
      my $content_cb;
      if ($chunked) {
          my $done;
          $content_cb = sub {
              my $chunk = $content->();
              return if $done;
              unless (defined $chunk) {
                  $done = 1;
                  return "0\015\012\015\012";
              }
              return '' unless length $chunk;
              return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
          };
      } else {
          $content_cb = $content;
      }
  
      bless { content => $content_cb }, $class;
  }
  
  sub read {
      my $self = shift;
  
      my $chunk = $self->{content}->();
      return 0 unless defined $chunk;
  
      $_[0] = '';
      substr($_[0], $_[2] || 0, length $chunk) = $chunk;
  
      return length $chunk;
  }
  
  sub close { }
  
  package HTTP::Message::PSGI;
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Message::PSGI - Converts HTTP::Request and HTTP::Response from/to PSGI env and response
  
  =head1 SYNOPSIS
  
    use HTTP::Message::PSGI;
  
    # $req is HTTP::Request, $res is HTTP::Response
    my $env = req_to_psgi($req);
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
    # Adds methods to HTTP::Request/Response class as well
    my $env = $req->to_psgi;
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  =head1 DESCRIPTION
  
  HTTP::Message::PSGI gives you convenient methods to convert an L<HTTP::Request>
  object to a PSGI env hash and convert a PSGI response arrayref to
  a L<HTTP::Response> object.
  
  If you want the other way around, see L<Plack::Request> and
  L<Plack::Response>.
  
  =head1 METHODS
  
  =over 4
  
  =item req_to_psgi
  
    my $env = req_to_psgi($req [, $key => $val ... ]);
  
  Converts a L<HTTP::Request> object into a PSGI env hash reference.
  
  =item HTTP::Request::to_psgi
  
    my $env = $req->to_psgi;
  
  Same as C<req_to_psgi> but an instance method in L<HTTP::Request>.
  
  =item res_from_psgi
  
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
  Creates a L<HTTP::Response> object from a PSGI response array ref.
  
  =item HTTP::Response->from_psgi
  
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  Same as C<res_from_psgi>, but is a class method in L<HTTP::Response>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Request::AsCGI> L<HTTP::Message> L<Plack::Test>
  
  =cut
  
HTTP_MESSAGE_PSGI

$fatpacked{"HTTP/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_SERVER_PSGI';
  package HTTP::Server::PSGI;
  use strict;
  use warnings;
  
  use Carp ();
  use Plack;
  use Plack::HTTPParser qw( parse_http_request );
  use IO::Socket::INET;
  use HTTP::Date;
  use HTTP::Status;
  use List::Util qw(max sum);
  use Plack::Util;
  use Stream::Buffered;
  use Plack::Middleware::ContentLength;
  use POSIX qw(EINTR);
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  use Try::Tiny;
  use Time::HiRes qw(time);
  
  my $alarm_interval;
  BEGIN {
      if ($^O eq 'MSWin32') {
          $alarm_interval = 1;
      } else {
          Time::HiRes->import('alarm');
          $alarm_interval = 0.1;
      }
  }
  
  use constant MAX_REQUEST_SIZE => 131072;
  use constant MSWin32          => $^O eq 'MSWin32';
  
  sub new {
      my($class, %args) = @_;
  
      my $self = bless {
          host               => $args{host} || 0,
          port               => $args{port} || 8080,
          timeout            => $args{timeout} || 300,
          server_software    => $args{server_software} || $class,
          server_ready       => $args{server_ready} || sub {},
          ssl                => $args{ssl},
          ipv6               => $args{ipv6},
          ssl_key_file       => $args{ssl_key_file},
          ssl_cert_file      => $args{ssl_cert_file},
      }, $class;
  
      $self;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->setup_listener();
      $self->accept_loop($app);
  }
  
  sub prepare_socket_class {
      my($self, $args) = @_;
  
      if ($self->{ssl} && $self->{ipv6}) {
          Carp::croak("SSL and IPv6 are not supported at the same time (yet). Choose one.");
      }
  
      if ($self->{ssl}) {
          eval { require IO::Socket::SSL; 1 }
              or Carp::croak("SSL suport requires IO::Socket::SSL");
          $args->{SSL_key_file}  = $self->{ssl_key_file};
          $args->{SSL_cert_file} = $self->{ssl_cert_file};
          return "IO::Socket::SSL";
      } elsif ($self->{ipv6}) {
          eval { require IO::Socket::IP; 1 }
              or Carp::croak("IPv6 support requires IO::Socket::IP");
          $self->{host}      ||= '::';
          $args->{LocalAddr} ||= '::';
          return "IO::Socket::IP";
      }
  
      return "IO::Socket::INET";
  }
  
  sub setup_listener {
      my $self = shift;
  
      my %args = (
          Listen    => SOMAXCONN,
          LocalPort => $self->{port},
          LocalAddr => $self->{host},
          Proto     => 'tcp',
          ReuseAddr => 1,
      );
  
      my $class = $self->prepare_socket_class(\%args);
      $self->{listen_sock} ||= $class->new(%args)
          or die "failed to listen to port $self->{port}: $!";
  
      $self->{server_ready}->({ %$self, proto => $self->{ssl} ? 'https' : 'http' });
  }
  
  sub accept_loop {
      my($self, $app) = @_;
  
      $app = Plack::Middleware::ContentLength->wrap($app);
  
      while (1) {
          local $SIG{PIPE} = 'IGNORE';
          if (my $conn = $self->{listen_sock}->accept) {
              $conn->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
                  or die "setsockopt(TCP_NODELAY) failed:$!";
              my $env = {
                  SERVER_PORT => $self->{port},
                  SERVER_NAME => $self->{host},
                  SCRIPT_NAME => '',
                  REMOTE_ADDR => $conn->peerhost,
                  REMOTE_PORT => $conn->peerport || 0,
                  'psgi.version' => [ 1, 1 ],
                  'psgi.errors'  => *STDERR,
                  'psgi.url_scheme' => $self->{ssl} ? 'https' : 'http',
                  'psgi.run_once'     => Plack::Util::FALSE,
                  'psgi.multithread'  => Plack::Util::FALSE,
                  'psgi.multiprocess' => Plack::Util::FALSE,
                  'psgi.streaming'    => Plack::Util::TRUE,
                  'psgi.nonblocking'  => Plack::Util::FALSE,
                  'psgix.harakiri'    => Plack::Util::TRUE,
                  'psgix.input.buffered' => Plack::Util::TRUE,
                  'psgix.io'          => $conn,
              };
  
              $self->handle_connection($env, $conn, $app);
              $conn->close;
              last if $env->{'psgix.harakiri.commit'};
          }
      }
  }
  
  sub handle_connection {
      my($self, $env, $conn, $app) = @_;
  
      my $buf = '';
      my $res = [ 400, [ 'Content-Type' => 'text/plain' ], [ 'Bad Request' ] ];
  
      while (1) {
          my $rlen = $self->read_timeout(
              $conn, \$buf, MAX_REQUEST_SIZE - length($buf), length($buf),
              $self->{timeout},
          ) or return;
          my $reqlen = parse_http_request($buf, $env);
          if ($reqlen >= 0) {
              $buf = substr $buf, $reqlen;
              if (my $cl = $env->{CONTENT_LENGTH}) {
                  my $buffer = Stream::Buffered->new($cl);
                  while ($cl > 0) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, $cl, 0, $self->{timeout})
                              or return;
                      }
                      $buffer->print($chunk);
                      $cl -= length $chunk;
                  }
                  $env->{'psgi.input'} = $buffer->rewind;
              } else {
                  open my $input, "<", \$buf;
                  $env->{'psgi.input'} = $input;
              }
  
              $res = Plack::Util::run_app $app, $env;
              last;
          }
          if ($reqlen == -2) {
              # request is incomplete, do nothing
          } elsif ($reqlen == -1) {
              # error, close conn
              last;
          }
      }
  
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res, $conn);
      } elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0], $conn);
          });
      } else {
          die "Bad response $res";
      }
  
      return;
  }
  
  sub _handle_response {
      my($self, $res, $conn) = @_;
  
      my @lines = (
          "Date: @{[HTTP::Date::time2str()]}\015\012",
          "Server: $self->{server_software}\015\012",
      );
  
      Plack::Util::header_iter($res->[1], sub {
          my ($k, $v) = @_;
          push @lines, "$k: $v\015\012";
      });
  
      unshift @lines, "HTTP/1.0 $res->[0] @{[ HTTP::Status::status_message($res->[0]) ]}\015\012";
      push @lines, "\015\012";
  
      $self->write_all($conn, join('', @lines), $self->{timeout})
          or return;
  
      if (defined $res->[2]) {
          my $err;
          my $done;
          {
              local $@;
              eval {
                  Plack::Util::foreach(
                      $res->[2],
                      sub {
                          $self->write_all($conn, $_[0], $self->{timeout})
                              or die "failed to send all data\n";
                      },
                  );
                  $done = 1;
              };
              $err = $@;
          };
          unless ($done) {
              if ($err =~ /^failed to send all data\n/) {
                  return;
              } else {
                  die $err;
              }
          }
      } else {
          return Plack::Util::inline_object
              write => sub { $self->write_all($conn, $_[0], $self->{timeout}) },
              close => sub { };
      }
  }
  
  # returns 1 if socket is ready, undef on timeout
  sub do_timeout {
      my ($self, $cb, $timeout) = @_;
      local $SIG{ALRM} = sub {};
      my $wait_until = time + $timeout;
      alarm($timeout);
      my $ret;
      while (1) {
          if ($ret = $cb->()) {
              last;
          } elsif (! (! defined($ret) && $! == EINTR)) {
              undef $ret;
              last;
          }
          # got EINTR
          my $left = $wait_until - time;
          last if $left <= 0;
          alarm($left + $alarm_interval);
      }
      alarm(0);
      $ret;
  }
  
  # returns (positive) number of bytes read, or undef if the socket is to be closed
  sub read_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->sysread($$buf, $len, $off) }, $timeout);
  }
  
  # returns (positive) number of bytes written, or undef if the socket is to be closed
  sub write_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->syswrite($buf, $len, $off) }, $timeout);
  }
  
  # writes all data in buf and returns number of bytes written or undef if failed
  sub write_all {
      my ($self, $sock, $buf, $timeout) = @_;
      return 0 unless defined $buf;
      _encode($buf);
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $ret = $self->write_timeout($sock, $buf, $len, $off, $timeout)
              or return;
          $off += $ret;
      }
      return length $buf;
  }
  
  # syswrite() will crash when given wide characters
  sub _encode {
      if ($_[0] =~ /[^\x00-\xff]/) {
          Carp::carp("Wide character outside byte range in response. Encoding data as UTF-8");
          utf8::encode($_[0]);
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Server::PSGI - Standalone PSGI compatible HTTP server
  
  =head1 SYNOPSIS
  
    use HTTP::Server::PSGI;
  
    my $server = HTTP::Server::PSGI->new(
        host => "127.0.0.1",
        port => 9091,
        timeout => 120,
    );
  
    $server->run($app);
  
  =head1 DESCRIPTION
  
  HTTP::Server::PSGI is a standalone, single-process and PSGI compatible
  HTTP server implementations.
  
  This server should be great for the development and testing, but might
  not be suitable for a production use.
  
  Some features in HTTP/1.1, notably chunked requests, responses and
  pipeline requests are B<NOT> supported, and it also does not support
  HTTP/0.9.
  
  See L<Starman> or uWSGI server if you want HTTP/1.1 and other features
  ready for a production use.
  
  =head1 PREFORKING
  
  L<HTTP::Server::PSGI> does B<NOT> support preforking. See L<Starman>
  or L<Starlet> if you want a multi-process prefork web servers.
  
  =head1 HARAKIRI SUPPORT
  
  This web server supports `psgix.harakiri` extension defined in the
  L<PSGI::Extensions>.
  
  This application is a non-forking single process web server
  (i.e. `psgi.multiprocess` is false), and if your application commits
  harakiri, the entire web server stops too. In case this behavior is
  not what you want, be sure to check `psgi.multiprocess` as well to
  enable harakiri only in the preforking servers such as L<Starman>.
  
  On the other hand, this behavior might be handy if you want to embed
  this module in your application and serve HTTP requests for only short
  period of time, then go back to your main program.
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Standalone> L<Starman> L<Starlet>
  
  =cut
HTTP_SERVER_PSGI

$fatpacked{"MySensors.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MYSENSORS';
  package Domo;
  # This program is free software; you can redistribute it and/or
  # modify it under the terms of the GNU General Public License
  # version 2 as published by the Free Software Foundation.
  # Author: epierre
  use Dancer ':syntax';
  use DBI;
  use File::Spec;
  use File::Slurp;
  use LWP::UserAgent;
  use Crypt::SSLeay;
  use utf8;
  use Time::Piece;
  use Device::SerialPort;
  use IO::Handle;
  use feature     qw< unicode_strings >;
  #use JSON;
  
  our $VERSION = '0.2';
  set warnings => 0;
  set 'database'     => File::Spec->catfile(File::Spec->tmpdir(), 'mysensors.db');
  
  
  set serializer => 'JSON'; 
  prefix undef;
  # USB port opening
  my $ob = &connect_usb(config->{usb_port});
  my $domo_ip = config->{domo_ip};
  my $domo_port = config->{domo_port};
  my %sensor_tab;
  
  get '/' => sub {
      template 'index';
  };
  
  get '/rooms' => sub {
         #Room list
    return {"rooms" => [ 
  		{ "id"=> "noroom", "name"=> "noroom" },
  		{ "id"=> "Switches", "name"=> "Switches" },
  		{ "id"=> "Scenes", "name"=> "Scenes" },
  		{ "id"=> "Temp", "name"=> "Weather" },
  		{ "id"=> "Utility", "name"=> "Utility" },
  			]};
  };
  
  get '/system' => sub {
   return {"id"=> "MyDomoAtHome","apiversion"=> 1};
  };
  
  
  get '/devices/:deviceId/action/:actionName/:actionParam?' => sub {
  my $deviceId = params->{deviceId};
  my $actionName = params->{actionName};
  my $actionParam = params->{actionParam}||"";
  };
  
  get '/message/:radioId/:childId/:messageType/:subType/:payload?' => sub {
  	my $radioId = params->{radioId};
  	my $childId = params->{childId};
  	my $messageType = params->{messageType};
  	my $subType = params->{subType};
  	my $payload = params->{payload}||"0";
  
  	my $dt = DateTime->now;
  	my $date=join ' ', $dt->ymd, $dt->hms;
  	 
  	
  	if ($messageType==4) {
  		#I_RELAY_NODE 		1 255 4 7 0 
  		#I_SKETCH_NAME 		1 255 4 14 Humidity
  		#I_SKETCH_VERSION 	1 255 4 15 1.0
  
  		if ($subType==5) {
  		#Gives a new node its ID
  			my $db = connect_db();
  			my $sql = "insert into device (I_BATTERY_LEVEL,I_RELAY_NODE,I_UNIT) values (100,255,'M')";
  			my $sth = $db->prepare($sql) or die $db->errstr;
  			$sth->execute or die $sth->errstr;
  			#get the id
  			$sql = 'SELECT last_insert_rowid() FROM device';
  			$sth = $db->prepare($sql) or die $db->errstr;
  			$sth->execute or die $sth->errstr;
  			my $row;my $id;while($row = $sth->fetchrow_hashref()) { $id=$row->{id};}			
             	my $msg = "$radioId;$childId;4;5;$id\n";
              my $co = $ob->write($msg);
              if (!$co) {
  					status 'error';
  					return { success => false, errormsg => "USB write failed"};					
  			}
              $ob->write_drain;
  			return { success => true};					
  		}
  		if ($subType==9) {
  		#I_PING
               my $msg = "$radioId;$childId;4;10;\n";
               my $co = $ob->write($msg);
               if (!$co) {
  					status 'error';
  					return { success => false, errormsg => "USB write failed"};					
  			 }
               $ob->write_drain;
  			 return { success => true};					
  		}
  		if ($subType==13) {
  		#Answer we are Metric
  		#I_UNIT 			1 255 4 13 0
               my $msg = "$radioId;$childId;4;13;M\n";
               my $co = $ob->write($msg);
               if (!$co) {
  					status 'error';
  					return { success => false, errormsg => "USB write failed"};					
  			 }
               $ob->write_drain;
  			 return { success => true};					
  		}
      } elsif ($messageType==1) {
  		$sensor_tab{$radioId}->{$subType}=$payload;
  		&update_sensor($radioId,$subType,$payload);
  		if($subType==0) {
  		# Read the Temp value
  	  		 my $hum=$sensor_tab{$radioId}->{1}||0;
  			 next if ($hum<=0);		
  			 `curl -s "http://$domo_ip:$domo_port/json.htm?type=command&param=udevice&idx=164&svalue=$payload;$hum;2" &`;
  			 return { success => true};					
  		}
  		if ($subType==1) {
  			# Read the Humidity value
  			my $temp=$sensor_tab{$radioId}->{0}||0;
  			next if ($temp<=0);
  			`curl -s "http://$domo_ip:$domo_port/json.htm?type=command&param=udevice&idx=164&svalue=$temp;$payload;2" &`;
  			return { success => true};					
  		} 
  	} elsif ($messageType==3) {
  	#Variable Acknowledgments	
  	} elsif ($messageType==0) {
  	#Presentation	
  	#1 255 0 17 1.3b3 (67f4ca1)
  	#S_ARDUINO_NODE		17	Arduino node device
  	#S_ARDUINO_RELAY	18	Arduino relaying node device
  		if ($subType==17) {
  			my $db = connect_db();
  			my $sql = 'insert into sensor (device_id, subtype,version) values (?, ?, ?)';
  			my $sth = $db->prepare($sql) or die $db->errstr;
  			$sth->execute($radioId, ) or die $sth->errstr;
  		}	
  	};
  
  if ($actionName eq 'setStatus') {
          #setStatus	0/1
  	my $action;
  	if ($actionParam eq 0) {
  		$action="Off";
  	} else {
  		$action="On";
  	}
  	my $url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=$action&level=0&passcode=";
  	my $browser = LWP::UserAgent->new;
  	my $response = $browser->get($url);
  	if ($response->is_success){ 
  		return { success => true};
  	} else {
  		status 'error';
  		return { success => false, errormsg => $response->status_line};
  	}
  } elsif ($actionName eq 'setArmed') {
  	#setArmed	0/1
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
  } elsif ($actionName eq 'setAck') {
  	#setAck	
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
  } elsif ($actionName eq 'setLevel') {
  	#setLevel	0-100
  	#/json.htm?type=command&param=switchlight&idx=&switchcmd=Set%20Level&level=6
  	return { success => true};
  } elsif ($actionName eq 'stopShutter') {
  	#stopShutter
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
  } elsif ($actionName eq 'pulseShutter') {
  	#pulseShutter	up/down
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
  } elsif ($actionName eq 'launchScene') {
  	#launchScene
  	#/json.htm?type=command&param=switchscene&idx=&switchcmd=
  	return { success => true};
  } elsif ($actionName eq 'setChoice') {
  	#setChoice string
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
      } else {
          status 'not_found';
          return "What?";
     }
  };
  
  get '/devices' => sub {
  	my $feed={ "devices" => []};
  	my $system_url = config->{domo_path}."/json.htm?type=devices&filter=all&used=true&order=Name";
  debug($system_url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $system_url );
  	warn "Could not get $system_url!" unless defined $json;
  	# Decode the entire JSON
  	my $decoded = JSON->new->utf8(0)->decode( $json->decoded_content );
  	my @results = @{ $decoded->{'result'} };
  	foreach my $f ( @results ) {
  			my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  			my $name=$f->{"Name"};
  			$name=~s/\s/_/;
  			$name=~s/\s/_/;
  			$name=~s/\//_/;
  			$name=~s/%/P/;
  		 if ($f->{"SwitchType"}) {			
  			#print $f->{"idx"} . " " . $f->{"Name"} . " " . $f->{"Status"} . $f->{"LastUpdate"}."\n";
  			$name.="_E";
  			my $bl=$f->{"Status"};my $rbl;
  			if ($bl eq "On") { $rbl=1;}
  			elsif ($bl eq "Off") { $rbl=0;}
  			elsif ($bl eq "Opened") { $rbl=1;}
  			elsif ($bl eq "Closed") { $rbl=0;}
  			else { $rbl=$bl;}
  			if ($f->{"SwitchType"} eq "On/Off") {
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSwitch", "room" => "Switches", params =>[]};
  				push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			} elsif ($f->{"SwitchType"} eq "Dimmer") {
  				#DevDimmer	Dimmable light
  				#Status	Current status : 1 = On / 0 = Off	N/A
  				#Level	Current dim level (0-100)	%
  				#"idx" : "3", "Name" : "Alerte",  "Level" : 0,  "SwitchType" : "Dimmer",  "Status" : "Off","LastUpdate" : "2014-03-18 22:17:18"
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDimmer", "room" => "Switches", params =>[]};
  
  				push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  				push (@{$feeds->{'params'}}, {"key" => "Level", "value" => $f->{"Level"} } );
  
  				push (@{$feed->{'devices'}}, $feeds );
  			} elsif ($f->{"SwitchType"} eq "Motion Sensor") {
  				#DevMotion	Motion security sensor
  				#Status	Current status : 1 = On / 0 = Off	N/A
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevMotion", "room" => "Switches", params =>[]};
  				push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  				push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  				push (@{$feed->{'devices'}}, $feeds );
  			} elsif ($f->{"SwitchType"} eq "Door Lock") {
  				#DevLock	Door / window lock
  				#Status	Current status : 1 = On / 0 = Off	N/A
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDoor", "room" => "Switches", params =>[]};
  				push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  				push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  				push (@{$feed->{'devices'}}, $feeds );
  			}elsif ($f->{"SwitchType"} eq "Smoke Detector") {
  				#DevSmoke	Smoke security sensor
  				#Armable	Ability to arm the device : 1 = Yes / 0 = No	N/A
  				#Ackable	Ability to acknowledge alerts : 1 = Yes / 0 = No	N/A
  				#Armed	Current arming status : 1 = On / 0 = Off	N/A
  				#Tripped	Is the sensor tripped ? (0 = No - 1 = Tripped)	N/A				
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSmoke", "room" => "Switches", params =>[]};
  				push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  				push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  				push (@{$feed->{'devices'}}, $feeds );				
  			}
  			#DevDoor	Door / window security sensor
  			#DevFlood	Flood security sensor
  			#DevCO2Alert	CO2 Alert sensor	
  		} else {
  			if ($f->{"Type"} eq "Energy") {
  				#DevElectricity Electricity consumption sensor
  				#Watts  Current consumption     Watt
  				#ConsoTotal     Current total consumption       kWh
  				#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  				my ($usage)= ($f->{"Usage"} =~ /(\d+) Watt/);
  				my ($total)= ($f->{"Data"} =~ /(\d+).\d+ kWh/);
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  				push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$usage, "unit" => "W"} );
  				 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>$total, "unit" => "kWh"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			} elsif ($f->{"Type"} eq "Current/Energy") {
  				#DevElectricity Electricity consumption sensor
  				#Watts  Current consumption     Watt
  				#ConsoTotal     Current total consumption       kWh
  				#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  				my ($L1,$L2,$L3,$tot)= split(/,/,$f->{"Data"});
  				my ($l1)= ($L1 =~ /(\d+) Watt/);
  				my ($l2)= ($L2 =~ /(\d+) Watt/);
  				my ($l3)= ($L3 =~ /(\d+) Watt/);
  				if ($l1) {	
  					my $feeds={"id" => $f->{"idx"}."_L1", "name" => $name." L1", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  					push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$l1, "unit" => "W"} );
  					push (@{$feed->{'devices'}}, $feeds );
  				}
  				if ($l2) {	
  					my $feeds={"id" => $f->{"idx"}."_L2", "name" => $name." L2", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  					push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$l2, "unit" => "W"} );
  					push (@{$feed->{'devices'}}, $feeds );
  				}
  				if ($l3) {	
  					my $feeds={"id" => $f->{"idx"}."_L3", "name" => $name." L3", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  					push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$l3, "unit" => "W"} );
  					push (@{$feed->{'devices'}}, $feeds );
  				}
  			}  elsif (($f->{"Type"} =~ "Temp")||($f->{"Type"} =~ "Humidity"))  {
  				my @type=split(/ \+ /,$f->{"Type"});
  				my $cnt;
  				foreach my $curs (@type) {
  					$cnt++;
  					if ($curs eq "Temp") {
  						#DevTemperature Temperature sensor
  						#Value  Current temperature     °C
  						#"Temp" : 21.50,  "Type" : "Temp + Humidity" / Type" : "Temp",
  
  						my $feeds={params =>[],"room" => "Temp","type" => "DevTemperature","name" => $name, "id" => $f->{"idx"}."_".$cnt};
  						my $v=$f->{"Temp"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "°C"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($curs eq "Humidity") {
  						#DevHygrometry  Hygro sensor
  						#Value  Current hygro value     %
  						# "Humidity" : 52  "Type" : "Temp + Humidity" / Type" : "Humidity",
  
  						my $feeds={"id" => $f->{"idx"}."_".$cnt, "name" => $name, "type" => "DevHygrometry", "room" => "Temp", params =>[]};
  						my $v=$f->{"Humidity"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "%"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($curs eq "Baro") {
  						#DevPressure    Pressure sensor
  						#Value  Current pressure        mbar
  						#"Barometer" : 1022, "Type" : "Temp + Humidity + Baro"
  						my $feeds={"id" => $f->{"idx"}."_".$cnt, "name" => $name, "type" => "DevPressure", "room" => "Temp", params =>[]};
  						my $v=$f->{"Barometer"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "mbar"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  				}
  			}  elsif ($f->{"Type"} eq "Rain")  {
  				#DevRain        Rain sensor
  				#Value  Current instant rain value      mm/h
  				#Accumulation   Total rain accumulation mm
  				#"Rain" : "0.0", "RainRate" : "0.0", "Type" : "Rain"
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevRain", "room" => "Temp", params =>[]};
  						my $v0=$f->{"RainRate"};
  						my $v1=$f->{"Rain"};
  						push (@{$feeds->{'params'}}, {"key" => "Accumulation", "value" => "$v1", "unit" => "mm"} );
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v0", "unit" => "mm/h"} );
  						push (@{$feed->{'devices'}}, $feeds );
  			} elsif ($f->{"Type"} eq "UV")  {
  				#DevUV  UV sensor
  				#Value  Current UV index        index
  				# "Type" : "UV","UVI" : "6.0"
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevUV", "room" => "Temp", params =>[]};
  				my $v=$f->{"UVI"};
  				push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			}
  
  		}
  
  
  	}; 
  	#Get Scenes
  	$system_url=config->{domo_path}."/json.htm?type=scenes";
  	$json = $ua->get( $system_url );
  	warn "Could not get $system_url!" unless defined $json;
  	if ($json) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(0)->decode( $json->decoded_content );
  		@results = @{ $decoded->{'result'} };
  		foreach my $f ( @results ) {
  				my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  #	debug($dt->strftime("%Y-%m-%d %H:%M:%S"));
  				my $name=$f->{"Name"};
  				$name=~s/\s/_/;
  				$name=~s/\s/_/;
  				$name=~s/\//_/;
  				$name=~s/%/P/;
  				#DevScene       Scene (launchable)
  				#LastRun        Date of last run        N/A
  				#"idx" : "3", "Name" : "Alerte", "Type" : "Scenes", "LastUpdate" : "2014-03-18 22:17:18"
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevScene", "room" => "Scenes", params =>[]};
  				my $v=$dt->strftime("%Y-%m-%d %H:%M:%S");
  				push (@{$feeds->{'params'}}, {"key" => "LastRun", "value" => "$v"} );
  				push (@{$feed->{'devices'}}, $feeds );
  		}
  	}
  	#Get Camera
  	$system_url=config->{domo_path}."/json.htm?type=cameras";
  debug($system_url);
  	$json = $ua->get( $system_url );
  	warn "Could not get $system_url!" unless defined $json;
  	if ($json) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(0)->decode( $json->decoded_content );
  		@results = @{ $decoded->{'result'} };
  		foreach my $f ( @results ) {
  				my $name=$f->{"Name"};
  				$name=~s/\s/_/;
  				$name=~s/\s/_/;
  				$name=~s/\//_/;
  				$name=~s/%/P/;
  				my $feeds={"id" => $f->{"idx"}."_cam", "name" => $name, "type" => "DevCamera", "room" => "Switches", params =>[]};
  				my $v=$f->{"ImageURL"};
  				push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  #				push (@{$feeds->{'params'}}, {"key" => "remotejpegurl", "value" => "$v"} );
  				push (@{$feed->{'devices'}}, $feeds );
  		}
  	}
  	#DevGenericSensor      Generic sensor (any value)
  	#Value  Current value   N/A
  
  
  
  	return($feed);
  	return { success => true};
  };
  
  sub connect_usb {
  	my $port=$_[0];
  	Device::SerialPort->new($port, 1) || die "Can't open $port: $ +!"; 
  	$ob = Device::SerialPort->new($port, 1) || die "Can't open $port: $ +!";
  	$ob->databits(8);
  	$ob->baudrate(115200);
  	$ob->parity("none");
  	$ob->stopbits(1);
  	$ob->buffers( 4096, 4096 );
  	$ob->write_settings();
  	return $ob;
  }
  
    sub connect_db {
      my $dbh = DBI->connect("dbi:SQLite:dbname=".setting('database')."?cache=shared", 
  	    "",                          
  	    "",                          
  	    { RaiseError => 1 }
  	) or die $DBI::errstr;
  
      return $dbh;
    }
  
    sub init_db {
      my $db = connect_db();
      my $schema = read_file('./schema.sql');
      $db->do($schema) or die $db->errstr;
    }
  
  init_db();  
  true;
MYSENSORS

$fatpacked{"MySensorsMSG.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MYSENSORSMSG';
  # MySensors Gateway Plugin
  # 
  # Created by epierre <epierre@e-nef.com>
  #
  # http://www.mysensors.org
  # https://github.com/empierre/arduino/
  #
  # See github for contributors
  #	
  # This program is free software; you can redistribute it and/or
  # modify it under the terms of the GNU General Public License
  # version 2 as published by the Free Software Foundation.
  package MySensorsMSG;
  use utf8;
  use Time::Piece;
  use Device::SerialPort;
  use File::Slurp;
  use IO::Handle;
  use feature     qw< unicode_strings >;
  use constant {
  	VERSION 	=> '0.2',
  	PLUGIN_NAME 	=> "MySensors Gateway Plugin",
  	PLUGIN_VERSION 	=> "1.4b1",
  	MAX_RADIO_ID	=>255,
  	NODE_CHILD_ID	=>"255",
  	BAUD_RATE 	=> "115200",
  	ARDUINO_SID 	=> "urn:upnp-arduino-cc:serviceId:arduino1",
  	VARIABLE_CONTAINER_SID => "urn:upnp-org:serviceId:VContainer1"
  };
  my $inclusionResult = {};
  my $includeCount = 0;
  #Variables in msgw can be overridded in config file
  my $InclusionMode = 0;
  my $unit = "M";
  	
  #defines
  my %msgType = (
          'PRESENTATION' => "0",
          'SET_VARIABLE' => "1",
          'REQ_VARIABLE' => "2",
  	'ACK_VARIABLE' => "3",
          'INTERNAL'     => "4",
  	'STREAMING'    => "5" );
  
  my %tDeviceLookupNumType;
  my %tDeviceTypes = (
  	'DOOR' 	=> [0, "urn:schemas-micasaverde-com:device:DoorSensor:1", "D_DoorSensor1.xml", "Door "],
  	'MOTION' 	=> [1, "urn:schemas-micasaverde-com:device:MotionSensor:1", "D_MotionSensor1.xml", "Motion "],
  	SMOKE 	=> [2, "urn:schemas-micasaverde-com:device:SmokeSensor:1", "D_SmokeSensor1.xml", "Smoke "],
  	LIGHT 	=> [3, "urn:schemas-upnp-org:device:BinaryLight:1", "D_BinaryLight1.xml", "Light "],
  	DIMMER 	=> [4, "urn:schemas-upnp-org:device:DimmableLight:1", "D_DimmableLight1.xml", "Dim Light "],
  	COVER 	=> [5, "urn:schemas-micasaverde-com:device:WindowCovering:1", "D_WindowCovering1.xml", "Win Covering "] ,
  	TEMP 	=> [6, "urn:schemas-micasaverde-com:device:TemperatureSensor:1", "D_TemperatureSensor1.xml", "Temp "],
  	HUM 	=> [7, "urn:schemas-micasaverde-com:device:HumiditySensor:1", "D_HumiditySensor1.xml", "Humidity "],
  	BARO 	=> [8, "urn:schemas-micasaverde-com:device:BarometerSensor:1", "D_BarometerSensor1.xml", "Baro "],
  	WIND 	=> [9, "urn:schemas-micasaverde-com:device:WindSensor:1", "D_WindSensor1.xml", "Wind "],
  	RAIN 	=> [10, "urn:schemas-micasaverde-com:device:RainSensor:1", "D_RainSensor1.xml", "Rain "],
  	UV 	=> [11, "urn:schemas-micasaverde-com:device:UvSensor:1", "D_UvSensor1.xml", "UV "],
  	WEIGHT 	=> [12, "urn:schemas-micasaverde-com:device:ScaleSensor:1", "D_ScaleSensor1.xml", "Weight "],
  	POWER 	=> [13, "urn:schemas-micasaverde-com:device:PowerMeter:1", "D_PowerMeter1.xml", "Power "],
  	HEATER 	=> [14, "urn:schemas-upnp-org:device:Heater:1", "D_Heater1.xml", "Heater "],
  	DISTANCE => [15, "urn:schemas-upnp-org:device:Distance:1", "D_DistanceSensor1.xml", "Distance "],
  	LIGHT_LEVEL => [16, "urn:schemas-micasaverde-com:device:LightSensor:1", "D_LightSensor1.xml", "Light "],
  	ARDUINO_NODE => [17, "urn:schemas-arduino-cc:device:arduinonode:1", "D_ArduinoNode1.xml", "Node "],
  	ARDUINO_RELAY => [18, "urn:schemas-arduino-cc:device:arduinorelay:1", "D_ArduinoRelay1.xml", "Relay "],
  	LOCK 	=> [19, "urn:micasaverde-com:serviceId:DoorLock1", "D_DoorLock1.xml", "Lock "],
  	IR 	=> [20, "urn:schemas-arduino-cc:device:ArduinoIr:1", "D_ArduinoIr1.xml", "IR "],
  	WATER 	=> [21, "urn:schemas-micasaverde-com:device:WaterMeter:1", "D_WaterMeter1.xml", "Water "]
  );
  
  my %tVarLookupNumType;
  my %tVarTypes =(
  	TEMP 	=> [0, "urn:upnp-org:serviceId:TemperatureSensor1", "CurrentTemperature", ""],
  	HUM 	=> [1, "urn:micasaverde-com:serviceId:HumiditySensor1", "CurrentLevel", ""],
  	LIGHT 	=> [2, "urn:upnp-org:serviceId:SwitchPower1", "Status", "0"] ,
  	DIMMER 	=> [3, "urn:upnp-org:serviceId:Dimming1", "LoadLevelStatus", ""],
  	PRESSURE => [4, "urn:upnp-org:serviceId:BarometerSensor1", "CurrentPressure", ""],
  	FORECAST => [5, "urn:upnp-org:serviceId:BarometerSensor1", "Forecast", ""],
  	RAIN 	=> [6, "urn:upnp-org:serviceId:RainSensor1", "CurrentTRain", ""],
  	RAINRATE => [7, "urn:upnp-org:serviceId:RainSensor1", "CurrentRain", ""],
  	WIND 	=> [8, "urn:upnp-org:serviceId:WindSensor1", "AvgSpeed", ""],
  	GUST 	=> [9, "urn:upnp-org:serviceId:WindSensor1", "GustSpeed", ""],
  	DIRECTION => [10, "urn:upnp-org:serviceId:WindSensor1", "Direction", ""],
  	UV 	=> [11, "urn:upnp-org:serviceId:UvSensor1", "CurrentLevel", ""],
  	WEIGHT 	=> [12, "urn:micasaverde-com:serviceId:ScaleSensor1", "Weight", ""],
  	DISTANCE => [13, "urn:micasaverde-com:serviceId:DistanceSensor1", "CurrentDistance", ""],
  	IMPEDANCE => [14, "urn:micasaverde-com:serviceId:ScaleSensor1", "Impedance", ""],
  	ARMED 	=> [15, "urn:micasaverde-com:serviceId:SecuritySensor1", "Armed", ""],
  	TRIPPED => [16, "urn:micasaverde-com:serviceId:SecuritySensor1", "Tripped", "0"] ,
  	WATT 	=> [17, "urn:micasaverde-com:serviceId:EnergyMetering1", "Watts", ""],
  	KWH 	=> [18, "urn:micasaverde-com:serviceId:EnergyMetering1", "KWH", "0"],
  	SCENE_ON => [19, "urn:micasaverde-com:serviceId:SceneController1", "sl_SceneActivated", ""],
  	SCENE_OFF => [20, "urn:micasaverde-com:serviceId:SceneController1", "sl_SceneDeactivated", ""],
  	HEATER 	=> [21, "urn:upnp-org:serviceId:HVAC_UserOperatingMode1", "ModeStatus", ""],
  	HEATER_SW => [22, "urn:upnp-org:serviceId:SwitchPower1", "Status", ""],
  	LIGHT_LEVEL => [23, "urn:micasaverde-com:serviceId:LightSensor1", "CurrentLevel", ""],
  	VAR_1 	=> [24, "urn:upnp-org:serviceId:VContainer1", "Variable1", ""],
  	VAR_2 	=> [25, "urn:upnp-org:serviceId:VContainer1", "Variable2", ""],
  	VAR_3 	=> [26, "urn:upnp-org:serviceId:VContainer1", "Variable3", ""],
  	VAR_4 	=> [27, "urn:upnp-org:serviceId:VContainer1", "Variable4", ""],
  	VAR_5 	=> [28, "urn:upnp-org:serviceId:VContainer1", "Variable5", ""],
  	UP 	=> [29,'','', ""],
  	DOWN 	=> [30,'','', ""],
  	STOP 	=> [31,'','', ""],
  	IR_SEND => [32,'','', ""],
  	IR_RECEIVE => [33, "urn:upnp-org:serviceId:ArduinoIr1", "IrCode", ""],
  	FLOW 	=> [34, "urn:micasaverde-com:serviceId:WaterMetering1", "Flow", ""],
  	VOLUME 	=> [35, "urn:micasaverde-com:serviceId:WaterMetering1", "Volume", "0"],
  	LOCK 	=> [36, "urn:micasaverde-com:serviceId:DoorLock1", "Status", ""]
  );
  my %tInternalLookupNumType;
  my %tInternalTypes = (
  	BATTERY_LEVEL => [0, "urn:micasaverde-com:serviceId:HaDevice1", "BatteryLevel", ""],
  	BATTERY_DATE  => [1, "urn:micasaverde-com:serviceId:HaDevice1", "BatteryDate", ""],
  	'LAST_TRIP'     => [2, "urn:micasaverde-com:serviceId:SecuritySensor1", "LastTrip", ""],
  	TIME 	      => [3,'','',''],
  	VERSION       => [4, "urn:upnp-arduino-cc:serviceId:arduinonode1", "ArduinoLibVersion", ""],
  	REQUEST_ID    => [5,'','',''],
  	INCLUSION_MODE =>[6, "urn:upnp-arduino-cc:serviceId:arduino1", "InclusionMode", "0"],
  	RELAY_NODE    => [7, "urn:upnp-arduino-cc:serviceId:arduinonode1", "RelayNode", ""],
  	LAST_UPDATE   => [8, "urn:micasaverde-com:serviceId:HaDevice1", "LastUpdate", ""],
  	PING 	      => [9,'','',''],
  	PING_ACK      => [10,'','',''],
  	LOG_MESSAGE   => [11,'','',''],
  	CHILDREN      => [12, "urn:upnp-arduino-cc:serviceId:arduinonode1", "Children", "0"],
  	UNIT          =>	[13, "urn:upnp-arduino-cc:serviceId:arduino1", "Unit", "M"], # M = Metric / I = Imperial
  	SKETCH_NAME   => [14, "urn:upnp-arduino-cc:serviceId:arduinonode1", "SketchName", ""],
  	SKETCH_VERSION => [15, "urn:upnp-arduino-cc:serviceId:arduinonode1", "SketchVersion", ""]
  );
  
  #lookup tables
  my %childIdLookupTable;
  my %availableIds;for (my $i=0;$i<254;$i++) {$availableIds[$i]=1;};
  
  while (my ($k, $v) = each %tVarTypes) {
  	$tVarLookupNumType[$v->[0]] = $k;
  }
  while (my ($k, $v) = each %tDeviceTypes) {
  	$tVarLookupNumType[$v->[0]] = $k;
  }
  while (my ($k, $v) = each %tInternalTypes) {
  	$tInternalLookupNumType[$v->[0]] = $k;
  }
  
  
  sub log {
  	my ($text,$level)=@_;
      if (! $text) {
  		print STDERR "Arduino: nil-value";
  	}else{
  		print STDERR "Arduino: $text";
  	}
  }
  sub insert_variable {
  	my $stmt = qq(INSERT INTO variable (id,type,subtype,value)
  	      VALUES ($_[0], $_[1], $_[2], $[3] ));
  	my $rv = $dbh->do($stmt) or die $DBI::errstr;
  	$sth->finish();
  }
  sub update_variable {
  	my $stmt = qq(UPDATE variable set value=$_[3] where id=$_[0] and type=$_[1] and subtype=$_[2] );
  	my $rv = $dbh->do($stmt) or die $DBI::errstr;
  	$sth->finish();
  }
  
  sub variable_set {
  my ($serviceId, $name, $deviceId, $variable)=@_;
  	my $sth = $dbh->prepare( "SELECT value FROM variable WHERE id=$deviceId AND type=$serviceId AND subtype=$name");
  	$sth->execute();
      my $row = $sth->fetch;
  	if (!$row) {
  		insert_variable($_[0],$_[1],$_[2]);
  	} else {
  		update_variable($_[0],$_[1],$_[2]); 
  	}
  }
  
  #
  # Update variable if changed
  # Return true if changed or false if no change
  #
  sub setVariableIfChanged {
  	my ($serviceId, $name, $value, $deviceId)=@_;
      &log($serviceId .",".$name.", ".$value.", ". $deviceId);
      my $curValue = &variable_get($serviceId, $name, $deviceId);
      if (($value ~= $curValue) or (! $curValue)) {
          &variable_set($serviceId, $name, $value, $deviceId);
          return true;        
      } else {
          return false;        
      }
  }
  
  sub variable_get {
  	my ($serviceId, $name, $deviceId)=@_;
  	my $sth = $dbh->prepare( "SELECT value FROM variable WHERE id=$deviceId AND type=$serviceId AND subtype=$name");
  	my($count) = $dbh->selectrow_array($sth);
      return $count;
  }
  
  sub setVariable {
  	my ($incomingData, $childId, $nodeId)=@_;
  	if ($childId){ 
  		# Set variable reported from a child sensor.
  		my $index = $incomingData->[3];
  		my $varType = $tVarLookupNumType[$index];
  		my $var = $tVarTypes[$varType];
  		my $value = $incomingData->[4];
  		if ($var->[2]) {
  			&log("setVariable: RadioId: "+$incomingData->[0]+" Sensor: "+$incomingData->[1]+" ChildId: "+$childId+" Type: " +$tVarLookupNumType[$index]+" reporting value: "+ $value);
  			&setVariableIfChanged($var->[2], $var->[3], $value, $childId);
  			# Handle special variables battery level and tripped which also
  			# should update other variables to os.time(). This part should be removed...
  			if (($varType eq "TRIPPED") and ($value eq "1")) {
  				my $variable = $tInternalTypes{'LAST_TRIP'};
  				&setVariableIfChanged($variable->[2], $variable->[3], time(), $childId);
  			} else {
  			 	my $variable = $tInternalTypes{'LAST_UPDATE'};
  				&setVariableIfChanged($variable->[2], $variable->[3], time(),$childId);
  			}
  		}
  	}
  }
  
  1;
MYSENSORSMSG

$fatpacked{"Plack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK';
  package Plack;
  
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '1.0037';
  
  1;
  __END__
  
  =head1 NAME
  
  Plack - Perl Superglue for Web frameworks and Web Servers (PSGI toolkit)
  
  =head1 DESCRIPTION
  
  Plack is a set of tools for using the PSGI stack. It contains
  middleware components, a reference server and utilities for Web
  application frameworks. Plack is like Ruby's Rack or Python's Paste
  for WSGI.
  
  See L<PSGI> for the PSGI specification and L<PSGI::FAQ> to know what
  PSGI and Plack are and why we need them.
  
  =head1 MODULES AND UTILITIES
  
  =head2 Plack::Handler
  
  L<Plack::Handler> and its subclasses contains adapters for web
  servers. We have adapters for the built-in standalone web server
  L<HTTP::Server::PSGI>, L<CGI|Plack::Handler::CGI>,
  L<FCGI|Plack::Handler::FCGI>, L<Apache1|Plack::Handler::Apache1>,
  L<Apache2|Plack::Handler::Apache2> and
  L<HTTP::Server::Simple|Plack::Handler::HTTP::Server::Simple> included
  in the core Plack distribution.
  
  There are also many HTTP server implementations on CPAN that have Plack
  handlers.
  
  See L<Plack::Handler> when writing your own adapters.
  
  =head2 Plack::Loader
  
  L<Plack::Loader> is a loader to load one L<Plack::Handler> adapter
  and run a PSGI application code reference with it.
  
  =head2 Plack::Util
  
  L<Plack::Util> contains a lot of utility functions for server
  implementors as well as middleware authors.
  
  =head2 .psgi files
  
  A PSGI application is a code reference but it's not easy to pass code
  reference via the command line or configuration files, so Plack uses a
  convention that you need a file named C<app.psgi> or similar, which
  would be loaded (via perl's core function C<do>) to return the PSGI
  application code reference.
  
    # Hello.psgi
    my $app = sub {
        my $env = shift;
        # ...
        return [ $status, $headers, $body ];
    };
  
  If you use a web framework, chances are that they provide a helper
  utility to automatically generate these C<.psgi> files for you, such
  as:
  
    # MyApp.psgi
    use MyApp;
    my $app = sub { MyApp->run_psgi(@_) };
  
  It's important that the return value of C<.psgi> file is the code
  reference. See C<eg/dot-psgi> directory for more examples of C<.psgi>
  files.
  
  =head2 plackup, Plack::Runner
  
  L<plackup> is a command line launcher to run PSGI applications from
  command line using L<Plack::Loader> to load PSGI backends. It can be
  used to run standalone servers and FastCGI daemon processes. Other
  server backends like Apache2 needs a separate configuration but
  C<.psgi> application file can still be the same.
  
  If you want to write your own frontend that replaces, or adds
  functionalities to L<plackup>, take a look at the L<Plack::Runner> module.
  
  =head2 Plack::Middleware
  
  PSGI middleware is a PSGI application that wraps an existing PSGI
  application and plays both side of application and servers. From the
  servers the wrapped code reference still looks like and behaves
  exactly the same as PSGI applications.
  
  L<Plack::Middleware> gives you an easy way to wrap PSGI applications
  with a clean API, and compatibility with L<Plack::Builder> DSL.
  
  =head2 Plack::Builder
  
  L<Plack::Builder> gives you a DSL that you can enable Middleware in
  C<.psgi> files to wrap existent PSGI applications.
  
  =head2 Plack::Request, Plack::Response
  
  L<Plack::Request> gives you a nice wrapper API around PSGI C<$env>
  hash to get headers, cookies and query parameters much like
  L<Apache::Request> in mod_perl.
  
  L<Plack::Response> does the same to construct the response array
  reference.
  
  =head2 Plack::Test
  
  L<Plack::Test> is a unified interface to test your PSGI application
  using standard L<HTTP::Request> and L<HTTP::Response> pair with simple
  callbacks.
  
  =head2 Plack::Test::Suite
  
  L<Plack::Test::Suite> is a test suite to test a new PSGI server backend.
  
  =head1 CONTRIBUTING
  
  =head2 Patches and Bug Fixes
  
  Small patches and bug fixes can be either submitted via nopaste on IRC
  L<irc://irc.perl.org/#plack> or L<the github issue
  tracker|http://github.com/plack/Plack/issues>.  Forking on
  L<github|http://github.com/plack/Plack> is another good way if you
  intend to make larger fixes.
  
  See also L<http://contributing.appspot.com/plack> when you think this
  document is terribly outdated.
  
  =head2 Module Namespaces
  
  Modules added to the Plack:: sub-namespaces should be reasonably generic
  components which are useful as building blocks and not just simply using
  Plack.
  
  Middleware authors are free to use the Plack::Middleware:: namespace for
  their middleware components. Middleware must be written in the pipeline
  style such that they can chained together with other middleware components.
  The Plack::Middleware:: modules in the core distribution are good examples
  of such modules. It is recommended that you inherit from L<Plack::Middleware>
  for these types of modules.
  
  Not all middleware components are wrappers, but instead are more like
  endpoints in a middleware chain. These types of components should use the
  Plack::App:: namespace. Again, look in the core modules to see excellent
  examples of these (L<Plack::App::File>, L<Plack::App::Directory>, etc.).
  It is recommended that you inherit from L<Plack::Component> for these
  types of modules.
  
  B<DO NOT USE> Plack:: namespace to build a new web application or a
  framework. It's like naming your application under CGI:: namespace if
  it's supposed to run on CGI and that is a really bad choice and
  would confuse people badly.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 COPYRIGHT
  
  The following copyright notice applies to all the files provided in
  this distribution, including binary files, unless explicitly noted
  otherwise.
  
  Copyright 2009-2013 Tatsuhiko Miyagawa
  
  =head1 CORE DEVELOPERS
  
  Tatsuhiko Miyagawa (miyagawa)
  
  Tokuhiro Matsuno (tokuhirom)
  
  Jesse Luehrs (doy)
  
  Tomas Doran (bobtfish)
  
  Graham Knop (haarg)
  
  =head1 CONTRIBUTORS
  
  Yuval Kogman (nothingmuch)
  
  Kazuhiro Osawa (Yappo)
  
  Kazuho Oku
  
  Florian Ragwitz (rafl)
  
  Chia-liang Kao (clkao)
  
  Masahiro Honma (hiratara)
  
  Daisuke Murase (typester)
  
  John Beppu
  
  Matt S Trout (mst)
  
  Shawn M Moore (Sartak)
  
  Stevan Little
  
  Hans Dieter Pearcey (confound)
  
  mala
  
  Mark Stosberg
  
  Aaron Trevena
  
  =head1 SEE ALSO
  
  The L<PSGI> specification upon which Plack is based.
  
  L<http://plackperl.org/>
  
  The Plack wiki: L<https://github.com/plack/Plack/wiki>
  
  The Plack FAQ: L<https://github.com/plack/Plack/wiki/Faq>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK

$fatpacked{"Plack/App/CGIBin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_CGIBIN';
  package Plack::App::CGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util::Accessor qw( exec_cb );
  use Plack::App::WrapCGI;
  
  sub allow_path_info { 1 }
  
  my %exec_cache;
  
  sub would_exec {
      my($self, $file) = @_;
  
      return $exec_cache{$file} if exists $exec_cache{$file};
  
      my $exec_cb = $self->exec_cb || sub { $self->exec_cb_default(@_) };
  
      return $exec_cache{$file} = $exec_cb->($file);
  }
  
  sub exec_cb_default {
      my($self, $file) = @_;
  
      if ($file =~ /\.pl$/i) {
          return 0;
      } elsif ($self->shebang_for($file) =~ /^\#\!.*perl/) {
          return 0;
      } else {
          return 1;
      }
  }
  
  sub shebang_for {
      my($self, $file) = @_;
  
      open my $fh, "<", $file or return '';
      my $line = <$fh>;
      return $line;
  }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::App::WrapCGI->new(
          script => $file, execute => $self->would_exec($file),
      )->to_app;
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::CGIBin - cgi-bin replacement for Plack servers
  
  =head1 SYNOPSIS
  
    use Plack::App::CGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app;
    builder {
        mount "/cgi-bin" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::CGIBin -e 'Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app'
  
  =head1 DESCRIPTION
  
  Plack::App::CGIBin allows you to load CGI scripts from a directory and
  convert them into a PSGI application.
  
  This would give you the extreme easiness when you have bunch of old
  CGI scripts that is loaded using I<cgi-bin> of Apache web server.
  
  =head1 HOW IT WORKS
  
  This application checks if a given file path is a perl script and if
  so, uses L<CGI::Compile> to compile a CGI script into a sub (like
  L<ModPerl::Registry>) and then run it as a persistent application
  using L<CGI::Emulate::PSGI>.
  
  If the given file is not a perl script, it executes the script just
  like a normal CGI script with fork & exec. This is like a normal web
  server mode and no performance benefit is achieved.
  
  The default mechanism to determine if a given file is a Perl script is
  as follows:
  
  =over 4
  
  =item *
  
  Check if the filename ends with C<.pl>. If yes, it is a Perl script.
  
  =item *
  
  Open the file and see if the shebang (first line of the file) contains
  the word C<perl> (like C<#!/usr/bin/perl>). If yes, it is a Perl
  script.
  
  =back
  
  You can customize this behavior by passing C<exec_cb> callback, which
  takes a file path to its first argument.
  
  For example, if your perl-based CGI script uses lots of global
  variables and such and are not ready to run on a persistent
  environment, you can do:
  
    my $app = Plack::App::CGIBin->new(
        root => "/path/to/cgi-bin",
        exec_cb => sub { 1 },
    )->to_app;
  
  to always force the execute option for any files.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File> L<CGI::Emulate::PSGI> L<CGI::Compile> L<Plack::App::WrapCGI>
  
  See also L<Plack::App::WrapCGI> if you compile one CGI script into a
  PSGI application without serving CGI scripts from a directory, to
  remove overhead of filesystem lookups, etc.
  
  =cut
PLACK_APP_CGIBIN

$fatpacked{"Plack/App/Cascade.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_CASCADE';
  package Plack::App::Cascade;
  use strict;
  use base qw(Plack::Component);
  
  use Plack::Util;
  use Plack::Util::Accessor qw(apps catch codes);
  
  sub add {
      my $self = shift;
      $self->apps([]) unless $self->apps;
      push @{$self->apps}, @_;
  }
  
  sub prepare_app {
      my $self = shift;
      my %codes = map { $_ => 1 } @{ $self->catch || [ 404 ] };
      $self->codes(\%codes);
  }
  
  sub call {
      my($self, $env) = @_;
  
      return sub {
          my $respond = shift;
  
          my $done;
          my $respond_wrapper = sub {
              my $res = shift;
              if ($self->codes->{$res->[0]}) {
                  # suppress output by giving the app an
                  # output spool which drops everything on the floor
                  return Plack::Util::inline_object
                      write => sub { }, close => sub { };
              } else {
                  $done = 1;
                  return $respond->($res);
              }
          };
  
          my @try = @{$self->apps || []};
          my $tries_left = 0 + @try;
  
          if (not $tries_left) {
              return $respond->([ 404, [ 'Content-Type' => 'text/html' ], [ '404 Not Found' ] ])
          }
  
          for my $app (@try) {
              my $res = $app->($env);
              if ($tries_left-- == 1) {
                  $respond_wrapper = sub { $respond->(shift) };
              }
  
              if (ref $res eq 'CODE') {
                  $res->($respond_wrapper);
              } else {
                  $respond_wrapper->($res);
              }
              return if $done;
          }
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Cascade - Cascadable compound application
  
  =head1 SYNOPSIS
  
    use Plack::App::Cascade;
    use Plack::App::URLMap;
    use Plack::App::File;
  
    # Serve static files from multiple search paths
    my $cascade = Plack::App::Cascade->new;
    $cascade->add( Plack::App::File->new(root => "/www/example.com/foo")->to_app );
    $cascade->add( Plack::App::File->new(root => "/www/example.com/bar")->to_app );
  
    my $app = Plack::App::URLMap->new;
    $app->map("/static", $cascade);
    $app->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::Cascade is a Plack middleware component that compounds
  several apps and tries them to return the first response that is not
  404.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $app = Plack::App::Cascade->new(apps => [ $app1, $app2 ]);
  
  Creates a new Cascade application.
  
  =item add
  
    $app->add($app1);
    $app->add($app2, $app3);
  
  Appends a new application to the list of apps to try. You can pass the
  multiple apps to the one C<add> call.
  
  =item catch
  
    $app->catch([ 403, 404 ]);
  
  Sets which error codes to catch and process onwards. Defaults to C<404>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::URLMap> Rack::Cascade
  
  =cut
PLACK_APP_CASCADE

$fatpacked{"Plack/App/Directory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_DIRECTORY';
  package Plack::App::Directory;
  use parent qw(Plack::App::File);
  use strict;
  use warnings;
  use Plack::Util;
  use HTTP::Date;
  use Plack::MIME;
  use DirHandle;
  use URI::Escape;
  use Plack::Request;
  
  # Stolen from rack/directory.rb
  my $dir_file = "<tr><td class='name'><a href='%s'>%s</a></td><td class='size'>%s</td><td class='type'>%s</td><td class='mtime'>%s</td></tr>";
  my $dir_page = <<PAGE;
  <html><head>
    <title>%s</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <style type='text/css'>
  table { width:100%%; }
  .name { text-align:left; }
  .size, .mtime { text-align:right; }
  .type { width:11em; }
  .mtime { width:15em; }
    </style>
  </head><body>
  <h1>%s</h1>
  <hr />
  <table>
    <tr>
      <th class='name'>Name</th>
      <th class='size'>Size</th>
      <th class='type'>Type</th>
      <th class='mtime'>Last Modified</th>
    </tr>
  %s
  </table>
  <hr />
  </body></html>
  PAGE
  
  sub should_handle {
      my($self, $file) = @_;
      return -d $file || -f $file;
  }
  
  sub return_dir_redirect {
      my ($self, $env) = @_;
      my $uri = Plack::Request->new($env)->uri;
      return [ 301,
          [
              'Location' => $uri . '/',
              'Content-Type' => 'text/plain',
              'Content-Length' => 8,
          ],
          [ 'Redirect' ],
      ];
  }
  
  sub serve_path {
      my($self, $env, $dir, $fullpath) = @_;
  
      if (-f $dir) {
          return $self->SUPER::serve_path($env, $dir, $fullpath);
      }
  
      my $dir_url = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
  
      if ($dir_url !~ m{/$}) {
          return $self->return_dir_redirect($env);
      }
  
      my @files = ([ "../", "Parent Directory", '', '', '' ]);
  
      my $dh = DirHandle->new($dir);
      my @children;
      while (defined(my $ent = $dh->read)) {
          next if $ent eq '.' or $ent eq '..';
          push @children, $ent;
      }
  
      for my $basename (sort { $a cmp $b } @children) {
          my $file = "$dir/$basename";
          my $url = $dir_url . $basename;
  
          my $is_dir = -d $file;
          my @stat = stat _;
  
          $url = join '/', map {uri_escape($_)} split m{/}, $url;
  
          if ($is_dir) {
              $basename .= "/";
              $url      .= "/";
          }
  
          my $mime_type = $is_dir ? 'directory' : ( Plack::MIME->mime_type($file) || 'text/plain' );
          push @files, [ $url, $basename, $stat[7], $mime_type, HTTP::Date::time2str($stat[9]) ];
      }
  
      my $path  = Plack::Util::encode_html("Index of $env->{PATH_INFO}");
      my $files = join "\n", map {
          my $f = $_;
          sprintf $dir_file, map Plack::Util::encode_html($_), @$f;
      } @files;
      my $page  = sprintf $dir_page, $path, $path, $files;
  
      return [ 200, ['Content-Type' => 'text/html; charset=utf-8'], [ $page ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Directory - Serve static files from document root with directory index
  
  =head1 SYNOPSIS
  
    # app.psgi
    use Plack::App::Directory;
    my $app = Plack::App::Directory->new({ root => "/path/to/htdocs" })->to_app;
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application with directory index a la Apache's mod_autoindex.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to the current directory.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File>
  
  =cut
PLACK_APP_DIRECTORY

$fatpacked{"Plack/App/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_FILE';
  package Plack::App::File;
  use strict;
  use warnings;
  use parent qw/Plack::Component/;
  use File::Spec::Unix;
  use Cwd ();
  use Plack::Util;
  use Plack::MIME;
  use HTTP::Date;
  
  use Plack::Util::Accessor qw( root file content_type encoding );
  
  sub should_handle {
      my($self, $file) = @_;
      return -f $file;
  }
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my($file, $path_info) = $self->file || $self->locate_file($env);
      return $file if ref $file eq 'ARRAY';
  
      if ($path_info) {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.SCRIPT_NAME'} =~ s/\Q$path_info\E$//;
          $env->{'plack.file.PATH_INFO'}   = $path_info;
      } else {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.PATH_INFO'}   = '';
      }
  
      return $self->serve_path($env, $file);
  }
  
  sub locate_file {
      my($self, $env) = @_;
  
      my $path = $env->{PATH_INFO} || '';
  
      if ($path =~ /\0/) {
          return $self->return_400;
      }
  
      my $docroot = $self->root || ".";
      my @path = split /[\\\/]/, $path, -1; # -1 *MUST* be here to avoid security issues!
      if (@path) {
          shift @path if $path[0] eq '';
      } else {
          @path = ('.');
      }
  
      if (grep /^\.{2,}$/, @path) {
          return $self->return_403;
      }
  
      my($file, @path_info);
      while (@path) {
          my $try = File::Spec::Unix->catfile($docroot, @path);
          if ($self->should_handle($try)) {
              $file = $try;
              last;
          } elsif (!$self->allow_path_info) {
              last;
          }
          unshift @path_info, pop @path;
      }
  
      if (!$file) {
          return $self->return_404;
      }
  
      if (!-r $file) {
          return $self->return_403;
      }
  
      return $file, join("/", "", @path_info);
  }
  
  sub allow_path_info { 0 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      my $content_type = $self->content_type || Plack::MIME->mime_type($file)
                         || 'text/plain';
  
      if ("CODE" eq ref $content_type) {
  		$content_type = $content_type->($file);
      }
  
      if ($content_type =~ m!^text/!) {
          $content_type .= "; charset=" . ($self->encoding || "utf-8");
      }
  
      open my $fh, "<:raw", $file
          or return $self->return_403;
  
      my @stat = stat $file;
  
      Plack::Util::set_io_path($fh, Cwd::realpath($file));
  
      return [
          200,
          [
              'Content-Type'   => $content_type,
              'Content-Length' => $stat[7],
              'Last-Modified'  => HTTP::Date::time2str( $stat[9] )
          ],
          $fh,
      ];
  }
  
  sub return_403 {
      my $self = shift;
      return [403, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['forbidden']];
  }
  
  sub return_400 {
      my $self = shift;
      return [400, ['Content-Type' => 'text/plain', 'Content-Length' => 11], ['Bad Request']];
  }
  
  # Hint: subclasses can override this to return undef to pass through 404
  sub return_404 {
      my $self = shift;
      return [404, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['not found']];
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::App::File - Serve static files from root directory
  
  =head1 SYNOPSIS
  
    use Plack::App::File;
    my $app = Plack::App::File->new(root => "/path/to/htdocs")->to_app;
  
    # Or map the path to a specific file
    use Plack::Builder;
    builder {
        mount "/favicon.ico" => Plack::App::File->new(file => '/path/to/favicon.ico')->to_app;
    };
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application, and internally used by
  L<Plack::Middleware::Static>. This application serves file from
  document root if the path matches with the local file. Use
  L<Plack::App::Directory> if you want to list files in the directory
  as well.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to C<.> (current directory)
  
  =item file
  
  The file path to create responses from. Optional.
  
  If it's set the application would B<ALWAYS> create a response out of
  the file and there will be no security check etc. (hence fast). If
  it's not set, the application uses C<root> to find the matching file.
  
  =item encoding
  
  Set the file encoding for text files. Defaults to C<utf-8>.
  
  =item content_type
  
  Set the file content type. If not set L<Plack::MIME> will try to detect it
  based on the file extension or fall back to C<text/plain>.
  Can be set to a callback which should work on $_[0] to check full path file 
  name.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::Static> L<Plack::App::Directory>
  
  =cut
  
  
PLACK_APP_FILE

$fatpacked{"Plack/App/PSGIBin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_PSGIBIN';
  package Plack::App::PSGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util;
  
  sub allow_path_info { 1 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::Util::load_psgi($file);
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::PSGIBin - Run .psgi files from a directory
  
  =head1 SYNOPSIS
  
    use Plack::App::PSGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::PSGIBin->new(root => "/path/to/psgi/scripts")->to_app;
    builder {
        mount "/psgi" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::PSGIBin -e 'Plack::App::PSGIBin->new(root => "/path/psgi/scripts")->to_app'
  
  =head1 DESCRIPTION
  
  This application loads I<.psgi> files (or actually whichever filename
  extensions) from the root directory and run it as a PSGI
  application. Suppose you have a directory containing C<foo.psgi> and
  C<bar.psgi>, map this application to C</app> with
  L<Plack::App::URLMap> and you can access them via the URL:
  
    http://example.com/app/foo.psgi
    http://example.com/app/bar.psgi
  
  to load them. You can rename the file to the one without C<.psgi>
  extension to make the URL look nicer, or use the URL rewriting tools
  like L<Plack::Middleware::Rewrite> to do the same thing.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
PLACK_APP_PSGIBIN

$fatpacked{"Plack/App/URLMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_URLMAP';
  package Plack::App::URLMap;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use constant DEBUG => $ENV{PLACK_URLMAP_DEBUG};
  
  use Carp ();
  
  sub mount { shift->map(@_) }
  
  sub map {
      my $self = shift;
      my($location, $app) = @_;
  
      my $host;
      if ($location =~ m!^https?://(.*?)(/.*)!) {
          $host     = $1;
          $location = $2;
      }
  
      if ($location !~ m!^/!) {
          Carp::croak("Paths need to start with /");
      }
      $location =~ s!/$!!;
  
      push @{$self->{_mapping}}, [ $host, $location, qr/^\Q$location\E/, $app ];
  }
  
  sub prepare_app {
      my $self = shift;
      # sort by path length
      $self->{_sorted_mapping} = [
          map  { [ @{$_}[2..5] ] }
          sort { $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] }
          map  { [ ($_->[0] ? length $_->[0] : 0), length($_->[1]), @$_ ] } @{$self->{_mapping}},
      ];
  }
  
  sub call {
      my ($self, $env) = @_;
  
      my $path_info   = $env->{PATH_INFO};
      my $script_name = $env->{SCRIPT_NAME};
  
      my($http_host, $server_name) = @{$env}{qw( HTTP_HOST SERVER_NAME )};
  
      if ($http_host and my $port = $env->{SERVER_PORT}) {
          $http_host =~ s/:$port$//;
      }
  
      for my $map (@{ $self->{_sorted_mapping} }) {
          my($host, $location, $location_re, $app) = @$map;
          my $path = $path_info; # copy
          no warnings 'uninitialized';
          DEBUG && warn "Matching request (Host=$http_host Path=$path) and the map (Host=$host Path=$location)\n";
          next unless not defined $host     or
                      $http_host   eq $host or
                      $server_name eq $host;
          next unless $location eq '' or $path =~ s!$location_re!!;
          next unless $path eq '' or $path =~ m!^/!;
          DEBUG && warn "-> Matched!\n";
  
          my $orig_path_info   = $env->{PATH_INFO};
          my $orig_script_name = $env->{SCRIPT_NAME};
  
          $env->{PATH_INFO}  = $path;
          $env->{SCRIPT_NAME} = $script_name . $location;
          return $self->response_cb($app->($env), sub {
              $env->{PATH_INFO} = $orig_path_info;
              $env->{SCRIPT_NAME} = $orig_script_name;
          });
      }
  
      DEBUG && warn "All matching failed.\n";
  
      return [404, [ 'Content-Type' => 'text/plain' ], [ "Not Found" ]];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::URLMap - Map multiple apps in different paths
  
  =head1 SYNOPSIS
  
    use Plack::App::URLMap;
  
    my $app1 = sub { ... };
    my $app2 = sub { ... };
    my $app3 = sub { ... };
  
    my $urlmap = Plack::App::URLMap->new;
    $urlmap->map("/" => $app1);
    $urlmap->map("/foo" => $app2);
    $urlmap->map("http://bar.example.com/" => $app3);
  
    my $app = $urlmap->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::URLMap is a PSGI application that can dispatch multiple
  applications based on URL path and host names (a.k.a "virtual hosting")
  and takes care of rewriting C<SCRIPT_NAME> and C<PATH_INFO> (See
  L</"HOW THIS WORKS"> for details). This module is inspired by
  Ruby's Rack::URLMap.
  
  =head1 METHODS
  
  =over 4
  
  =item map
  
    $urlmap->map("/foo" => $app);
    $urlmap->map("http://bar.example.com/" => $another_app);
  
  Maps URL path or an absolute URL to a PSGI application. The match
  order is sorted by host name length and then path length (longest strings
  first).
  
  URL paths need to match from the beginning and should match completely
  until the path separator (or the end of the path). For example, if you
  register the path C</foo>, it I<will> match with the request C</foo>,
  C</foo/> or C</foo/bar> but it I<won't> match with C</foox>.
  
  Mapping URLs with host names is also possible, and in that case the URL
  mapping works like a virtual host.
  
  Mappings will nest.  If $app is already mapped to C</baz> it will
  match a request for C</foo/baz> but not C</foo>. See L</"HOW THIS
  WORKS"> for more details.
  
  =item mount
  
  Alias for C<map>.
  
  =item to_app
  
    my $handler = $urlmap->to_app;
  
  Returns the PSGI application code reference. Note that the
  Plack::App::URLMap object is callable (by overloading the code
  dereference), so returning the object itself as a PSGI application
  should also work.
  
  =back
  
  =head1 PERFORMANCE
  
  If you C<map> (or C<mount> with Plack::Builder) N applications,
  Plack::App::URLMap will need to at most iterate through N paths to
  match incoming requests.
  
  It is a good idea to use C<map> only for a known, limited amount of
  applications, since mounting hundreds of applications could affect
  runtime request performance.
  
  =head1 DEBUGGING
  
  You can set the environment variable C<PLACK_URLMAP_DEBUG> to see how
  this application matches with the incoming request host names and
  paths.
  
  =head1 HOW THIS WORKS
  
  This application works by I<fixing> C<SCRIPT_NAME> and C<PATH_INFO>
  before dispatching the incoming request to the relocated
  applications.
  
  Say you have a Wiki application that takes C</index> and C</page/*>
  and makes a PSGI application C<$wiki_app> out of it, using one of
  supported web frameworks, you can put the whole application under
  C</wiki> by:
  
    # MyWikiApp looks at PATH_INFO and handles /index and /page/*
    my $wiki_app = sub { MyWikiApp->run(@_) };
    
    use Plack::App::URLMap;
    my $app = Plack::App::URLMap->new;
    $app->mount("/wiki" => $wiki_app);
  
  When a request comes in with C<PATH_INFO> set to C</wiki/page/foo>,
  the URLMap application C<$app> strips the C</wiki> part from
  C<PATH_INFO> and B<appends> that to C<SCRIPT_NAME>.
  
  That way, if the C<$app> is mounted under the root
  (i.e. C<SCRIPT_NAME> is C<"">) with standalone web servers like
  L<Starman>, C<SCRIPT_NAME> is now locally set to C</wiki> and
  C<PATH_INFO> is changed to C</page/foo> when C<$wiki_app> gets called.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_APP_URLMAP

$fatpacked{"Plack/App/WrapCGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_WRAPCGI';
  package Plack::App::WrapCGI;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use Plack::Util::Accessor qw(script execute _app);
  use File::Spec;
  use CGI::Emulate::PSGI;
  use CGI::Compile;
  use Carp;
  use POSIX ":sys_wait_h";
  
  sub slurp_fh {
      my $fh = $_[0];
      local $/;
      my $v = <$fh>;
      defined $v ? $v : '';
  }
  
  sub prepare_app {
      my $self = shift;
      my $script = $self->script
          or croak "'script' is not set";
  
      $script = File::Spec->rel2abs($script);
  
      if ($self->execute) {
          my $app = sub {
              my $env = shift;
  
              pipe( my $stdoutr, my $stdoutw );
              pipe( my $stdinr,  my $stdinw );
  
  
              my $pid = fork();
              Carp::croak("fork failed: $!") unless defined $pid;
  
  
              if ($pid == 0) { # child
                  local $SIG{__DIE__} = sub {
                      print STDERR @_;
                      exit(1);
                  };
  
                  close $stdoutr;
                  close $stdinw;
  
                  local %ENV = (%ENV, CGI::Emulate::PSGI->emulate_environment($env));
  
                  open( STDOUT, ">&=" . fileno($stdoutw) )
                    or Carp::croak "Cannot dup STDOUT: $!";
                  open( STDIN, "<&=" . fileno($stdinr) )
                    or Carp::croak "Cannot dup STDIN: $!";
  
                  chdir(File::Basename::dirname($script));
                  exec($script) or Carp::croak("cannot exec: $!");
  
                  exit(2);
              }
  
              close $stdoutw;
              close $stdinr;
  
              syswrite($stdinw, slurp_fh($env->{'psgi.input'}));
              # close STDIN so child will stop waiting
              close $stdinw;
  
              my $res = '';
              while (waitpid($pid, WNOHANG) <= 0) {
                  $res .= slurp_fh($stdoutr);
              }
              $res .= slurp_fh($stdoutr);
  
              if (POSIX::WIFEXITED($?)) {
                  return CGI::Parse::PSGI::parse_cgi_output(\$res);
              } else {
                  Carp::croak("Error at run_on_shell CGI: $!");
              }
          };
          $self->_app($app);
      } else {
          my $sub = CGI::Compile->compile($script);
          my $app = CGI::Emulate::PSGI->handler($sub);
  
          $self->_app($app);
      }
  }
  
  sub call {
      my($self, $env) = @_;
      $self->_app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::WrapCGI - Compiles a CGI script as PSGI application
  
  =head1 SYNOPSIS
  
    use Plack::App::WrapCGI;
  
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.pl")->to_app;
  
    # if you want to execute as a real CGI script
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.rb", execute => 1)->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::WrapCGI compiles a CGI script into a PSGI application
  using L<CGI::Compile> and L<CGI::Emulate::PSGI>, and runs it with any
  PSGI server as a PSGI application.
  
  See also L<Plack::App::CGIBin> if you have a directory that contains a
  lot of CGI scripts and serve them like Apache's mod_cgi.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    my $app = Plack::App::WrapCGI->new(%args);
  
  Creates a new PSGI application using the given script. I<%args> has two
  parameters:
  
  =over 8
  
  =item script
  
  The path to a CGI-style program. This is a required parameter.
  
  =item execute
  
  An optional parameter. When set to a true value, this app will run the script
  with a CGI-style C<fork>/C<exec> model. Note that you may run programs written
  in other languages with this approach.
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
  
  =cut
PLACK_APP_WRAPCGI

$fatpacked{"Plack/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_BUILDER';
  package Plack::Builder;
  use strict;
  use parent qw( Exporter );
  our @EXPORT = qw( builder add enable enable_if mount );
  
  use Carp ();
  use Plack::App::URLMap;
  use Plack::Middleware::Conditional; # TODO delayed load?
  use Scalar::Util ();
  
  sub new {
      my $class = shift;
      bless { middlewares => [ ] }, $class;
  }
  
  sub add_middleware {
      my($self, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, $mw;
  }
  
  sub add_middleware_if {
      my($self, $cond, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, sub {
          Plack::Middleware::Conditional->wrap($_[0], condition => $cond, builder => $mw);
      };
  }
  
  # do you want remove_middleware() etc.?
  
  sub _mount {
      my ($self, $location, $app) = @_;
  
      if (!$self->{_urlmap}) {
          $self->{_urlmap} = Plack::App::URLMap->new;
      }
  
      $self->{_urlmap}->map($location => $app);
      $self->{_urlmap}; # for backward compat.
  }
  
  sub to_app {
      my($self, $app) = @_;
  
      if ($app) {
          $self->wrap($app);
      } elsif ($self->{_urlmap}) {
          $self->{_urlmap} = $self->{_urlmap}->to_app
              if Scalar::Util::blessed($self->{_urlmap});
          $self->wrap($self->{_urlmap});
      } else {
          Carp::croak("to_app() is called without mount(). No application to build.");
      }
  }
  
  sub wrap {
      my($self, $app) = @_;
  
      if ($self->{_urlmap} && $app ne $self->{_urlmap}) {
          Carp::carp("WARNING: wrap() and mount() can't be used altogether in Plack::Builder.\n" .
                     "WARNING: This causes all previous mount() mappings to be ignored.");
      }
  
      for my $mw (reverse @{$self->{middlewares}}) {
          $app = $mw->($app);
      }
  
      $app;
  }
  
  # DSL goes here
  our $_add = our $_add_if = our $_mount = sub {
      Carp::croak("enable/mount should be called inside builder {} block");
  };
  
  sub enable         { $_add->(@_) }
  sub enable_if(&$@) { $_add_if->(@_) }
  
  sub mount {
      my $self = shift;
      if (Scalar::Util::blessed($self)) {
          $self->_mount(@_);
      }else{
          $_mount->($self, @_);
      }
  }
  
  sub builder(&) {
      my $block = shift;
  
      my $self = __PACKAGE__->new;
  
      my $mount_is_called;
      my $urlmap = Plack::App::URLMap->new;
      local $_mount = sub {
          $mount_is_called++;
          $urlmap->map(@_);
          $urlmap;
      };
      local $_add = sub {
          $self->add_middleware(@_);
      };
      local $_add_if = sub {
          $self->add_middleware_if(@_);
      };
  
      my $app = $block->();
  
      if ($mount_is_called) {
          if ($app ne $urlmap) {
              Carp::carp("WARNING: You used mount() in a builder block, but the last line (app) isn't using mount().\n" .
                         "WARNING: This causes all mount() mappings to be ignored.\n");
          } else {
              $app = $app->to_app;
          }
      }
  
      $app = $app->to_app if $app and Scalar::Util::blessed($app) and $app->can('to_app');
  
      $self->to_app($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Builder - OO and DSL to enable Plack Middlewares
  
  =head1 SYNOPSIS
  
    # in .psgi
    use Plack::Builder;
  
    my $app = sub { ... };
  
    builder {
        enable "Deflater";
        enable "Session", store => "File";
        enable "Debug", panels => [ qw(DBITrace Memory Timer) ];
        enable "+My::Plack::Middleware";
        $app;
    };
  
    # use URLMap
  
    builder {
        mount "/foo" => builder {
            enable "Foo";
            $app;
        };
  
        mount "/bar" => $app2;
        mount "http://example.com/" => builder { $app3 };
    };
  
    # using OO interface
    my $builder = Plack::Builder->new;
    $builder->add_middleware('Foo', opt => 1);
    $builder->add_middleware('Bar');
    $builder->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Builder gives you a quick domain specific language (DSL) to
  wrap your application with L<Plack::Middleware> subclasses. The
  middleware you're trying to use should use L<Plack::Middleware> as a
  base class to use this DSL, inspired by Rack::Builder.
  
  Whenever you call C<enable> on any middleware, the middleware app is
  pushed to the stack inside the builder, and then reversed when it
  actually creates a wrapped application handler. C<"Plack::Middleware::">
  is added as a prefix by default. So:
  
    builder {
        enable "Foo";
        enable "Bar", opt => "val";
        $app;
    };
  
  is syntactically equal to:
  
    $app = Plack::Middleware::Bar->wrap($app, opt => "val");
    $app = Plack::Middleware::Foo->wrap($app);
  
  In other words, you're supposed to C<enable> middleware from outer to inner.
  
  =head1 INLINE MIDDLEWARE
  
  Plack::Builder allows you to code middleware inline using a nested
  code reference.
  
  If the first argument to C<enable> is a code reference, it will be
  passed an C<$app> and should return another code reference
  which is a PSGI application that consumes C<$env> at runtime. So:
  
    builder {
        enable sub {
            my $app = shift;
            sub {
                my $env = shift;
                # do preprocessing
                my $res = $app->($env);
                # do postprocessing
                return $res;
            };
        };
        $app;
    };
  
  is equal to:
  
    my $mw = sub {
        my $app = shift;
        sub { my $env = shift; $app->($env) };
    };
  
    $app = $mw->($app);
  
  =head1 URLMap support
  
  Plack::Builder has a native support for L<Plack::App::URLMap> via the C<mount> method.
  
    use Plack::Builder;
    my $app = builder {
        mount "/foo" => $app1;
        mount "/bar" => builder {
            enable "Foo";
            $app2;
        };
    };
  
  See L<Plack::App::URLMap>'s C<map> method to see what they mean. With
  C<builder> you can't use C<map> as a DSL, for the obvious reason :)
  
  B<NOTE>: Once you use C<mount> in your builder code, you have to use
  C<mount> for all the paths, including the root path (C</>). You can't
  have the default app in the last line of C<builder> like:
  
    my $app = sub {
        my $env = shift;
        ...
    };
  
    builder {
        mount "/foo" => sub { ... };
        $app; # THIS DOESN'T WORK
    };
  
  You'll get warnings saying that your mount configuration will be
  ignored. Instead you should use C<< mount "/" => ... >> in the last
  line to set the default fallback app.
  
    builder {
        mount "/foo" => sub { ... };
        mount "/" => $app;
    }
  
  Note that the C<builder> DSL returns a whole new PSGI application, which means
  
  =over 4
  
  =item *
  
  C<builder { ... }> should normally the last statement of a C<.psgi>
  file, because the return value of C<builder> is the application that
  is actually executed.
  
  =item *
  
  You can nest your C<builder> blocks, mixed with C<mount> statements (see L</"URLMap support">
  above):
  
    builder {
        mount "/foo" => builder {
            mount "/bar" => $app;
        }
    }
  
  will locate the C<$app> under C</foo/bar>, since the inner C<builder>
  block puts it under C</bar> and it results in a new PSGI application
  which is located under C</foo> because of the outer C<builder> block.
  
  =back
  
  =head1 CONDITIONAL MIDDLEWARE SUPPORT
  
  You can use C<enable_if> to conditionally enable middleware based on
  the runtime environment.
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace', force => 1;
        $app;
    };
  
  See L<Plack::Middleware::Conditional> for details.
  
  =head1 OBJECT ORIENTED INTERFACE
  
  Object oriented interface supports the same functionality with the DSL
  version in a clearer interface, probably with more typing required.
  
    # With mount
    my $builder = Plack::Builder->new;
    $builder->add_middleware('Foo', opt => 1);
    $builder->mount('/foo' => $foo_app);
    $builder->mount('/' => $root_app);
    $builder->to_app;
  
    # Nested builders. Equivalent to:
    # builder {
    #     mount '/foo' => builder {
    #         enable 'Foo';
    #         $app;
    #     };
    #     mount '/' => $app2;
    # };
    my $builder_out = Plack::Builder->new;
    my $builder_in  = Plack::Builder->new;
    $builder_in->add_middleware('Foo');
    $builder_out->mount("/foo" => $builder_in->wrap($app));
    $builder_out->mount("/" => $app2);
    $builder_out->to_app;
  
    # conditional. You can also directly use Plack::Middleware::Conditional
    my $builder = Plack::Builder->new;
    $builder->add_middleware_if(sub { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' }, 'StackTrace');
    $builder->wrap($app);
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::App::URLMap> L<Plack::Middleware::Conditional>
  
  =cut
  
  
  
PLACK_BUILDER

$fatpacked{"Plack/Component.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_COMPONENT';
  package Plack::Component;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use overload '&{}' => \&to_app_auto, fallback => 1;
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self;
      if (@_ == 1 && ref $_[0] eq 'HASH') {
          $self = bless {%{$_[0]}}, $class;
      } else {
          $self = bless {@_}, $class;
      }
  
      $self;
  }
  
  sub to_app_auto {
      my $self = shift;
      if (($ENV{PLACK_ENV} || '') eq 'development') {
          my $class = ref($self);
          warn "WARNING: Automatically converting $class instance to a PSGI code reference. " .
            "If you see this warning for each request, you probably need to explicitly call " .
            "to_app() i.e. $class->new(...)->to_app in your PSGI file.\n";
      }
      $self->to_app(@_);
  }
  
  # NOTE:
  # this is for back-compat only,
  # future modules should use
  # Plack::Util::Accessor directly
  # or their own favorite accessor
  # generator.
  # - SL
  sub mk_accessors {
      my $self = shift;
      Plack::Util::Accessor::mk_accessors( ref( $self ) || $self, @_ )
  }
  
  sub prepare_app { return }
  
  sub to_app {
      my $self = shift;
      $self->prepare_app;
      return sub { $self->call(@_) };
  }
  
  
  sub response_cb {
      my($self, $res, $cb) = @_;
      Plack::Util::response_cb($res, $cb);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Component - Base class for PSGI endpoints
  
  =head1 SYNOPSIS
  
    package Plack::App::Foo;
    use parent qw( Plack::Component );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        my $res = ...; # create a response ...
  
        # return the response
        return $res;
    }
  
  =head1 DESCRIPTION
  
  Plack::Component is the base class shared between L<Plack::Middleware>
  and C<Plack::App::*> modules. If you are writing middleware, you should
  inherit from L<Plack::Middleware>, but if you are writing a
  Plack::App::* you should inherit from this directly.
  
  =head1 REQUIRED METHOD
  
  =over 4
  
  =item call ($env)
  
  You are expected to implement a C<call> method in your component. This
  is where all the work gets done. It receives the PSGI C<$env> hash-ref
  as an argument and is expected to return a proper PSGI response value.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item new (%opts | \%opts)
  
  The constructor accepts either a hash or a hashref and uses that to
  create the instance. It will call no other methods and simply return
  the instance that is created.
  
  =item prepare_app
  
  This method is called by C<to_app> and is meant as a hook to be used to
  prepare your component before it is packaged as a PSGI C<$app>.
  
  =item to_app
  
  This is the method used in several parts of the Plack infrastructure to
  convert your component into a PSGI C<$app>. You should not ever need to
  override this method; it is recommended to use C<prepare_app> and C<call>
  instead.
  
  =item response_cb
  
  This is a wrapper for C<response_cb> in L<Plack::Util>. See
  L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =head1 OBJECT LIFECYCLE
  
  Objects for the derived classes (Plack::App::* or
  Plack::Middleware::*) are created at the PSGI application compile
  phase using C<new>, C<prepare_app> and C<to_app>, and the created
  object persists during the web server lifecycle, unless it is running
  on the non-persistent environment like CGI. C<call> is invoked against
  the same object whenever a new request comes in.
  
  You can check if it is running in a persistent environment by checking
  C<psgi.run_once> key in the C<$env> being true (non-persistent) or
  false (persistent), but it is best for you to write your middleware
  safely for a persistent environment. To accomplish that, you should
  avoid saving per-request data like C<$env> in your object.
  
  =head1 BACKWARDS COMPATIBILITY
  
  The L<Plack::Middleware> module used to inherit from L<Class::Accessor::Fast>,
  which has been removed in favor of the L<Plack::Util::Accessor> module. When
  developing new components it is recommended to use L<Plack::Util::Accessor>
  like so:
  
    use Plack::Util::Accessor qw( foo bar baz );
  
  However, in order to keep backwards compatibility this module provides a
  C<mk_accessors> method similar to L<Class::Accessor::Fast>. New code should
  not use this and use L<Plack::Util::Accessor> instead.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Middleware>
  
  =cut
PLACK_COMPONENT

$fatpacked{"Plack/HTTPParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HTTPPARSER';
  package Plack::HTTPParser;
  use strict;
  use parent qw(Exporter);
  
  our @EXPORT = qw( parse_http_request );
  
  use Try::Tiny;
  
  {
      if (!$ENV{PLACK_HTTP_PARSER_PP} && try { require HTTP::Parser::XS; 1 }) {
          *parse_http_request = \&HTTP::Parser::XS::parse_http_request;
      } else {
          require Plack::HTTPParser::PP;
          *parse_http_request = \&Plack::HTTPParser::PP::parse_http_request;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser - Parse HTTP headers
  
  =head1 SYNOPSIS
  
    use Plack::HTTPParser qw(parse_http_request);
  
    my $ret = parse_http_request($header_str, \%env);
    # see HTTP::Parser::XS docs
  
  =head1 DESCRIPTION
  
  Plack::HTTPParser is a wrapper class to dispatch C<parse_http_request>
  to Kazuho Oku's XS based HTTP::Parser::XS or pure perl fallback based
  on David Robins HTTP::Parser.
  
  If you want to force the use of the slower pure perl version even if the
  fast XS version is available, set the environment variable
  C<PLACK_HTTP_PARSER_PP> to 1.
  
  =head1 SEE ALSO
  
  L<HTTP::Parser::XS> L<HTTP::Parser>
  
  =cut
PLACK_HTTPPARSER

$fatpacked{"Plack/HTTPParser/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HTTPPARSER_PP';
  package Plack::HTTPParser::PP;
  use strict;
  use warnings;
  use URI::Escape;
  
  sub parse_http_request {
      my($chunk, $env) = @_;
      $env ||= {};
  
      # pre-header blank lines are allowed (RFC 2616 4.1)
      $chunk =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $chunk;
  
      # double line break indicates end of header; parse it
      if ($chunk =~ /^(.*?\x0d?\x0a\x0d?\x0a)/s) {
          return _parse_header($chunk, length $1, $env);
      }
      return -2;  # still waiting for unknown amount of header lines
  }
  
  sub _parse_header {
      my($chunk, $eoh, $env) = @_;
  
      my $header = substr($chunk, 0, $eoh,'');
      $chunk =~ s/^\x0d?\x0a\x0d?\x0a//;
  
      # parse into lines
      my @header  = split /\x0d?\x0a/,$header;
      my $request = shift @header;
  
      # join folded lines
      my @out;
      for(@header) {
          if(/^[ \t]+/) {
              return -1 unless @out;
              $out[-1] .= $_;
          } else {
              push @out, $_;
          }
      }
  
      # parse request or response line
      my $obj;
      my ($major, $minor);
  
      my ($method,$uri,$http) = split / /,$request;
      return -1 unless $http and $http =~ /^HTTP\/(\d+)\.(\d+)$/i;
      ($major, $minor) = ($1, $2);
  
      $env->{REQUEST_METHOD}  = $method;
      $env->{SERVER_PROTOCOL} = "HTTP/$major.$minor";
      $env->{REQUEST_URI}     = $uri;
  
      my($path, $query) = ( $uri =~ /^([^?]*)(?:\?(.*))?$/s );
      for ($path, $query) { s/\#.*$// if defined && length } # dumb clients sending URI fragments
  
      $env->{PATH_INFO}    = URI::Escape::uri_unescape($path);
      $env->{QUERY_STRING} = $query || '';
      $env->{SCRIPT_NAME}  = '';
  
      # import headers
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
      my $k;
      for my $header (@out) {
          if ( $header =~ s/^($token): ?// ) {
              $k = $1;
              $k =~ s/-/_/g;
              $k = uc $k;
  
              if ($k !~ /^(?:CONTENT_LENGTH|CONTENT_TYPE)$/) {
                  $k = "HTTP_$k";
              }
          } elsif ( $header =~ /^\s+/) {
              # multiline header
          } else {
              return -1;
          }
  
          if (exists $env->{$k}) {
              $env->{$k} .= ", $header";
          } else {
              $env->{$k} = $header;
          }
      }
  
      return $eoh;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser::PP - Pure perl fallback of HTTP::Parser::XS
  
  =head1 DESCRIPTION
  
  Do not use this module directly. Use L<Plack::HTTPParser> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
  
PLACK_HTTPPARSER_PP

$fatpacked{"Plack/Handler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER';
  package Plack::Handler;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler - Connects PSGI applications and Web servers
  
  =head1 SYNOPSIS
  
    package Plack::Handler::AwesomeWebServer;
    sub new {
        my($class, %opt) = @_;
        ...
        return $self;
    }
  
    sub run {
        my($self, $app) = @_;
        # launch the AwesomeWebServer and run $app in the loop
    }
  
    # then from command line
    plackup -s AwesomeWebServer -a app.psgi
  
  =head1 DESCRIPTION
  
  Plack::Handler defines an adapter (connector) interface to adapt
  L<plackup> and L<Plack::Runner> to various PSGI web servers, such as
  Apache2 for mod_perl and Standalone for L<HTTP::Server::PSGI>.
  
  It is an empty class, and as long as they implement the methods
  defined as an Server adapter interface, they do not need to inherit
  Plack::Handler.
  
  If you write a new handler for existing web servers, I recommend you
  to include the full name of the server module after I<Plack::Handler>
  prefix, like L<Plack::Handler::Net::Server::Coro> if you write a
  handler for L<Net::Server::Coro>. That way you'll be using plackup
  command line option like:
  
    plackup -s Net::Server::Coro
  
  that makes it easy to figure out which web server you're going to use.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $server = FooBarServer->new(%args);
  
  Creates a new adapter object. I<%args> can take arbitrary parameters
  to configure server environments but common parameters are:
  
  =over 8
  
  =item port
  
  Port number the server listens to.
  
  =item host
  
  Address the server listens to. Set to undef to listen any interface.
  
  =back
  
  =item run
  
    $server->run($app);
  
  Starts the server process and when a request comes in, run the PSGI
  application passed in C<$app> in the loop.
  
  =item register_service
  
    $server->register_service($app);
  
  Optional interface if your server should run in parallel with other
  event loop, particularly L<AnyEvent>. This is the same as C<run> but
  doesn't run the main loop.
  
  =back
  
  =head1 SEE ALSO
  
  rackup
  
  =cut
  
PLACK_HANDLER

$fatpacked{"Plack/Handler/Apache1.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_APACHE1';
  package Plack::Handler::Apache1;
  use strict;
  use Apache::Request;
  use Apache::Constants qw(:common :response);
  
  use Plack::Util;
  use Scalar::Util;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          # Trick Catalyst, CGI.pm, CGI::Cookie and others that check
          # for $ENV{MOD_PERL}.
          #
          # Note that we delete it instead of just localizing
          # $ENV{MOD_PERL} because some users may check if the key
          # exists, and we do it this way because "delete local" is new
          # in 5.12:
          # http://perldoc.perl.org/5.12.0/perldelta.html#delete-local
          local $ENV{MOD_PERL};
          delete $ENV{MOD_PERL};
  
          Plack::Util::load_psgi $app;
      };
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
          'psgix.harakiri'      => Plack::Util::TRUE,
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      my $vpath    = $env->{SCRIPT_NAME} . ($env->{PATH_INFO} || '');
  
      my $location = $r->location || "/";
         $location =~ s{/$}{};
      (my $path_info = $vpath) =~ s/^\Q$location\E//;
  
      $env->{SCRIPT_NAME} = $location;
      $env->{PATH_INFO}   = $path_info;
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if ($env->{'psgix.harakiri.commit'}) {
          $r->child_terminate;
      }
  
      return OK;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
      $r->send_http_header;
  
      if (defined $body) {
          if (Plack::Util::is_real_fh($body)) {
              $r->send_fd($body);
          } else {
              Plack::Util::foreach($body, sub { $r->print(@_) });
          }
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_) },
              close => sub { };
      }
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Plack::Handler::Apache1 - Apache 1.3.x mod_perl handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlHandler Plack::Handler::Apache1
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    <Perl>
    use Plack::Handler::Apache1;
    Plack::Handler::Apache1->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a mod_perl handler module to run any PSGI application with mod_perl on Apache 1.3.x.
  
  If you want to run PSGI applications I<behind> Apache instead of using
  mod_perl, see L<Plack::Handler::FCGI> to run with FastCGI, or use
  standalone HTTP servers such as L<Starman> or L<Starlet> proxied with
  mod_proxy.
  
  =head1 AUTHOR
  
  Aaron Trevena
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_APACHE1

$fatpacked{"Plack/Handler/Apache2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_APACHE2';
  package Plack::Handler::Apache2;
  use strict;
  use warnings;
  use Apache2::RequestRec;
  use Apache2::RequestIO;
  use Apache2::RequestUtil;
  use Apache2::Response;
  use Apache2::Const -compile => qw(OK);
  use Apache2::Log;
  use APR::Table;
  use IO::Handle;
  use Plack::Util;
  use Scalar::Util;
  use URI;
  use URI::Escape;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          # Trick Catalyst, CGI.pm, CGI::Cookie and others that check
          # for $ENV{MOD_PERL}.
          #
          # Note that we delete it instead of just localizing
          # $ENV{MOD_PERL} because some users may check if the key
          # exists, and we do it this way because "delete local" is new
          # in 5.12:
          # http://perldoc.perl.org/5.12.0/perldelta.html#delete-local
          local $ENV{MOD_PERL};
          delete $ENV{MOD_PERL};
  
          Plack::Util::load_psgi $app;
      };
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'           => [ 1, 1 ],
          'psgi.url_scheme'        => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'             => $r,
          'psgi.errors'            => *STDERR,
          'psgi.multithread'       => Plack::Util::FALSE,
          'psgi.multiprocess'      => Plack::Util::TRUE,
          'psgi.run_once'          => Plack::Util::FALSE,
          'psgi.streaming'         => Plack::Util::TRUE,
          'psgi.nonblocking'       => Plack::Util::FALSE,
          'psgix.harakiri'         => Plack::Util::TRUE,
          'psgix.cleanup'          => Plack::Util::TRUE,
          'psgix.cleanup.handlers' => [],
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      # If you supply more than one Content-Length header Apache will
      # happily concat the values with ", ", e.g. "72, 72". This
      # violates the PSGI spec so fix this up and just take the first
      # one.
      if (exists $env->{CONTENT_LENGTH} && $env->{CONTENT_LENGTH} =~ /,/) {
          no warnings qw(numeric);
          $env->{CONTENT_LENGTH} = int $env->{CONTENT_LENGTH};
      }
  
      # Actually, we can not trust PATH_INFO from mod_perl because mod_perl squeezes multiple slashes into one slash.
      my $uri = URI->new("http://".$r->hostname.$r->unparsed_uri);
  
      $env->{PATH_INFO} = uri_unescape($uri->path);
  
      $class->fixup_path($r, $env);
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if (@{ $env->{'psgix.cleanup.handlers'} }) {
          $r->push_handlers(
              PerlCleanupHandler => sub {
                  for my $cleanup_handler (@{ $env->{'psgix.cleanup.handlers'} }) {
                      $cleanup_handler->($env);
                  }
  
                  if ($env->{'psgix.harakiri.commit'}) {
                      $r->child_terminate;
                  }
              },
          );
      } else {
          if ($env->{'psgix.harakiri.commit'}) {
              $r->child_terminate;
          }
      }
  
      return Apache2::Const::OK;
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  # The method for PH::Apache2::Registry to override.
  sub fixup_path {
      my ($class, $r, $env) = @_;
  
      # $env->{PATH_INFO} is created from unparsed_uri so it is raw.
      my $path_info = $env->{PATH_INFO} || '';
  
      # Get argument of <Location> or <LocationMatch> directive
      # This may be string or regexp and we can't know either.
      my $location = $r->location;
  
      # Let's *guess* if we're in a LocationMatch directive
      if ($location eq '/') {
          # <Location /> could be handled as a 'root' case where we make
          # everything PATH_INFO and empty SCRIPT_NAME as in the PSGI spec
          $env->{SCRIPT_NAME} = '';
      } elsif ($path_info =~ s{^($location)/?}{/}) {
          $env->{SCRIPT_NAME} = $1 || '';
      } else {
          # Apache's <Location> is matched but here is not.
          # This is something wrong. We can only respect original.
          $r->server->log_error(
              "Your request path is '$path_info' and it doesn't match your Location(Match) '$location'. " .
              "This should be due to the configuration error. See perldoc Plack::Handler::Apache2 for details."
          );
      }
  
      $env->{PATH_INFO}   = $path_info;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
  
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } elsif (lc $h eq 'content-length') {
              $r->set_content_length($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
  
      if (Scalar::Util::blessed($body) and $body->can('path') and my $path = $body->path) {
          $r->sendfile($path);
      } elsif (defined $body) {
          Plack::Util::foreach($body, sub { $r->print(@_) });
          $r->rflush;
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_); $r->rflush },
              close => sub { $r->rflush };
      }
  
      return Apache2::Const::OK;
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Plack::Handler::Apache2 - Apache 2.0 mod_perl handler to run PSGI application
  
  =head1 SYNOPSIS
  
    # in your httpd.conf
    <Location />
    SetHandler perl-script
    PerlResponseHandler Plack::Handler::Apache2
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    # Optionally preload your apps in startup
    PerlPostConfigRequire /etc/httpd/startup.pl
  
  See L</STARTUP FILE> for more details on writing a C<startup.pl>.
  
  =head1 DESCRIPTION
  
  This is a mod_perl handler module to run any PSGI application with mod_perl on Apache 2.x.
  
  If you want to run PSGI applications I<behind> Apache instead of using
  mod_perl, see L<Plack::Handler::FCGI> to run with FastCGI, or use
  standalone HTTP servers such as L<Starman> or L<Starlet> proxied with
  mod_proxy.
  
  =head1 CREATING CUSTOM HANDLER
  
  If you want to create a custom handler that loads or creates PSGI
  applications using other means than loading from C<.psgi> files, you
  can create your own handler class and use C<call_app> class method to
  run your application.
  
    package My::ModPerl::Handler;
    use Plack::Handler::Apache2;
  
    sub get_app {
      # magic!
    }
  
    sub handler {
      my $r = shift;
      my $app = get_app();
      Plack::Handler::Apache2->call_app($r, $app);
    }
  
  =head1 STARTUP FILE
  
  Here is an example C<startup.pl> to preload PSGI applications:
  
      #!/usr/bin/env perl
  
      use strict;
      use warnings;
      use Apache2::ServerUtil ();
  
      BEGIN {
          return unless Apache2::ServerUtil::restart_count() > 1;
  
          require lib;
          lib->import('/path/to/my/perl/libs');
  
          require Plack::Handler::Apache2;
  
          my @psgis = ('/path/to/app1.psgi', '/path/to/app2.psgi');
          foreach my $psgi (@psgis) {
              Plack::Handler::Apache2->preload($psgi);
          }
      }
  
      1; # file must return true!
  
  See L<http://perl.apache.org/docs/2.0/user/handlers/server.html#Startup_File>
  for general information on the C<startup.pl> file for preloading perl modules
  and your apps.
  
  Some things to keep in mind when writing this file:
  
  =over 4
  
  =item * multiple init phases
  
  You have to check that L<Apache2::ServerUtil/restart_count> is C<< > 1 >>,
  otherwise your app will load twice and the env vars you set with
  L<PerlSetEnv|http://perl.apache.org/docs/2.0/user/config/config.html#C_PerlSetEnv_>
  will not be available when your app is loading the first time.
  
  Use the example above as a template.
  
  =item * C<@INC>
  
  The C<startup.pl> file is a good place to add entries to your C<@INC>.
  Use L<lib> to add entries, they can be in your app or C<.psgi> as well, but if
  your modules are in a L<local::lib> or some such, you will need to add the path
  for anything to load.
  
  Alternately, if you follow the example above, you can use:
  
      PerlSetEnv PERL5LIB /some/path
  
  or
  
      PerlSwitches -I/some/path
  
  in your C<httpd.conf>, which will also work.
  
  =item * loading errors
  
  Any exceptions thrown in your C<startup.pl> will stop Apache from starting at
  all.
  
  You probably don't want a stray syntax error to bring your whole server down in
  a shared or development environment, in which case it's a good idea to wrap the
  L</preload> call in an eval, using something like this:
  
      require Plack::Handler::Apache2;
  
      my @psgis = ('/path/to/app1.psgi', '/path/to/app2.psgi');
  
      foreach my $psgi (@psgis) {
          eval {
              Plack::Handler::Apache2->preload($psgi); 1;
          } or do {
              my $error = $@ || 'Unknown Error';
              # STDERR goes to the error_log
              print STDERR "Failed to load psgi '$psgi': $error\n";
          };
      }
  
  
  =item * dynamically loaded modules
  
  Some modules load their dependencies at runtime via e.g. L<Class::Load>. These
  modules will not get preloaded into your parent process by just including the
  app/module you are using.
  
  As an optimization, you can dump C<%INC> from a request to see if you are using
  any such modules and preload them in your C<startup.pl>.
  
  Another method is dumping the difference between the C<%INC> on
  process start and process exit. You can use something like this to
  accomplish this:
  
      my $start_inc = { %INC };
  
      END {
          my @m;
          foreach my $m (keys %INC) {
              push @m, $m unless exists $start_inc->{$m};
          }
  
          if (@m) {
              # STDERR goes to the error_log
              print STDERR "The following modules need to be preloaded:\n";
              print STDERR "$_\n" for @m;
          }
      }
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Paul Driver
  
  Ævar Arnfjörð Bjarmason
  
  Rafael Kitover
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_HANDLER_APACHE2

$fatpacked{"Plack/Handler/Apache2/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_APACHE2_REGISTRY';
  package Plack::Handler::Apache2::Registry;
  use strict;
  use warnings;
  use Try::Tiny;
  use Apache2::Const;
  use Apache2::Log;
  use parent qw/Plack::Handler::Apache2/;
  
  sub handler {
      my $class = __PACKAGE__;
      my ($r) = @_;
  
      return try {
          my $app = $class->load_app( $r->filename );
          $class->call_app( $r, $app );
      }catch{
          if(/no such file/i){
              $r->log_error( $_ );
              return Apache2::Const::NOT_FOUND;
          }else{
              $r->log_error( $_ );
              return Apache2::Const::SERVER_ERROR;
          }
      };
  }
  
  # Overriding
  sub fixup_path {
      my ($class, $r, $env) = @_;
      $env->{PATH_INFO} =~ s{^$env->{SCRIPT_NAME}}{};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2::Registry - Runs .psgi files.
  
  =head1 SYNOPSIS
  
    PerlModule Plack::Handler::Apache2::Registry;
    <Location /psgi-bin>
    SetHandler modperl
    PerlHandler Plack::Handler::Apache2::Registry
    </Location>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any *.psgi files with mod_perl2,
  just like ModPerl::Registry.
  
  =head1 AUTHOR
  
  Masahiro Honma E<lt>hiratara@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Apache2>
  
  =cut
  
PLACK_HANDLER_APACHE2_REGISTRY

$fatpacked{"Plack/Handler/CGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_CGI';
  package Plack::Handler::CGI;
  use strict;
  use warnings;
  use IO::Handle;
  
  # copied from HTTP::Status
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
  );
  
  sub new { bless {}, shift }
  
  sub run {
      my ($self, $app) = @_;
  
      my $env = $self->setup_env();
  
      my $res = $app->($env);
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  }
  
  sub setup_env {
      my ( $self, $override_env ) = @_;
  
      $override_env ||= {};
  
      binmode STDIN;
      binmode STDERR;
  
      my $env = {
          %ENV,
          'psgi.version'    => [ 1, 1 ],
          'psgi.url_scheme' => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'      => *STDIN,
          'psgi.errors'     => *STDERR,
          'psgi.multithread'  => 0,
          'psgi.multiprocess' => 1,
          'psgi.run_once'     => 1,
          'psgi.streaming'    => 1,
          'psgi.nonblocking'  => 1,
          %{ $override_env },
      };
  
      delete $env->{HTTP_CONTENT_TYPE};
      delete $env->{HTTP_CONTENT_LENGTH};
      $env->{'HTTP_COOKIE'} ||= $ENV{COOKIE}; # O'Reilly server bug
  
      if (!exists $env->{PATH_INFO}) {
          $env->{PATH_INFO} = '';
      }
  
      if ($env->{SCRIPT_NAME} eq '/') {
          $env->{SCRIPT_NAME} = '';
          $env->{PATH_INFO}   = '/' . $env->{PATH_INFO};
      }
  
      return $env;
  }
  
  
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
      binmode STDOUT;
  
      my $hdrs;
      my $message = $StatusCode{$res->[0]};
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice(@$headers, 0, 2)) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $body = $res->[2];
      my $cb = sub { print STDOUT $_[0] };
  
      # inline Plack::Util::foreach here
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      }
      elsif (defined $body) {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
      else {
          return Plack::Handler::CGI::Writer->new;
      }
  }
  
  package Plack::Handler::CGI::Writer;
  sub new   { bless \do { my $x }, $_[0] }
  sub write { print STDOUT $_[1] }
  sub close { }
  
  package Plack::Handler::CGI;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Handler::CGI - CGI handler for Plack
  
  =head1 SYNOPSIS
  
  Want to run PSGI application as a CGI script? Rename .psgi to .cgi and
  change the shebang line like:
  
    #!/usr/bin/env plackup
    # rest of the file can be the same as other .psgi file
  
  You can alternatively create a .cgi file that contains something like:
  
    #!/usr/bin/perl
    use Plack::Loader;
    my $app = Plack::Util::load_psgi("/path/to/app.psgi");
    Plack::Loader->auto->run($app);
  
  This will auto-recognize the CGI environment variable to load this class.
  
  If you really want to explicitly load the CGI handler, you can. For instance
  you might do this when you want to embed a PSGI application server built into
  CGI-compatible perl-based web server:
  
    use Plack::Handler::CGI;
    Plack::Handler::CGI->new->run($app);
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a CGI script.
  
  =head1 UTILITY METHODS
  
  =head2 setup_env()
  
    my $env = Plack::Handler::CGI->setup_env();
    my $env = Plack::Handler::CGI->setup_env(\%override_env);
  
  Sets up the PSGI environment hash for a CGI request from C<< %ENV >>> and returns it.
  You can provide a hashref of key/value pairs to override the defaults if you would like.
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
  
PLACK_HANDLER_CGI

$fatpacked{"Plack/Handler/FCGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_FCGI';
  package Plack::Handler::FCGI;
  use strict;
  use warnings;
  use constant RUNNING_IN_HELL => $^O eq 'MSWin32';
  
  use Scalar::Util qw(blessed);
  use Plack::Util;
  use FCGI;
  use HTTP::Status qw(status_message);
  use URI;
  use URI::Escape;
  
  sub new {
      my $class = shift;
      my $self  = bless {@_}, $class;
  
      $self->{leave_umask} ||= 0;
      $self->{keep_stderr} ||= 0;
      $self->{nointr}      ||= 0;
      $self->{daemonize}   ||= $self->{detach}; # compatibility
      $self->{nproc}       ||= 1 unless blessed $self->{manager};
      $self->{pid}         ||= $self->{pidfile}; # compatibility
      $self->{listen}      ||= [ ":$self->{port}" ] if $self->{port}; # compatibility
      $self->{backlog}     ||= 100;
      $self->{manager}     = 'FCGI::ProcManager' unless exists $self->{manager};
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $running_on_server_starter = exists $ENV{SERVER_STARTER_PORT};
      my $sock = 0;
      if (-S STDIN) {
          # running from web server. Do nothing
          # Note it should come before listen check because of plackup's default
      } elsif ($running_on_server_starter) {
          # Runing under Server::Starter
          require Server::Starter;
          my %socks = %{Server::Starter::server_ports()};
          if (scalar(keys(%socks)) > 1) {
              die "More than one socket are specified by Server::Starter";
          }
          $sock = (values %socks)[0];
      } elsif ($self->{listen}) {
          my $old_umask = umask;
          unless ($self->{leave_umask}) {
              umask(0);
          }
          $sock = FCGI::OpenSocket( $self->{listen}->[0], $self->{backlog} )
              or die "failed to open FastCGI socket: $!";
          unless ($self->{leave_umask}) {
              umask($old_umask);
          }
      } elsif (!RUNNING_IN_HELL) {
          die "STDIN is not a socket: specify a listen location";
      }
  
      @{$self}{qw(stdin stdout stderr)} 
        = (IO::Handle->new, IO::Handle->new, IO::Handle->new);
  
      my %env;
      my $request = FCGI::Request(
          $self->{stdin}, $self->{stdout}, $self->{stderr},
          \%env, $sock,
          ($self->{nointr} ? 0 : &FCGI::FAIL_ACCEPT_ON_INTR),
      );
  
      my $proc_manager;
  
      if ($self->{listen} or $running_on_server_starter) {
          $self->daemon_fork if $self->{daemonize};
  
          if ($self->{manager}) {
              if (blessed $self->{manager}) {
                  for (qw(nproc pid proc_title)) {
                      die "Don't use '$_' when passing in a 'manager' object"
                          if $self->{$_};
                  }
                  $proc_manager = $self->{manager};
              } else {
                  Plack::Util::load_class($self->{manager});
                  $proc_manager = $self->{manager}->new({
                      n_processes => $self->{nproc},
                      pid_fname   => $self->{pid},
                      (exists $self->{proc_title}
                           ? (pm_title => $self->{proc_title}) : ()),
                  });
              }
  
              # detach *before* the ProcManager inits
              $self->daemon_detach if $self->{daemonize};
  
              $proc_manager->pm_manage;
          }
          elsif ($self->{daemonize}) {
              $self->daemon_detach;
          }
      }
  
      while ($request->Accept >= 0) {
          $proc_manager && $proc_manager->pm_pre_dispatch;
  
          my $env = {
              %env,
              'psgi.version'      => [1,1],
              'psgi.url_scheme'   => ($env{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
              'psgi.input'        => $self->{stdin},
              'psgi.errors'       => 
                  ($self->{keep_stderr} ? \*STDERR : $self->{stderr}),
              'psgi.multithread'  => Plack::Util::FALSE,
              'psgi.multiprocess' => defined $proc_manager,
              'psgi.run_once'     => Plack::Util::FALSE,
              'psgi.streaming'    => Plack::Util::TRUE,
              'psgi.nonblocking'  => Plack::Util::FALSE,
              'psgix.harakiri'    => defined $proc_manager,
          };
  
          delete $env->{HTTP_CONTENT_TYPE};
          delete $env->{HTTP_CONTENT_LENGTH};
  
          # lighttpd munges multiple slashes in PATH_INFO into one. Try recovering it
          my $uri = URI->new("http://localhost" .  $env->{REQUEST_URI});
          $env->{PATH_INFO} = uri_unescape($uri->path);
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E//;
  
          # root access for mod_fastcgi
          if (!exists $env->{PATH_INFO}) {
              $env->{PATH_INFO} = '';
          }
  
          # typical fastcgi_param from nginx might get empty values
          for my $key (qw(CONTENT_TYPE CONTENT_LENGTH)) {
              no warnings;
              delete $env->{$key} if exists $env->{$key} && $env->{$key} eq '';
          }
  
          if (defined(my $HTTP_AUTHORIZATION = $env->{Authorization})) {
              $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
          }
  
          my $res = Plack::Util::run_app $app, $env;
  
          if (ref $res eq 'ARRAY') {
              $self->_handle_response($res);
          }
          elsif (ref $res eq 'CODE') {
              $res->(sub {
                  $self->_handle_response($_[0]);
              });
          }
          else {
              die "Bad response $res";
          }
  
          # give pm_post_dispatch the chance to do things after the client thinks
          # the request is done
          $request->Finish;
  
          $proc_manager && $proc_manager->pm_post_dispatch();
  
          if ($proc_manager && $env->{'psgix.harakiri.commit'}) {
              $proc_manager->pm_exit("safe exit with harakiri");
          }
      }
  }
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      $self->{stdout}->autoflush(1);
      binmode $self->{stdout};
  
      my $hdrs;
      my $message = status_message($res->[0]);
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice @$headers, 0, 2) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print { $self->{stdout} } $hdrs;
  
      my $cb = sub { print { $self->{stdout} } $_[0] };
      my $body = $res->[2];
      if (defined $body) {
          Plack::Util::foreach($body, $cb);
      }
      else {
          return Plack::Util::inline_object
              write => $cb,
              close => sub { };
      }
  }
  
  sub daemon_fork {
      require POSIX;
      fork && exit;
  }
  
  sub daemon_detach {
      my $self = shift;
      print "FastCGI daemon started (pid $$)\n";
      open STDIN,  "+</dev/null" or die $!; ## no critic
      open STDOUT, ">&STDIN"     or die $!;
      open STDERR, ">&STDIN"     or die $!;
      POSIX::setsid();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::FCGI - FastCGI handler for Plack
  
  =head1 SYNOPSIS
  
    # Run as a standalone daemon
    plackup -s FCGI --listen /tmp/fcgi.sock --daemonize --nproc 10
  
    # Run from your web server like mod_fastcgi
    #!/usr/bin/env plackup -s FCGI
    my $app = sub { ... };
  
    # Roll your own
    my $server = Plack::Handler::FCGI->new(
        nproc  => $num_proc,
        listen => [ $port_or_socket ],
        detach => 1,
    );
    $server->run($app);
  
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a standalone
  FastCGI daemon or a .fcgi script.
  
  =head2 OPTIONS
  
  =over 4
  
  =item listen
  
      listen => [ '/path/to/socket' ]
      listen => [ ':8080' ]
  
  Listen on a socket path, hostname:port, or :port.
  
  =item port
  
  listen via TCP on port on all interfaces (Same as C<< listen => ":$port" >>)
  
  =item leave-umask
  
  Set to 1 to disable setting umask to 0 for socket open
  
  =item nointr
  
  Do not allow the listener to be interrupted by Ctrl+C
  
  =item nproc
  
  Specify a number of processes for FCGI::ProcManager
  
  =item pid
  
  Specify a filename for the pid file
  
  =item manager
  
  Specify either a FCGI::ProcManager subclass, or an actual FCGI::ProcManager-compatible object.
  If you do not want a FCGI::ProcManager but instead run in a single process, set this to undef.
  
    use FCGI::ProcManager::Dynamic;
    Plack::Handler::FCGI->new(
        manager => FCGI::ProcManager::Dynamic->new(...),
    );
  
  =item daemonize
  
  Daemonize the process.
  
  =item proc-title
  
  Specify process title
  
  =item keep-stderr
  
  Send psgi.errors to STDERR instead of to the FCGI error stream.
  
  =item backlog
  
  Maximum length of the queue of pending connections
  
  =back
  
  =head2 WEB SERVER CONFIGURATIONS
  
  In all cases, you will want to install L<FCGI> and L<FCGI::ProcManager>.
  You may find it most convenient to simply install L<Task::Plack> which
  includes both of these.
  
  =head3 nginx
  
  This is an example nginx configuration to run your FCGI daemon on a
  Unix domain socket and run it at the server's root URL (/).
  
    http {
      server {
        listen 3001;
        location / {
          set $script "";
          set $path_info $uri;
          fastcgi_pass unix:/tmp/fastcgi.sock;
          fastcgi_param  SCRIPT_NAME      $script;
          fastcgi_param  PATH_INFO        $path_info;
          fastcgi_param  QUERY_STRING     $query_string;
          fastcgi_param  REQUEST_METHOD   $request_method;
          fastcgi_param  CONTENT_TYPE     $content_type;
          fastcgi_param  CONTENT_LENGTH   $content_length;
          fastcgi_param  REQUEST_URI      $request_uri;
          fastcgi_param  SERVER_PROTOCOL  $server_protocol;
          fastcgi_param  REMOTE_ADDR      $remote_addr;
          fastcgi_param  REMOTE_PORT      $remote_port;
          fastcgi_param  SERVER_ADDR      $server_addr;
          fastcgi_param  SERVER_PORT      $server_port;
          fastcgi_param  SERVER_NAME      $server_name;
        }
      }
    }
  
  If you want to host your application in a non-root path, then you
  should mangle this configuration to set the path to C<SCRIPT_NAME> and
  the rest of the path in C<PATH_INFO>.
  
  See L<http://wiki.nginx.org/NginxFcgiExample> for more details.
  
  =head3 Apache mod_fastcgi
  
  After installing C<mod_fastcgi>, you should add the C<FastCgiExternalServer>
  directive to your Apache config:
  
    FastCgiExternalServer /tmp/myapp.fcgi -socket /tmp/fcgi.sock
  
    ## Then set up the location that you want to be handled by fastcgi:
  
    # EITHER from a given path
    Alias /myapp/ /tmp/myapp.fcgi/
  
    # OR at the root
    Alias / /tmp/myapp.fcgi/
  
  Now you can use plackup to listen to the socket that you've just configured in Apache.
  
    $  plackup -s FCGI --listen /tmp/myapp.sock psgi/myapp.psgi
  
  The above describes the "standalone" method, which is usually appropriate.
  There are other methods, described in more detail at 
  L<Catalyst::Engine::FastCGI/Standalone_server_mode> (with regards to Catalyst, but which may be set up similarly for Plack).
  
  See also L<http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html#FastCgiExternalServer>
  for more details.
  
  =head3 lighttpd
  
  To host the app in the root path, you're recommended to use lighttpd
  1.4.23 or newer with C<fix-root-scriptname> flag like below.
  
    fastcgi.server = ( "/" =>
       ((
         "socket" => "/tmp/fcgi.sock",
         "check-local" => "disable",
         "fix-root-scriptname" => "enable",
       ))
  
  If you use lighttpd older than 1.4.22 where you don't have
  C<fix-root-scriptname>, mounting apps under the root causes wrong
  C<SCRIPT_NAME> and C<PATH_INFO> set. Also, mounting under the empty
  root (C<"">) or a path that has a trailing slash would still cause
  weird values set even with C<fix-root-scriptname>. In such cases you
  can use L<Plack::Middleware::LighttpdScriptNameFix> to fix it.
  
  To mount in the non-root path over TCP:
  
    fastcgi.server = ( "/foo" =>
       ((
         "host" = "127.0.0.1",
         "port" = "5000",
         "check-local" => "disable",
       ))
  
  It's recommended that your mount path does B<NOT> have the trailing
  slash. If you I<really> need to have one, you should consider using
  L<Plack::Middleware::LighttpdScriptNameFix> to fix the wrong
  B<PATH_INFO> values set by lighttpd.
  
  =cut
  
  =head2 Authorization
  
  Most fastcgi configuration does not pass C<Authorization> headers to
  C<HTTP_AUTHORIZATION> environment variable by default for security
  reasons. Authentication middleware such as L<Plack::Middleware::Auth::Basic> or
  L<Catalyst::Authentication::Credential::HTTP> requires the variable to
  be set up. Plack::Handler::FCGI supports extracting the C<Authorization> environment
  variable when it is configured that way.
  
  Apache2 with mod_fastcgi:
  
    --pass-header Authorization
  
  mod_fcgid:
  
    FcgiPassHeader Authorization
  
  =head2 Server::Starter
  
  This plack handler supports L<Server::Starter> as a superdaemon.
  Simply launch plackup from start_server with a path option.
  The listen option is ignored when launched from Server::Starter.
  
    start_server --path=/tmp/socket -- plackup -s FCGI app.psgi 
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_FCGI

$fatpacked{"Plack/Handler/HTTP/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_HTTP_SERVER_PSGI';
  package Plack::Handler::HTTP::Server::PSGI;
  use strict;
  
  # for temporary backward compat
  use parent qw( HTTP::Server::PSGI );
  
  sub new {
      my($class, %args) = @_;
      bless { %args }, $class;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->_server->run($app);
  }
  
  sub _server {
      my $self = shift;
      HTTP::Server::PSGI->new(%$self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::PSGI - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s HTTP::Server::PSGI \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 BACKWARD COMPATIBLITY
  
  Since Plack 0.99_22 this handler doesn't support preforking
  configuration i.e. C<--max-workers>. Use L<Starman> or L<Starlet> if
  you need preforking PSGI web server.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item host
  
  Host the server binds to. Defaults to all interfaces.
  
  =item port
  
  Port number the server listens on. Defaults to 8080.
  
  =item timeout
  
  Number of seconds a request times out. Defaults to 300.
  
  =item max-reqs-per-child
  
  Number of requests per worker to process. Defaults to 100.
  
  =back
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack> L<HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_HTTP_SERVER_PSGI

$fatpacked{"Plack/Handler/Standalone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_STANDALONE';
  package Plack::Handler::Standalone;
  use strict;
  use warnings;
  use parent qw( Plack::Handler::HTTP::Server::PSGI );
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Standalone - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s Standalone \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 DESCRIPTION
  
  Plack::Handler::Standalone is an adapter for default Plack server
  implementation L<HTTP::Server::PSGI>. This is just an alias for
  L<Plack::Handler::HTTP::Server::PSGI>.
  
  =head1 SEE ALSO
  
  L<Plack::Handler::HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_STANDALONE

$fatpacked{"Plack/LWPish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LWPISH';
  package Plack::LWPish;
  use strict;
  use warnings;
  use HTTP::Tiny;
  use HTTP::Response;
  use Hash::MultiValue;
  
  sub new {
      my $class = shift;
      my $self  = bless {}, $class;
      $self->{http} = @_ == 1 ? $_[0] : HTTP::Tiny->new(@_);
      $self;
  }
  
  sub request {
      my($self, $req) = @_;
  
      my @headers;
      $req->headers->scan(sub { push @headers, @_ });
  
      my $options = {
          headers => Hash::MultiValue->new(@headers)->mixed,
      };
      $options->{content} = $req->content if defined $req->content && length($req->content);
  
      my $response = $self->{http}->request($req->method, $req->url, $options);
  
      my $res = HTTP::Response->new(
          $response->{status},
          $response->{reason},
          [ Hash::MultiValue->from_mixed($response->{headers})->flatten ],
          $response->{content},
      );
      $res->request($req);
  
      return $res;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::LWPish - HTTP::Request/Response compatible interface with HTTP::Tiny backend
  
  =head1 SYNOPSIS
  
    use Plack::LWPish;
  
    my $request = HTTP::Request->new(GET => 'http://perl.com/');
  
    my $ua = Plack::LWPish->new;
    my $res = $ua->request($request); # returns HTTP::Response
  
  =head1 DESCRIPTION
  
  This module is an adapter object that implements one method,
  C<request> that acts like L<LWP::UserAgent>'s request method
  i.e. takes HTTP::Request object and returns HTTP::Response object.
  
  This module is used solely inside L<Plack::Test::Suite> and
  L<Plack::Test::Server>, and you are recommended to take a look at
  L<HTTP::Thin> if you would like to use this outside Plack.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Thin> L<HTTP::Tiny> L<LWP::UserAgent>
  
  =cut
PLACK_LWPISH

$fatpacked{"Plack/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER';
  package Plack::Loader;
  use strict;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {}, $class;
  }
  
  sub watch {
      # do nothing. Override in subclass
  }
  
  sub auto {
      my($class, @args) = @_;
  
      my $backend = $class->guess
          or Carp::croak("Couldn't auto-guess server server implementation. Set it with PLACK_SERVER");
  
      my $server = try {
          $class->load($backend, @args);
      } catch {
          if (($ENV{PLACK_ENV}||'') eq 'development' or !/^Can't locate /) {
              warn "Autoloading '$backend' backend failed. Falling back to the Standalone. ",
                  "(You might need to install Plack::Handler::$backend from CPAN.  Caught error was: $_)\n"
                      if $ENV{PLACK_ENV} && $ENV{PLACK_ENV} eq 'development';
          }
          $class->load('Standalone' => @args);
      };
  
      return $server;
  }
  
  sub load {
      my($class, $server, @args) = @_;
  
      my($server_class, $error);
      try {
          $server_class = Plack::Util::load_class($server, 'Plack::Handler');
      } catch {
          $error ||= $_;
      };
  
      if ($server_class) {
          $server_class->new(@args);
      } else {
          die $error;
      }
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{app} = $builder->();
  }
  
  sub guess {
      my $class = shift;
  
      my $env = $class->env;
  
      return $env->{PLACK_SERVER} if $env->{PLACK_SERVER};
  
      if ($env->{PHP_FCGI_CHILDREN} || $env->{FCGI_ROLE} || $env->{FCGI_SOCKET_PATH}) {
          return "FCGI";
      } elsif ($env->{GATEWAY_INTERFACE}) {
          return "CGI";
      } elsif (exists $INC{"Coro.pm"}) {
          return "Corona";
      } elsif (exists $INC{"AnyEvent.pm"}) {
          return "Twiggy";
      } elsif (exists $INC{"POE.pm"}) {
          return "POE";
      } else {
          return "Standalone";
      }
  }
  
  sub env { \%ENV }
  
  sub run {
      my($self, $server, $builder) = @_;
      $server->run($self->{app});
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader - (auto)load Plack Servers
  
  =head1 SYNOPSIS
  
    # auto-select server backends based on env vars
    use Plack::Loader;
    Plack::Loader->auto(%args)->run($app);
  
    # specify the implementation with a name
    Plack::Loader->load('FCGI', %args)->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Loader is a factory class to load one of Plack::Handler subclasses based on the environment.
  
  =head1 AUTOLOADING
  
  C<< Plack::Loader->auto(%args) >> will autoload the most correct
  server implementation by guessing from environment variables and Perl INC
  hashes.
  
  =over 4
  
  =item PLACK_SERVER
  
    env PLACK_SERVER=AnyEvent ...
  
  Plack users can specify the specific implementation they want to load
  using the C<PLACK_SERVER> environment variable.
  
  =item PHP_FCGI_CHILDREN, GATEWAY_INTERFACE
  
  If there's one of FastCGI or CGI specific environment variables set,
  use the corresponding server implementation.
  
  =item %INC
  
  If one of L<AnyEvent>, L<Coro> or L<POE> is loaded, the relevant
  server implementation such as L<Twiggy>, L<Corona> or
  L<POE::Component::Server::PSGI> will be loaded, if they're available.
  
  =back
  
  =cut
  
  
PLACK_LOADER

$fatpacked{"Plack/Loader/Delayed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER_DELAYED';
  package Plack::Loader::Delayed;
  use strict;
  use parent qw(Plack::Loader);
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $compiled;
      my $app = sub {
          $compiled ||= $self->{builder}->();
          $compiled->(@_);
      };
  
      $server->{psgi_app_builder} = $self->{builder};
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Delayed - Delay the loading of .psgi until the first run
  
  =head1 SYNOPSIS
  
    plackup -s Starlet -L Delayed myapp.psgi
  
  =head1 DESCRIPTION
  
  This loader delays the compilation of specified PSGI application until
  the first request time. This prevents bad things from happening with
  preforking web servers like L<Starlet>, when your application
  manipulates resources such as sockets or database connections in the
  master startup process and then shared by children.
  
  You can combine this loader with C<-M> command line option, like:
  
    plackup -s Starlet -MCatalyst -L Delayed myapp.psgi
  
  loads the module Catalyst in the master process for the better process
  management with copy-on-write, however the application C<myapp.psgi>
  is loaded per children.
  
  L<Starman> since version 0.2000 loads this loader by default unless
  you specify the command line option C<--preload-app> for the
  L<starman> executable.
  
  =head1 DEVELOPERS
  
  Web server developers can make use of C<psgi_app_builder> attribute
  callback set in Plack::Handler, to load the application earlier than
  the first request time.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
PLACK_LOADER_DELAYED

$fatpacked{"Plack/Loader/Restarter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER_RESTARTER';
  package Plack::Loader::Restarter;
  use strict;
  use warnings;
  use parent qw(Plack::Loader);
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my($class, $runner) = @_;
      bless { watch => [] }, $class;
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub watch {
      my($self, @dir) = @_;
      push @{$self->{watch}}, @dir;
  }
  
  sub _fork_and_start {
      my($self, $server) = @_;
  
      delete $self->{pid}; # re-init in case it's a restart
  
      my $pid = fork;
      die "Can't fork: $!" unless defined $pid;
  
      if ($pid == 0) { # child
          return $server->run($self->{builder}->());
      } else {
          $self->{pid} = $pid;
      }
  }
  
  sub _kill_child {
      my $self = shift;
  
      my $pid = $self->{pid} or return;
      warn "Killing the existing server (pid:$pid)\n";
      kill 'TERM' => $pid;
      waitpid($pid, 0);
  }
  
  sub valid_file {
      my($self, $file) = @_;
  
      # vim temporary file is  4913 to 5036
      # http://www.mail-archive.com/vim_dev@googlegroups.com/msg07518.html
      if ( $file->{path} =~ m{(\d+)$} && $1 >= 4913 && $1 <= 5036) {
          return 0;
      }
      $file->{path} !~ m!\.(?:git|svn)[/\\]|\.(?:bak|swp|swpx|swx)$|~$|_flymake\.p[lm]$|\.#!;
  }
  
  sub run {
      my($self, $server) = @_;
  
      $self->_fork_and_start($server);
      return unless $self->{pid};
  
      require Filesys::Notify::Simple;
      my $watcher = Filesys::Notify::Simple->new($self->{watch});
      warn "Watching @{$self->{watch}} for file updates.\n";
      local $SIG{TERM} = sub { $self->_kill_child; exit(0); };
  
      while (1) {
          my @restart;
  
          # this is blocking
          $watcher->wait(sub {
              my @events = @_;
              @events = grep $self->valid_file($_), @events;
              return unless @events;
  
              @restart = @events;
          });
  
          next unless @restart;
  
          for my $ev (@restart) {
              warn "-- $ev->{path} updated.\n";
          }
  
          $self->_kill_child;
          warn "Successfully killed! Restarting the new server process.\n";
          $self->_fork_and_start($server);
          return unless $self->{pid};
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Restarter - Restarting loader
  
  =head1 SYNOPSIS
  
    plackup -r -R paths
  
  =head1 DESCRIPTION
  
  Plack::Loader::Restarter is a loader backend that implements C<-r> and
  C<-R> option for the L<plackup> script. It forks the server as a child
  process and the parent watches the directories for file updates, and
  whenever it receives the notification, kills the child server and
  restart.
  
  =head1 SEE ALSO
  
  L<Plack::Runner>, L<Catalyst::Restarter>
  
  =cut
PLACK_LOADER_RESTARTER

$fatpacked{"Plack/Loader/Shotgun.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER_SHOTGUN';
  package Plack::Loader::Shotgun;
  use strict;
  use parent qw(Plack::Loader);
  use Storable;
  use Try::Tiny;
  use Plack::Middleware::BufferedStreaming;
  
  die <<DIE if $^O eq 'MSWin32' && !$ENV{PLACK_SHOTGUN_MEMORY_LEAK};
  
  Shotgun loader uses fork(2) system call to create a fresh Perl interpreter, that is known to not work
  properly in a fork-emulation layer on Windows and cause huge memory leaks.
  
  If you're aware of this and still want to run the loader, run it with the environment variable
  PLACK_SHOTGUN_MEMORY_LEAK on.
  
  DIE
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = sub { Plack::Middleware::BufferedStreaming->wrap($builder->()) };
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $app = sub {
          my $env = shift;
  
          pipe my $read, my $write;
  
          my $pid = fork;
          if ($pid) {
              # parent
              close $write;
              my $res = Storable::thaw(join '', <$read>);
              close $read;
              waitpid($pid, 0);
  
              return $res;
          } else {
              # child
              close $read;
  
              my $res;
              try {
                  $env->{'psgi.streaming'} = 0;
                  $res = $self->{builder}->()->($env);
                  my @body;
                  Plack::Util::foreach($res->[2], sub { push @body, $_[0] });
                  $res->[2] = \@body;
              } catch {
                  $env->{'psgi.errors'}->print($_);
                  $res = [ 500, [ "Content-Type", "text/plain" ], [ "Internal Server Error" ] ];
              };
  
              print {$write} Storable::freeze($res);
              close $write;
              exit;
          }
      };
  
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Shotgun - forking implementation of plackup
  
  =head1 SYNOPSIS
  
    plackup -L Shotgun
  
  =head1 DESCRIPTION
  
  Shotgun loader delays the compilation and execution of your
  application until the runtime. When a new request comes in, this forks
  a new child, compiles your code and runs the application.
  
  This should be an ultimate alternative solution when reloading with
  L<Plack::Middleware::Refresh> doesn't work, or plackup's default C<-r>
  filesystem watcher causes problems. I can imagine this is useful for
  applications which expects their application is only evaluated once
  (like in-file templates) or on operating systems with broken fork
  implementation, etc.
  
  This is much like good old CGI's fork and run but you don't need a web
  server, and there's a benefit of preloading modules that are not
  likely to change. For instance if you develop a web application using
  Moose and DBIx::Class,
  
    plackup -MMoose -MDBIx::Class -L Shotgun yourapp.psgi
  
  would preload those modules and only re-evaluates your code in every
  request.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa with an inspiration from L<http://github.com/rtomayko/shotgun>
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
PLACK_LOADER_SHOTGUN

$fatpacked{"Plack/MIME.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIME';
  package Plack::MIME;
  use strict;
  
  # stolen from rack.mime.rb
  our $MIME_TYPES = {
      ".3gp"     => "video/3gpp",
      ".a"       => "application/octet-stream",
      ".ai"      => "application/postscript",
      ".aif"     => "audio/x-aiff",
      ".aiff"    => "audio/x-aiff",
      ".asc"     => "application/pgp-signature",
      ".asf"     => "video/x-ms-asf",
      ".asm"     => "text/x-asm",
      ".asx"     => "video/x-ms-asf",
      ".atom"    => "application/atom+xml",
      ".au"      => "audio/basic",
      ".avi"     => "video/x-msvideo",
      ".bat"     => "application/x-msdownload",
      ".bin"     => "application/octet-stream",
      ".bmp"     => "image/bmp",
      ".bz2"     => "application/x-bzip2",
      ".c"       => "text/x-c",
      ".cab"     => "application/vnd.ms-cab-compressed",
      ".cc"      => "text/x-c",
      ".chm"     => "application/vnd.ms-htmlhelp",
      ".class"   => "application/octet-stream",
      ".com"     => "application/x-msdownload",
      ".conf"    => "text/plain",
      ".cpp"     => "text/x-c",
      ".crt"     => "application/x-x509-ca-cert",
      ".css"     => "text/css",
      ".csv"     => "text/csv",
      ".cxx"     => "text/x-c",
      ".deb"     => "application/x-debian-package",
      ".der"     => "application/x-x509-ca-cert",
      ".diff"    => "text/x-diff",
      ".djv"     => "image/vnd.djvu",
      ".djvu"    => "image/vnd.djvu",
      ".dll"     => "application/x-msdownload",
      ".dmg"     => "application/octet-stream",
      ".doc"     => "application/msword",
      ".dot"     => "application/msword",
      ".dtd"     => "application/xml-dtd",
      ".dvi"     => "application/x-dvi",
      ".ear"     => "application/java-archive",
      ".eml"     => "message/rfc822",
      ".eps"     => "application/postscript",
      ".exe"     => "application/x-msdownload",
      ".f"       => "text/x-fortran",
      ".f77"     => "text/x-fortran",
      ".f90"     => "text/x-fortran",
      ".flv"     => "video/x-flv",
      ".for"     => "text/x-fortran",
      ".gem"     => "application/octet-stream",
      ".gemspec" => "text/x-script.ruby",
      ".gif"     => "image/gif",
      ".gz"      => "application/x-gzip",
      ".h"       => "text/x-c",
      ".hh"      => "text/x-c",
      ".htm"     => "text/html",
      ".html"    => "text/html",
      ".ico"     => "image/vnd.microsoft.icon",
      ".ics"     => "text/calendar",
      ".ifb"     => "text/calendar",
      ".iso"     => "application/octet-stream",
      ".jar"     => "application/java-archive",
      ".java"    => "text/x-java-source",
      ".jnlp"    => "application/x-java-jnlp-file",
      ".jpeg"    => "image/jpeg",
      ".jpg"     => "image/jpeg",
      ".js"      => "application/javascript",
      ".json"    => "application/json",
      ".log"     => "text/plain",
      ".m3u"     => "audio/x-mpegurl",
      ".m4v"     => "video/mp4",
      ".man"     => "text/troff",
      ".manifest"=> "text/cache-manifest",
      ".mathml"  => "application/mathml+xml",
      ".mbox"    => "application/mbox",
      ".mdoc"    => "text/troff",
      ".me"      => "text/troff",
      ".mid"     => "audio/midi",
      ".midi"    => "audio/midi",
      ".mime"    => "message/rfc822",
      ".mml"     => "application/mathml+xml",
      ".mng"     => "video/x-mng",
      ".mov"     => "video/quicktime",
      ".mp3"     => "audio/mpeg",
      ".mp4"     => "video/mp4",
      ".mp4v"    => "video/mp4",
      ".mpeg"    => "video/mpeg",
      ".mpg"     => "video/mpeg",
      ".ms"      => "text/troff",
      ".msi"     => "application/x-msdownload",
      ".odp"     => "application/vnd.oasis.opendocument.presentation",
      ".ods"     => "application/vnd.oasis.opendocument.spreadsheet",
      ".odt"     => "application/vnd.oasis.opendocument.text",
      ".ogg"     => "application/ogg",
      ".ogv"     => "video/ogg",
      ".p"       => "text/x-pascal",
      ".pas"     => "text/x-pascal",
      ".pbm"     => "image/x-portable-bitmap",
      ".pdf"     => "application/pdf",
      ".pem"     => "application/x-x509-ca-cert",
      ".pgm"     => "image/x-portable-graymap",
      ".pgp"     => "application/pgp-encrypted",
      ".pkg"     => "application/octet-stream",
      ".pl"      => "text/x-script.perl",
      ".pm"      => "text/x-script.perl-module",
      ".png"     => "image/png",
      ".pnm"     => "image/x-portable-anymap",
      ".ppm"     => "image/x-portable-pixmap",
      ".pps"     => "application/vnd.ms-powerpoint",
      ".ppt"     => "application/vnd.ms-powerpoint",
      ".ps"      => "application/postscript",
      ".psd"     => "image/vnd.adobe.photoshop",
      ".py"      => "text/x-script.python",
      ".qt"      => "video/quicktime",
      ".ra"      => "audio/x-pn-realaudio",
      ".rake"    => "text/x-script.ruby",
      ".ram"     => "audio/x-pn-realaudio",
      ".rar"     => "application/x-rar-compressed",
      ".rb"      => "text/x-script.ruby",
      ".rdf"     => "application/rdf+xml",
      ".roff"    => "text/troff",
      ".rpm"     => "application/x-redhat-package-manager",
      ".rss"     => "application/rss+xml",
      ".rtf"     => "application/rtf",
      ".ru"      => "text/x-script.ruby",
      ".s"       => "text/x-asm",
      ".sgm"     => "text/sgml",
      ".sgml"    => "text/sgml",
      ".sh"      => "application/x-sh",
      ".sig"     => "application/pgp-signature",
      ".snd"     => "audio/basic",
      ".so"      => "application/octet-stream",
      ".svg"     => "image/svg+xml",
      ".svgz"    => "image/svg+xml",
      ".swf"     => "application/x-shockwave-flash",
      ".t"       => "text/troff",
      ".tar"     => "application/x-tar",
      ".tbz"     => "application/x-bzip-compressed-tar",
      ".tcl"     => "application/x-tcl",
      ".tex"     => "application/x-tex",
      ".texi"    => "application/x-texinfo",
      ".texinfo" => "application/x-texinfo",
      ".text"    => "text/plain",
      ".tif"     => "image/tiff",
      ".tiff"    => "image/tiff",
      ".torrent" => "application/x-bittorrent",
      ".tr"      => "text/troff",
      ".txt"     => "text/plain",
      ".vcf"     => "text/x-vcard",
      ".vcs"     => "text/x-vcalendar",
      ".vrml"    => "model/vrml",
      ".war"     => "application/java-archive",
      ".wav"     => "audio/x-wav",
      ".webm"    => "video/webm",
      ".wma"     => "audio/x-ms-wma",
      ".wmv"     => "video/x-ms-wmv",
      ".wmx"     => "video/x-ms-wmx",
      ".woff"    => "application/font-woff",
      ".wrl"     => "model/vrml",
      ".wsdl"    => "application/wsdl+xml",
      ".xbm"     => "image/x-xbitmap",
      ".xhtml"   => "application/xhtml+xml",
      ".xls"     => "application/vnd.ms-excel",
      ".xml"     => "application/xml",
      ".xpm"     => "image/x-xpixmap",
      ".xsl"     => "application/xml",
      ".xslt"    => "application/xslt+xml",
      ".yaml"    => "text/yaml",
      ".yml"     => "text/yaml",
      ".zip"     => "application/zip",
  };
  
  my $fallback = sub { };
  
  sub mime_type {
      my($class, $file) = @_;
      $file =~ /(\.[a-zA-Z0-9]+)$/ or return;
      $MIME_TYPES->{lc $1} || $fallback->(lc $1);
  }
  
  sub add_type {
      my $class = shift;
      while (my($ext, $type) = splice @_, 0, 2) {
          $MIME_TYPES->{lc $ext} = $type;
      }
  }
  
  sub set_fallback {
      my($class, $cb) = @_;
      $fallback = $cb;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::MIME - MIME type registry
  
  =head1 SYNOPSIS
  
    use Plack::MIME;
  
    my $mime = Plack::MIME->mime_type(".png"); # image/png
  
    # register new type(s)
    Plack::MIME->add_type(".foo" => "application/x-foo");
  
    # Use MIME::Types as a fallback
    use MIME::Types 'by_suffix';
    Plack::MIME->set_fallback(sub { (by_suffix $_[0])[0] });
  
  =head1 DESCRIPTION
  
  Plack::MIME is a simple MIME type registry for Plack applications. The
  selection of MIME types is based on Rack's Rack::Mime module.
  
  =head1 SEE ALSO
  
  Rack::Mime L<MIME::Types>
  
  =cut
  
  
PLACK_MIME

$fatpacked{"Plack/Middleware.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE';
  package Plack::Middleware;
  use strict;
  use warnings;
  use Carp ();
  use parent qw(Plack::Component);
  use Plack::Util;
  use Plack::Util::Accessor qw( app );
  
  sub wrap {
      my($self, $app, @args) = @_;
      if (ref $self) {
          $self->{app} = $app;
      } else {
          $self = $self->new({ app => $app, @args });
      }
      return $self->to_app;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware - Base class for easy-to-use PSGI middleware
  
  =head1 SYNOPSIS
  
    package Plack::Middleware::Foo;
    use parent qw( Plack::Middleware );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        # $self->app is the original app
        my $res = $self->app->($env);
  
        # Do something with $res
        return $res;
    }
  
    # then in app.psgi
    use Plack::Builder;
  
    my $app = sub { ... } # as usual
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", %options;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware is a utility base class to write PSGI
  middleware. All you have to do is to inherit from Plack::Middleware
  and then implement the callback C<call> method (or the C<to_app> method
  that would return the PSGI code reference) to do the actual work. You
  can use C<< $self->app >> to call the original (wrapped) application.
  
  Your middleware object is created at the PSGI application compile time
  and is persistent during the web server life cycle (unless it is a
  non-persistent environment such as CGI), so you should never set or
  cache per-request data like C<$env> in your middleware object. See
  also L<Plack::Component/"OBJECT LIFECYCLE">.
  
  See L<Plack::Builder> how to actually enable middleware in your
  I<.psgi> application file using the DSL. If you do not like our
  builder DSL, you can also use the C<wrap> method to wrap your application
  with a middleware:
  
    use Plack::Middleware::Foo;
  
    my $app = sub { ... };
    $app = Plack::Middleware::Foo->wrap($app, %options);
    $app = Plack::Middleware::Bar->wrap($app, %options);
  
  =head1 RESPONSE CALLBACK
  
  The typical middleware is written like this:
  
    package Plack::Middleware::Something;
    use parent qw(Plack::Middleware);
  
    sub call {
        my($self, $env) = @_;
        # pre-processing $env
        my $res = $self->app->($env);
        # post-processing $res
        return $res;
    }
  
  The tricky thing about post-processing the response is that it could
  either be an immediate 3 element array ref, or a code reference that
  implements the delayed (streaming) interface.
  
  Dealing with these two types of response in each piece of middleware
  is pointless, so you're recommended to use the C<response_cb> wrapper
  function in L<Plack::Util> when implementing a post processing
  middleware.
  
    sub call {
        my($self, $env) = @_;
        # pre-processing $env
        my $res = $app->($env);
  
        return Plack::Util::response_cb($res, sub {
            my $res = shift;
            # do something with $res;
        });
    }
  
  The callback function gets a response as an array reference, and you can
  update the reference to implement the post-processing. In the normal
  case, this arrayref will have three elements (as described by the PSGI
  spec), but will have only two elements when using a C<$writer> as
  described below.
  
    package Plack::Middleware::Always500;
    use parent qw(Plack::Middleware);
    use Plack::Util;
  
    sub call {
        my($self, $env) = @_;
        my $res  = $self->app->($env);
        return Plack::Util::response_cb($res, sub {
            my $res = shift;
            $res->[0] = 500;
            return;
        });
    }
  
  In this example, the callback gets the C<$res> and updates its first
  element (status code) to 500. Using C<response_cb> makes sure that
  this works with the delayed response too.
  
  You're not required (and not recommended either) to return a new array
  reference - they will be simply ignored. You're suggested to
  explicitly return, unless you fiddle with the content filter callback
  (see below).
  
  Similarly, note that you have to keep the C<$res> reference when you
  swap the entire response.
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        $res = [ $new_status, $new_headers, $new_body ]; # THIS DOES NOT WORK
        return;
    });
  
  This does not work, since assigning a new anonymous array to C<$res>
  doesn't update the original PSGI response value. You should instead
  do:
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        @$res = ($new_status, $new_headers, $new_body); # THIS WORKS
        return;
    });
  
  The third element of the response array ref is a body, and it could
  be either an arrayref or L<IO::Handle>-ish object. The application could
  also make use of the C<$writer> object if C<psgi.streaming> is in
  effect, and in this case, the third element will not exist
  (C<@$res == 2>). Dealing with these variants is again really painful,
  and C<response_cb> can take care of that too, by allowing you to return
  a content filter as a code reference.
  
    # replace all "Foo" in content body with "Bar"
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        return sub {
            my $chunk = shift;
            return unless defined $chunk;
            $chunk =~ s/Foo/Bar/g;
            return $chunk;
        }
    });
  
  The callback takes one argument C<$chunk> and your callback is
  expected to return the updated chunk. If the given C<$chunk> is undef,
  it means the stream has reached the end, so your callback should also
  return undef, or return the final chunk and return undef when called
  next time.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Component>
  
  =cut
PLACK_MIDDLEWARE

$fatpacked{"Plack/Middleware/AccessLog.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_ACCESSLOG';
  package Plack::Middleware::AccessLog;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  use Plack::Util::Accessor qw( logger format compiled_format);
  use Apache::LogFormat::Compiler;
  
  my %formats = (
      common => '%h %l %u %t "%r" %>s %b',
      combined => '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"',
  );
  
  sub prepare_app {
      my $self = shift;
      my $fmt = $self->format || "combined";
      $fmt = $formats{$fmt} if exists $formats{$fmt};
      $self->compiled_format(Apache::LogFormat::Compiler->new($fmt));
  }
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $res = $self->app->($env);
  
      if ( ref($res) && ref($res) eq 'ARRAY' ) {
          my $content_length = Plack::Util::content_length($res->[2]);
          my $log_line = $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length });
          if ( my $logger = $self->logger ) {
              $logger->($log_line);
          }
          else {
              $env->{'psgi.errors'}->print($log_line);
          }  
          return $res;
      }
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $content_length = Plack::Util::content_length($res->[2]);
          my $log_line = $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length });
          if ( my $logger = $self->logger ) {
              $logger->($log_line);
          }
          else {
              $env->{'psgi.errors'}->print($log_line);
          }  
      });
  }
  
  sub log_line {
      my($self, $status, $headers, $env, $opts) = @_;
  
      $self->compiled_format->log_line(
          $env,
          [$status,$headers],
          $opts->{content_length},
          $opts->{time}
      );
  }
  
  1;
  
  __END__
  
  =for stopwords
  LogFormat
  
  =head1 NAME
  
  Plack::Middleware::AccessLog - Logs requests like Apache's log format
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog", format => "combined";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog forwards the request to the given app and
  logs request and response details to the logger callback. The format
  can be specified using Apache-like format strings (or C<combined> or
  C<common> for the default formats). If none is specified C<combined> is
  used.
  
  This middleware uses calculable Content-Length by checking body type,
  and cannot log the time taken to serve requests. It also logs the
  request B<before> the response is actually sent to the client. Use
  L<Plack::Middleware::AccessLog::Timed> if you want to log details
  B<after> the response is transmitted (more like a real web server) to
  the client.
  
  This middleware is enabled by default when you run L<plackup> as a
  default C<development> environment.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item format
  
    enable "Plack::Middleware::AccessLog",
        format => '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"';
  
  Takes a format string (or a preset template C<combined> or C<custom>)
  to specify the log format. This middleware uses L<Apache::LogFormat::Compiler> to
  generate access_log lines. See more details on perldoc L<Apache::LogFormat::Compiler>
  
     %%    a percent sign
     %h    REMOTE_ADDR from the PSGI environment, or -
     %l    remote logname not implemented (currently always -)
     %u    REMOTE_USER from the PSGI environment, or -
     %t    [local timestamp, in default format]
     %r    REQUEST_METHOD, REQUEST_URI and SERVER_PROTOCOL from the PSGI environment
     %s    the HTTP status code of the response
     %b    content length of the response
     %T    custom field for handling times in subclasses
     %D    custom field for handling sub-second times in subclasses
     %v    SERVER_NAME from the PSGI environment, or -
     %V    HTTP_HOST or SERVER_NAME from the PSGI environment, or -
     %p    SERVER_PORT from the PSGI environment
     %P    the worker's process id
     %m    REQUEST_METHOD from the PSGI environment
     %U    PATH_INFO from the PSGI environment
     %q    QUERY_STRING from the PSGI environment
     %H    SERVER_PROTOCOL from the PSGI environment
  
  Some of these format fields are only supported by middleware that subclasses C<AccessLog>.
  
  In addition, custom values can be referenced, using C<%{name}>,
  with one of the mandatory modifier flags C<i>, C<o> or C<t>:
  
     %{variable-name}i    HTTP_VARIABLE_NAME value from the PSGI environment
     %{header-name}o      header-name header in the response
     %{time-format]t      localtime in the specified strftime format
  
  =item logger
  
    my $logger = Log::Dispatch->new(...);
    enable "Plack::Middleware::AccessLog",
        logger => sub { $logger->log(level => 'debug', message => @_) };
  
  Sets a callback to print log message to. It prints to the C<psgi.errors>
  output stream by default.
  
  =back
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Nagano
  
  =head1 SEE ALSO
  
  L<Apache::LogFormat::Compiler>, L<http://httpd.apache.org/docs/2.2/mod/mod_log_config.html> Rack::CustomLogger
  
  =cut
  
PLACK_MIDDLEWARE_ACCESSLOG

$fatpacked{"Plack/Middleware/AccessLog/Timed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_ACCESSLOG_TIMED';
  package Plack::Middleware::AccessLog::Timed;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware::AccessLog );
  
  use Time::HiRes;
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $time = Time::HiRes::gettimeofday;
      my $length = 0;
      my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my($status, $header, $body) = @$res;
  
          if (!defined $body) {
              my $length;
  
              return sub {
                  my $line = shift;
                  
                  $length += length $line if defined $line;
  
                  unless( defined $line ) {
                      my $now = Time::HiRes::gettimeofday;
                      $logger->( $self->log_line($status, $header, $env, { time => $now - $time, content_length => $length }) );
                  }
  
                  return $line;
              };
          }
  
          my $getline = ref $body eq 'ARRAY' ? sub { shift @$body } : sub { $body->getline };
  
          my $timer_body = Plack::Util::inline_object(
              getline => sub {
                  my $line = $getline->();
                  $length += length $line if defined $line;
                  return $line;
              },
              close => sub {
                  $body->close if ref $body ne 'ARRAY';
  
                  my $now = Time::HiRes::gettimeofday;
                  $logger->( $self->log_line($status, $header, $env, { time => $now - $time, content_length => $length }) );
              },
          );
  
          @$res = ($status, $header, $timer_body);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::AccessLog::Timed - Logs requests with time and accurate body size
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog::Timed",
            format => "%v %h %l %u %t \"%r\" %>s %b %D";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog::Timed is a subclass of
  L<Plack::Middleware::AccessLog> but uses a wrapped body handle to get the
  actual response body size C<%b> (even if it's not a chunk of array or
  a real filehandle) and the time taken to serve the request: C<%T> or
  C<%D>.
  
  This wraps the response body output stream to capture the time taken
  for the PSGI server to read the whole response body.
  
  This would mean, if the middleware is in use, it will prevent some
  server-side optimizations like sendfile(2) from working, as well as
  middleware like L<Plack::Middleware::ContentLength> can't guess the
  body size out of the file handle.
  
  If all you want is to capture the time taken in your PSGI application
  and do not want the wrapped body behavior described above, consider instead
  applying L<Plack::Middleware::Runtime> and using L<Plack::Middleware::AccessLog>
  to log the C<X-Runtime> header.
  
  =head1 CONFIGURATION
  
  Same as L<Plack::Middleware::AccessLog>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::AccessLog>
  
  L<Plack::Middleware::Runtime>
  
  =cut
PLACK_MIDDLEWARE_ACCESSLOG_TIMED

$fatpacked{"Plack/Middleware/Auth/Basic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_AUTH_BASIC';
  package Plack::Middleware::Auth::Basic;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw( realm authenticator );
  use Scalar::Util;
  use MIME::Base64;
  
  sub prepare_app {
      my $self = shift;
  
      my $auth = $self->authenticator or die 'authenticator is not set';
      if (Scalar::Util::blessed($auth) && $auth->can('authenticate')) {
          $self->authenticator(sub { $auth->authenticate(@_[0,1]) }); # because Authen::Simple barfs on 3 params
      } elsif (ref $auth ne 'CODE') {
          die 'authenticator should be a code reference or an object that responds to authenticate()';
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $auth = $env->{HTTP_AUTHORIZATION}
          or return $self->unauthorized;
  
      # note the 'i' on the regex, as, according to RFC2617 this is a 
      # "case-insensitive token to identify the authentication scheme"
      if ($auth =~ /^Basic (.*)$/i) {
          my($user, $pass) = split /:/, (MIME::Base64::decode($1) || ":"), 2;
          $pass = '' unless defined $pass;
          if ($self->authenticator->($user, $pass, $env)) {
              $env->{REMOTE_USER} = $user;
              return $self->app->($env);
          }
      }
  
      return $self->unauthorized;
  }
  
  sub unauthorized {
      my $self = shift;
      my $body = 'Authorization required';
      return [
          401,
          [ 'Content-Type' => 'text/plain',
            'Content-Length' => length $body,
            'WWW-Authenticate' => 'Basic realm="' . ($self->realm || "restricted area") . '"' ],
          [ $body ],
      ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Auth::Basic - Simple basic authentication middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    my $app = sub { ... };
  
    builder {
        enable "Auth::Basic", authenticator => \&authen_cb;
        $app;
    };
  
    sub authen_cb {
        my($username, $password, $env) = @_;
        return $username eq 'admin' && $password eq 's3cr3t';
    }
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Auth::Basic is a basic authentication handler for Plack.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item authenticator
  
  A callback function that takes username, password and PSGI environment
  supplied and returns whether the authentication succeeds. Required.
  
  Authenticator can also be an object that responds to C<authenticate>
  method that takes username and password and returns boolean, so
  backends for L<Authen::Simple> is perfect to use:
  
    use Authen::Simple::LDAP;
    enable "Auth::Basic", authenticator => Authen::Simple::LDAP->new(...);
  
  =item realm
  
  Realm name to display in the basic authentication dialog. Defaults to I<restricted area>.
  
  =back
  
  =head1 LIMITATIONS
  
  This middleware expects that the application has a full access to the
  headers sent by clients in PSGI environment. That is normally the case
  with standalone Perl PSGI web servers such as L<Starman> or
  L<HTTP::Server::Simple::PSGI>.
  
  However, in a web server configuration where you can't achieve this
  (i.e. using your application via Apache's mod_cgi), this middleware
  does not work since your application can't know the value of
  C<Authorization:> header.
  
  If you use Apache as a web server and CGI to run your PSGI
  application, you can either a) compile Apache with
  C<-DSECURITY_HOLE_PASS_AUTHORIZATION> option, or b) use mod_rewrite to
  pass the Authorization header to the application with the rewrite rule
  like following.
  
    RewriteEngine on
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_MIDDLEWARE_AUTH_BASIC

$fatpacked{"Plack/Middleware/BufferedStreaming.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_BUFFEREDSTREAMING';
  package Plack::Middleware::BufferedStreaming;
  use strict;
  no warnings;
  use Carp;
  use Plack::Util;
  use Plack::Util::Accessor qw(force);
  use Scalar::Util qw(weaken);
  use parent qw(Plack::Middleware);
  
  sub call {
      my ( $self, $env ) = @_;
  
      my $caller_supports_streaming = $env->{'psgi.streaming'};
      $env->{'psgi.streaming'} = Plack::Util::TRUE;
  
      my $res = $self->app->($env);
      return $res if $caller_supports_streaming && !$self->force;
  
      if ( ref($res) eq 'CODE' ) {
          my $ret;
  
          $res->(sub {
              my $write = shift;
  
              if ( @$write == 2 ) {
                  my @body;
  
                  $ret = [ @$write, \@body ];
  
                  return Plack::Util::inline_object(
                      write => sub { push @body, $_[0] },
                      close => sub { },
                  );
              } else {
                  $ret = $write;
                  return;
              }
          });
  
          return $ret;
      } else {
          return $res;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::BufferedStreaming - Enable buffering for non-streaming aware servers
  
  =head1 SYNOPSIS
  
    enable "BufferedStreaming";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::BufferedStreaming is a PSGI middleware component
  that wraps the application that uses C<psgi.streaming> interface to
  run on the servers that do not support the interface, by buffering the
  writer output to a temporary buffer.
  
  This middleware doesn't do anything and bypass the application if the
  server supports C<psgi.streaming> interface, unless you set C<force>
  option (see below).
  
  =head1 OPTIONS
  
  =over 4
  
  =item force
  
  Force enable this middleware only if the container supports C<psgi.streaming>.
  
  =back
  
  =head1 AUTHOR
  
  Yuval Kogman
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_BUFFEREDSTREAMING

$fatpacked{"Plack/Middleware/Chunked.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CHUNKED';
  package Plack::Middleware::Chunked;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($env->{'SERVER_PROTOCOL'} ne 'HTTP/1.0' and
              ! Plack::Util::status_with_no_entity_body($res->[0]) and
              ! $h->exists('Content-Length') and
              ! $h->exists('Transfer-Encoding')
          ) {
              $h->set('Transfer-Encoding' => 'chunked');
              my $done;
              return sub {
                  my $chunk = shift;
                  return if $done;
                  unless (defined $chunk) {
                      $done = 1;
                      return "0\015\012\015\012";
                  }
                  return '' unless length $chunk;
                  return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Chunked - Applies chunked encoding to the response body
  
  =head1 SYNOPSIS
  
    # Mostly from server implemenations
    $app = Plack::Middeware::Chunked->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middeware::Chunked is a middleware, or rather a library for
  PSGI server to automatically add chunked encoding to the response body
  when Content-Length is not set in the response header.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Chunked
  
  =cut
PLACK_MIDDLEWARE_CHUNKED

$fatpacked{"Plack/Middleware/Conditional.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONDITIONAL';
  package Plack::Middleware::Conditional;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util::Accessor qw( condition middleware builder );
  
  sub prepare_app {
      my $self = shift;
      $self->middleware( $self->builder->($self->app) );
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $app = $self->condition->($env) ? $self->middleware : $self->app;
      return $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Conditional - Conditional wrapper for Plack middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace', force => 1;
        $app;
    };
  
    # or using the OO interface:
    $app = Plack::Middleware::Conditional->wrap(
        $app,
        condition  => sub { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' },
        builder => sub { Plack::Middleware::StackTrace->wrap($_[0], force => 1) },
    );
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Conditional is a piece of meta-middleware, to run a
  specific middleware component under runtime conditions. The goal of
  this middleware is to avoid baking runtime configuration options in
  individual middleware components, and rather share them as another
  middleware component.
  
  =head1 EXAMPLES
  
  Note that some of the middleware component names are just made up for
  the explanation and might not exist.
  
    # Minify JavaScript if the browser is Firefox
    enable_if { $_[0]->{HTTP_USER_AGENT} =~ /Firefox/ } 'JavaScriptMinifier';
  
    # Enable Stacktrace when being accessed from the local network
    enable_if { $_[0]->{REMOTE_ADDR} =~ /^10\.0\.1\.*/ } 'StackTrace';
  
    # Work with other conditional setter middleware:
    # Transcode Jpeg on the fly for mobile clients
    builder {
        enable 'MobileDetector';
        enable_if { $_[0]->{'plack.mobile_detected'} }
          'TranscodeJpeg', max_size => 30_000;
        $app;
    };
  
  Note that in the last example I<MobileDetector> should come first
  because the conditional check runs in I<pre-run> conditions, which is
  from outer to inner: that is, from the top to the bottom in the
  Builder DSL code.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Steve Cook
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_MIDDLEWARE_CONDITIONAL

$fatpacked{"Plack/Middleware/ConditionalGET.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONDITIONALGET';
  package Plack::Middleware::ConditionalGET;
  use strict;
  use parent qw( Plack::Middleware );
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      return $res unless $env->{REQUEST_METHOD} =~ /^(GET|HEAD)$/;
  
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = Plack::Util::headers($res->[1]);
          if ( $self->etag_matches($h, $env) || $self->not_modified_since($h, $env) ) {
              $res->[0] = 304;
              $h->remove($_) for qw( Content-Type Content-Length Content-Disposition );
              if ($res->[2]) {
                  $res->[2] = [];
              } else {
                  return sub {
                      return defined $_[0] ? '' : undef;
                  };
              }
          }
      });
  }
  
  no warnings 'uninitialized';
  
  # RFC 2616 14.25 says it's OK and expected to use 'eq' :)
  # > Note: When handling an If-Modified-Since header field, some
  # > servers will use an exact date comparison function, rather than a
  # > less-than function, for deciding whether to send a 304 ...
  
  sub etag_matches {
      my($self, $h, $env) = @_;
      $h->exists('ETag') && $h->get('ETag') eq _value($env->{HTTP_IF_NONE_MATCH});
  }
  
  sub not_modified_since {
      my($self, $h, $env) = @_;
      $h->exists('Last-Modified') && $h->get('Last-Modified') eq _value($env->{HTTP_IF_MODIFIED_SINCE});
  }
  
  sub _value {
      my $str = shift;
      # IE sends wrong formatted value(i.e. "Thu, 03 Dec 2009 01:46:32 GMT; length=17936")
      $str =~ s/;.*$//;
      return $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ConditionalGET - Middleware to enable conditional GET
  
  =head1 SYNOPSIS
  
    builder {
        enable "ConditionalGET";
        ....
    };
  
  =head1 DESCRIPTION
  
  This middleware enables conditional GET and HEAD using
  C<If-None-Match> and C<If-Modified-Since> header. The application
  should set either or both of C<Last-Modified> or C<ETag> response
  headers per RFC 2616. When either of the conditions is met, the
  response body is set to be zero length and the status is set to 304
  Not Modified.
  
  =head1 SEE ALSO
  
  Rack::ConditionalGet
  
  =cut
PLACK_MIDDLEWARE_CONDITIONALGET

$fatpacked{"Plack/Middleware/ContentLength.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONTENTLENGTH';
  package Plack::Middleware::ContentLength;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if (!Plack::Util::status_with_no_entity_body($res->[0]) &&
              !$h->exists('Content-Length') &&
              !$h->exists('Transfer-Encoding') &&
              defined(my $content_length = Plack::Util::content_length($res->[2]))) {
              $h->push('Content-Length' => $content_length);
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentLength - Adds Content-Length header automatically
  
  =head1 SYNOPSIS
  
    # in app.psgi
  
    builder {
        enable "Plack::Middleware::ContentLength";
        $app;
    }
  
    # Or in Plack::Handler::*
    $app = Plack::Middleware::ContentLength->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ContentLength is a middleware that automatically
  adds C<Content-Length> header when it's appropriate i.e. the response
  has a content body with calculable size (array of chunks or a real
  filehandle).
  
  This middleware can also be used as a library from PSGI server
  implementations to automatically set C<Content-Length> rather than in
  the end user level.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::ContentLength
  
  =cut
  
PLACK_MIDDLEWARE_CONTENTLENGTH

$fatpacked{"Plack/Middleware/ContentMD5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONTENTMD5';
  package Plack::Middleware::ContentMD5;
  
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Digest::MD5 qw/md5_hex/;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
      
      $self->response_cb($res, sub {
          my $res = shift;
  
          return unless defined $res->[2];
          return if (Plack::Util::status_with_no_entity_body($res->[0]));
          
          my $h = Plack::Util::headers($res->[1]);
          return if ( $h->exists('Content-MD5') );
          
          my $body = $res->[2];
          if (ref $body eq 'ARRAY') {
              $h->set('Content-MD5', md5_hex(@$body));
          }
          # Do we need support $fh?
  
          return;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentMD5 - Automatically sets the Content-MD5 header on all String bodies
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::ContentMD5";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Automatically sets the Content-MD5 header on all String bodies
  
  =head1 AUTHOR
  
  Fayland Lam
  
  =cut
PLACK_MIDDLEWARE_CONTENTMD5

$fatpacked{"Plack/Middleware/ErrorDocument.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_ERRORDOCUMENT';
  package Plack::Middleware::ErrorDocument;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  use Plack::MIME;
  use Plack::Util;
  use Plack::Util::Accessor qw( subrequest );
  
  use HTTP::Status qw(is_error);
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $r = $self->app->($env);
  
      $self->response_cb($r, sub {
          my $r = shift;
          unless (is_error($r->[0]) && exists $self->{$r->[0]}) {
              return;
          }
  
          my $path = $self->{$r->[0]};
          if ($self->subrequest) {
              for my $key (keys %$env) {
                  unless ($key =~ /^psgi/) {
                      $env->{'psgix.errordocument.' . $key} = $env->{$key};
                  }
              }
  
              # TODO: What if SCRIPT_NAME is not empty?
              $env->{REQUEST_METHOD} = 'GET';
              $env->{REQUEST_URI}    = $path;
              $env->{PATH_INFO}      = $path;
              $env->{QUERY_STRING}   = '';
              delete $env->{CONTENT_LENGTH};
  
              my $sub_r = $self->app->($env);
              if ($sub_r->[0] == 200) {
                  $r->[1] = $sub_r->[1];
                  if (@$r == 3) {
                      $r->[2] = $sub_r->[2];
                  }
                  else {
                      my $full_sub_response = '';
                      Plack::Util::foreach($sub_r->[2], sub {
                          $full_sub_response .= $_[0];
                      });
  
                      my $returned;
                      return sub {
                          if ($returned) {
                              return defined($_[0]) ? '' : undef;
                          }
                          $returned = 1;
                          return $full_sub_response;
                      }
                  }
              }
              # TODO: allow 302 here?
          } else {
              my $h = Plack::Util::headers($r->[1]);
              $h->remove('Content-Length');
              $h->remove('Content-Encoding');
              $h->remove('Transfer-Encoding');
              $h->set('Content-Type', Plack::MIME->mime_type($path));
  
              open my $fh, "<", $path or die "$path: $!";
              if ($r->[2]) {
                  $r->[2] = $fh;
              } else {
                  my $done;
                  return sub {
                      unless ($done) {
                          $done = 1;
                          return join '', <$fh>;
                      }
                      return defined $_[0] ? '' : undef;
                  };
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ErrorDocument - Set Error Document based on HTTP status code
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            500 => '/uri/errors/500.html', 404 => '/uri/errors/404.html',
            subrequest => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ErrorDocument allows you to customize error screen
  by setting paths (file system path or URI path) of error pages per
  status code.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item subrequest
  
  A boolean flag to serve error pages using a new GET sub request.
  Defaults to false, which means it serves error pages using file
  system path.
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            502 => '/home/www/htdocs/errors/maint.html';
        enable "Plack::Middleware::ErrorDocument",
            404 => '/static/404.html', 403 => '/static/403.html', subrequest => 1;
        $app;
    };
  
  This configuration serves 502 error pages from file system directly
  assuming that's when you probably maintain database etc. but serves
  404 and 403 pages using a sub request so your application can do some
  logic there like logging or doing suggestions.
  
  When using a subrequest, the subrequest should return a regular '200' response.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  =cut
PLACK_MIDDLEWARE_ERRORDOCUMENT

$fatpacked{"Plack/Middleware/FixMissingBodyInRedirect.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_FIXMISSINGBODYINREDIRECT';
  package Plack::Middleware::FixMissingBodyInRedirect;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use HTML::Entities;
  use Scalar::Util qw(blessed);
  # ABSTRACT: Plack::Middleware which sets body for redirect response, if it's not already set
  
  our $VERSION = '0.12';
  
  sub call {
      my $self = shift;
  
      return $self->response_cb($self->app->(@_), sub {
          my $res = shift;
          return unless $res->[0] >= 300 && $res->[0] < 400;
          my $headers = Plack::Util::headers($res->[1]); # first index contains HTTP header
          if( $headers->exists('Location') ) {
              my $location = $headers->get("Location");
              # checking if body (which is at index 2) is set or not
              if (@$res == 3 && !_is_body_set($res->[2])) {
                  my $body = $self->_default_html_body($location);
                  $res->[2] = [$body];
                  my $content_length = Plack::Util::content_length([$body]);
                  $headers->set('Content-Length' => $content_length);
                  $headers->set('Content-Type' => 'text/html; charset=utf-8');
                  return;
              }
              elsif (@$res == 2 || blessed($res->[2])) {
                  if(! $headers->exists('Content-Type')) {
                      $headers->set('Content-Type' => 'text/html; charset=utf-8')
                  }
                  my $done;
                  return sub {
                      my $chunk = shift;
                      return $chunk if $done;
                      if (!defined $chunk) {
                          $done = 1;
                          return $self->_default_html_body($location);
                      }
                      elsif (length $chunk) {
                          $done = 1;
                      }
                      return $chunk;
                  };
              }
          }
      });
  }
  
  sub _default_html_body {
    my ($self_or_class, $location) = @_;
    my $encoded_location = encode_entities($location);
    return <<"EOF";
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
      <html xmlns="http://www.w3.org/1999/xhtml">
      <head>
      <title>Moved</title>
      </head>
      <body>
     <p>This item has moved <a href="$encoded_location">here</a>.</p>
  </body>
  </html>
  EOF
  }
  
  sub _is_body_set {
      my $body = shift;
      if (ref $body eq 'ARRAY') {
          return grep { defined && length } @$body;
      }
      elsif (Plack::Util::is_real_fh($body) && -f $body && -z _) {
          return 0;
      }
      return 1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Plack::Middleware::FixMissingBodyInRedirect - Plack::Middleware which sets body for redirect response, if it's not already set
  
  =head1 VERSION
  
  version 0.12
  
  =head1 SYNOPSIS
  
     use strict;
     use warnings;
  
     use Plack::Builder;
  
     my $app = sub { ...  };
  
     builder {
         enable "FixMissingBodyInRedirect";
         $app;
     };
  
  =head1 DESCRIPTION
  
  This module sets body in redirect response, if it's not already set.
  
  =head1 CONTRIBUTORS
  
  John Napiorkowski <jjn1056@yahoo.com>
  
  Graham Knop <haarg@haarg.org>
  
  n0body, Mark Ellis <m@rkellis.com>
  
  ether, Karen Etheridge <ether@cpan.org>
  
  =head1 AUTHOR
  
  Upasana <me@upasana.me>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Upasana.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PLACK_MIDDLEWARE_FIXMISSINGBODYINREDIRECT

$fatpacked{"Plack/Middleware/HTTPExceptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_HTTPEXCEPTIONS';
  package Plack::Middleware::HTTPExceptions;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(rethrow);
  
  use Carp ();
  use Try::Tiny;
  use Scalar::Util 'blessed';
  use HTTP::Status ();
  
  sub prepare_app {
      my $self = shift;
      $self->rethrow(1) if ($ENV{PLACK_ENV} || '') eq 'development';
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $res = try {
          $self->app->($env);
      } catch {
          $self->transform_error($_, $env);
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if ($writer) {
                  Carp::cluck $_;
                  $writer->close;
              } else {
                  my $res = $self->transform_error($_, $env);
                  $respond->($res);
              }
          };
      };
  }
  
  sub transform_error {
      my($self, $e, $env) = @_;
  
      my($code, $message);
      if (blessed $e && $e->can('as_psgi')) {
          return $e->as_psgi;
      }
      if (blessed $e && $e->can('code')) {
          $code = $e->code;
          $message =
              $e->can('as_string')       ? $e->as_string :
              overload::Method($e, '""') ? "$e"          : undef;
      } else {
          if ($self->rethrow) {
              die $e;
          }
          else {
              $code = 500;
              $env->{'psgi.errors'}->print($e);
          }
      }
  
      if ($code !~ /^[3-5]\d\d$/) {
          die $e; # rethrow
      }
  
      $message ||= HTTP::Status::status_message($code);
  
      my @headers = (
           'Content-Type'   => 'text/plain',
           'Content-Length' => length($message),
      );
  
      if ($code =~ /^3/ && (my $loc = eval { $e->location })) {
          push(@headers, Location => $loc);
      }
  
      return [ $code, \@headers, [ $message ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::HTTPExceptions - Catch HTTP exceptions
  
  =head1 SYNOPSIS
  
    use HTTP::Exception;
  
    my $app = sub {
        # ...
        HTTP::Exception::500->throw;
    };
  
    builder {
        enable "HTTPExceptions", rethrow => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::HTTPExceptions is a PSGI middleware component to
  catch exceptions from applications that can be translated into HTTP
  status codes.
  
  Your application is supposed to throw an object that implements a
  C<code> method which returns the HTTP status code, such as 501 or
  404. This middleware catches them and creates a valid response out of
  the code. If the C<code> method returns a code that is not an HTTP
  redirect or error code (3xx, 4xx, or 5xx), the exception will be
  rethrown.
  
  The exception object may also implement C<as_string> or overload
  stringification to represent the text of the error. The text defaults to
  the status message of the error code, such as I<Service Unavailable> for
  C<503>.
  
  Finally, the exception object may implement C<as_psgi>, and the result
  of this will be returned directly as the PSGI response.
  
  If the code is in the 3xx range and the exception implements the 'location'
  method (HTTP::Exception::3xx does), the Location header will be set in the
  response, so you can do redirects this way.
  
  There are CPAN modules L<HTTP::Exception> and L<HTTP::Throwable>, and
  they are perfect to throw from your application to let this middleware
  catch and display, but you can also implement your own exception class
  to throw.
  
  If the thrown exception is not an object that implements either a
  C<code> or an C<as_psgi> method, a 500 error will be returned, and the
  exception is printed to the psgi.errors stream.
  Alternatively, you can pass a true value for the C<rethrow> parameter
  for this middleware, and the exception will instead be rethrown. This is
  enabled by default when C<PLACK_ENV> is set to C<development>, so that
  the L<StackTrace|Plack::Middleware::StackTrace> middleware can catch it
  instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  paste.httpexceptions L<HTTP::Exception> L<HTTP::Throwable>
  
  =cut
PLACK_MIDDLEWARE_HTTPEXCEPTIONS

$fatpacked{"Plack/Middleware/Head.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_HEAD';
  package Plack::Middleware::Head;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  sub call {
      my($self, $env) = @_;
  
      return $self->app->($env)
          unless $env->{REQUEST_METHOD} eq 'HEAD';
  
      $self->response_cb($self->app->($env), sub {
          my $res = shift;
          if ($res->[2]) {
              $res->[2] = [];
          } else {
              return sub {
                  return defined $_[0] ? '': undef;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Head - auto delete response body in HEAD requests
  
  =head1 SYNOPSIS
  
    enable "Head";
  
  =head1 DESCRIPTION
  
  This middleware deletes response body in HEAD requests.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Head
  
  =cut
  
PLACK_MIDDLEWARE_HEAD

$fatpacked{"Plack/Middleware/IIS6ScriptNameFix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX';
  package Plack::Middleware::IIS6ScriptNameFix;
  
  use strict;
  use parent 'Plack::Middleware';
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /IIS\/[6-9]\.[0-9]/) {
          my @script_name = split(m!/!, $env->{PATH_INFO});
          my @path_translated = split(m!/|\\\\?!, $env->{PATH_TRANSLATED});
          my @path_info;
  
          while ($script_name[$#script_name] eq $path_translated[$#path_translated]) {
              pop(@path_translated);
              unshift(@path_info, pop(@script_name));
          }
  
          unshift(@path_info, '', '');
  
          $env->{PATH_INFO} = join('/', @path_info);
          $env->{SCRIPT_NAME} = join('/', @script_name);
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::IIS6ScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that IIS6 sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "IIS6ScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "IIS6ScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by IIS6.
  
  =head1 AUTHORS
  
  Florian Ragwitz
  
  =cut
PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/IIS7KeepAliveFix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_IIS7KEEPALIVEFIX';
  package Plack::Middleware::IIS7KeepAliveFix;
  
  use strict;
  use parent 'Plack::Middleware';
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
          # Fixes buffer being cut off on redirect when keep-alive is active
          my $res  = $self->app->($env);
  
          Plack::Util::response_cb($res, sub {
              my $res = shift;
              if ($res->[0] =~ m!^30[123]$! ) {
                  Plack::Util::header_remove($res->[1], 'Content-Length');
                  Plack::Util::header_remove($res->[1], 'Content-Type');
                 return sub{ my $chunk; return unless defined $chunk; return ''; };
              }
  
              return;
          });
  
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::IIS7KeepAliveFix - fixes buffer being cut off on redirect when keep-alive is active on IIS.
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "IIS7KeepAliveFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "IIS7KeepAliveFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes buffer being cut off on redirect when keep-alive is active on IIS7.
  
  =head1 AUTHORS
  
  KnowZeroX
  
  =cut
  
PLACK_MIDDLEWARE_IIS7KEEPALIVEFIX

$fatpacked{"Plack/Middleware/JSONP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_JSONP';
  package Plack::Middleware::JSONP;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use URI::Escape ();
  
  use Plack::Util::Accessor qw/callback_key/;
  
  sub prepare_app {
      my $self = shift;
      unless (defined $self->callback_key) {
          $self->callback_key('callback');
      }
  }
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          if (defined $res->[2]) {
              my $h = Plack::Util::headers($res->[1]);
              my $callback_key = $self->callback_key;
              if ($h->get('Content-Type') =~ m!/(?:json|javascript)! &&
                  $env->{QUERY_STRING} =~ /(?:^|&)$callback_key=([^&]+)/) {
                  my $cb = URI::Escape::uri_unescape($1);
                  if ($cb =~ /^[\w\.\[\]]+$/) {
                      my $body;
                      Plack::Util::foreach($res->[2], sub { $body .= $_[0] });
                      my $jsonp = "/**/$cb($body)";
                      $res->[2] = [ $jsonp ];
                      $h->set('Content-Length', length $jsonp);
                      $h->set('Content-Type', 'text/javascript');
                  }
              }
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::JSONP - Wraps JSON response in JSONP if callback parameter is specified
  
  =head1 SYNOPSIS
  
      enable "JSONP", callback_key => 'jsonp';
  
  =head1 DESCRIPTION
  
  Plack::Middleware::JSONP wraps JSON response, which has Content-Type
  value either C<text/javascript> or C<application/json> as a JSONP
  response which is specified with the C<callback> query parameter. The
  name of the parameter can be set while enabling the middleware.
  
  This middleware only works with a non-streaming response, and doesn't
  touch the response otherwise.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_JSONP

$fatpacked{"Plack/Middleware/LighttpdScriptNameFix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX';
  package Plack::Middleware::LighttpdScriptNameFix;
  use strict;
  use parent qw/Plack::Middleware/;
  use Plack::Util::Accessor qw(script_name);
  
  sub prepare_app {
      my $self = shift;
  
      my $script_name = $self->script_name;
      $script_name = '' unless defined($script_name);
      $script_name =~ s!/$!!;
      $self->script_name($script_name);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /lighttpd/) {
          $env->{PATH_INFO}   = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{SCRIPT_NAME} = $self->script_name;
          $env->{PATH_INFO}  =~ s/^\Q$env->{SCRIPT_NAME}\E//;
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LighttpdScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that lighttpd sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "LighttpdScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "LighttpdScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by
  lighttpd when you mount your app under the root path ("/"). If you use
  lighttpd 1.4.23 or later you can instead enable C<fix-root-scriptname>
  flag inside C<fastcgi.server> instead of using this middleware.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item script_name
  
  Even with C<fix-root-scriptname>, lighttpd I<still> sets weird
  C<SCRIPT_NAME> and C<PATH_INFO> if you mount your application at C<"">
  or something that ends with C</>. Setting C<script_name> option tells
  the middleware how to reconstruct the new correct C<SCRIPT_NAME> and
  C<PATH_INFO>.
  
  If you mount the app under C</something/>, you should set:
  
    enable "LighttpdScriptNameFix", script_name => "/something";
  
  and when a request for C</something/a/b?param=1> comes, C<SCRIPT_NAME>
  becomes C</something> and C<PATH_INFO> becomes C</a/b>.
  
  C<script_name> option is set to empty by default, which means all the
  request path is set to C<PATH_INFO> and it behaves like your fastcgi
  application is mounted in the root path.
  
  =back
  
  =head1 AUTHORS
  
  Yury Zavarin
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::FCGI>
  L<http://github.com/plack/Plack/issues#issue/68>
  L<https://redmine.lighttpd.net/issues/729>
  
  =cut
  
PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/Lint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LINT';
  package Plack::Middleware::Lint;
  use strict;
  no warnings;
  use Carp ();
  use parent qw(Plack::Middleware);
  use Scalar::Util qw(blessed);
  use Plack::Util;
  
  sub wrap {
      my($self, $app) = @_;
  
      unless (ref $app eq 'CODE' or overload::Method($app, '&{}')) {
          die("PSGI app should be a code reference: ", (defined $app ? $app : "undef"));
      }
  
      $self->SUPER::wrap($app);
  }
  
  sub call {
      my $self = shift;
      my $env = shift;
  
      $self->validate_env($env);
      my $res = $self->app->($env);
      return $self->validate_res($res);
  }
  
  sub validate_env {
      my ($self, $env) = @_;
      unless ($env->{REQUEST_METHOD}) {
          die('Missing env param: REQUEST_METHOD');
      }
      unless ($env->{REQUEST_METHOD} =~ /^[A-Z]+$/) {
          die("Invalid env param: REQUEST_METHOD($env->{REQUEST_METHOD})");
      }
      unless (defined($env->{SCRIPT_NAME})) { # allows empty string
          die('Missing mandatory env param: SCRIPT_NAME');
      }
      if ($env->{SCRIPT_NAME} eq '/') {
          die('SCRIPT_NAME must not be /');
      }
      unless (defined($env->{PATH_INFO})) { # allows empty string
          die('Missing mandatory env param: PATH_INFO');
      }
      if ($env->{PATH_INFO} ne '' && $env->{PATH_INFO} !~ m!^/!) {
          die('PATH_INFO must begin with / ($env->{PATH_INFO})');
      }
      unless (defined($env->{SERVER_NAME})) {
          die('Missing mandatory env param: SERVER_NAME');
      }
      if ($env->{SERVER_NAME} eq '') {
          die('SERVER_NAME must not be empty string');
      }
      unless (defined($env->{SERVER_PORT})) {
          die('Missing mandatory env param: SERVER_PORT');
      }
      if ($env->{SERVER_PORT} eq '') {
          die('SERVER_PORT must not be empty string');
      }
      if (defined($env->{SERVER_PROTOCOL}) and $env->{SERVER_PROTOCOL} !~ m{^HTTP/\d}) {
          die("Invalid SERVER_PROTOCOL: $env->{SERVER_PROTOCOL}");
      }
      for my $param (qw/version url_scheme input errors multithread multiprocess/) {
          unless (exists $env->{"psgi.$param"}) {
              die("Missing psgi.$param");
          }
      }
      unless (ref($env->{'psgi.version'}) eq 'ARRAY') {
          die("psgi.version should be ArrayRef: $env->{'psgi.version'}");
      }
      unless (scalar(@{$env->{'psgi.version'}}) == 2) {
          die('psgi.version should contain 2 elements, not ', scalar(@{$env->{'psgi.version'}}));
      }
      unless ($env->{'psgi.url_scheme'} =~ /^https?$/) {
          die("psgi.url_scheme should be 'http' or 'https': ", $env->{'psgi.url_scheme'});
      }
      if ($env->{"psgi.version"}->[1] == 1) { # 1.1
          for my $param (qw(streaming nonblocking run_once)) {
              unless (exists $env->{"psgi.$param"}) {
                  die("Missing psgi.$param");
              }
          }
      }
      if ($env->{HTTP_CONTENT_TYPE}) {
          die('HTTP_CONTENT_TYPE should not exist');
      }
      if ($env->{HTTP_CONTENT_LENGTH}) {
          die('HTTP_CONTENT_LENGTH should not exist');
      }
  }
  
  sub is_possibly_fh {
      my $fh = shift;
  
      ref $fh eq 'GLOB' &&
      *{$fh}{IO} &&
      *{$fh}{IO}->can('getline');
  }
  
  sub validate_res {
      my ($self, $res, $streaming) = @_;
  
      unless (ref($res) eq 'ARRAY' or ref($res) eq 'CODE') {
          die("Response should be array ref or code ref: $res");
      }
  
      if (ref $res eq 'CODE') {
          return $self->response_cb($res, sub { $self->validate_res(@_, 1) });
      }
  
      unless (@$res == 3 || ($streaming && @$res == 2)) {
          die('Response needs to be 3 element array, or 2 element in streaming');
      }
  
      unless ($res->[0] =~ /^\d+$/ && $res->[0] >= 100) {
          die("Status code needs to be an integer greater than or equal to 100: $res->[0]");
      }
  
      unless (ref $res->[1] eq 'ARRAY') {
          die("Headers needs to be an array ref: $res->[1]");
      }
  
      my @copy = @{$res->[1]};
      unless (@copy % 2 == 0) {
          die('The number of response headers needs to be even, not odd(', scalar(@copy), ')');
      }
  
      while(my($key, $val) = splice(@copy, 0, 2)) {
          if (lc $key eq 'status') {
              die('Response headers MUST NOT contain a key named Status');
          }
          if ($key =~ /[:\r\n]|[-_]$/) {
              die("Response headers MUST NOT contain a key with : or newlines, or that end in - or _: $key");
          }
          unless ($key =~ /^[a-zA-Z][0-9a-zA-Z\-_]*$/) {
              die("Response headers MUST consist only of letters, digits, _ or - and MUST start with a letter: $key");
          }
          if ($val =~ /[\000-\037]/) {
              die("Response headers MUST NOT contain characters below octal \037: $val");
          }
          if (!defined $val) {
              die("Response headers MUST be a defined string");
          }
      }
  
      # @$res == 2 is only right in psgi.streaming, and it's already checked.
      unless (@$res == 2 ||
              ref $res->[2] eq 'ARRAY' ||
              Plack::Util::is_real_fh($res->[2]) ||
              is_possibly_fh($res->[2]) ||
              (blessed($res->[2]) && $res->[2]->can('getline'))) {
          die("Body should be an array ref or filehandle: $res->[2]");
      }
  
      if (ref $res->[2] eq 'ARRAY' && grep _has_wide_char($_), @{$res->[2]}) {
          die("Body must be bytes and should not contain wide characters (UTF-8 strings)");
      }
  
      return $res;
  }
  
  # NOTE: Some modules like HTML:: or XML:: could possibly generate
  # ASCII/Latin-1 strings with utf8 flags on. They're actually safe to
  # print, so there's no need to give warnings about it.
  sub _has_wide_char {
      my $str = shift;
      utf8::is_utf8($str) && $str =~ /[^\x00-\xff]/;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Lint - Validate request and response
  
  =head1 SYNOPSIS
  
    use Plack::Middleware::Lint;
  
    my $app = sub { ... }; # your app or middleware
    $app = Plack::Middleware::Lint->wrap($app);
  
    # Or from plackup
    plackup -e 'enable "Lint"' myapp.psgi
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Lint is a middleware component to validate request
  and response environment formats. You are strongly suggested to use
  this middleware when you develop a new framework adapter or a new PSGI
  web server that implements the PSGI interface.
  
  This middleware is enabled by default when you run plackup or other
  launcher tools with the default environment I<development> value.
  
  =head1 DEBUGGING
  
  Because of how this middleware works, it may not be easy to debug Lint
  errors when you encounter one, unless you're writing a PSGI web server
  or a framework.
  
  For example, when you're an application developer (user of some
  framework) and see errors like:
  
    Body should be an array ref or filehandle at lib/Plack/Middleware/Lint.pm line XXXX
  
  there's no clue about which line of I<your application> produces that
  error.
  
  We're aware of the issue, and have a plan to spit out more helpful
  errors to diagnose the issue. But until then, currently there are some
  workarounds to make this easier. For now, the easiest one would be to
  enable L<Plack::Middleware::REPL> outside of the Lint middleware,
  like:
  
    plackup -e 'enable "REPL"; enable "Lint"' app.psgi
  
  so that the Lint errors are caught by the REPL shell, where you can
  inspect all the variables in the response.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_LINT

$fatpacked{"Plack/Middleware/Log4perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LOG4PERL';
  package Plack::Middleware::Log4perl;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(category logger conf);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
  
      if ($self->conf) {
          require Log::Log4perl;
          Log::Log4perl::init($self->conf);
      }
  
      $self->logger( Log::Log4perl->get_logger($self->category || '') );
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          my $level = $args->{level};
          local $Log::Log4perl::caller_depth
              = $Log::Log4perl::caller_depth + 1;
          $self->logger->$level($args->{message});
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Log4perl - Uses Log::Log4perl to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Log4perl;
  
    Log::Log4perl::init('/path/to/log4perl.conf');
  
    builder {
        enable "Log4perl", category => "plack";
        $app;
    }
  
    # in log4perl.conf
    log4perl.logger.plack = INFO, Logfile
    log4perl.appender.Logfile = Log::Log4perl::Appender::File
    log4perl.appender.Logfile.filename = /path/to/logfile.log
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::SimpleLayout
  
    # Or let middleware to configure log4perl
    enable "Log4perl", category => "plack", conf => '/path/to/log.conf';
  
  =head1 DESCRIPTION
  
  Log4perl is a L<Plack::Middleware> component that allows you to use
  L<Log::Log4perl> to configure the logging object, C<psgix.logger>.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item category
  
  The C<log4perl> category to send logs to. Defaults to C<''> which means
  it send to the root logger.
  
  =item conf
  
  The configuration file path (or a scalar ref containing the config
  string) for L<Log::Log4perl> to automatically configure.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Log4perl>
  
  L<Plack::Middleware::LogDispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOG4PERL

$fatpacked{"Plack/Middleware/LogDispatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LOGDISPATCH';
  package Plack::Middleware::LogDispatch;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(logger);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
      unless ($self->logger) {
          Carp::croak "logger is not defined";
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          $args->{level} = 'critical' if $args->{level} eq 'fatal';
  
          if ( ref $args->{message} && ref $args->{message} ne 'CODE' ) {
              $args->{message} .= q{};
          }
  
          $self->logger->log(%$args);
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LogDispatch - Uses Log::Dispatch to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Dispatch;
  
    my $logger = Log::Dispatch->new;
    $logger->add( Log::Dispatch::File->new(...) );
    $logger->add( Log::Dispatch::DesktopNotification->new(...) );
  
    builder {
        enable "LogDispatch", logger => $logger;
        $app;
    }
  
    # use with Log::Dispatch::Config
    use Log::Dispatch::Config;
    Log::Dispatch::Config->configure('/path/to/log.conf');
  
    builder {
        enable "LogDispatch", logger => Log::Dispatch::Config->instance;
        ...
    }
  
  =head1 DESCRIPTION
  
  LogDispatch is a L<Plack::Middleware> component that allows you to use
  L<Log::Dispatch> to configure the logging object, C<psgix.logger>.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item logger
  
  L<Log::Dispatch> object to send logs to. Required.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  L<Plack::Middleware::Log4perl>
  
  =cut
  
PLACK_MIDDLEWARE_LOGDISPATCH

$fatpacked{"Plack/Middleware/NullLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_NULLLOGGER';
  package Plack::Middleware::NullLogger;
  use strict;
  use parent qw/Plack::Middleware/;
  
  sub call {
      my($self, $env) = @_;
      $env->{'psgix.logger'} = sub { };
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::NullLogger - Send logs to /dev/null
  
  =head1 SYNOPSIS
  
    enable "NullLogger";
  
  =head1 DESCRIPTION
  
  NullLogger is a middleware component that receives logs and does
  nothing but discarding them. Might be useful to shut up all the logs
  from frameworks in one shot.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_NULLLOGGER

$fatpacked{"Plack/Middleware/RearrangeHeaders.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_REARRANGEHEADERS';
  package Plack::Middleware::RearrangeHeaders;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use HTTP::Headers;
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = HTTP::Headers->new(@{$res->[1]});
          my @new_headers;
          $h->scan(sub { push @new_headers, @_ });
  
          $res->[1] = \@new_headers;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::RearrangeHeaders - Reorder HTTP headers for buggy clients
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [
            'Last-Modified' => 'Wed, 23 Sep 2009 13:36:33 GMT',
            'Content-Type' => 'text/plain',
            'ETag' => 'foo bar',
        ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::RearrangeHeaders";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::RearrangeHeaders sorts HTTP headers based on "Good Practice" i.e.:
  
    # "Good Practice" order of HTTP message headers:
    #    - Response-Headers
    #    - Entity-Headers
  
  to work around buggy clients like very old MSIE or broken HTTP proxy
  servers. Most clients today don't (and shouldn't) care about HTTP
  header order but if you're too pedantic or have some environments
  where you need to deal with buggy clients like above, this might be
  useful.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>
  
  =cut
PLACK_MIDDLEWARE_REARRANGEHEADERS

$fatpacked{"Plack/Middleware/Recursive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_RECURSIVE';
  package Plack::Middleware::Recursive;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Try::Tiny;
  use Scalar::Util qw(blessed);
  
  open my $null_io, "<", \"";
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'plack.recursive.include'} = $self->recurse_callback($env, 1);
  
      my $res = try {
          $self->app->($env);
      } catch {
          if (blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
              return $self->recurse_callback($env)->($_->path);
          } else {
              die $_; # rethrow
          }
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if (!$writer && blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
                  $res = $self->recurse_callback($env)->($_->path);
                  return ref $res eq 'CODE' ? $res->($respond) : $respond->($res);
              } else {
                  die $_;
              }
          };
      };
  }
  
  sub recurse_callback {
      my($self, $env, $include) = @_;
  
      my $old_path_info = $env->{PATH_INFO};
  
      return sub {
          my $new_path_info = shift;
          my($path, $query) = split /\?/, $new_path_info, 2;
  
          Scalar::Util::weaken($env);
  
          $env->{PATH_INFO}      = $path;
          $env->{QUERY_STRING}   = $query;
          $env->{REQUEST_METHOD} = 'GET';
          $env->{CONTENT_LENGTH} = 0;
          $env->{CONTENT_TYPE}   = '';
          $env->{'psgi.input'}   = $null_io;
          push @{$env->{'plack.recursive.old_path_info'}}, $old_path_info;
  
          $include ? $self->app->($env) : $self->call($env);
      };
  }
  
  package Plack::Recursive::ForwardRequest;
  use overload q("") => \&as_string, fallback => 1;
  
  sub new {
      my($class, $path) = @_;
      bless { path => $path }, $class;
  }
  
  sub path { $_[0]->{path} }
  
  sub throw {
      my($class, @args) = @_;
      die $class->new(@args);
  }
  
  sub as_string {
      my $self = shift;
      return "Forwarding to $self->{path}: Your application should be wrapped with Plack::Middleware::Recursive.";
  }
  
  package Plack::Middleware::Recursive;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Recursive - Allows PSGI apps to include or forward requests recursively
  
  =head1 SYNOPSIS
  
    # with Builder
    enable "Recursive";
  
    # in apps
    my $res = $env->{'plack.recursive.include'}->("/new_path");
  
    # Or, use exceptions
    my $app = sub {
        # ...
        Plack::Recursive::ForwardRequest->throw("/new_path");
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Recursive allows PSGI applications to recursively
  include or forward requests to other paths. Applications can make use
  of callbacks stored in C<< $env->{'plack.recursive.include'} >> to
  I<include> another path to get the response (whether it's an array ref
  or a code ref depending on your application), or throw an exception
  Plack::Recursive::ForwardRequest anywhere in the code to I<forward>
  the current request (i.e. abort the current and redo the request).
  
  =head1 EXCEPTIONS
  
  This middleware passes through unknown exceptions to the outside
  middleware stack, so if you use this middleware with other exception
  handlers such as L<Plack::Middleware::StackTrace> or
  L<Plack::Middleware::HTTPExceptions>, be sure to wrap this so
  L<Plack::Middleware::Recursive> gets as inner as possible.
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Honma
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Middleware::HTTPExceptions>
  
  The idea, code and interface are stolen from Rack::Recursive and paste.recursive.
  
  =cut
  
  
PLACK_MIDDLEWARE_RECURSIVE

$fatpacked{"Plack/Middleware/Refresh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_REFRESH';
  package Plack::Middleware::Refresh;
  use strict;
  use parent qw(Plack::Middleware);
  use Module::Refresh;
  use Plack::Util::Accessor qw(last cooldown);
  
  sub prepare_app {
      my $self = shift;
      $self->cooldown(10) unless defined $self->cooldown;
  
      Module::Refresh->new;
      $self->last(time - $self->cooldown);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if (time > $self->last + $self->cooldown) {
          Module::Refresh->refresh;
          $self->last(time);
      }
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Refresh - Refresh all modules in %INC
  
  =head1 SYNOPSIS
  
    enable "Refresh", cooldown => 3;
    $app;
  
  =head1 DESCRIPTION
  
  This is I<yet another> approach to refresh modules in C<%INC> during
  the development cycle, without the need to have a forking process to
  watch for filesystem updates. This middleware, in a request time,
  compares the last refresh time and the current time and if the
  difference is bigger than I<cooldown> seconds which defaults to 10,
  call L<Module::Refresh> to reload all Perl modules in C<%INC> if the
  files have been modified.
  
  Note that this only reloads modules and not other files such as
  templates.
  
  This middleware is quite similar to what Rack::Reoader does. If you
  have issues with this reloading technique, for instance when you have
  in-file templates that needs to be recompiled, or Moose classes that
  has C<make_immutable>, take a look at L<plackup>'s default -r option
  or L<Plack::Loader::Shotgun> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Module::Refresh> Rack::Reloader
  
  =cut
  
PLACK_MIDDLEWARE_REFRESH

$fatpacked{"Plack/Middleware/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_RUNTIME';
  package Plack::Middleware::Runtime;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use Plack::Util::Accessor qw(header_name);
  use Time::HiRes;
  
  sub call {
      my($self, $env) = @_;
  
      my $start = [ Time::HiRes::gettimeofday ];
      my $res = $self->app->($env);
      my $header = $self->header_name || 'X-Runtime';
  
      $self->response_cb($res, sub {
          my $res = shift;
          my $req_time = sprintf '%.6f', Time::HiRes::tv_interval($start);
          Plack::Util::header_set($res->[1], $header, $req_time);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Runtime - Sets an X-Runtime response header
  
  =head1 SYNOPSIS
  
    enable "Runtime";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Runtime is a Plack middleware component that sets
  the application's response time (in seconds) in the I<X-Runtime> HTTP response
  header.
  
  =head1 OPTIONS
  
  =over 4
  
  =item header_name
  
  Name of the header. Defaults to I<X-Runtime>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Time::HiRes> Rack::Runtime
  
  =cut
PLACK_MIDDLEWARE_RUNTIME

$fatpacked{"Plack/Middleware/SimpleContentFilter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_SIMPLECONTENTFILTER';
  package Plack::Middleware::SimpleContentFilter;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Plack::Util::Accessor qw( filter );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          return unless $h->get('Content-Type');
          if ($h->get('Content-Type') =~ m!^text/!) {
              return sub {
                  my $chunk = shift;
                  return unless defined $chunk;
                  local $_ = $chunk;
                  $self->filter->();
                  return $_;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleContentFilter - Filters response content
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::SimpleContentFilter",
            filter => sub { s/Foo/Bar/g; };
        $app;
    };
  
  =head1 DESCRIPTION
  
  B<This middleware should be considered as a demo. Running this against
  your application might break your HTML unless you code the filter
  callback carefully>.
  
  Plack::Middleware::SimpleContentFilter is a simple content text filter
  to run against response body. This middleware is only enabled against
  responses with C<text/*> Content-Type.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLECONTENTFILTER

$fatpacked{"Plack/Middleware/SimpleLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_SIMPLELOGGER';
  package Plack::Middleware::SimpleLogger;
  use strict;
  use parent qw(Plack::Middleware);
  use Config ();
  use Plack::Util::Accessor qw(level);
  use POSIX ();
  use Scalar::Util ();
  
  # Should this be in Plack::Util?
  my $i = 0;
  my %level_numbers = map { $_ => $i++ } qw(debug info warn error fatal);
  
  sub call {
      my($self, $env) = @_;
  
      my $min = $level_numbers{ $self->level || "debug" };
  
      my $env_ref = $env;
      Scalar::Util::weaken($env_ref);
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
  
          if ($level_numbers{$args->{level}} >= $min) {
              $env_ref->{'psgi.errors'}->print($self->format_message($args->{level}, $args->{message}));
          }
      };
  
      $self->app->($env);
  }
  
  sub format_time {
      my $old_locale;
      if ( $Config::config{d_setlocale} ) {
          $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
          POSIX::setlocale(&POSIX::LC_ALL, 'C');
      }
      my $out = POSIX::strftime(@_);
      if ( $Config::config{d_setlocale} ) {
          POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
      };
      return $out;
  }
  
  sub format_message {
      my($self, $level, $message) = @_;
  
      my $time = format_time("%Y-%m-%dT%H:%M:%S", localtime);
      sprintf "%s [%s #%d] %s: %s\n", uc substr($level, 0, 1), $time, $$, uc $level, $message;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleLogger - Simple logger that prints to psgi.errors
  
  =head1 SYNOPSIS
  
    enable "SimpleLogger", level => "warn";
  
  =head1 DESCRIPTION
  
  SimpleLogger is a middleware component that formats the log message
  with information such as the time and PID and prints them to
  I<psgi.errors> stream, which is mostly STDERR or server log output.
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::LogErrors>, essentially the opposite of this module
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLELOGGER

$fatpacked{"Plack/Middleware/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_STACKTRACE';
  package Plack::Middleware::StackTrace;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Devel::StackTrace;
  use Devel::StackTrace::AsHTML;
  use Scalar::Util qw( refaddr );
  use Try::Tiny;
  use Plack::Util::Accessor qw( force no_print_errors );
  
  our $StackTraceClass = "Devel::StackTrace";
  
  # Optional since it needs PadWalker
  if (try { require Devel::StackTrace::WithLexicals; Devel::StackTrace::WithLexicals->VERSION(0.08); 1 }) {
      $StackTraceClass = "Devel::StackTrace::WithLexicals";
  }
  
  sub call {
      my($self, $env) = @_;
  
      my ($trace, %string_traces, %ref_traces);
      local $SIG{__DIE__} = sub {
          $trace = $StackTraceClass->new(
              indent => 1, message => munge_error($_[0], [ caller ]),
              ignore_package => __PACKAGE__, no_refs => 1,
          );
          if (ref $_[0]) {
              $ref_traces{refaddr($_[0])} ||= $trace;
          }
          else {
              $string_traces{$_[0]} ||= $trace;
          }
          die @_;
      };
  
      my $caught;
      my $res = try {
          $self->app->($env);
      } catch {
          $caught = $_;
          [ 500, [ "Content-Type", "text/plain; charset=utf-8" ], [ no_trace_error(utf8_safe($caught)) ] ];
      };
  
      if ($caught) {
          # Try to find the correct trace for the caught exception
          my $caught_trace;
          if (ref $caught) {
              $caught_trace = $ref_traces{refaddr($caught)};
          }
          else {
              # This is not guaranteed to work if multiple exceptions with
              # the same message are thrown.
              $caught_trace = $string_traces{$caught};
          }
          $trace = $caught_trace if $caught_trace;
      }
  
      if ($trace && ($caught || ($self->force && ref $res eq 'ARRAY' && $res->[0] == 500)) ) {
          my $text = $trace->as_string;
          my $html = $trace->as_html;
          $env->{'plack.stacktrace.text'} = $text;
          $env->{'plack.stacktrace.html'} = $html;
          $env->{'psgi.errors'}->print($text) unless $self->no_print_errors;
          if (($env->{HTTP_ACCEPT} || '*/*') =~ /html/) {
              $res = [500, ['Content-Type' => 'text/html; charset=utf-8'], [ utf8_safe($html) ]];
          } else {
              $res = [500, ['Content-Type' => 'text/plain; charset=utf-8'], [ utf8_safe($text) ]];
          }
      }
  
      # break $trace here since $SIG{__DIE__} holds the ref to it, and
      # $trace has refs to Standalone.pm's args ($conn etc.) and
      # prevents garbage collection to be happening.
      undef $trace;
  
      return $res;
  }
  
  sub no_trace_error {
      my $msg = shift;
      chomp($msg);
  
      return <<EOF;
  The application raised the following error:
  
    $msg
  
  and the StackTrace middleware couldn't catch its stack trace, possibly because your application overrides \$SIG{__DIE__} by itself, preventing the middleware from working correctly. Remove the offending code or module that does it: known examples are CGI::Carp and Carp::Always.
  EOF
  }
  
  sub munge_error {
      my($err, $caller) = @_;
      return $err if ref $err;
  
      # Ugly hack to remove " at ... line ..." automatically appended by perl
      # If there's a proper way to do this, please let me know.
      $err =~ s/ at \Q$caller->[1]\E line $caller->[2]\.\n$//;
  
      return $err;
  }
  
  sub utf8_safe {
      my $str = shift;
  
      # NOTE: I know messing with utf8:: in the code is WRONG, but
      # because we're running someone else's code that we can't
      # guarantee which encoding an exception is encoded, there's no
      # better way than doing this. The latest Devel::StackTrace::AsHTML
      # (0.08 or later) encodes high-bit chars as HTML entities, so this
      # path won't be executed.
      if (utf8::is_utf8($str)) {
          utf8::encode($str);
      }
  
      $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::StackTrace - Displays stack trace when your app dies
  
  =head1 SYNOPSIS
  
    enable "StackTrace";
  
  =head1 DESCRIPTION
  
  This middleware uses C<$SIG{__DIE__}> to intercept I<all> exceptions
  (run-time errors) happening in your application, even those that are caught.
  For each exception it builds a detailed stack trace.
  
  If the applications aborts by throwing an exception it will be caught and matched
  against the saved stack traces. If a match is found it will be displayed as a nice
  stack trace screen, if not then the exception will be reported without a stack trace.
  
  The stack trace is also stored in the environment as a plaintext and HTML under the key
  C<plack.stacktrace.text> and C<plack.stacktrace.html> respectively, so
  that middleware further up the stack can reference it.
  
  This middleware is enabled by default when you run L<plackup> in the
  default I<development> mode.
  
  You're recommended to use this middleware during the development and
  use L<Plack::Middleware::HTTPExceptions> in the deployment mode as a
  replacement, so that all the exceptions thrown from your application
  still get caught and rendered as a 500 error response, rather than
  crashing the web server.
  
  Catching errors in streaming response is not supported.
  
  =head2 Stack Trace Module
  
  The L<Devel::StackTrace::WithLexicals> module will be used to capture the stack trace
  if the installed version is 0.08 or later. Otherwise L<Devel::StackTrace> is used.
  
  =head2 Performance
  
  Gathering the information for a stack trace via L<Devel::StackTrace> is slow,
  and L<Devel::StackTrace::WithLexicals> is significantly slower still.
  This is not usually a concern in development and when exceptions are rare.
  However, your application may include code that's throwing and catching exceptions
  that you're not aware of. Such code will run I<significantly> slower with this module.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item force
  
    enable "StackTrace", force => 1;
  
  Force display the stack trace when an error occurs within your
  application and the response code from your application is
  500. Defaults to off.
  
  The use case of this option is that when your framework catches all
  the exceptions in the main handler and returns all failures in your
  code as a normal 500 PSGI error response. In such cases, this
  middleware would never have a chance to display errors because it
  can't tell if it's an application error or just random C<eval> in your
  code. This option enforces the middleware to display stack trace even
  if it's not the direct error thrown by the application.
  
  =item no_print_errors
  
    enable "StackTrace", no_print_errors => 1;
  
  Skips printing the text stacktrace to console
  (C<psgi.errors>). Defaults to 0, which means the text version of the
  stack trace error is printed to the errors handle, which usually is a
  standard error.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Devel::StackTrace::AsHTML> L<Plack::Middleware> L<Plack::Middleware::HTTPExceptions>
  
  =cut
  
PLACK_MIDDLEWARE_STACKTRACE

$fatpacked{"Plack/Middleware/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_STATIC';
  package Plack::Middleware::Static;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Plack::App::File;
  
  use Plack::Util::Accessor qw( path root encoding pass_through content_type );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->_handle_static($env);
      if ($res && not ($self->pass_through and $res->[0] == 404)) {
          return $res;
      }
  
      return $self->app->($env);
  }
  
  sub _handle_static {
      my($self, $env) = @_;
  
      my $path_match = $self->path or return;
      my $path = $env->{PATH_INFO};
  
      for ($path) {
          my $matched = 'CODE' eq ref $path_match ? $path_match->($_, $env) : $_ =~ $path_match;
          return unless $matched;
      }
  
      $self->{file} ||= Plack::App::File->new({ root => $self->root || '.', encoding => $self->encoding, content_type => $self->content_type });
      local $env->{PATH_INFO} = $path; # rewrite PATH
      return $self->{file}->call($env);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Static - serve static files with Plack
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::Static",
            path => qr{^/(images|js|css)/}, root => './htdocs/';
        $app;
    };
  
  =head1 DESCRIPTION
  
  This middleware allows your Plack-based application to serve static files.
  
  Note that if you are building an app using L<Plack::App::URLMap>, you should
  consider using L<Plack::App::File> to serve static files instead. This makes
  the overall routing of your application simpler to understand.
  
  With this middleware, if a static file exists for the requested path, it will
  be served. If it does not exist, by default this middleware returns a 404, but
  you can set the C<pass_through> option to change this behavior.
  
  If the requested document is not within the C<root> or the file is there but
  not readable, this middleware will return a 403 Forbidden response.
  
  The content type returned will be determined from the file extension by using
  L<Plack::MIME> or using C<content_type>.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item path, root
  
    enable "Plack::Middleware::Static",
        path => qr{^/static/}, root => 'htdocs/';
  
  The C<path> option specifies the URL pattern (regular expression) or a
  callback to match against requests. If the <path> option matches, the
  middleware looks in C<root> to find the static files to serve. The default
  value of C<root> is the current directory.
  
  This example configuration serves C</static/foo.jpg> from
  C<htdocs/static/foo.jpg>. Note that the matched portion of the path,
  C</static/>, still appears in the locally mapped path under C<root>. If you
  don't want this to happen, you can use a callback to munge the path as you
  match it:
  
    enable "Plack::Middleware::Static",
        path => sub { s!^/static/!! }, root => 'static-files/';
  
  The callback should operate on C<$_> and return a true or false value. Any
  changes it makes to C<$_> are used when looking for the static file in the
  C<root>.
  
  The configuration above serves C</static/foo.png> from
  C<static-files/foo.png>, not C<static-files/static/foo.png>. The callback
  specified in the C<path> option matches against C<$_> munges this value using
  C<s///>. The substitution operator returns the number of matches it made, so it
  will return true when the path matches C<^/static>.
  
  For more complex static handling in the C<path> callback, in addition
  to C<$_> being set the callback receives two arguments, C<PATH_INFO>
  (same as C<$_>) and C<$env>.
  
  If you want to map multiple static directories from different roots, simply
  add this middleware multiple times with different configuration options.
  
  =item pass_through
  
  When this option is set to a true value, then this middleware will never
  return a 404 if it cannot find a matching file. Instead, it will simply pass
  the request on to the application it is wrapping.
  
  =item content_type
  
  The C<content_type> option can be used to provide access to a different MIME 
  database than L<Plack::MIME>.
  L<Plack::MIME> works fast and good for a list of well known file endings, 
  but if you need a more accurate content based checking you can use modules
  like L<File::MimeInfo> or L<File::MMagic> for example.
  The callback should work on $_[0] which is the filename of the file.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno, Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::Builder>
  
  =cut
  
  
PLACK_MIDDLEWARE_STATIC

$fatpacked{"Plack/Middleware/XFramework.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_XFRAMEWORK';
  package Plack::Middleware::XFramework;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  
  use Plack::Util;
  use Plack::Util::Accessor qw( framework );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->( @_ );
      $self->response_cb($res, sub {
          my $res = shift;
          if ($self->framework) {
              Plack::Util::header_set $res->[1], 'X-Framework' => $self->framework;
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XFramework - Sample middleware to add X-Framework
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XFramework", framework => "Catalyst";
  
  =head1 DESCRIPTION
  
  This middleware adds C<X-Framework> header to the HTTP response.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item framework
  
  Sets the string value of C<X-Framework> header. If not set, the header is not set to the response.
  
  =back
  
  =head1 SEE ALSO
  
  L<Plack::Middleware>
  
  =cut
  
PLACK_MIDDLEWARE_XFRAMEWORK

$fatpacked{"Plack/Middleware/XSendfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_XSENDFILE';
  package Plack::Middleware::XSendfile;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  use Scalar::Util;
  use Plack::Util::Accessor qw( variation );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my($status, $headers, $body) = @$res;
          return unless defined $body;
  
          if (Scalar::Util::blessed($body) && $body->can('path')) {
              my $type = $self->_variation($env) || '';
              my $h = Plack::Util::headers($headers);
              if ($type && !$h->exists($type)) {
                  if ($type eq 'X-Accel-Redirect') {
                      my $path = $body->path;
                      my $url = $self->map_accel_path($env, $path);
                      $h->set($type => $url) if $url;
                      $body = [];
                  } elsif ($type eq 'X-Sendfile' or $type eq 'X-Lighttpd-Send-File') {
                      my $path = $body->path;
                      $h->set($type => $path) if defined $path;
                      $body = [];
                  } else {
                      $env->{'psgi.errors'}->print("Unknown x-sendfile variation: $type");
                  }
              }
          }
  
          @$res = ( $status, $headers, $body );
      });
  }
  
  sub map_accel_path {
      my($self, $env, $path) = @_;
  
      if (my $mapping = $env->{HTTP_X_ACCEL_MAPPING}) {
          my($internal, $external) = split /=/, $mapping, 2;
          $path =~ s!^\Q$internal\E!$external!i;
      }
  
      return $path;
  }
  
  sub _variation {
      my($self, $env) = @_;
      $self->variation || $env->{'plack.xsendfile.type'} || $env->{HTTP_X_SENDFILE_TYPE};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XSendfile - Sets X-Sendfile (or a like) header for frontends
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XSendfile";
  
  =head1 DESCRIPTION
  
  You should use L<IO::File::WithPath> or L<Plack::Util>'s
  C<set_io_path> to add C<path> method to an IO object in the body.
  
  See L<http://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/sendfile.rb>
  for the frontend configuration.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_XSENDFILE

$fatpacked{"Plack/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_REQUEST';
  package Plack::Request;
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '1.0037';
  
  use HTTP::Headers::Fast;
  use Carp ();
  use Hash::MultiValue;
  use HTTP::Body;
  
  use Plack::Request::Upload;
  use Stream::Buffered;
  use URI;
  use URI::Escape ();
  
  sub new {
      my($class, $env) = @_;
      Carp::croak(q{$env is required})
          unless defined $env && ref($env) eq 'HASH';
  
      bless { env => $env }, $class;
  }
  
  sub env { $_[0]->{env} }
  
  sub address     { $_[0]->env->{REMOTE_ADDR} }
  sub remote_host { $_[0]->env->{REMOTE_HOST} }
  sub protocol    { $_[0]->env->{SERVER_PROTOCOL} }
  sub method      { $_[0]->env->{REQUEST_METHOD} }
  sub port        { $_[0]->env->{SERVER_PORT} }
  sub user        { $_[0]->env->{REMOTE_USER} }
  sub request_uri { $_[0]->env->{REQUEST_URI} }
  sub path_info   { $_[0]->env->{PATH_INFO} }
  sub path        { $_[0]->env->{PATH_INFO} || '/' }
  sub query_string{ $_[0]->env->{QUERY_STRING} }
  sub script_name { $_[0]->env->{SCRIPT_NAME} }
  sub scheme      { $_[0]->env->{'psgi.url_scheme'} }
  sub secure      { $_[0]->scheme eq 'https' }
  sub body        { $_[0]->env->{'psgi.input'} }
  sub input       { $_[0]->env->{'psgi.input'} }
  
  sub content_length   { $_[0]->env->{CONTENT_LENGTH} }
  sub content_type     { $_[0]->env->{CONTENT_TYPE} }
  
  sub session         { $_[0]->env->{'psgix.session'} }
  sub session_options { $_[0]->env->{'psgix.session.options'} }
  sub logger          { $_[0]->env->{'psgix.logger'} }
  
  sub cookies {
      my $self = shift;
  
      return {} unless $self->env->{HTTP_COOKIE};
  
      # HTTP_COOKIE hasn't changed: reuse the parsed cookie
      if (   $self->env->{'plack.cookie.parsed'}
          && $self->env->{'plack.cookie.string'} eq $self->env->{HTTP_COOKIE}) {
          return $self->env->{'plack.cookie.parsed'};
      }
  
      $self->env->{'plack.cookie.string'} = $self->env->{HTTP_COOKIE};
  
      my %results;
      my @pairs = grep m/=/, split "[;,] ?", $self->env->{'plack.cookie.string'};
      for my $pair ( @pairs ) {
          # trim leading trailing whitespace
          $pair =~ s/^\s+//; $pair =~ s/\s+$//;
  
          my ($key, $value) = map URI::Escape::uri_unescape($_), split( "=", $pair, 2 );
  
          # Take the first one like CGI.pm or rack do
          $results{$key} = $value unless exists $results{$key};
      }
  
      $self->env->{'plack.cookie.parsed'} = \%results;
  }
  
  sub query_parameters {
      my $self = shift;
      $self->env->{'plack.request.query'} ||= $self->_parse_query;
  }
  
  sub _parse_query {
      my $self = shift;
  
      my @query;
      my $query_string = $self->env->{QUERY_STRING};
      if (defined $query_string) {
          $query_string =~ s/\A[&;]+//;
          @query =
              map { s/\+/ /g; URI::Escape::uri_unescape($_) }
              map { /=/ ? split(/=/, $_, 2) : ($_ => '')}
              split(/[&;]+/, $query_string);
      }
  
      Hash::MultiValue->new(@query);
  }
  
  sub content {
      my $self = shift;
  
      unless ($self->env->{'psgix.input.buffered'}) {
          $self->_parse_request_body;
      }
  
      my $fh = $self->input                 or return '';
      my $cl = $self->env->{CONTENT_LENGTH} or return '';
  
      $fh->seek(0, 0); # just in case middleware/apps read it without seeking back
      $fh->read(my($content), $cl, 0);
      $fh->seek(0, 0);
  
      return $content;
  }
  
  sub raw_body { $_[0]->content }
  
  # XXX you can mutate headers with ->headers but it's not written through to the env
  
  sub headers {
      my $self = shift;
      if (!defined $self->{headers}) {
          my $env = $self->env;
          $self->{headers} = HTTP::Headers::Fast->new(
              map {
                  (my $field = $_) =~ s/^HTTPS?_//;
                  ( $field => $env->{$_} );
              }
                  grep { /^(?:HTTP|CONTENT)/i } keys %$env
              );
      }
      $self->{headers};
  }
  
  sub content_encoding { shift->headers->content_encoding(@_) }
  sub header           { shift->headers->header(@_) }
  sub referer          { shift->headers->referer(@_) }
  sub user_agent       { shift->headers->user_agent(@_) }
  
  sub body_parameters {
      my $self = shift;
  
      unless ($self->env->{'plack.request.body'}) {
          $self->_parse_request_body;
      }
  
      return $self->env->{'plack.request.body'};
  }
  
  # contains body + query
  sub parameters {
      my $self = shift;
  
      $self->env->{'plack.request.merged'} ||= do {
          my $query = $self->query_parameters;
          my $body  = $self->body_parameters;
          Hash::MultiValue->new($query->flatten, $body->flatten);
      };
  }
  
  sub uploads {
      my $self = shift;
  
      if ($self->env->{'plack.request.upload'}) {
          return $self->env->{'plack.request.upload'};
      }
  
      $self->_parse_request_body;
      return $self->env->{'plack.request.upload'};
  }
  
  sub param {
      my $self = shift;
  
      return keys %{ $self->parameters } if @_ == 0;
  
      my $key = shift;
      return $self->parameters->{$key} unless wantarray;
      return $self->parameters->get_all($key);
  }
  
  sub upload {
      my $self = shift;
  
      return keys %{ $self->uploads } if @_ == 0;
  
      my $key = shift;
      return $self->uploads->{$key} unless wantarray;
      return $self->uploads->get_all($key);
  }
  
  sub uri {
      my $self = shift;
  
      my $base = $self->_uri_base;
  
      # We have to escape back PATH_INFO in case they include stuff like
      # ? or # so that the URI parser won't be tricked. However we should
      # preserve '/' since encoding them into %2f doesn't make sense.
      # This means when a request like /foo%2fbar comes in, we recognize
      # it as /foo/bar which is not ideal, but that's how the PSGI PATH_INFO
      # spec goes and we can't do anything about it. See PSGI::FAQ for details.
  
      # See RFC 3986 before modifying.
      my $path_escape_class = q{^/;:@&=A-Za-z0-9\$_.+!*'(),-};
  
      my $path = URI::Escape::uri_escape($self->env->{PATH_INFO} || '', $path_escape_class);
      $path .= '?' . $self->env->{QUERY_STRING}
          if defined $self->env->{QUERY_STRING} && $self->env->{QUERY_STRING} ne '';
  
      $base =~ s!/$!! if $path =~ m!^/!;
  
      return URI->new($base . $path)->canonical;
  }
  
  sub base {
      my $self = shift;
      URI->new($self->_uri_base)->canonical;
  }
  
  sub _uri_base {
      my $self = shift;
  
      my $env = $self->env;
  
      my $uri = ($env->{'psgi.url_scheme'} || "http") .
          "://" .
          ($env->{HTTP_HOST} || (($env->{SERVER_NAME} || "") . ":" . ($env->{SERVER_PORT} || 80))) .
          ($env->{SCRIPT_NAME} || '/');
  
      return $uri;
  }
  
  sub new_response {
      my $self = shift;
      require Plack::Response;
      Plack::Response->new(@_);
  }
  
  sub _parse_request_body {
      my $self = shift;
  
      my $ct = $self->env->{CONTENT_TYPE};
      my $cl = $self->env->{CONTENT_LENGTH};
      if (!$ct && !$cl) {
          # No Content-Type nor Content-Length -> GET/HEAD
          $self->env->{'plack.request.body'}   = Hash::MultiValue->new;
          $self->env->{'plack.request.upload'} = Hash::MultiValue->new;
          return;
      }
  
      my $body = HTTP::Body->new($ct, $cl);
  
      # HTTP::Body will create temporary files in case there was an
      # upload.  Those temporary files can be cleaned up by telling
      # HTTP::Body to do so. It will run the cleanup when the request
      # env is destroyed. That the object will not go out of scope by
      # the end of this sub we will store a reference here.
      $self->env->{'plack.request.http.body'} = $body;
      $body->cleanup(1);
  
      my $input = $self->input;
  
      my $buffer;
      if ($self->env->{'psgix.input.buffered'}) {
          # Just in case if input is read by middleware/apps beforehand
          $input->seek(0, 0);
      } else {
          $buffer = Stream::Buffered->new($cl);
      }
  
      my $spin = 0;
      while ($cl) {
          $input->read(my $chunk, $cl < 8192 ? $cl : 8192);
          my $read = length $chunk;
          $cl -= $read;
          $body->add($chunk);
          $buffer->print($chunk) if $buffer;
  
          if ($read == 0 && $spin++ > 2000) {
              Carp::croak "Bad Content-Length: maybe client disconnect? ($cl bytes remaining)";
          }
      }
  
      if ($buffer) {
          $self->env->{'psgix.input.buffered'} = 1;
          $self->env->{'psgi.input'} = $buffer->rewind;
      } else {
          $input->seek(0, 0);
      }
  
      $self->env->{'plack.request.body'}   = Hash::MultiValue->from_mixed($body->param);
  
      my @uploads = Hash::MultiValue->from_mixed($body->upload)->flatten;
      my @obj;
      while (my($k, $v) = splice @uploads, 0, 2) {
          push @obj, $k, $self->_make_upload($v);
      }
  
      $self->env->{'plack.request.upload'} = Hash::MultiValue->new(@obj);
  
      1;
  }
  
  sub _make_upload {
      my($self, $upload) = @_;
      my %copy = %$upload;
      $copy{headers} = HTTP::Headers::Fast->new(%{$upload->{headers}});
      Plack::Request::Upload->new(%copy);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request - Portable HTTP request object from PSGI env hash
  
  =head1 SYNOPSIS
  
    use Plack::Request;
  
    my $app_or_middleware = sub {
        my $env = shift; # PSGI env
  
        my $req = Plack::Request->new($env);
  
        my $path_info = $req->path_info;
        my $query     = $req->parameters->{query};
  
        my $res = $req->new_response(200); # new Plack::Response
        $res->finalize;
    };
  
  =head1 DESCRIPTION
  
  L<Plack::Request> provides a consistent API for request objects across
  web server environments.
  
  =head1 CAVEAT
  
  Note that this module is intended to be used by Plack middleware
  developers and web application framework developers rather than
  application developers (end users).
  
  Writing your web application directly using Plack::Request is
  certainly possible but not recommended: it's like doing so with
  mod_perl's Apache::Request: yet too low level.
  
  If you're writing a web application, not a framework, then you're
  encouraged to use one of the web application frameworks that support PSGI (L<http://plackperl.org/#frameworks>),
  or see modules like L<HTTP::Engine> to provide higher level
  Request and Response API on top of PSGI.
  
  =head1 METHODS
  
  Some of the methods defined in the earlier versions are deprecated in
  version 0.99. Take a look at L</"INCOMPATIBILITIES">.
  
  Unless otherwise noted, all methods and attributes are B<read-only>,
  and passing values to the method like an accessor doesn't work like
  you expect it to.
  
  =head2 new
  
      Plack::Request->new( $env );
  
  Creates a new request object.
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item env
  
  Returns the shared PSGI environment hash reference. This is a
  reference, so writing to this environment passes through during the
  whole PSGI request/response cycle.
  
  =item address
  
  Returns the IP address of the client (C<REMOTE_ADDR>).
  
  =item remote_host
  
  Returns the remote host (C<REMOTE_HOST>) of the client. It may be
  empty, in which case you have to get the IP address using C<address>
  method and resolve on your own.
  
  =item method
  
  Contains the request method (C<GET>, C<POST>, C<HEAD>, etc).
  
  =item protocol
  
  Returns the protocol (HTTP/1.0 or HTTP/1.1) used for the current request.
  
  =item request_uri
  
  Returns the raw, undecoded request URI path. You probably do B<NOT>
  want to use this to dispatch requests.
  
  =item path_info
  
  Returns B<PATH_INFO> in the environment. Use this to get the local
  path for the requests.
  
  =item path
  
  Similar to C<path_info> but returns C</> in case it is empty. In other
  words, it returns the virtual path of the request URI after C<<
  $req->base >>. See L</"DISPATCHING"> for details.
  
  =item query_string
  
  Returns B<QUERY_STRING> in the environment. This is the undecoded
  query string in the request URI.
  
  =item script_name
  
  Returns B<SCRIPT_NAME> in the environment. This is the absolute path
  where your application is hosted.
  
  =item scheme
  
  Returns the scheme (C<http> or C<https>) of the request.
  
  =item secure
  
  Returns true or false, indicating whether the connection is secure (https).
  
  =item body, input
  
  Returns C<psgi.input> handle.
  
  =item session
  
  Returns (optional) C<psgix.session> hash. When it exists, you can
  retrieve and store per-session data from and to this hash.
  
  =item session_options
  
  Returns (optional) C<psgix.session.options> hash.
  
  =item logger
  
  Returns (optional) C<psgix.logger> code reference. When it exists,
  your application is supposed to send the log message to this logger,
  using:
  
    $req->logger->({ level => 'debug', message => "This is a debug message" });
  
  =item cookies
  
  Returns a reference to a hash containing the cookies. Values are
  strings that are sent by clients and are URI decoded.
  
  If there are multiple cookies with the same name in the request, this
  method will ignore the duplicates and return only the first value. If
  that causes issues for you, you may have to use modules like
  CGI::Simple::Cookie to parse C<< $request->header('Cookies') >> by
  yourself.
  
  =item query_parameters
  
  Returns a reference to a hash containing query string (GET)
  parameters. This hash reference is L<Hash::MultiValue> object.
  
  =item body_parameters
  
  Returns a reference to a hash containing posted parameters in the
  request body (POST). As with C<query_parameters>, the hash
  reference is a L<Hash::MultiValue> object.
  
  =item parameters
  
  Returns a L<Hash::MultiValue> hash reference containing (merged) GET
  and POST parameters.
  
  =item content, raw_body
  
  Returns the request content in an undecoded byte string for POST requests.
  
  =item uri
  
  Returns an URI object for the current request. The URI is constructed
  using various environment values such as C<SCRIPT_NAME>, C<PATH_INFO>,
  C<QUERY_STRING>, C<HTTP_HOST>, C<SERVER_NAME> and C<SERVER_PORT>.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item base
  
  Returns an URI object for the base path of current request. This is
  like C<uri> but only contains up to C<SCRIPT_NAME> where your
  application is hosted at.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item user
  
  Returns C<REMOTE_USER> if it's set.
  
  =item headers
  
  Returns an L<HTTP::Headers::Fast> object containing the headers for the current request.
  
  =item uploads
  
  Returns a reference to a hash containing uploads. The hash reference
  is a L<Hash::MultiValue> object and values are L<Plack::Request::Upload>
  objects.
  
  =item content_encoding
  
  Shortcut to $req->headers->content_encoding.
  
  =item content_length
  
  Shortcut to $req->headers->content_length.
  
  =item content_type
  
  Shortcut to $req->headers->content_type.
  
  =item header
  
  Shortcut to $req->headers->header.
  
  =item referer
  
  Shortcut to $req->headers->referer.
  
  =item user_agent
  
  Shortcut to $req->headers->user_agent.
  
  =item param
  
  Returns GET and POST parameters with a CGI.pm-compatible param
  method. This is an alternative method for accessing parameters in
  $req->parameters just in case you want the compatibility with
  CGI.pm objects.
  
  You are B<not recommended> to use this method since it is easy to
  misuse in a list context such as inside a hash constructor or method
  arguments. Use C<parameters> and Hash::MultiValue instead.
  
  Unlike CGI.pm, it does I<not> allow setting or modifying query
  parameters.
  
      $value  = $req->param( 'foo' );
      @values = $req->param( 'foo' );
      @params = $req->param;
  
  =item upload
  
  A convenient method to access $req->uploads.
  
      $upload  = $req->upload('field');
      @uploads = $req->upload('field');
      @fields  = $req->upload;
  
      for my $upload ( $req->upload('field') ) {
          print $upload->filename;
      }
  
  =item new_response
  
    my $res = $req->new_response;
  
  Creates a new L<Plack::Response> object. Handy to remove dependency on
  L<Plack::Response> in your code for easy subclassing and duck typing
  in web application frameworks, as well as overriding Response
  generation in middlewares.
  
  =back
  
  =head2 Hash::MultiValue parameters
  
  Parameters that can take one or multiple values (i.e. C<parameters>,
  C<query_parameters>, C<body_parameters> and C<uploads>) store the
  hash reference as a L<Hash::MultiValue> object. This means you can use
  the hash reference as a plain hash where values are B<always> scalars
  (B<NOT> array references), so you don't need to code ugly and unsafe
  C<< ref ... eq 'ARRAY' >> anymore.
  
  And if you explicitly want to get multiple values of the same key, you
  can call the C<get_all> method on it, such as:
  
    my @foo = $req->query_parameters->get_all('foo');
  
  You can also call C<get_one> to always get one parameter independent
  of the context (unlike C<param>), and even call C<mixed> (with
  Hash::MultiValue 0.05 or later) to get the I<traditional> hash
  reference,
  
    my $params = $req->parameters->mixed;
  
  where values are either a scalar or an array reference depending on
  input, so it might be useful if you already have the code to deal with
  that ugliness.
  
  =head2 PARSING POST BODY and MULTIPLE OBJECTS
  
  The methods to parse request body (C<content>, C<body_parameters> and
  C<uploads>) are carefully coded to save the parsed body in the
  environment hash as well as in the temporary buffer, so you can call
  them multiple times and create Plack::Request objects multiple times
  in a request and they should work safely, and won't parse request body
  more than twice for the efficiency.
  
  =head1 DISPATCHING
  
  If your application or framework wants to dispatch (or route) actions
  based on request paths, be sure to use C<< $req->path_info >> not C<<
  $req->uri->path >>.
  
  This is because C<path_info> gives you the virtual path of the request,
  regardless of how your application is mounted. If your application is
  hosted with mod_perl or CGI scripts, or even multiplexed with tools
  like L<Plack::App::URLMap>, request's C<path_info> always gives you
  the action path.
  
  Note that C<path_info> might give you an empty string, in which case
  you should assume that the path is C</>.
  
  You will also want to use C<< $req->base >> as a base prefix when
  building URLs in your templates or in redirections. It's a good idea
  for you to subclass Plack::Request and define methods such as:
  
    sub uri_for {
        my($self, $path, $args) = @_;
        my $uri = $self->base;
        $uri->path($uri->path . $path);
        $uri->query_form(@$args) if $args;
        $uri;
    }
  
  So you can say:
  
    my $link = $req->uri_for('/logout', [ signoff => 1 ]);
  
  and if C<< $req->base >> is C</app> you'll get the full URI for
  C</app/logout?signoff=1>.
  
  =head1 INCOMPATIBILITIES
  
  In version 0.99, many utility methods are removed or deprecated, and
  most methods are made read-only. These methods were deleted in version
  1.0001.
  
  All parameter-related methods such as C<parameters>,
  C<body_parameters>, C<query_parameters> and C<uploads> now contains
  L<Hash::MultiValue> objects, rather than I<scalar or an array
  reference depending on the user input> which is insecure. See
  L<Hash::MultiValue> for more about this change.
  
  C<< $req->path >> method had a bug, where the code and the document
  was mismatching. The document was suggesting it returns the sub
  request path after C<< $req->base >> but the code was always returning
  the absolute URI path. The code is now updated to be an alias of C<<
  $req->path_info >> but returns C</> in case it's empty. If you need
  the older behavior, just call C<< $req->uri->path >> instead.
  
  Cookie handling is simplified, and doesn't use L<CGI::Simple::Cookie>
  anymore, which means you B<CAN NOT> set array reference or hash
  reference as a cookie value and expect it be serialized. You're always
  required to set string value, and encoding or decoding them is totally
  up to your application or framework. Also, C<cookies> hash reference
  now returns I<strings> for the cookies rather than CGI::Simple::Cookie
  objects, which means you no longer have to write a wacky code such as:
  
    $v = $req->cookies->{foo} ? $req->cookies->{foo}->value : undef;
  
  and instead, simply do:
  
    $v = $req->cookies->{foo};
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Kazuhiro Osawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Response> L<HTTP::Request>, L<Catalyst::Request>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_REQUEST

$fatpacked{"Plack/Request/Upload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_REQUEST_UPLOAD';
  package Plack::Request::Upload;
  use strict;
  use warnings;
  use Carp ();
  
  sub new {
      my($class, %args) = @_;
  
      bless {
          headers  => $args{headers},
          tempname => $args{tempname},
          size     => $args{size},
          filename => $args{filename},
      }, $class;
  }
  
  sub filename { $_[0]->{filename} }
  sub headers  { $_[0]->{headers} }
  sub size     { $_[0]->{size} }
  sub tempname { $_[0]->{tempname} }
  sub path     { $_[0]->{tempname} }
  
  sub content_type {
      my $self = shift;
      $self->{headers}->content_type(@_);
  }
  
  sub type { shift->content_type(@_) }
  
  sub basename {
      my $self = shift;
      unless (defined $self->{basename}) {
          require File::Spec::Unix;
          my $basename = $self->{filename};
          $basename =~ s|\\|/|g;
          $basename = ( File::Spec::Unix->splitpath($basename) )[2];
          $basename =~ s|[^\w\.-]+|_|g;
          $self->{basename} = $basename;
      }
      $self->{basename};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request::Upload - handles file upload requests
  
  =head1 SYNOPSIS
  
    # $req is Plack::Request
    my $upload = $req->uploads->{field};
  
    $upload->size;
    $upload->path;
    $upload->content_type;
    $upload->basename;
  
  =head1 METHODS
  
  =over 4
  
  =item size
  
  Returns the size of Uploaded file.
  
  =item path
  
  Returns the path to the temporary file where uploaded file is saved.
  
  =item content_type
  
  Returns the content type of the uploaded file.
  
  =item filename
  
  Returns the original filename in the client.
  
  =item basename
  
  Returns basename for "filename".
  
  =back
  
  =head1 AUTHORS
  
  Kazuhiro Osawa
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>, L<Catalyst::Request::Upload>
  
  =cut
PLACK_REQUEST_UPLOAD

$fatpacked{"Plack/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_RESPONSE';
  package Plack::Response;
  use strict;
  use warnings;
  our $VERSION = '1.0037';
  
  use Plack::Util::Accessor qw(body status);
  use Carp ();
  use Cookie::Baker ();
  use Scalar::Util ();
  use HTTP::Headers::Fast;
  use URI::Escape ();
  
  sub code    { shift->status(@_) }
  sub content { shift->body(@_)   }
  
  sub new {
      my($class, $rc, $headers, $content) = @_;
  
      my $self = bless {}, $class;
      $self->status($rc)       if defined $rc;
      $self->headers($headers) if defined $headers;
      $self->body($content)    if defined $content;
  
      $self;
  }
  
  sub headers {
      my $self = shift;
  
      if (@_) {
          my $headers = shift;
          if (ref $headers eq 'ARRAY') {
              Carp::carp("Odd number of headers") if @$headers % 2 != 0;
              $headers = HTTP::Headers::Fast->new(@$headers);
          } elsif (ref $headers eq 'HASH') {
              $headers = HTTP::Headers::Fast->new(%$headers);
          }
          return $self->{headers} = $headers;
      } else {
          return $self->{headers} ||= HTTP::Headers::Fast->new();
      }
  }
  
  sub cookies {
      my $self = shift;
      if (@_) {
          $self->{cookies} = shift;
      } else {
          return $self->{cookies} ||= +{ };
      }
  }
  
  sub header { shift->headers->header(@_) } # shortcut
  
  sub content_length {
      shift->headers->content_length(@_);
  }
  
  sub content_type {
      shift->headers->content_type(@_);
  }
  
  sub content_encoding {
      shift->headers->content_encoding(@_);
  }
  
  sub location {
      my $self = shift;
      return $self->headers->header('Location' => @_);
  }
  
  sub redirect {
      my $self = shift;
  
      if (@_) {
          my $url = shift;
          my $status = shift || 302;
          $self->location($url);
          $self->status($status);
      }
  
      return $self->location;
  }
  
  sub finalize {
      my $self = shift;
      Carp::croak "missing status" unless $self->status();
  
      my $headers = $self->headers;
      my @headers;
      $headers->scan(sub{
          my ($k,$v) = @_;
          $v =~ s/\015\012[\040|\011]+/chr(32)/ge; # replace LWS with a single SP
          $v =~ s/\015|\012//g; # remove CR and LF since the char is invalid here
          push @headers, $k, $v;
      });
  
      $self->_finalize_cookies(\@headers);
  
      return [
          $self->status,
          \@headers,
          $self->_body,
      ];
  }
  
  sub to_app {
      my $self = shift;
      return sub { $self->finalize };
  }
  
  
  sub _body {
      my $self = shift;
      my $body = $self->body;
         $body = [] unless defined $body;
      if (!ref $body or Scalar::Util::blessed($body) && overload::Method($body, q("")) && !$body->can('getline')) {
          return [ $body ];
      } else {
          return $body;
      }
  }
  
  sub _finalize_cookies {
      my($self, $headers) = @_;
  
      foreach my $name ( keys %{ $self->cookies } ) {
          my $val = $self->cookies->{$name};
  
          my $cookie = Cookie::Baker::bake_cookie( $name, $val );
          push @$headers, 'Set-Cookie' => $cookie;
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Response - Portable HTTP Response object for PSGI response
  
  =head1 SYNOPSIS
  
    use Plack::Response;
  
    sub psgi_handler {
        my $env = shift;
  
        my $res = Plack::Response->new(200);
        $res->content_type('text/html');
        $res->body("Hello World");
  
        return $res->finalize;
    }
  
  =head1 DESCRIPTION
  
  Plack::Response allows you a way to create PSGI response array ref through a simple API.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $res = Plack::Response->new;
    $res = Plack::Response->new($status);
    $res = Plack::Response->new($status, $headers);
    $res = Plack::Response->new($status, $headers, $body);
  
  Creates a new Plack::Response object.
  
  =item status
  
    $res->status(200);
    $status = $res->status;
  
  Sets and gets HTTP status code. C<code> is an alias.
  
  =item headers
  
    $headers = $res->headers;
    $res->headers([ 'Content-Type' => 'text/html' ]);
    $res->headers({ 'Content-Type' => 'text/html' });
    $res->headers( HTTP::Headers::Fast->new );
  
  Sets and gets HTTP headers of the response. Setter can take either an
  array ref, a hash ref or L<HTTP::Headers::Fast> object containing a list of
  headers.
  
  =item body
  
    $res->body($body_str);
    $res->body([ "Hello", "World" ]);
    $res->body($io);
  
  Gets and sets HTTP response body. Setter can take either a string, an
  array ref, or an IO::Handle-like object. C<content> is an alias.
  
  Note that this method doesn't automatically set I<Content-Length> for
  the response. You have to set it manually if you want, with the
  C<content_length> method (see below).
  
  =item header
  
    $res->header('X-Foo' => 'bar');
    my $val = $res->header('X-Foo');
  
  Shortcut for C<< $res->headers->header >>.
  
  =item content_type, content_length, content_encoding
  
    $res->content_type('text/plain');
    $res->content_length(123);
    $res->content_encoding('gzip');
  
  Shortcut for the equivalent get/set methods in C<< $res->headers >>.
  
  =item redirect
  
    $res->redirect($url);
    $res->redirect($url, 301);
  
  Sets redirect URL with an optional status code, which defaults to 302.
  
  Note that this method doesn't normalize the given URI string. Users of
  this module have to be responsible about properly encoding URI paths
  and parameters.
  
  =item location
  
  Gets and sets C<Location> header.
  
  Note that this method doesn't normalize the given URI string in the
  setter. See above in C<redirect> for details.
  
  =item cookies
  
    $res->cookies->{foo} = 123;
    $res->cookies->{foo} = { value => '123' };
  
  Returns a hash reference containing cookies to be set in the
  response. The keys of the hash are the cookies' names, and their
  corresponding values are a plain string (for C<value> with everything
  else defaults) or a hash reference that can contain keys such as
  C<value>, C<domain>, C<expires>, C<path>, C<httponly>, C<secure>,
  C<max-age>.
  
  C<expires> can take a string or an integer (as an epoch time) and
  B<does not> convert string formats such as C<+3M>.
  
    $res->cookies->{foo} = {
        value => 'test',
        path  => "/",
        domain => '.example.com',
        expires => time + 24 * 60 * 60,
    };
  
  =item finalize
  
    $res->finalize;
  
  Returns the status code, headers, and body of this response as a PSGI
  response array reference.
  
  =item to_app
  
    $app = $res->to_app;
  
  A helper shortcut for C<< sub { $res->finalize } >>.
  
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>
  
  =cut
PLACK_RESPONSE

$fatpacked{"Plack/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_RUNNER';
  package Plack::Runner;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {
          env      => $ENV{PLACK_ENV},
          loader   => 'Plack::Loader',
          includes => [],
          modules  => [],
          default_middleware => 1,
          @_,
      }, $class;
  }
  
  # delay the build process for reloader
  sub build(&;$) {
      my $block = shift;
      my $app   = shift || sub { };
      return sub { $block->($app->()) };
  }
  
  sub parse_options {
      my $self = shift;
  
      local @ARGV = @_;
  
      # From 'prove': Allow cuddling the paths with -I, -M and -e
      @ARGV = map { /^(-[IMe])(.+)/ ? ($1,$2) : $_ } @ARGV;
  
      my($host, $port, $socket, @listen);
  
      require Getopt::Long;
      my $parser = Getopt::Long::Parser->new(
          config => [ "no_auto_abbrev", "no_ignore_case", "pass_through" ],
      );
  
      $parser->getoptions(
          "a|app=s"      => \$self->{app},
          "o|host=s"     => \$host,
          "p|port=i"     => \$port,
          "s|server=s"   => \$self->{server},
          "S|socket=s"   => \$socket,
          'l|listen=s@'  => \@listen,
          'D|daemonize'  => \$self->{daemonize},
          "E|env=s"      => \$self->{env},
          "e=s"          => \$self->{eval},
          'I=s@'         => $self->{includes},
          'M=s@'         => $self->{modules},
          'r|reload'     => sub { $self->{loader} = "Restarter" },
          'R|Reload=s'   => sub { $self->{loader} = "Restarter"; $self->loader->watch(split ",", $_[1]) },
          'L|loader=s'   => \$self->{loader},
          "access-log=s" => \$self->{access_log},
          "path=s"       => \$self->{path},
          "h|help"       => \$self->{help},
          "v|version"    => \$self->{version},
          "default-middleware!" => \$self->{default_middleware},
      );
  
      my(@options, @argv);
      while (defined(my $arg = shift @ARGV)) {
          if ($arg =~ s/^--?//) {
              my @v = split '=', $arg, 2;
              $v[0] =~ tr/-/_/;
              if (@v == 2) {
                  push @options, @v;
              } elsif ($v[0] =~ s/^(disable|enable)_//) {
                  push @options, $v[0], $1 eq 'enable';
              } else {
                  push @options, $v[0], shift @ARGV;
              }
          } else {
              push @argv, $arg;
          }
      }
  
      push @options, $self->mangle_host_port_socket($host, $port, $socket, @listen);
      push @options, daemonize => 1 if $self->{daemonize};
  
      $self->{options} = \@options;
      $self->{argv}    = \@argv;
  }
  
  sub set_options {
      my $self = shift;
      push @{$self->{options}}, @_;
  }
  
  sub mangle_host_port_socket {
      my($self, $host, $port, $socket, @listen) = @_;
  
      for my $listen (reverse @listen) {
          if ($listen =~ /:\d+$/) {
              ($host, $port) = split /:/, $listen, 2;
              $host = undef if $host eq '';
          } else {
              $socket ||= $listen;
          }
      }
  
      unless (@listen) {
          if ($socket) {
              @listen = ($socket);
          } else {
              $port ||= 5000;
              @listen = ($host ? "$host:$port" : ":$port");
          }
      }
  
      return host => $host, port => $port, listen => \@listen, socket => $socket;
  }
  
  sub version_cb {
      my $self = shift;
      $self->{version_cb} || sub {
          require Plack;
          print "Plack $Plack::VERSION\n";
      };
  }
  
  sub setup {
      my $self = shift;
  
      if ($self->{help}) {
          require Pod::Usage;
          Pod::Usage::pod2usage(0);
      }
  
      if ($self->{version}) {
          $self->version_cb->();
          exit;
      }
  
      if (@{$self->{includes}}) {
          require lib;
          lib->import(@{$self->{includes}});
      }
  
      if ($self->{eval}) {
          push @{$self->{modules}}, 'Plack::Builder';
      }
  
      for (@{$self->{modules}}) {
          my($module, @import) = split /[=,]/;
          eval "require $module" or die $@;
          $module->import(@import);
      }
  }
  
  sub locate_app {
      my($self, @args) = @_;
  
      my $psgi = $self->{app} || $args[0];
  
      if (ref $psgi eq 'CODE') {
          return sub { $psgi };
      }
  
      if ($self->{eval}) {
          $self->loader->watch("lib");
          return build {
              no strict;
              no warnings;
              my $eval = "builder { $self->{eval};";
              $eval .= "Plack::Util::load_psgi(\$psgi);" if $psgi;
              $eval .= "}";
              eval $eval or die $@;
          };
      }
  
      $psgi ||= "app.psgi";
  
      require File::Basename;
      $self->loader->watch( File::Basename::dirname($psgi) . "/lib", $psgi );
      build { Plack::Util::load_psgi $psgi };
  }
  
  sub watch {
      my($self, @dir) = @_;
  
      push @{$self->{watch}}, @dir
          if $self->{loader} eq 'Restarter';
  }
  
  sub apply_middleware {
      my($self, $app, $class, @args) = @_;
  
      my $mw_class = Plack::Util::load_class($class, 'Plack::Middleware');
      build { $mw_class->wrap($_[0], @args) } $app;
  }
  
  sub prepare_devel {
      my($self, $app) = @_;
  
      if ($self->{default_middleware}) {
          $app = $self->apply_middleware($app, 'Lint');
          $app = $self->apply_middleware($app, 'StackTrace');
          if (!$ENV{GATEWAY_INTERFACE} and !$self->{access_log}) {
              $app = $self->apply_middleware($app, 'AccessLog');
          }
      }
  
      push @{$self->{options}}, server_ready => sub {
          my($args) = @_;
          my $name  = $args->{server_software} || ref($args); # $args is $server
          my $host  = $args->{host} || 0;
          my $proto = $args->{proto} || 'http';
          print STDERR "$name: Accepting connections at $proto://$host:$args->{port}/\n";
      };
  
      $app;
  }
  
  sub loader {
      my $self = shift;
      $self->{_loader} ||= Plack::Util::load_class($self->{loader}, 'Plack::Loader')->new;
  }
  
  sub load_server {
      my($self, $loader) = @_;
  
      if ($self->{server}) {
          return $loader->load($self->{server}, @{$self->{options}});
      } else {
          return $loader->auto(@{$self->{options}});
      }
  }
  
  sub run {
      my $self = shift;
  
      unless (ref $self) {
          $self = $self->new;
          $self->parse_options(@_);
          return $self->run;
      }
  
      unless ($self->{options}) {
          $self->parse_options();
      }
  
      my @args = @_ ? @_ : @{$self->{argv}};
  
      $self->setup;
  
      my $app = $self->locate_app(@args);
  
      if ($self->{path}) {
          require Plack::App::URLMap;
          $app = build {
              my $urlmap = Plack::App::URLMap->new;
              $urlmap->mount($self->{path} => $_[0]);
              $urlmap->to_app;
          } $app;
      }
  
      $ENV{PLACK_ENV} ||= $self->{env} || 'development';
      if ($ENV{PLACK_ENV} eq 'development') {
          $app = $self->prepare_devel($app);
      }
  
      if ($self->{access_log}) {
          open my $logfh, ">>", $self->{access_log}
              or die "open($self->{access_log}): $!";
          $logfh->autoflush(1);
          $app = $self->apply_middleware($app, 'AccessLog', logger => sub { $logfh->print( @_ ) });
      }
  
      my $loader = $self->loader;
      $loader->preload_app($app);
  
      my $server = $self->load_server($loader);
      $loader->run($server);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Runner - plackup core
  
  =head1 SYNOPSIS
  
    # Your bootstrap script
    use Plack::Runner;
    my $app = sub { ... };
  
    my $runner = Plack::Runner->new;
    $runner->parse_options(@ARGV);
    $runner->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Runner is the core of L<plackup> runner script. You can create
  your own frontend to run your application or framework, munge command
  line options and pass that to C<run> method of this class.
  
  C<run> method does exactly the same thing as the L<plackup> script
  does, but one notable addition is that you can pass a PSGI application
  code reference directly to the method, rather than via C<.psgi>
  file path or with C<-e> switch. This would be useful if you want to
  make an installable PSGI application.
  
  Also, when C<-h> or C<--help> switch is passed, the usage text is
  automatically extracted from your own script using L<Pod::Usage>.
  
  =head1 NOTES
  
  Do not directly call this module from your C<.psgi>, since that makes
  your PSGI application unnecessarily depend on L<plackup> and won't run
  other backends like L<Plack::Handler::Apache2> or mod_psgi.
  
  If you I<really> want to make your C<.psgi> runnable as a standalone
  script, you can do this:
  
    my $app = sub { ... };
  
    unless (caller) {
        require Plack::Runner;
        my $runner = Plack::Runner->new;
        $runner->parse_options(@ARGV);
        return $runner->run($app);
    }
  
    return $app;
  
  B<WARNING>: this section used to recommend C<if (__FILE__ eq $0)> but
  it's known to be broken since Plack 0.9971, since C<$0> is now
  I<always> set to the .psgi file path even when you run it from
  plackup.
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
  
PLACK_RUNNER

$fatpacked{"Plack/TempBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEMPBUFFER';
  package Plack::TempBuffer;
  use strict;
  use warnings;
  
  use parent 'Stream::Buffered';
  
  sub new {
      my $class = shift;
  
      if (defined $Plack::TempBuffer::MaxMemoryBufferSize) {
          warn "Setting \$Plack::TempBuffer::MaxMemoryBufferSize is deprecated. "
             . "You should set \$Stream::Buffered::MaxMemoryBufferSize instead.";
          $Stream::Buffered::MaxMemoryBufferSize = $Plack::TempBuffer::MaxMemoryBufferSize;
      }
  
      return $class->SUPER::new(@_);
  }
  
  1;
PLACK_TEMPBUFFER

$fatpacked{"Plack/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST';
  package Plack::Test;
  use strict;
  use warnings;
  use Carp;
  use parent qw(Exporter);
  our @EXPORT = qw(test_psgi);
  
  our $Impl;
  $Impl ||= $ENV{PLACK_TEST_IMPL} || "MockHTTP";
  
  sub create {
      my($class, $app, @args) = @_;
  
      my $subclass = "Plack::Test::$Impl";
      eval "require $subclass";
      die $@ if $@;
  
      no strict 'refs';
      if (defined &{"Plack::Test::$Impl\::test_psgi"}) {
          return \&{"Plack::Test::$Impl\::test_psgi"};
      }
  
      $subclass->new($app, @args);
  }
  
  sub test_psgi {
      if (ref $_[0] && @_ == 2) {
          @_ = (app => $_[0], client => $_[1]);
      }
      my %args = @_;
  
      my $app    = delete $args{app}; # Backward compat: some implementations don't need app
      my $client = delete $args{client} or Carp::croak "client test code needed";
  
      my $tester = Plack::Test->create($app, %args);
      return $tester->(@_) if ref $tester eq 'CODE'; # compatibility
  
      $client->(sub { $tester->request(@_) });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test - Test PSGI applications with various backends
  
  =head1 SYNOPSIS
  
    use Plack::Test;
    use HTTP::Request::Common;
  
    # Simple OO interface
    my $app = sub { return [ 200, [], [ "Hello "] ] };
    my $test = Plack::Test->create($app);
  
    my $res = $test->request(GET "/");
    is $res->content, "Hello";
  
    # traditional - named params
    test_psgi
        app => sub {
            my $env = shift;
            return [ 200, [ 'Content-Type' => 'text/plain' ], [ "Hello World" ] ],
        },
        client => sub {
            my $cb  = shift;
            my $req = HTTP::Request->new(GET => "http://localhost/hello");
            my $res = $cb->($req);
            like $res->content, qr/Hello World/;
        };
  
    # positional params (app, client)
    my $app = sub { return [ 200, [], [ "Hello "] ] };
    test_psgi $app, sub {
        my $cb  = shift;
        my $res = $cb->(GET "/");
        is $res->content, "Hello";
    };
  
  =head1 DESCRIPTION
  
  Plack::Test is a unified interface to test PSGI applications using
  L<HTTP::Request> and L<HTTP::Response> objects. It also allows you to run PSGI
  applications in various ways. The default backend is C<Plack::Test::MockHTTP>,
  but you may also use any L<Plack::Handler> implementation to run live HTTP
  requests against a web server.
  
  =head1 METHODS
  
  =over 4
  
  =item create
  
    $test = Plack::Test->create($app, %options);
  
  creates an instance of Plack::Test implementation class. C<$app> has
  to be a valid PSGI application code reference.
  
  =item request
  
    $res = $test->request($request);
  
  takes an HTTP::Request object, runs it through the PSGI application to
  test and returns an HTTP::Response object.
  
  =back
  
  =head1 FUNCTIONS
  
  Plack::Test also provides a functional interface that takes two
  callbacks, each of which represents PSGI application and HTTP client
  code that tests the application.
  
  =over 4
  
  =item test_psgi
  
    test_psgi $app, $client;
    test_psgi app => $app, client => $client;
  
  Runs the client test code C<$client> against a PSGI application
  C<$app>. The client callback gets one argument C<$cb>, a
  callback that accepts an C<HTTP::Request> object and returns an
  C<HTTP::Response> object.
  
  Use L<HTTP::Request::Common> to import shortcuts for creating requests for
  C<GET>, C<POST>, C<DELETE>, and C<PUT> operations.
  
  For your convenience, the C<HTTP::Request> given to the callback automatically
  uses the HTTP protocol and the localhost (I<127.0.0.1> by default), so the
  following code just works:
  
    use HTTP::Request::Common;
    test_psgi $app, sub {
        my $cb  = shift;
        my $res = $cb->(GET "/hello");
    };
  
  Note that however, it is not a good idea to pass an arbitrary
  (i.e. user-input) string to C<GET> or even C<<
  HTTP::Request->new >> by assuming that it always represents a path,
  because:
  
    my $req = GET "//foo/bar";
  
  would represent a request for a URL that has no scheme, has a hostname
  I<foo> and a path I</bar>, instead of a path I<//foo/bar> which you
  might actually want.
  
  =back
  
  =head1 OPTIONS
  
  Specify the L<Plack::Test> backend using the environment
  variable C<PLACK_TEST_IMPL> or C<$Plack::Test::Impl> package variable.
  
  The available values for the backend are:
  
  =over 4
  
  =item MockHTTP
  
  (Default) Creates a PSGI env hash out of HTTP::Request object, runs
  the PSGI application in-process and returns HTTP::Response.
  
  =item Server
  
  Runs one of Plack::Handler backends (C<Standalone> by default) and
  sends live HTTP requests to test.
  
  =item ExternalServer
  
  Runs tests against an external server specified in the
  C<PLACK_TEST_EXTERNALSERVER_URI> environment variable instead of spawning the
  application in a server locally.
  
  =back
  
  For instance, test your application with the C<HTTP::Server::ServerSimple>
  server backend with:
  
    > env PLACK_TEST_IMPL=Server PLACK_SERVER=HTTP::Server::ServerSimple \
      prove -l t/test.t
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_TEST

$fatpacked{"Plack/Test/MockHTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST_MOCKHTTP';
  package Plack::Test::MockHTTP;
  use strict;
  use warnings;
  
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use HTTP::Message::PSGI;
  use Try::Tiny;
  
  sub new {
      my($class, $app) = @_;
      bless { app => $app }, $class;
  }
  
  sub request {
      my($self, $req) = @_;
  
      $req->uri->scheme('http')    unless defined $req->uri->scheme;
      $req->uri->host('localhost') unless defined $req->uri->host;
      my $env = $req->to_psgi;
  
      my $res = try {
          HTTP::Response->from_psgi($self->{app}->($env));
      } catch {
          HTTP::Response->from_psgi([ 500, [ 'Content-Type' => 'text/plain' ], [ $_ ] ]);
      };
  
      $res->request($req);
      return $res;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::MockHTTP - Run mocked HTTP tests through PSGI applications
  
  =head1 DESCRIPTION
  
  Plack::Test::MockHTTP is a utility to run PSGI application given
  HTTP::Request objects and return HTTP::Response object out of PSGI
  application response. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Test>
  
  =cut
  
  
PLACK_TEST_MOCKHTTP

$fatpacked{"Plack/Test/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST_SERVER';
  package Plack::Test::Server;
  use strict;
  use warnings;
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use Test::TCP;
  use Plack::Loader;
  use Plack::LWPish;
  
  sub new {
      my($class, $app, %args) = @_;
  
      my $server = Test::TCP->new(
          code => sub {
              my $port = shift;
              my $server = Plack::Loader->auto(port => $port, host => ($args{host} || '127.0.0.1'));
              $server->run($app);
              exit;
          },
      );
  
      bless { server => $server, %args }, $class;
  }
  
  sub port {
      my $self = shift;
      $self->{server}->port;
  }
  
  sub request {
      my($self, $req) = @_;
  
      my $ua = $self->{ua} || Plack::LWPish->new( no_proxy => [qw/127.0.0.1/] );
  
      $req->uri->scheme('http');
      $req->uri->host($self->{host} || '127.0.0.1');
      $req->uri->port($self->port);
  
      return $ua->request($req);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::Server - Run HTTP tests through live Plack servers
  
  =head1 DESCRIPTION
  
  Plack::Test::Server is a utility to run PSGI application with Plack
  server implementations, and run the live HTTP tests with the server
  using a callback. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Loader> L<Test::TCP> L<Plack::Test>
  
  =cut
  
PLACK_TEST_SERVER

$fatpacked{"Plack/Test/Suite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST_SUITE';
  package Plack::Test::Suite;
  use strict;
  use warnings;
  use Digest::MD5;
  use File::ShareDir;
  use HTTP::Request;
  use HTTP::Request::Common;
  use Test::More;
  use Test::TCP;
  use Plack::Loader;
  use Plack::Middleware::Lint;
  use Plack::Util;
  use Plack::Request;
  use Try::Tiny;
  use Plack::LWPish;
  
  my $share_dir = try { File::ShareDir::dist_dir('Plack') } || 'share';
  
  $ENV{PLACK_TEST_SCRIPT_NAME} = '';
  
  # 0: test name
  # 1: request generator coderef.
  # 2: request handler
  # 3: test case for response
  our @TEST = (
      [
          'SCRIPT_NAME',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->content, "script_name=$ENV{PLACK_TEST_SCRIPT_NAME}";
          },
          sub {
              my $env = shift;
              return [ 200, ["Content-Type", "text/plain"], [ "script_name=$env->{SCRIPT_NAME}" ] ];
          },
      ],
      [
          'GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ 'Hello, ' . $env->{QUERY_STRING} ],
              ];
          },
      ],
      [
          'POST',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/", [name => 'tatsuhiko']);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), 14;
              is $res->header('Client-Content-Type'), 'application/x-www-form-urlencoded';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=tatsuhiko';
          },
          sub {
              my $env = shift;
              my $body;
              $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH});
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ 'Hello, ' . $body ],
              ];
          },
      ],
      [
          'big POST',
          sub {
              my $cb = shift;
              my $chunk = "abcdefgh" x 12000;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content_length(length $chunk);
              $req->content_type('application/octet-stream');
              $req->content($chunk);
  
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), length $chunk;
              is length $res->content, length $chunk;
              is Digest::MD5::md5_hex($res->content), Digest::MD5::md5_hex($chunk);
          },
          sub {
              my $env = shift;
              my $len = $env->{CONTENT_LENGTH};
              my $body = '';
              my $spin;
              while ($len > 0) {
                  my $rc = $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH}, length $body);
                  $len -= $rc;
                  last if $spin++ > 2000;
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ $body ],
              ];
          },
      ],
      [
          'psgi.url_scheme',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'http';
          },
          sub {
              my $env = $_[0];
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{'psgi.url_scheme'} ],
              ];
          },
      ],
      [
          'return glob',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr/^package /;
              like $res->content, qr/END_MARK_FOR_TESTING$/;
          },
          sub {
              my $env = shift;
              open my $fh, '<', __FILE__ or die $!;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  $fh,
              ];
          },
      ],
      [
          'filehandle',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 2898;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'bigger file',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/baybridge.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 14750;
              is Digest::MD5::md5_hex($res->content), '70546a79c7abb9c497ca91730a0686e4';
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/baybridge.jpg";
              binmode $fh;
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'handle HTTP-Header',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Foo => "Bar");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_FOO}],
              ];
          },
      ],
      [
          'handle HTTP-Cookie',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Cookie => "foo");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'foo';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_COOKIE}],
              ];
          },
      ],
      [
          'validate env',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, join("\n",
                  'REQUEST_METHOD:GET',
                  "SCRIPT_NAME:$ENV{PLACK_TEST_SCRIPT_NAME}",
                  'PATH_INFO:/foo/',
                  'QUERY_STRING:dankogai=kogaidan',
                  'SERVER_NAME:127.0.0.1',
                  "SERVER_PORT:" . $res->request->uri->port,
              )."\n";
          },
          sub {
              my $env = shift;
              my $body;
              $body .= $_ . ':' . $env->{$_} . "\n" for qw/REQUEST_METHOD SCRIPT_NAME PATH_INFO QUERY_STRING SERVER_NAME SERVER_PORT/;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$body],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%2cbaz");
              is $res->content, "/foo/bar,baz", "PATH_INFO should be decoded per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% double encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%252cbaz");
              is $res->content, "/foo/bar%2cbaz", "PATH_INFO should be decoded only once, per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO (outside of URI characters)',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo%E3%81%82");
              is $res->content, "/foo\x{e3}\x{81}\x{82}";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          'SERVER_PROTOCOL is required',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr{^HTTP/1\.[01]$};
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{SERVER_PROTOCOL}],
              ];
          },
      ],
      [
          'SCRIPT_NAME should not be undef',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $cont = defined $env->{'SCRIPT_NAME'};
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$cont],
              ];
          },
      ],
      [
          'call close after read IO::Handle-like',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/call_close");
              is($res->content, '1234');
          },
          sub {
              my $env = shift;
              {
                  our $closed = -1;
                  sub CalledClose::new { $closed = 0; my $i=0; bless \$i, 'CalledClose' }
                  sub CalledClose::getline {
                      my $self = shift;
                      return $$self++ < 4 ? $$self : undef;
                  }
                  sub CalledClose::close { ::ok(1, 'closed') if defined &::ok }
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  CalledClose->new(),
              ];
          },
      ],
      [
          'has errors',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/has_errors");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $err = $env->{'psgi.errors'};
              my $has_errors = defined $err;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$has_errors]
              ];
          },
      ],
      [
          'status line',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is($res->status_line, '200 OK');
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [1]
              ];
          },
      ],
      [
          'Do not crash when the app dies',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 500;
              is $res->message, 'Internal Server Error';
          },
          sub {
              my $env = shift;
              open my $io, '>', \my $error;
              $env->{'psgi.errors'} = $io;
              die "Throwing an exception from app handler. Server shouldn't crash.";
          },
      ],
      [
          'multi headers (request)',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Foo => "bar");
              $req->push_header(Foo => "baz");
              my $res = $cb->($req);
              like($res->content, qr/^bar,\s*baz$/);
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{HTTP_FOO} ]
              ];
          },
      ],
      [
          'multi headers (response)',
          sub {
              my $cb  = shift;
              my $res = $cb->(HTTP::Request->new(GET => "http://127.0.0.1/"));
              my $foo = $res->header('X-Foo');
              like $foo, qr/foo,\s*bar,\s*baz/;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Foo', 'foo', 'X-Foo', 'bar, baz' ],
                  [ 'hi' ]
              ];
          },
      ],
      [
          'Do not set $env->{COOKIE}',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Cookie => "foo=bar");
              my $res = $cb->($req);
              is($res->header('X-Cookie'), 0);
              is $res->content, 'foo=bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Cookie' => $env->{COOKIE} ? 1 : 0 ],
                  [ $env->{HTTP_COOKIE} ]
              ];
          },
      ],
      [
          'no entity headers on 304',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 304;
              is $res->message, 'Not Modified';
              is $res->content, '';
              ok ! defined $res->header('content_type'), "No Content-Type";
              ok ! defined $res->header('content_length'), "No Content-Length";
              ok ! defined $res->header('transfer_encoding'), "No Transfer-Encoding";
          },
          sub {
              my $env = shift;
              return [ 304, [], [] ];
          },
      ],
      [
          'REQUEST_URI is set',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%20baz%73?x=a");
              is $res->content, $ENV{PLACK_TEST_SCRIPT_NAME} . "/foo/bar%20baz%73?x=a";
          },
          sub {
              my $env = shift;
              return [ 200, [ 'Content-Type' => 'text/plain' ], [ $env->{REQUEST_URI} ] ];
          },
      ],
      [
          'filehandle with path()',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 2898;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              Plack::Util::set_io_path($fh, "$share_dir/face.jpg");
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'a big header value > 128 bytes',
          sub {
              my $cb  = shift;
              my $req = GET "http://127.0.0.1/";
              my $v = ("abcdefgh" x 16);
              $req->header('X-Foo' => $v);
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->content, $v;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain' ],
                  [ $env->{HTTP_X_FOO} ],
              ];
          },
      ],
      [
          'coderef res',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
              return sub {
                  my $respond = shift;
                  $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                      [ 'Hello, ' . $env->{QUERY_STRING} ],
                  ]);
              }
          },
      ],
      [
          'coderef streaming',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
  
              return sub {
                  my $respond = shift;
  
                  my $writer = $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                  ]);
  
                  $writer->write("Hello, ");
                  $writer->write($env->{QUERY_STRING});
                  $writer->close();
              }
          },
      ],
      [
          'CRLF output and FCGI parse bug',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
  
              is $res->header("Foo"), undef;
              is $res->content, "Foo: Bar\r\n\r\nHello World";
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Foo: Bar\r\n\r\nHello World" ] ];
          },
      ],
      [
          'newlines',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is length($res->content), 7;
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Bar\nBaz" ] ];
          },
      ],
      [
          'test 404',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 404;
              is $res->message, 'Not Found';
              is $res->content, 'Not Found';
          },
          sub {
              return [ 404, [ "Content-Type", "text/plain" ], [ "Not Found" ] ];
          },
      ],
      [
          'request->input seekable',
          sub {
              my $cb = shift;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content("body");
              $req->content_type('text/plain');
              $req->content_length(4);
              my $res = $cb->($req);
              is $res->content, 'body';
          },
          sub {
              my $req = Plack::Request->new(shift);
              return [ 200, [ "Content-Type", "text/plain" ], [ $req->content ] ];
          },
      ],
      [
          'request->content on GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              ok $res->is_success;
          },
          sub {
              my $req = Plack::Request->new(shift);
              $req->content;
              return [ 200, [ "Content-Type", "text/plain" ], [ "OK" ] ];
          },
      ],
      [
          'handle Authorization header',
          sub {
              my $cb  = shift;
              SKIP: {
                  skip "Authorization header is unsupported under CGI", 4 if ($ENV{PLACK_TEST_HANDLER} || "") eq "CGI";
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      $req->push_header(Authorization => 'Basic XXXX');
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 1;
                      is $res->content, 'Basic XXXX';
                  };
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 0;
                      is $res->content, 'no_auth';
                  };
              };
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-AUTHORIZATION' => exists($env->{HTTP_AUTHORIZATION}) ? 1 : 0 ],
                  [ $env->{HTTP_AUTHORIZATION} || 'no_auth' ],
              ];
          },
      ],
      [
          'repeated slashes',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1//foo///bar/baz");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, '//foo///bar/baz';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
  );
  
  sub runtests {
      my($class, $runner) = @_;
      for my $test (@TEST) {
          $runner->(@$test);
      }
  }
  
  sub run_server_tests {
      my($class, $server, $server_port, $http_port, %args) = @_;
  
      if (ref $server ne 'CODE') {
          my $server_class = $server;
          $server = sub {
              my($port, $app) = @_;
              my $server = Plack::Loader->load($server_class, port => $port, host => "127.0.0.1", %args);
              $app = Plack::Middleware::Lint->wrap($app);
              $server->run($app);
          }
      }
  
      test_tcp(
          client => sub {
              my $port = shift;
              my $ua = Plack::LWPish->new( no_proxy => [qw/127.0.0.1/] );
              for my $i (0..$#TEST) {
                  my $test = $TEST[$i];
                  note $test->[0];
                  my $cb = sub {
                      my $req = shift;
                      $req->uri->port($http_port || $port);
                      $req->uri->path(($ENV{PLACK_TEST_SCRIPT_NAME}||"") . $req->uri->path);
                      $req->header('X-Plack-Test' => $i);
                      return $ua->request($req);
                  };
  
                  $test->[1]->($cb);
              }
          },
          server => sub {
              my $port = shift;
              my $app  = $class->test_app_handler;
              $server->($port, $app);
              exit(0); # for Test::TCP
          },
          port => $server_port,
      );
  }
  
  sub test_app_handler {
      return sub {
          my $env = shift;
          $TEST[$env->{HTTP_X_PLACK_TEST}][2]->($env);
      };
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Test::Suite - Test suite for Plack handlers
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Plack::Test::Suite;
    Plack::Test::Suite->run_server_tests('Your::Handler');
    done_testing;
  
  =head1 DESCRIPTION
  
  Plack::Test::Suite is a test suite to test a new PSGI server
  implementation. It automatically loads a new handler environment and
  uses LWP to send HTTP requests to the local server to make sure your
  handler implements the PSGI specification correctly.
  
  Note that the handler name doesn't include the C<Plack::Handler::>
  prefix, i.e. if you have a new Plack handler Plack::Handler::Foo, your
  test script would look like:
  
    Plack::Test::Suite->run_server_tests('Foo');
  
  Developers writing Plack applications should look at C<Plack::Test> for testing,
  as subclassing C<Plack::Handler> is for developing server implementations.
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  Kazuho Oku
  
  =cut
  
  END_MARK_FOR_TESTING
PLACK_TEST_SUITE

$fatpacked{"Plack/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_UTIL';
  package Plack::Util;
  use strict;
  use Carp ();
  use Scalar::Util;
  use IO::Handle;
  use overload ();
  use File::Spec ();
  
  sub TRUE()  { 1==1 }
  sub FALSE() { !TRUE }
  
  # there does not seem to be a relevant RT or perldelta entry for this
  use constant _SPLICE_SAME_ARRAY_SEGFAULT => $] < '5.008007';
  
  sub load_class {
      my($class, $prefix) = @_;
  
      if ($prefix) {
          unless ($class =~ s/^\+// || $class =~ /^$prefix/) {
              $class = "$prefix\::$class";
          }
      }
  
      my $file = $class;
      $file =~ s!::!/!g;
      require "$file.pm"; ## no critic
  
      return $class;
  }
  
  sub is_real_fh ($) {
      my $fh = shift;
  
      {
          no warnings 'uninitialized';
          return FALSE if -p $fh or -c _ or -b _;
      }
  
      my $reftype = Scalar::Util::reftype($fh) or return;
      if (   $reftype eq 'IO'
          or $reftype eq 'GLOB' && *{$fh}{IO}
      ) {
          # if it's a blessed glob make sure to not break encapsulation with
          # fileno($fh) (e.g. if you are filtering output then file descriptor
          # based operations might no longer be valid).
          # then ensure that the fileno *opcode* agrees too, that there is a
          # valid IO object inside $fh either directly or indirectly and that it
          # corresponds to a real file descriptor.
          my $m_fileno = $fh->fileno;
          return FALSE unless defined $m_fileno;
          return FALSE unless $m_fileno >= 0;
  
          my $f_fileno = fileno($fh);
          return FALSE unless defined $f_fileno;
          return FALSE unless $f_fileno >= 0;
          return TRUE;
      } else {
          # anything else, including GLOBS without IO (even if they are blessed)
          # and non GLOB objects that look like filehandle objects cannot have a
          # valid file descriptor in fileno($fh) context so may break.
          return FALSE;
      }
  }
  
  sub set_io_path {
      my($fh, $path) = @_;
      bless $fh, 'Plack::Util::IOWithPath';
      $fh->path($path);
  }
  
  sub content_length {
      my $body = shift;
  
      return unless defined $body;
  
      if (ref $body eq 'ARRAY') {
          my $cl = 0;
          for my $chunk (@$body) {
              $cl += length $chunk;
          }
          return $cl;
      } elsif ( is_real_fh($body) ) {
          return (-s $body) - tell($body);
      }
  
      return;
  }
  
  sub foreach {
      my($body, $cb) = @_;
  
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      } else {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
  }
  
  sub class_to_file {
      my $class = shift;
      $class =~ s!::!/!g;
      $class . ".pm";
  }
  
  sub _load_sandbox {
      my $_file = shift;
  
      my $_package = $_file;
      $_package =~ s/([^A-Za-z0-9_])/sprintf("_%2x", unpack("C", $1))/eg;
  
      local $0 = $_file; # so FindBin etc. works
      local @ARGV = ();  # Some frameworks might try to parse @ARGV
  
      return eval sprintf <<'END_EVAL', $_package;
  package Plack::Sandbox::%s;
  {
      my $app = do $_file;
      if ( !$app && ( my $error = $@ || $! )) { die $error; }
      $app;
  }
  END_EVAL
  }
  
  sub load_psgi {
      my $stuff = shift;
  
      local $ENV{PLACK_ENV} = $ENV{PLACK_ENV} || 'development';
  
      my $file = $stuff =~ /^[a-zA-Z0-9\_\:]+$/ ? class_to_file($stuff) : File::Spec->rel2abs($stuff);
      my $app = _load_sandbox($file);
      die "Error while loading $file: $@" if $@;
  
      return $app;
  }
  
  sub run_app($$) {
      my($app, $env) = @_;
  
      return eval { $app->($env) } || do {
          my $body = "Internal Server Error";
          $env->{'psgi.errors'}->print($@);
          [ 500, [ 'Content-Type' => 'text/plain', 'Content-Length' => length($body) ], [ $body ] ];
      };
  }
  
  sub headers {
      my $headers = shift;
      inline_object(
          iter   => sub { header_iter($headers, @_) },
          get    => sub { header_get($headers, @_) },
          set    => sub { header_set($headers, @_) },
          push   => sub { header_push($headers, @_) },
          exists => sub { header_exists($headers, @_) },
          remove => sub { header_remove($headers, @_) },
          headers => sub { $headers },
      );
  }
  
  sub header_iter {
      my($headers, $code) = @_;
  
      my @headers = @$headers; # copy
      while (my($key, $val) = splice @headers, 0, 2) {
          $code->($key, $val);
      }
  }
  
  sub header_get {
      my($headers, $key) = (shift, lc shift);
  
      return () if not @$headers;
  
      my $i = 0;
  
      if (wantarray) {
          return map {
              $key eq lc $headers->[$i++] ? $headers->[$i++] : ++$i && ();
          } 1 .. @$headers/2;
      }
  
      while ($i < @$headers) {
          return $headers->[$i+1] if $key eq lc $headers->[$i];
          $i += 2;
      }
  
      ();
  }
  
  sub header_set {
      my($headers, $key, $val) = @_;
  
      @$headers = ($key, $val), return if not @$headers;
  
      my ($i, $_key) = (0, lc $key);
  
      # locate and change existing header
      while ($i < @$headers) {
          $headers->[$i+1] = $val, last if $_key eq lc $headers->[$i];
          $i += 2;
      }
  
      if ($i > $#$headers) { # didn't find it?
          push @$headers, $key, $val;
          return;
      }
  
      $i += 2; # found and changed it; so, first, skip that pair
  
      return if $i > $#$headers; # anything left?
  
      # yes... so do the same thing as header_remove
      # but for the tail of the array only, starting at $i
  
      my $keep;
      my @keep = grep {
          $_ & 1 ? $keep : ($keep = $_key ne lc $headers->[$_]);
      } $i .. $#$headers;
  
      my $remainder = @$headers - $i;
      return if @keep == $remainder; # if we're not changing anything...
  
      splice @$headers, $i, $remainder, ( _SPLICE_SAME_ARRAY_SEGFAULT
          ? @{[ @$headers[@keep] ]} # force different source array
          :     @$headers[@keep]
      );
      ();
  }
  
  sub header_push {
      my($headers, $key, $val) = @_;
      push @$headers, $key, $val;
  }
  
  sub header_exists {
      my($headers, $key) = (shift, lc shift);
  
      my $check;
      for (@$headers) {
          return 1 if ($check = not $check) and $key eq lc;
      }
  
      return !1;
  }
  
  sub header_remove {
      my($headers, $key) = (shift, lc shift);
  
      return if not @$headers;
  
      my $keep;
      my @keep = grep {
          $_ & 1 ? $keep : ($keep = $key ne lc $headers->[$_]);
      } 0 .. $#$headers;
  
      @$headers = @$headers[@keep] if @keep < @$headers;
      ();
  }
  
  sub status_with_no_entity_body {
      my $status = shift;
      return $status < 200 || $status == 204 || $status == 304;
  }
  
  sub encode_html {
      my $str = shift;
      $str =~ s/&/&amp;/g;
      $str =~ s/>/&gt;/g;
      $str =~ s/</&lt;/g;
      $str =~ s/"/&quot;/g;
      $str =~ s/'/&#39;/g;
      return $str;
  }
  
  sub inline_object {
      my %args = @_;
      bless \%args, 'Plack::Util::Prototype';
  }
  
  sub response_cb {
      my($res, $cb) = @_;
  
      my $body_filter = sub {
          my($cb, $res) = @_;
          my $filter_cb = $cb->($res);
          # If response_cb returns a callback, treat it as a $body filter
          if (defined $filter_cb && ref $filter_cb eq 'CODE') {
              Plack::Util::header_remove($res->[1], 'Content-Length');
              if (defined $res->[2]) {
                  if (ref $res->[2] eq 'ARRAY') {
                      for my $line (@{$res->[2]}) {
                          $line = $filter_cb->($line);
                      }
                      # Send EOF.
                      my $eof = $filter_cb->( undef );
                      push @{ $res->[2] }, $eof if defined $eof;
                  } else {
                      my $body    = $res->[2];
                      my $getline = sub { $body->getline };
                      $res->[2] = Plack::Util::inline_object
                          getline => sub { $filter_cb->($getline->()) },
                          close => sub { $body->close };
                  }
              } else {
                  return $filter_cb;
              }
          }
      };
  
      if (ref $res eq 'ARRAY') {
          $body_filter->($cb, $res);
          return $res;
      } elsif (ref $res eq 'CODE') {
          return sub {
              my $respond = shift;
              my $cb = $cb;  # To avoid the nested closure leak for 5.8.x
              $res->(sub {
                  my $res = shift;
                  my $filter_cb = $body_filter->($cb, $res);
                  if ($filter_cb) {
                      my $writer = $respond->($res);
                      if ($writer) {
                          return Plack::Util::inline_object
                              write => sub { $writer->write($filter_cb->(@_)) },
                              close => sub {
                                  my $chunk = $filter_cb->(undef);
                                  $writer->write($chunk) if defined $chunk;
                                  $writer->close;
                              };
                      }
                  } else {
                      return $respond->($res);
                  }
              });
          };
      }
  
      return $res;
  }
  
  package Plack::Util::Prototype;
  
  our $AUTOLOAD;
  sub can {
      return $_[0]->{$_[1]} if Scalar::Util::blessed($_[0]);
      goto &UNIVERSAL::can;
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $attr = $AUTOLOAD;
      $attr =~ s/.*://;
      if (ref($self->{$attr}) eq 'CODE') {
          $self->{$attr}->(@_);
      } else {
          Carp::croak(qq/Can't locate object method "$attr" via package "Plack::Util::Prototype"/);
      }
  }
  
  sub DESTROY { }
  
  package Plack::Util::IOWithPath;
  use parent qw(IO::Handle);
  
  sub path {
      my $self = shift;
      if (@_) {
          ${*$self}{+__PACKAGE__} = shift;
      }
      ${*$self}{+__PACKAGE__};
  }
  
  package Plack::Util;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util - Utility subroutines for Plack server and framework developers
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item TRUE, FALSE
  
    my $true  = Plack::Util::TRUE;
    my $false = Plack::Util::FALSE;
  
  Utility constants to include when you specify boolean variables in C<$env> hash (e.g. C<psgi.multithread>).
  
  =item load_class
  
    my $class = Plack::Util::load_class($class [, $prefix ]);
  
  Constructs a class name and C<require> the class. Throws an exception
  if the .pm file for the class is not found, just with the built-in
  C<require>.
  
  If C<$prefix> is set, the class name is prepended to the C<$class>
  unless C<$class> begins with C<+> sign, which means the class name is
  already fully qualified.
  
    my $class = Plack::Util::load_class("Foo");                   # Foo
    my $class = Plack::Util::load_class("Baz", "Foo::Bar");       # Foo::Bar::Baz
    my $class = Plack::Util::load_class("+XYZ::ZZZ", "Foo::Bar"); # XYZ::ZZZ
  
  Note that this function doesn't validate (or "sanitize") the passed
  string, hence if you pass a user input to this function (which is an
  insecure thing to do in the first place) it might lead to unexpected
  behavior of loading files outside your C<@INC> path. If you want a
  generic module loading function, you should check out CPAN modules
  such as L<Module::Runtime>.
  
  =item is_real_fh
  
    if ( Plack::Util::is_real_fh($fh) ) { }
  
  returns true if a given C<$fh> is a real file handle that has a file
  descriptor. It returns false if C<$fh> is PerlIO handle that is not
  really related to the underlying file etc.
  
  =item content_length
  
    my $cl = Plack::Util::content_length($body);
  
  Returns the length of content from body if it can be calculated. If
  C<$body> is an array ref it's a sum of length of each chunk, if
  C<$body> is a real filehandle it's a remaining size of the filehandle,
  otherwise returns undef.
  
  =item set_io_path
  
    Plack::Util::set_io_path($fh, "/path/to/foobar.txt");
  
  Sets the (absolute) file path to C<$fh> filehandle object, so you can
  call C<< $fh->path >> on it. As a side effect C<$fh> is blessed to an
  internal package but it can still be treated as a normal file
  handle.
  
  This module doesn't normalize or absolutize the given path, and is
  intended to be used from Server or Middleware implementations. See
  also L<IO::File::WithPath>.
  
  =item foreach
  
    Plack::Util::foreach($body, $cb);
  
  Iterate through I<$body> which is an array reference or
  IO::Handle-like object and pass each line (which is NOT really
  guaranteed to be a I<line>) to the callback function.
  
  It internally sets the buffer length C<$/> to 65536 in case it reads
  the binary file, unless otherwise set in the caller's code.
  
  =item load_psgi
  
    my $app = Plack::Util::load_psgi $psgi_file_or_class;
  
  Load C<app.psgi> file or a class name (like C<MyApp::PSGI>) and
  require the file to get PSGI application handler. If the file can't be
  loaded (e.g. file doesn't exist or has a perl syntax error), it will
  throw an exception.
  
  Since version 1.0006, this function would not load PSGI files from
  include paths (C<@INC>) unless it looks like a class name that only
  consists of C<[A-Za-z0-9_:]>. For example:
  
    Plack::Util::load_psgi("app.psgi");          # ./app.psgi
    Plack::Util::load_psgi("/path/to/app.psgi"); # /path/to/app.psgi
    Plack::Util::load_psgi("MyApp::PSGI");       # MyApp/PSGI.pm from @INC
  
  B<Security>: If you give this function a class name or module name
  that is loadable from your system, it will load the module. This could
  lead to a security hole:
  
    my $psgi = ...; # user-input: consider "Moose"
    $app = Plack::Util::load_psgi($psgi); # this would lead to 'require "Moose.pm"'!
  
  Generally speaking, passing an external input to this function is
  considered very insecure. If you really want to do that, validate that
  a given file name contains dots (like C<foo.psgi>) and also turn it
  into a full path in your caller's code.
  
  =item run_app
  
    my $res = Plack::Util::run_app $app, $env;
  
  Runs the I<$app> by wrapping errors with I<eval> and if an error is
  found, logs it to C<< $env->{'psgi.errors'} >> and returns the
  template 500 Error response.
  
  =item header_get, header_exists, header_set, header_push, header_remove
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
  
    my $v = Plack::Util::header_get($hdrs, $key); # First found only
    my @v = Plack::Util::header_get($hdrs, $key);
    my $bool = Plack::Util::header_exists($hdrs, $key);
    Plack::Util::header_set($hdrs, $key, $val);   # overwrites existent header
    Plack::Util::header_push($hdrs, $key, $val);
    Plack::Util::header_remove($hdrs, $key);
  
  Utility functions to manipulate PSGI response headers array
  reference. The methods that read existent header value handles header
  name as case insensitive.
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
    my $v = Plack::Util::header_get($hdrs, 'content-type'); # 'text/plain'
  
  =item headers
  
    my $headers = [ 'Content-Type' => 'text/plain' ];
  
    my $h = Plack::Util::headers($headers);
    $h->get($key);
    if ($h->exists($key)) { ... }
    $h->set($key => $val);
    $h->push($key => $val);
    $h->remove($key);
    $h->headers; # same reference as $headers
  
  Given a header array reference, returns a convenient object that has
  an instance methods to access C<header_*> functions with an OO
  interface. The object holds a reference to the original given
  C<$headers> argument and updates the reference accordingly when called
  write methods like C<set>, C<push> or C<remove>. It also has C<headers>
  method that would return the same reference.
  
  =item status_with_no_entity_body
  
    if (status_with_no_entity_body($res->[0])) { }
  
  Returns true if the given status code doesn't have any Entity body in
  HTTP response, i.e. it's 100, 101, 204 or 304.
  
  =item inline_object
  
    my $o = Plack::Util::inline_object(
        write => sub { $h->push_write(@_) },
        close => sub { $h->push_shutdown },
    );
    $o->write(@stuff);
    $o->close;
  
  Creates an instant object that can react to methods passed in the
  constructor. Handy to create when you need to create an IO stream
  object for input or errors.
  
  =item encode_html
  
    my $encoded_string = Plack::Util::encode( $string );
  
  Entity encodes C<<>, C<< > >>, C<&>, C<"> and C<'> in the input string
  and returns it.
  
  =item response_cb
  
  See L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =cut
  
  
  
PLACK_UTIL

$fatpacked{"Plack/Util/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_UTIL_ACCESSOR';
  package Plack::Util::Accessor;
  use strict;
  use warnings;
  
  sub import {
      shift;
      return unless @_;
      my $package = caller();
      mk_accessors( $package, @_ );
  }
  
  sub mk_accessors {
      my $package = shift;
      no strict 'refs';
      foreach my $field ( @_ ) {
          *{ $package . '::' . $field } = sub {
              return $_[0]->{ $field } if scalar( @_ ) == 1;
              return $_[0]->{ $field }  = scalar( @_ ) == 2 ? $_[1] : [ @_[1..$#_] ];
          };
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util::Accessor - Accessor generation utility for Plack
  
  =head1 DESCRIPTION
  
  This module is just a simple accessor generator for Plack to replace
  the Class::Accessor::Fast usage and so our classes don't have to inherit
  from their accessor generator.
  
  =head1 SEE ALSO
  
  L<PSGI> L<http://plackperl.org/>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_UTIL_ACCESSOR

$fatpacked{"RFXNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'RFXNAMES';
  package RFXNames;
  
  #based on SDK version 8.03A
  
  use constant {
  	pTypeRecXmitMessage => 0x02
  	sTypeReceiverLockError => 0x00
  	sTypeTransmitterResponse => 0x01
  
  	#undecoded => types
  	pTypeUndecoded => 0x03
  	sTypeUac => 0x00
  	sTypeUarc => 0x01
  	sTypeUati => 0x02
  	sTypeUhideki => 0x03
  	sTypeUlacrosse => 0x04
  	sTypeUad => 0x05
  	sTypeUmertik => 0x06
  	sTypeUoregon1 => 0x07
  	sTypeUoregon2 => 0x08
  	sTypeUoregon3 => 0x09
  	sTypeUproguard => 0x0A
  	sTypeUvisonic => 0x0B
  	sTypeUnec => 0x0C
  	sTypeUfs20 => 0x0D
  	sTypeUrsl => 0x0E
  	sTypeUblinds => 0x0F
  	sTypeUrubicson => 0x10
  	sTypeUae => 0x11
  	sTypeUfineoffset => 0x12
  	sTypeUrgb => 0x13
  	sTypeUrfy => 0x14
  	sTypeUselectplus => 0x15
  
  	#types => for => Lighting
  	pTypeLighting1 => 0x10
  	sTypeX10 => 0x0
  	sTypeARC => 0x1
  	sTypeAB400D => 0x2
  	sTypeWaveman => 0x3
  	sTypeEMW200 => 0x4
  	sTypeIMPULS => 0x5
  	sTypeRisingSun => 0x6
  	sTypePhilips => 0x7
  	sTypeEnergenie => 0x8
  	sTypeEnergenie5 => 0x9
  	sTypeGDR2 => 0x0A
  
  	light1_sOff => 0x0
  	light1_sOn => 0x1
  	light1_sDim => 0x2
  	light1_sBright => 0x3
  	light1_sAllOff => 0x5
  	light1_sAllOn => 0x6
  	light1_sChime => 0x7
  
  	pTypeLighting2 => 0x11
  	sTypeAC => 0x0
  	sTypeHEU => 0x1
  	sTypeANSLUT => 0x2
  	sTypeKambrook => 0x03
  
  	light2_sOff => 0x0
  	light2_sOn => 0x1
  	light2_sSetLevel => 0x2
  	light2_sGroupOff => 0x3
  	light2_sGroupOn => 0x4
  	light2_sSetGroupLevel => 0x5
  
  	pTypeLighting3 => 0x12
  	sTypeKoppla => 0x0
  	light3_sBright => 0x0
  	light3_sDim => 0x8
  	light3_sOn => 0x10
  	light3_sLevel1 => 0x11
  	light3_sLevel2 => 0x12
  	light3_sLevel3 => 0x13
  	light3_sLevel4 => 0x14
  	light3_sLevel5 => 0x15
  	light3_sLevel6 => 0x16
  	light3_sLevel7 => 0x17
  	light3_sLevel8 => 0x18
  	light3_sLevel9 => 0x19
  	light3_sOff => 0x1A
  	light3_sProgram => 0x1B
  
  	pTypeLighting4 => 0x13
  	sTypePT2262 => 0x0
  
  	pTypeLighting5 => 0x14
  	sTypeLightwaveRF => 0x0
  	sTypeEMW100 => 0x1
  	sTypeBBSB => 0x2
  	sTypeMDREMOTE => 0x03
  	sTypeRSL => 0x04
  	sTypeLivolo => 0x05
  	sTypeTRC02 => 0x06
  	sTypeAoke => 0x07
  	sTypeTRC02_2 => 0x08
  	sTypeEurodomest => 0x09
  	sTypeLivoloAppliance => 0x0A
  
  	light5_sOff => 0x0
  	light5_sOn => 0x1
  	light5_sGroupOff => 0x2
  	light5_sLearn => 0x2
  	light5_sGroupOn => 0x3
  	light5_sMood1 => 0x3
  	light5_sMood2 => 0x4
  	light5_sMood3 => 0x5
  	light5_sMood4 => 0x6
  	light5_sMood5 => 0x7
  	light5_sUnlock => 0xA
  	light5_sLock => 0xB
  	light5_sAllLock => 0xC
  	light5_sClose => 0xD
  	light5_sStop => 0xE
  	light5_sOpen => 0xF
  	light5_sSetLevel => 0x10
  	light5_sColourPalette => 0x11
  	light5_sColourTone => 0x12
  	light5_sColourCycle => 0x13
  	light5_sPower => 0x0
  	light5_sLight => 0x1
  	light5_sBright => 0x2
  	light5_sDim => 0x3
  	light5_s100 => 0x4
  	light5_s50 => 0x5
  	light5_s25 => 0x6
  	light5_sModePlus => 0x7
  	light5_sSpeedMin => 0x8
  	light5_sSpeedPlus => 0x9
  	light5_sModeMin => 0xA
  	light5_sLivoloAllOff => 0x00
  	light5_sLivoloGang1Toggle => 0x01
  	light5_sLivoloGang2Toggle => 0x02	#dim+ => for => dimmer
  	light5_sLivoloGang3Toggle => 0x03	#dim- => for => dimmer
  	light5_sLivoloGang4Toggle => 0x04
  	light5_sLivoloGang5Toggle => 0x05
  	light5_sLivoloGang6Toggle => 0x06
  	light5_sLivoloGang7Toggle => 0x07
  	light5_sLivoloGang8Toggle => 0x08
  	light5_sLivoloGang9Toggle => 0x09
  	light5_sLivoloGang10Toggle => 0x0A
  	light5_sRGBoff => 0x00
  	light5_sRGBon => 0x01
  	light5_sRGBbright => 0x02
  	light5_sRGBdim => 0x03
  	light5_sRGBcolorplus => 0x04
  	light5_sRGBcolormin => 0x05
  
  	pTypeLighting6 => 0x15
  	sTypeBlyss => 0x0
  	light6_sOn => 0x0
  	light6_sOff => 0x1
  	light6_sGroupOn => 0x2
  	light6_sGroupOff => 0x3
  
  	pTypeChime => 0x16
  	sTypeByronSX => 0x0
  	sTypeByronMP001 => 0x1
  	sTypeSelectPlus => 0x2
  	sTypeSelectPlus3 => 0x3
  	sTypeEnvivo => 0x4
  	chime_sound0 => 0x1
  	chime_sound1 => 0x3
  	chime_sound2 => 0x5
  	chime_sound3 => 0x9
  	chime_sound4 => 0xD
  	chime_sound5 => 0xE
  	chime_sound6 => 0x6
  	chime_sound7 => 0x2
  
  	pTypeFan => 0x17
  	sTypeSiemensSF01 => 0x0
  	fan_sTimer => 0x1
  	fan_sMin => 0x2
  	fan_sLearn => 0x3
  	fan_sPlus => 0x4
  	fan_sConfirm => 0x5
  	fan_sLight => 0x6
  
  	#types => for => Curtain
  	pTypeCurtain => 0x18
  	sTypeHarrison => 0x0
  	curtain_sOpen => 0x0
  	curtain_sClose => 0x1
  	curtain_sStop => 0x2
  	curtain_sProgram => 0x3
  
  	#types => for => Blinds
  	pTypeBlinds => 0x19
  	sTypeBlindsT0 => 0x0	#RollerTrol, => Hasta => new
  	sTypeBlindsT1 => 0x1	#Hasta => old
  	sTypeBlindsT2 => 0x2	#A-OK => RF01
  	sTypeBlindsT3 => 0x3	#A-OK => AC114
  	sTypeBlindsT4 => 0x4	#RAEX => YR1326
  	sTypeBlindsT5 => 0x5	#Media => Mount
  	sTypeBlindsT6 => 0x6	#DC106, => YOOHA, => Rohrmotor24 => RMF
  	sTypeBlindsT7 => 0x7	#Forest
  	sTypeBlindsT8 => 0x8	#Chamberlain => CS4330CN
  	sTypeBlindsT9 => 0x9	#Sunpery
  	sTypeBlindsT10 => 0xA	#Dolat => DLM-1
  
  	blinds_sOpen => 0x0
  	blinds_sClose => 0x1
  	blinds_sStop => 0x2
  	blinds_sConfirm => 0x3
  	blinds_sLimit => 0x4
  	blinds_slowerLimit => 0x5
  	blinds_sDeleteLimits => 0x6
  	blinds_sChangeDirection => 0x7
  	blinds_sLeft => 0x8
  	blinds_sRight => 0x9
  	blinds_s9ChangeDirection => 0x6
  	blinds_s9ImA => = => 0x7
  	blinds_s9ImCenter => = => 0x8
  	blinds_s9ImB => = => 0x9
  	blinds_s9EraseCurrentCh => = => 0xA
  	blinds_s9EraseAllCh => = => 0xB
  	blinds_s10LearnMaster => = => 0x4
  	blinds_s10EraseCurrentCh => = => 0x5
  	blinds_s10ChangeDirection => = => 0x6
  
  	#types => for => RFY
  	pTypeRFY => 0x1A
  	sTypeRFY => 0x0	#RFY
  	sTypeRFYext => 0x1	#RFY => extended
  	rfy_sStop => 0x0
  	rfy_sUp => 0x1
  	rfy_sUpStop => 0x2
  	rfy_sDown => 0x3
  	rfy_sDownStop => 0x4
  	rfy_sUpDown => 0x5
  	rfy_sListRemotes => 0x6
  	rfy_sProgram => 0x7
  	rfy_s2SecProgram => 0x8
  	rfy_s7SecProgram => 0x9
  	rfy_s2SecStop => 0xA
  	rfy_s5SecStop => 0xB
  	rfy_s5SecUpDown => 0xC
  	rfy_sEraseThis => 0xD
  	rfy_sEraseAll => 0xE
  	rfy_s05SecUp => 0xF
  	rfy_s05SecDown => 0x10
  	rfy_s2SecUp => 0x11
  	rfy_s2SecDown => 0x12
  	rfy_sEnableSunWind => 0x13
  	rfy_sDisableSun => 0x14
  
  	#types => for => Security1
  	pTypeSecurity1 => 0x20
  	sTypeSecX10 => 0x0				#X10 => security
  	sTypeSecX10M => 0x1			#X10 => security => motion
  	sTypeSecX10R => 0x2			#X10 => security => remote
  	sTypeKD101 => 0x3				#KD101 => smoke => detector
  	sTypePowercodeSensor => 0x04	#Visonic => PowerCode => sensor => - => primary => contact
  	sTypePowercodeMotion => 0x05	#Visonic => PowerCode => motion
  	sTypeCodesecure => 0x06		#Visonic => CodeSecure
  	sTypePowercodeAux => 0x07		#Visonic => PowerCode => sensor => - => auxiliary => contact
  	sTypeMeiantech => 0x8			#Meiantech
  	sTypeSA30 => 0x9				#SA30 => smoke => detector
  
  	#status => security
  	sStatusNormal => 0x0
  	sStatusNormalDelayed => 0x1
  	sStatusAlarm => 0x2
  	sStatusAlarmDelayed => 0x3
  	sStatusMotion => 0x4
  	sStatusNoMotion => 0x5
  	sStatusPanic => 0x6
  	sStatusPanicOff => 0x7
  	sStatusIRbeam => 0x8
  	sStatusArmAway => 0x9
  	sStatusArmAwayDelayed => 0xA
  	sStatusArmHome => 0xB
  	sStatusArmHomeDelayed => 0xC
  	sStatusDisarm => 0xD
  	sStatusLightOff => 0x10
  	sStatusLightOn => 0x11
  	sStatusLight2Off => 0x12
  	sStatusLight2On => 0x13
  	sStatusDark => 0x14
  	sStatusLight => 0x15
  	sStatusBatLow => 0x16
  	sStatusPairKD101 => 0x17
  	sStatusNormalTamper => 0x80
  	sStatusNormalDelayedTamper => 0x81
  	sStatusAlarmTamper => 0x82
  	sStatusAlarmDelayedTamper => 0x83
  	sStatusMotionTamper => 0x84
  	sStatusNoMotionTamper => 0x85
  
  	#types => for => Security2
  	pTypeSecurity2 => 0x21
  	sTypeSec2Classic => 0x0
  
  	#types => for => Camera
  	pTypeCamera => 0x28
  	sTypeNinja => 0x0		#X10 => Ninja/Robocam
  	camera_sLeft => 0x0
  	camera_sRight => 0x1
  	camera_sUp => 0x2
  	camera_sDown => 0x3
  	camera_sPosition1 => 0x4
  	camera_sProgramPosition1 => 0x5
  	camera_sPosition2 => 0x6
  	camera_sProgramPosition2 => 0x7
  	camera_sPosition3 => 8
  	camera_sProgramPosition3 => 0x9
  	camera_sPosition4 => 0xA
  	camera_sProgramPosition4 => 0xB
  	camera_sCenter => 0xC
  	camera_sProgramCenterPosition => 0xD
  	camera_sSweep => 0xE
  	camera_sProgramSweep => 0xF
  
  	#types => for => Remotes
  	pTypeRemote => 0x30
  	sTypeATI => 0x0		#ATI => Remote => Wonder
  	sTypeATIplus => 0x1	#ATI => Remote => Wonder => Plus
  	sTypeMedion => 0x2		#Medion => Remote
  	sTypePCremote => 0x3	#PC => Remote
  	sTypeATIrw2 => 0x4		#ATI => Remote => Wonder => II
  
  	#types => for => Thermostat
  	pTypeThermostat1 => 0x40
  	sTypeDigimax => 0x0		#Digimax
  	sTypeDigimaxShort => 0x1	#Digimax => with => short => format
  	thermostat1_sNoStatus => 0x0
  	thermostat1_sDemand => 0x1
  	thermostat1_sNoDemand => 0x2
  	thermostat1_sInitializing => 0x3
  
  	pTypeThermostat2 => 0x41
  	sTypeHE105 => 0x0
  	sTypeRTS10 => 0x1
  	thermostat2_sOff => 0x0
  	thermostat2_sOn => 0x1
  	thermostat2_sProgram => 0x2
  
  	pTypeThermostat3 => 0x42
  	sTypeMertikG6RH4T1 => 0x0	#Mertik => G6R-H4T1
  	sTypeMertikG6RH4TB => 0x1	#Mertik => G6R-H4TB
  	sTypeMertikG6RH4TD => 0x2	#Mertik => G6R-H4TD
  	sTypeMertikG6RH4S => 0x3	#Mertik => G6R-H4S
  	thermostat3_sOff => 0x0
  	thermostat3_sOn => 0x1
  	thermostat3_sUp => 0x2
  	thermostat3_sDown => 0x3
  	thermostat3_sRunUp => 0x4
  	thermostat3_Off2nd => 0x4
  	thermostat3_sRunDown => 0x5
  	thermostat3_On2nd => 0x5
  	thermostat3_sStop => 0x6
  
  	#types => for => Radiator => valve
  	pTypeRadiator1 => 0x48
  	sTypeSmartwares => 0x0	#Homewizard => smartwares
  
  	Radiator1_sNight => 0x0
  	Radiator1_sDay => 0x1
  	Radiator1_sSetTemp => 0x2
  
  	#types => for => BBQ => temperature
  	pTypeBBQ => 0x4E
  	sTypeBBQ1 => 0x1 =>  => #Maverick => ET-732
  
  	#types => for => temperature+rain
  	pTypeTEMP_RAIN => 0x4F
  	sTypeTR1 => 0x1 =>  => #WS1200
  
  	#types => for => temperature
  	pTypeTEMP => 0x50
  	sTypeTEMP1 => 0x1 =>  => #THR128/138,THC138
  	sTypeTEMP2 => 0x2 =>  => #THC238/268,THN132,THWR288,THRN122,THN122,AW129/131
  	sTypeTEMP3 => 0x3 =>  => #THWR800
  	sTypeTEMP4 => 0x4	#RTHN318
  	sTypeTEMP5 => 0x5 =>  => #LaCrosse => TX3
  	sTypeTEMP6 => 0x6 =>  => #TS15C
  	sTypeTEMP7 => 0x7 =>  => #Viking => 02811,TSS330
  	sTypeTEMP8 => 0x8 =>  => #LaCrosse => WS2300
  	sTypeTEMP9 => 0x9 =>  => #RUBiCSON
  	sTypeTEMP10 => 0xA =>  => #TFA => 30.3133
  	sTypeTEMP11 => 0xB =>  => #WT0122
  
  	#types => for => humidity
  	pTypeHUM => 0x51
  	sTypeHUM1 => 0x1 =>  => #LaCrosse => TX3
  	sTypeHUM2 => 0x2 =>  => #LaCrosse => WS2300
  
  	#status => types => for => humidity
  	humstat_normal => 0x0
  	humstat_comfort => 0x1
  	humstat_dry => 0x2
  	humstat_wet => 0x3
  
  	#types => for => temperature+humidity
  	pTypeTEMP_HUM => 0x52
  	sTypeTH1 => 0x1 =>  => #THGN122/123,THGN132,THGR122/228/238/268
  	sTypeTH2 => 0x2 =>  => #THGR810,THGN800
  	sTypeTH3 => 0x3 =>  => #RTGR328
  	sTypeTH4 => 0x4 =>  => #THGR328
  	sTypeTH5 => 0x5 =>  => #WTGR800
  	sTypeTH6 => 0x6 =>  => #THGR918,THGRN228,THGN500
  	sTypeTH7 => 0x7 =>  => #TFA => TS34C, => Cresta
  	sTypeTH8 => 0x8 =>  => #WT450H
  	sTypeTH9 => 0x9 =>  => #Viking => 02035,02038 => (02035 => has => no => humidity), => TSS320
  	sTypeTH10 => 0xA =>  =>  => #Rubicson
  	sTypeTH11 => 0xB =>  =>  => #EW109
  	sTypeTH12 => 0xC =>  =>  => #Imagintronix
  	sTypeTH13 => 0xD =>  =>  => #Alecto => WS1700 => and => compatibles
  	sTypeTH14 => 0xE =>  =>  => #Alecto
  
  	#types => for => barometric
  	pTypeBARO => 0x53
  
  	#types => for => temperature+humidity+baro
  	pTypeTEMP_HUM_BARO => 0x54
  	sTypeTHB1 => 0x1 =>  =>  => #BTHR918,BTHGN129
  	sTypeTHB2 => 0x2 =>  =>  => #BTHR918N,BTHR968
  	baroForecastNoInfo => 0x00
  	baroForecastSunny => 0x01
  	baroForecastPartlyCloudy => 0x02
  	baroForecastCloudy => 0x03
  	baroForecastRain => 0x04
  
  	#types => for => rain
  	pTypeRAIN => 0x55
  	sTypeRAIN1 => 0x1 =>  =>  => #RGR126/682/918
  	sTypeRAIN2 => 0x2 =>  =>  => #PCR800
  	sTypeRAIN3 => 0x3 =>  =>  => #TFA
  	sTypeRAIN4 => 0x4 =>  =>  => #UPM
  	sTypeRAIN5 => 0x5 =>  =>  => #WS2300
  	sTypeRAIN6 => 0x6 =>  =>  => #TX5
  	sTypeRAIN7 => 0x7 =>  =>  => #Alecto
  
  	#types => for => wind
  	pTypeWIND => 0x56
  	sTypeWIND1 => 0x1 =>  =>  => #WTGR800
  	sTypeWIND2 => 0x2 =>  =>  => #WGR800
  	sTypeWIND3 => 0x3 =>  =>  => #STR918,WGR918
  	sTypeWIND4 => 0x4 =>  =>  => #TFA
  	sTypeWIND5 => 0x5 =>  =>  => #UPM
  	sTypeWIND6 => 0x6 =>  =>  => #WS2300
  	sTypeWIND7 => 0x7 =>  =>  => #Alecto => WS4500
  
  	#types => for => uv
  	pTypeUV => 0x57
  	sTypeUV1 => 0x1 =>  =>  => #UVN128,UV138
  	sTypeUV2 => 0x2 =>  =>  => #UVN800
  	sTypeUV3 => 0x3 =>  =>  => #TFA
  
  	#types => for => date => & => time
  	pTypeDT => 0x58
  	sTypeDT1 => 0x1 =>  =>  => #RTGR328N
  
  	#types => for => current
  	pTypeCURRENT => 0x59
  	sTypeELEC1 => 0x1 =>  =>  => #CM113,Electrisave
  
  	#types => for => energy
  	pTypeENERGY => 0x5A
  	sTypeELEC2 => 0x1 =>  =>  => #CM119/160
  	sTypeELEC3 => 0x2 =>  =>  => #CM180
  
  	#types => for => current-energy
  	pTypeCURRENTENERGY => 0x5B
  	sTypeELEC4 => 0x1 =>  =>  => #CM180i
  
  	#types => for => power
  	pTypePOWER => 0x5C
  	sTypeELEC5 => 0x1 =>  =>  => #revolt
  
  	#types => for => weight => scales
  	pTypeWEIGHT => 0x5D
  	sTypeWEIGHT1 => 0x1 =>  =>  => #BWR102
  	sTypeWEIGHT2 => 0x2 =>  =>  => #GR101
  
  	#types => for => gas
  	pTypeGAS => 0x5E
  
  	#types => for => water
  	pTypeWATER => 0x5F
  
  	#RFXSensor
  	pTypeRFXSensor => 0x70
  	sTypeRFXSensorTemp => 0x0
  	sTypeRFXSensorAD => 0x1
  	sTypeRFXSensorVolt => 0x2
  	sTypeRFXSensorMessage => 0x3
  
  	#RFXMeter
  	pTypeRFXMeter => 0x71
  	sTypeRFXMeterCount => 0x0
  	sTypeRFXMeterInterval => 0x1
  	sTypeRFXMeterCalib => 0x2
  	sTypeRFXMeterAddr => 0x3
  	sTypeRFXMeterCounterReset => 0x4
  	sTypeRFXMeterCounterSet => 0xB
  	sTypeRFXMeterSetInterval => 0xC
  	sTypeRFXMeterSetCalib => 0xD
  	sTypeRFXMeterSetAddr => 0xE
  	sTypeRFXMeterIdent => 0xF
  
  	#FS20
  	pTypeFS20 => 0x72
  	sTypeFS20 => 0x0
  	sTypeFHT8V => 0x1
  	sTypeFHT80 => 0x2
  };
  
  my %pType= {
  0	=>	{ pTypeInterfaceControl, "Interface Control", "unknown" },
  1	=>	{ pTypeInterfaceMessage, "Interface Message", "unknown" },
  2	=>	{ pTypeRecXmitMessage, "Receiver/Transmitter Message", "unknown" },
  3	=>	{ pTypeUndecoded, "Undecoded RF Message", "unknown" },
  4	=>	{ pTypeLighting1, "Lighting 1" , "lightbulb", },
  5	=>	{ pTypeLighting2, "Lighting 2" , "lightbulb", },
  6	=>	{ pTypeLighting3, "Lighting 3" , "lightbulb", },
  7	=>	{ pTypeLighting4, "Lighting 4" , "lightbulb", },
  8	=>	{ pTypeLighting5, "Lighting 5" , "lightbulb", },
  9	=>	{ pTypeLighting6, "Lighting 6" , "lightbulb", },
  10	=>	{ pTypeLimitlessLights, "Lighting Limitless/Applamp" , "lightbulb" },
  11	=>	{ pTypeCurtain, "Curtain" , "blinds" },
  12	=>	{ pTypeBlinds, "Blinds" , "blinds" },
  13	=>	{ pTypeSecurity1, "Security", "security" },
  14	=>	{ pTypeSecurity2, "Security", "security" },
  15	=>	{ pTypeCamera, "Camera", "unknown" },
  16	=>	{ pTypeRemote, "Remote & IR" , "unknown" },
  17	=>	{ pTypeThermostat1, "Thermostat 1" , "temperature" },
  18	=>	{ pTypeThermostat2, "Thermostat 2" , "temperature" },
  19	=>	{ pTypeThermostat3, "Thermostat 3" , "temperature" },
  20	=>	{ pTypeRadiator1, "Radiator 1", "temperature" },
  21	=>	{ pTypeTEMP, "Temp", "temperature" },
  22	=>	{ pTypeHUM, "Humidity" , "temperature" },
  23	=>	{ pTypeTEMP_HUM, "Temp + Humidity" , "temperature" },
  24	=>	{ pTypeBARO, "Barometric" , "temperature" },
  25	=>	{ pTypeTEMP_HUM_BARO, "Temp + Humidity + Baro" , "temperature" },
  26	=>	{ pTypeRAIN, "Rain" , "rain" },
  27	=>	{ pTypeWIND, "Wind" , "wind" },
  28	=>	{ pTypeUV, "UV" , "uv" },
  29	=>	{ pTypeDT, "Date/Time" , "unknown" },
  30	=>	{ pTypeCURRENT, "Current" , "current" },
  31	=>	{ pTypeENERGY, "Energy" , "current" },
  32	=>	{ pTypeCURRENTENERGY, "Current/Energy" , "current" },
  33	=>	{ pTypeGAS, "Gas" , "counter" },
  34	=>	{ pTypeWATER, "Water" , "counter" },
  35	=>	{ pTypeWEIGHT, "Weight" , "scale" },
  36	=>	{ pTypeRFXSensor, "RFXSensor" , "unknown" },
  37	=>	{ pTypeRFXMeter, "RFXMeter" , "counter" },
  38	=>	{ pTypeP1Power, "P1 Smart Meter" , "counter" },
  39	=>	{ pTypeP1Gas, "P1 Smart Meter" , "counter" },
  40	=>	{ pTypeYouLess, "YouLess Meter", "counter" },
  41	=>	{ pTypeFS20, "FS20" , "unknown" },
  42	=>	{ pTypeRego6XXTemp, "Temp" , "temperature" },
  43	=>	{ pTypeRego6XXValue, "Value" , "utility" },
  44	=>	{ pTypeAirQuality, "Air Quality" , "air" },
  45	=>	{ pTypeUsage, "Usage" , "current" },
  46	=>	{ pTypeTEMP_BARO, "Temp + Baro" , "temperature" },
  47	=>	{ pTypeLux, "Lux" , "lux" },
  48	=>	{ pTypeGeneral, "General" , "General" },
  49	=>	{ pTypeThermostat, "Thermostat" , "thermostat" },
  50	=>	{ pTypeTEMP_RAIN, "Temp + Rain" , "Temp + Rain" },
  51	=>	{ pTypeChime, "Chime" , "doorbell" },
  52	=>	{ pTypeBBQ, "BBQ Meter", "bbq" },
  53	=>	{ pTypePOWER, "Current/Energy" , "current" },
  54	=>	{ pTypeRFY, "RFY" , "blinds" },
  55	=>	{ pTypeEvohome, "Heating" , "evohome" },
  56	=>	{ pTypeEvohomeZone, "Heating" , "evohome" },
  57	=>	{ pTypeEvohomeWater, "Heating" , "evohome" },
  58	=>	{ pTypeEvohomeRelay, "Heating" , "evohome" },
  59	=>	{ pTypeGeneralSwitch, "Light/Switch", "lightbulb" },
  
  };
  
  my %sType = {
   sTypeTEMP1	=>	pTypeTEMP		,
   sTypeTEMP2	=>	pTypeTEMP		,
   sTypeTEMP3	=>	pTypeTEMP		,
   sTypeTEMP4	=>	pTypeTEMP		,
   sTypeTEMP5	=>	pTypeTEMP		,
   sTypeTEMP6	=>	pTypeTEMP		,
   sTypeTEMP7	=>	pTypeTEMP		,
   sTypeTEMP8	=>	pTypeTEMP		,
   sTypeTEMP9	=>	pTypeTEMP		,
   sTypeTEMP10	=>	pTypeTEMP		,
   sTypeTEMP11	=>	pTypeTEMP		,
   sTypeTEMP_SYSTEM	=>	pTypeTEMP		,
   sTypeHUM1	=>	pTypeHUM		,
   sTypeHUM2	=>	pTypeHUM		,
   sTypeTH1	=>	pTypeTEMP_HUM		,
   sTypeTH2	=>	pTypeTEMP_HUM		,
   sTypeTH3	=>	pTypeTEMP_HUM		,
   sTypeTH4	=>	pTypeTEMP_HUM		,
   sTypeTH5	=>	pTypeTEMP_HUM		,
   sTypeTH6	=>	pTypeTEMP_HUM		,
   sTypeTH7	=>	pTypeTEMP_HUM		,
   sTypeTH8	=>	pTypeTEMP_HUM		,
   sTypeTH9	=>	pTypeTEMP_HUM		,
   sTypeTH10	=>	pTypeTEMP_HUM		,
   sTypeTH11	=>	pTypeTEMP_HUM		,
   sTypeTH12	=>	pTypeTEMP_HUM		,
   sTypeTH_LC_TC	=>	pTypeTEMP_HUM		,
   sTypeTHB1	=>	pTypeTEMP_HUM_BARO		,
   sTypeTHB2	=>	pTypeTEMP_HUM_BARO		,
   sTypeTHBFloat	=>	pTypeTEMP_HUM_BARO		,
   sTypeRAIN1	=>	pTypeRAIN		,
   sTypeRAIN2	=>	pTypeRAIN		,
   sTypeRAIN3	=>	pTypeRAIN		,
   sTypeRAIN4	=>	pTypeRAIN		,
   sTypeRAIN5	=>	pTypeRAIN		,
   sTypeRAIN6	=>	pTypeRAIN		,
   sTypeRAINWU	=>	pTypeRAIN		,
   sTypeWIND1	=>	pTypeWIND		,
   sTypeWIND2	=>	pTypeWIND		,
   sTypeWIND3	=>	pTypeWIND		,
   sTypeWIND4	=>	pTypeWIND		,
   sTypeWIND5	=>	pTypeWIND		,
   sTypeWIND6	=>	pTypeWIND		,
   sTypeWIND7	=>	pTypeWIND		,
   sTypeWINDNoTemp	=>	pTypeWIND		,
   sTypeUV1	=>	pTypeUV		,
   sTypeUV2	=>	pTypeUV		,
   sTypeUV3	=>	pTypeUV		,
   sTypeX10	=>	pTypeLighting1		,
   sTypeARC	=>	pTypeLighting1		,
   sTypeAB400D	=>	pTypeLighting1		,
   sTypeWaveman	=>	pTypeLighting1		,
   sTypeEMW200	=>	pTypeLighting1		,
   sTypeIMPULS	=>	pTypeLighting1		,
   sTypeRisingSun	=>	pTypeLighting1		,
   sTypePhilips	=>	pTypeLighting1		,
   sTypeEnergenie	=>	pTypeLighting1		,
   sTypeEnergenie5	=>	pTypeLighting1		,
   sTypeGDR2	=>	pTypeLighting1		,
   sTypeAC	=>	pTypeLighting2		,
   sTypeHEU	=>	pTypeLighting2		,
   sTypeANSLUT	=>	pTypeLighting2		,
   sTypeZWaveSwitch	=>	pTypeLighting2		,
   sTypeKoppla	=>	pTypeLighting3		,
   sTypePT2262	=>	pTypeLighting4		,
   sTypeLightwaveRF	=>	pTypeLighting5		,
   sTypeEMW100	=>	pTypeLighting5		,
   sTypeBBSB	=>	pTypeLighting5		,
   sTypeMDREMOTE	=>	pTypeLighting5		,
   sTypeRSL	=>	pTypeLighting5		,
   sTypeLivolo	=>	pTypeLighting5		,
   sTypeTRC02	=>	pTypeLighting5		,
   sTypeTRC02_2	=>	pTypeLighting5		,
   sTypeAoke	=>	pTypeLighting5		,
   sTypeEurodomest	=>	pTypeLighting5		,
   sTypeLivoloAppliance	=>	pTypeLighting5		,
   sTypeBlyss	=>	pTypeLighting6		,
   sTypeHarrison	=>	pTypeCurtain		,
   sTypeBlindsT0	=>	pTypeBlinds		,
   sTypeBlindsT1	=>	pTypeBlinds		,
   sTypeBlindsT2	=>	pTypeBlinds		,
   sTypeBlindsT3	=>	pTypeBlinds		,
   sTypeBlindsT4	=>	pTypeBlinds		,
   sTypeBlindsT5	=>	pTypeBlinds		,
   sTypeBlindsT6	=>	pTypeBlinds		,
   sTypeBlindsT7	=>	pTypeBlinds		,
   sTypeBlindsT8	=>	pTypeBlinds		,
   sTypeBlindsT9	=>	pTypeBlinds		,
   sTypeBlindsT10	=>	pTypeBlinds		,
   sTypeSecX10	=>	pTypeSecurity1		,
   sTypeSecX10M	=>	pTypeSecurity1		,
   sTypeSecX10R	=>	pTypeSecurity1		,
   sTypeKD101	=>	pTypeSecurity1		,
   sTypePowercodeSensor	=>	pTypeSecurity1		,
   sTypePowercodeMotion	=>	pTypeSecurity1		,
   sTypeCodesecure	=>	pTypeSecurity1		,
   sTypePowercodeAux	=>	pTypeSecurity1		,
   sTypeMeiantech	=>	pTypeSecurity1		,
   sTypeSA30	=>	pTypeSecurity1		,
   sTypeDomoticzSecurity	=>	pTypeSecurity1		,
   sTypeSec2Classic	=>	pTypeSecurity2		,
   sTypeNinja	=>	pTypeCamera		,
   sTypeATI	=>	pTypeRemote		,
   sTypeATIplus	=>	pTypeRemote		,
   sTypeMedion	=>	pTypeRemote		,
   sTypePCremote	=>	pTypeRemote		,
   sTypeATIrw2	=>	pTypeRemote		,
   sTypeDigimax	=>	pTypeThermostat1		,
   sTypeDigimaxShort	=>	pTypeThermostat1		,
   sTypeHE105	=>	pTypeThermostat2		,
   sTypeRTS10	=>	pTypeThermostat2		,
   sTypeMertikG6RH4T1	=>	pTypeThermostat3		,
   sTypeMertikG6RH4TB	=>	pTypeThermostat3		,
   sTypeMertikG6RH4TD	=>	pTypeThermostat3		,
   sTypeMertikG6RH4S	=>	pTypeThermostat3		,
   sTypeSmartwares	=>	pTypeRadiator1		,
   sTypeSmartwaresSwitchRadiator	=>	pTypeRadiator1		,
   sTypeDT1	=>	pTypeDT		,
   sTypeELEC1	=>	pTypeCURRENT		,
   sTypeELEC2	=>	pTypeENERGY		,
   sTypeELEC3	=>	pTypeENERGY		,
   sTypeZWaveUsage	=>	pTypeENERGY		,
   sTypeELEC4	=>	pTypeCURRENTENERGY		,
   sTypeWEIGHT1	=>	pTypeWEIGHT		,
   sTypeWEIGHT2	=>	pTypeWEIGHT		,
   sTypeRFXSensorTemp	=>	pTypeRFXSensor		,
   sTypeRFXSensorAD	=>	pTypeRFXSensor		,
   sTypeRFXSensorVolt	=>	pTypeRFXSensor		,
   sTypeRFXMeterCount	=>	pTypeRFXMeter		,
   sTypeP1Power	=>	pTypeP1Power		,
   sTypeP1Gas	=>	pTypeP1Gas		,
   sTypeYouLess	=>	pTypeYouLess		,
   sTypeRego6XXTemp	=>	pTypeRego6XXTemp		,
   sTypeRego6XXStatus	=>	pTypeRego6XXValue		,
   sTypeRego6XXCounter	=>	pTypeRego6XXValue		,
   sTypeVoltcraft	=>	pTypeAirQuality		,
   sTypeElectric	=>	pTypeUsage		,
   sTypeBMP085	=>	pTypeTEMP_BARO		,
   sTypeLux	=>	pTypeLux		,
   sTypeVisibility	=>	pTypeGeneral		,
   sTypeSolarRadiation	=>	pTypeGeneral		,
   sTypeSoilMoisture	=>	pTypeGeneral		,
   sTypeLeafWetness	=>	pTypeGeneral		,
   sTypeSystemTemp	=>	pTypeGeneral		,
   sTypePercentage	=>	pTypeGeneral		,
   sTypeFan	=>	pTypeGeneral		,
   sTypeVoltage	=>	pTypeGeneral		,
   sTypeCurrent	=>	pTypeGeneral		,
   sTypePressure	=>	pTypeGeneral		,
   sTypeBaro	=>	pTypeGeneral		,
   sTypeSetPoint	=>	pTypeGeneral		,
   sTypeTemperature	=>	pTypeGeneral		,
   sTypeZWaveClock	=>	pTypeGeneral		,
   sTypeTextStatus	=>	pTypeGeneral		,
   sTypeZWaveThermostatMode	=>	pTypeGeneral		,
   sTypeZWaveThermostatFanMode	=>	pTypeGeneral		,
   sTypeAlert	=>	pTypeGeneral		,
   sTypeSoundLevel	=>	pTypeGeneral		,
   sTypeDistance	=>	pTypeGeneral		,
   sTypeThermSetpoint	=>	pTypeThermostat		,
   sTypeThermTemperature	=>	pTypeThermostat		,
   sTypeByronSX	=>	pTypeChime		,
   sTypeByronMP001	=>	pTypeChime		,
   sTypeSelectPlus	=>	pTypeChime		,
   sTypeSelectPlus3	=>	pTypeChime		,
   sTypeEnvivo	=>	pTypeChime		,
   sTypeTR1	=>	pTypeTEMP_RAIN		,
   sTypeBBQ1	=>	pTypeBBQ		,
   sTypeELEC5	=>	pTypePOWER		,
   sTypeLimitlessRGBW	=>	pTypeLimitlessLights		,
   sTypeLimitlessRGB	=>	pTypeLimitlessLights		,
   sTypeLimitlessWhite	=>	pTypeLimitlessLights		,
   sTypeRFY	=>	pTypeRFY		,
   sTypeRFYext	=>	pTypeRFY		,
   sTypeEvohome	=>	pTypeEvohome		,
   sTypeEvohomeZone	=>	pTypeEvohomeZone		,
   sTypeEvohomeWater	=>	pTypeEvohomeWater		,
   sTypeEvohomeRelay	=>	pTypeEvohomeRelay		,
   sSwitchTypeX10	=>	pTypeGeneralSwitch		,
   sSwitchTypeARC	=>	pTypeGeneralSwitch		,
   sSwitchTypeAB400D	=>	pTypeGeneralSwitch		,
   sSwitchTypeWaveman	=>	pTypeGeneralSwitch		,
   sSwitchTypeEMW200	=>	pTypeGeneralSwitch		,
   sSwitchTypeIMPULS	=>	pTypeGeneralSwitch		,
   sSwitchTypeRisingSun	=>	pTypeGeneralSwitch		,
   sSwitchTypePhilips	=>	pTypeGeneralSwitch		,
   sSwitchTypeEnergenie	=>	pTypeGeneralSwitch		,
   sSwitchTypeEnergenie5	=>	pTypeGeneralSwitch		,
   sSwitchTypeGDR2	=>	pTypeGeneralSwitch		,
   sSwitchTypeAC	=>	pTypeGeneralSwitch		,
   sSwitchTypeHEU	=>	pTypeGeneralSwitch		,
   sSwitchTypeANSLUT	=>	pTypeGeneralSwitch		,
   sSwitchTypeKoppla	=>	pTypeGeneralSwitch		,
   sSwitchTypePT2262	=>	pTypeGeneralSwitch		,
   sSwitchTypeLightwaveRF	=>	pTypeGeneralSwitch		,
   sSwitchTypeEMW100	=>	pTypeGeneralSwitch		,
   sSwitchTypeBBSB	=>	pTypeGeneralSwitch		,
   sSwitchTypeMDREMOTE	=>	pTypeGeneralSwitch		,
   sSwitchTypeRSL	=>	pTypeGeneralSwitch		,
   sSwitchTypeLivolo	=>	pTypeGeneralSwitch		,
   sSwitchTypeTRC02	=>	pTypeGeneralSwitch		,
   sSwitchTypeTRC02_2	=>	pTypeGeneralSwitch		,
   sSwitchTypeAoke	=>	pTypeGeneralSwitch		,
   sSwitchTypeEurodomest	=>	pTypeGeneralSwitch		,
   sSwitchTypeLivoloAppliance	=>	pTypeGeneralSwitch		,
   sSwitchTypeBlyss	=>	pTypeGeneralSwitch		,
   sSwitchTypeByronSX	=>	pTypeGeneralSwitch		,
   sSwitchTypeByronMP001	=>	pTypeGeneralSwitch		,
   sSwitchTypeSelectPlus	=>	pTypeGeneralSwitch		,
   sSwitchTypeSelectPlus3	=>	pTypeGeneralSwitch		
  }
  
  true;
RFXNAMES

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;
  BEGIN {
    $Try::Tiny::AUTHORITY = 'cpan:NUFFIN';
  }
  $Try::Tiny::VERSION = '0.22';
  use 5.006;
  # ABSTRACT: minimal try/catch with proper preservation of $@
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN { eval "use Sub::Name; 1" or *{subname} = sub {1} }
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    subname("${caller}::try {...} " => $try);
    subname("${caller}::catch {...} " => $catch) if $catch;
    subname("${caller}::finally {...} " => $_) foreach @finally;
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $fail to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # set up a scope guard to invoke the finally block at the end
    my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ($] < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.22
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || { "bar" };
    my $x = (try { die "foo" }) // { "bar" };
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considired experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/doy/try-tiny/>
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Yuval Kogman <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Yuval Kogman.
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  our ($ABS_REMOTE_LEADING_DOTS, $ABS_ALLOW_RELATIVE_SCHEME, $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  our $reserved   = q(;/?:@&=+$,[]);
  our $mark       = q(-_.!~*'());                                    #'; emacs
  our $unreserved = "A-Za-z0-9\Q$mark\E";
  our $uric       = quotemeta($reserved) . $unreserved . "%";
  
  our $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      utf8::downgrade($str);
      return $str;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          # Try to load it
          eval "require $ic";
          die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
          return undef unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  sub TO_JSON { ${$_[0]} }
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return undef unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself; 
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return undef unless defined $scheme;
      lc($scheme);
  }
  
  sub has_recognized_scheme {
      my $self = shift;
      return ref($self) !~ /^URI::_(?:foreign|generic)\z/;
  }
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
      utf8::downgrade($new_opaque);
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  sub path { goto &opaque }  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return undef unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	utf8::downgrade($new_frag);
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   $u1 = URI->new("http://www.perl.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.perl.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.perl.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  If the scheme isn't one of those that URI recognizes, you still get
  an URI object back that you can access the generic methods on.  The
  C<< $uri->has_recognized_scheme >> method can be used to test for
  this.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped (percent-encoded) or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->has_recognized_scheme
  
  Returns TRUE if the URI scheme is one that URI recognizes.
  
  It will also be TRUE for relative URLs where a recognized
  scheme was provided to the constructor, even if C<< $uri->scheme >>
  returns C<undef> for these.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unrecognized schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  The C<URI::QueryParam> module can be loaded to add further methods to
  manipulate the form of a URI.  See L<URI::QueryParam> for details.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the $new_host string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
  =item $uri->ihost
  
  Returns the host in Unicode form.  Any IDNA A-labels are turned into U-labels.
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sftp>:
  
  C<URI> objects belonging to the sftp scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 BUGS
  
  There are some things that are not quite right:
  
  =over
  
  =item *
  
  Using regexp variables like $1 directly as arguments to the URI accessor methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  
  =item *
  
  The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
  URI constructor or when setting URI parts using the accessor methods depend on
  the state of the internal UTF8 flag (see utf8::is_utf8) of the string passed.
  If the UTF8 flag is set the UTF-8 encoded version of the character is percent
  encoded.  If the UTF8 flag isn't set the Latin-1 version (byte) of the
  character is percent encoded.  This basically exposes the internal encoding of
  Perl strings.
  
  =back
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::QueryParam>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  URI::Escape - Percent-encode and percent-decode unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to percent-encode and percent-decode URI strings as
  defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
  This is the terminology used by this module, which predates the formalization of the
  terms by the RFC by several years.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able to deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  Equivalent to:
  
      utf8::encode($string);
      my $uri = uri_escape($string);
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  use Exporter 5.57 'import';
  our %escapes;
  our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  our @EXPORT_OK = qw(%escapes);
  our $VERSION = "3.31";
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
  );
  
  sub uri_escape {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
          unless (exists  $subst{$patn}) {
              # Because we can't compile the regex we fake it with a cached sub
              (my $tmp = $patn) =~ s,/,\\/,g;
              eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
              Carp::croak("uri_escape: $@") if $@;
          }
          &{$subst{$patn}}($text);
      } else {
          $text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8 {
      my $text = shift;
      utf8::encode($text);
      return uri_escape($text, @_);
  }
  
  sub uri_unescape {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
          # not executed for the common case of a single argument
          my @str = ($str, @_);  # need to copy
          for (@str) {
              s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
          }
          return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  # XXX FIXME escape_char is buggy as it assigns meaning to the string's storage format.
  sub escape_char {
      # Old versions of utf8::is_utf8() didn't properly handle magical vars (e.g. $1).
      # The following forces a fetch to occur beforehand.
      my $dummy = substr($_[0], 0, 0);
  
      if (utf8::is_utf8($_[0])) {
          my $s = shift;
          utf8::encode($s);
          unshift(@_, $s);
      }
  
      return join '', @URI::Escape::escapes{split //, $_[0]};
  }
  
  1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item HTTP_ACCEPT_LANGUAGE, LC_ALL, LANG
  
  If COUNTRY is not set, these standard environment variables are
  examined and country (not language) information possibly found in them
  is used as the default country.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  our $VERSION = "4.20";
  
  our ($MY_COUNTRY, $DEBUG);
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Try the country part of LC_ALL and LANG from environment
  	my @srcs = ($ENV{LC_ALL}, $ENV{LANG});
  	# ...and HTTP_ACCEPT_LANGUAGE before those if present
  	if (my $httplang = $ENV{HTTP_ACCEPT_LANGUAGE}) {
  	    # TODO: q-value processing/ordering
  	    for $httplang (split(/\s*,\s*/, $httplang)) {
  		if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/) {
  		    unshift(@srcs, "${1}_${2}");
  		    last;
  		}
  	    }
  	}
  	for (@srcs) {
  	    next unless defined;
  	    return lc($1) if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/;
  	}
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  our %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'gb' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  # Backwards compatibility; uk != United Kingdom in ISO 3166
  $LOCAL_GUESSING{uk} = $LOCAL_GUESSING{gb};
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = lc($1) . "://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    my $scheme = "http";
  	    if (/^:(\d+)\b/) {
  		# Some more or less well known ports
  		if ($1 =~ /^[56789]?443$/) {
  		    $scheme = "https";
  		} elsif ($1 eq "21") {
  		    $scheme = "ftp";
  		}
  	    }
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, "www.$host." . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "$scheme://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;
  
  # Experimental
  
  use strict;
  use warnings;
  use URI ();
  
  use overload '""' => sub { shift->as_string };
  
  our $VERSION = "1.69";
  
  sub new {
      my($class, $uri, $scheme) = @_;
      utf8::upgrade($uri);
      return bless {
  	uri => URI->new($uri, $scheme),
      }, $class;
  }
  
  sub clone {
      my $self = shift;
      return bless {
  	uri => $self->{uri}->clone,
      }, ref($self);
  }
  
  sub as_string {
      my $self = shift;
      return $self->{uri}->as_iri;
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->{uri}->$method(@_) };
      goto &$method;
  }
  
  sub DESTROY {}   # avoid AUTOLOADing it
  
  1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my (%seen, $i);
  	return grep !($i++ % 2 || $seen{$_}++), @old;
      }
  
      my $key = shift;
      my @i = grep $_ % 2 == 0 && $old[$_] eq $key, 0 .. $#old;
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  
  	while (@new_i > @vals) {
  	    splice @new, pop @new_i, 2;
  	}
  	if (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    my @splice = splice @vals, @new_i, @vals - @new_i;
  
  	    splice @new, $i, 0, map { $key => $_ } @splice;
  	}
  	if (@vals) {
  	    #print "SET $new_i[0]\n";
  	    @new[ map $_ + 1, @new_i ] = @vals;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      my @vals = map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_;
      $self->query_form($self->query_form, $key => \@vals);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  Please note that you can supply multiple values to this method, but you cannot
  supply multiple keys.
  
  Do this:
  
      $uri->query_param( widget_id => 1, 5, 9 );
  
  Do NOT do this:
  
      $uri->query_param( widget_id => 1, frobnicator_id => 99 );
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:), URI::Escape::escape_char($1),e while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]), URI::Escape::escape_char($1),eg;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#), URI::Escape::escape_char($1),eg;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;
  
  use strict;
  use warnings;
  
  use parent 'URI::WithBase';
  
  our $VERSION = "5.04";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  use Exporter 5.57 'import';
  our @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return undef unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without losing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use warnings;
  
  use URI;
  use Scalar::Util 'blessed';
  
  our $VERSION = "2.20";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && blessed($base) && $base->isa(__PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if blessed($other) and $other->isa(__PACKAGE__);
      $self->[0]->eq($other);
  }
  
  our $AUTOLOAD;
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  our $VERSION = "1.69";
  
  1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;
  
  use strict;
  use warnings;
  
  use parent qw(URI URI::_query);
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  our $VERSION = "1.69";
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($auth);
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	my $fragment = $self->fragment;
  	$abs->fragment($fragment) if defined $fragment;
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The opposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;
  
  # This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)
  # based on Python-2.6.4/Lib/encodings/idna.py
  
  use strict;
  use warnings;
  
  use URI::_punycode qw(encode_punycode decode_punycode);
  use Carp qw(croak);
  
  our $VERSION = "1.69";
  
  BEGIN {
    *URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS = $] < 5.008_003
      ? sub () { 1 }
      : sub () { 0 }
    ;
  }
  
  my $ASCII = qr/^[\x00-\x7F]*\z/;
  
  sub encode {
      my $idomain = shift;
      my @labels = split(/\./, $idomain, -1);
      my @last_empty;
      push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq "";
      for (@labels) {
  	$_ = ToASCII($_);
      }
  
      return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;
      return join(".", @labels, @last_empty);
  }
  
  sub decode {
      my $domain = shift;
      return join(".", map ToUnicode($_), split(/\./, $domain, -1))
  }
  
  sub nameprep { # XXX real implementation missing
      my $label = shift;
      $label = lc($label);
      return $label;
  }
  
  sub check_size {
      my $label = shift;
      croak "Label empty" if $label eq "";
      croak "Label too long" if length($label) > 63;
      return $label;
  }
  
  sub ToASCII {
      my $label = shift;
      return check_size($label) if $label =~ $ASCII;
  
      # Step 2: nameprep
      $label = nameprep($label);
      # Step 3: UseSTD3ASCIIRules is false
      # Step 4: try ASCII again
      return check_size($label) if $label =~ $ASCII;
  
      # Step 5: Check ACE prefix
      if ($label =~ /^xn--/) {
          croak "Label starts with ACE prefix";
      }
  
      # Step 6: Encode with PUNYCODE
      $label = encode_punycode($label);
  
      # Step 7: Prepend ACE prefix
      $label = "xn--$label";
  
      # Step 8: Check size
      return check_size($label);
  }
  
  sub ToUnicode {
      my $label = shift;
      $label = nameprep($label) unless $label =~ $ASCII;
      return $label unless $label =~ /^xn--/;
      my $result = decode_punycode(substr($label, 4));
      my $label2 = ToASCII($result);
      if (lc($label) ne $label2) {
  	croak "IDNA does not round-trip: '\L$label\E' vs '$label2'";
      }
      return $result;
  }
  
  1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return undef unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowercase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  our $VERSION = "1.69";
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use Exporter 'import';
  our @EXPORT = qw(encode_punycode decode_punycode);
  
  use integer;
  
  our $DEBUG = 0;
  
  use constant BASE => 36;
  use constant TMIN => 1;
  use constant TMAX => 26;
  use constant SKEW => 38;
  use constant DAMP => 700;
  use constant INITIAL_BIAS => 72;
  use constant INITIAL_N => 128;
  
  my $Delimiter = chr 0x2D;
  my $BasicRE   = qr/[\x00-\x7f]/;
  
  sub _croak { require Carp; Carp::croak(@_); }
  
  sub digit_value {
      my $code = shift;
      return ord($code) - ord("A") if $code =~ /[A-Z]/;
      return ord($code) - ord("a") if $code =~ /[a-z]/;
      return ord($code) - ord("0") + 26 if $code =~ /[0-9]/;
      return;
  }
  
  sub code_point {
      my $digit = shift;
      return $digit + ord('a') if 0 <= $digit && $digit <= 25;
      return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;
      die 'NOT COME HERE';
  }
  
  sub adapt {
      my($delta, $numpoints, $firsttime) = @_;
      $delta = $firsttime ? $delta / DAMP : $delta / 2;
      $delta += $delta / $numpoints;
      my $k = 0;
      while ($delta > ((BASE - TMIN) * TMAX) / 2) {
  	$delta /= BASE - TMIN;
  	$k += BASE;
      }
      return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));
  }
  
  sub decode_punycode {
      my $code = shift;
  
      my $n      = INITIAL_N;
      my $i      = 0;
      my $bias   = INITIAL_BIAS;
      my @output;
  
      if ($code =~ s/(.*)$Delimiter//o) {
  	push @output, map ord, split //, $1;
  	return _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;
      }
  
      while ($code) {
  	my $oldi = $i;
  	my $w    = 1;
      LOOP:
  	for (my $k = BASE; 1; $k += BASE) {
  	    my $cp = substr($code, 0, 1, '');
  	    my $digit = digit_value($cp);
  	    defined $digit or return _croak("invalid punycode input");
  	    $i += $digit * $w;
  	    my $t = ($k <= $bias) ? TMIN
  		: ($k >= $bias + TMAX) ? TMAX : $k - $bias;
  	    last LOOP if $digit < $t;
  	    $w *= (BASE - $t);
  	}
  	$bias = adapt($i - $oldi, @output + 1, $oldi == 0);
  	warn "bias becomes $bias" if $DEBUG;
  	$n += $i / (@output + 1);
  	$i = $i % (@output + 1);
  	splice(@output, $i, 0, $n);
  	warn join " ", map sprintf('%04x', $_), @output if $DEBUG;
  	$i++;
      }
      return join '', map chr, @output;
  }
  
  sub encode_punycode {
      my $input = shift;
      my @input = split //, $input;
  
      my $n     = INITIAL_N;
      my $delta = 0;
      my $bias  = INITIAL_BIAS;
  
      my @output;
      my @basic = grep /$BasicRE/, @input;
      my $h = my $b = @basic;
      push @output, @basic;
      push @output, $Delimiter if $b && $h < @input;
      warn "basic codepoints: (@output)" if $DEBUG;
  
      while ($h < @input) {
  	my $m = min(grep { $_ >= $n } map ord, @input);
  	warn sprintf "next code point to insert is %04x", $m if $DEBUG;
  	$delta += ($m - $n) * ($h + 1);
  	$n = $m;
  	for my $i (@input) {
  	    my $c = ord($i);
  	    $delta++ if $c < $n;
  	    if ($c == $n) {
  		my $q = $delta;
  	    LOOP:
  		for (my $k = BASE; 1; $k += BASE) {
  		    my $t = ($k <= $bias) ? TMIN :
  			($k >= $bias + TMAX) ? TMAX : $k - $bias;
  		    last LOOP if $q < $t;
  		    my $cp = code_point($t + (($q - $t) % (BASE - $t)));
  		    push @output, chr($cp);
  		    $q = ($q - $t) / (BASE - $t);
  		}
  		push @output, chr(code_point($q));
  		$bias = adapt($delta, $h + 1, $h == $b);
  		warn "bias becomes $bias" if $DEBUG;
  		$delta = 0;
  		$h++;
  	    }
  	}
  	$delta++;
  	$n++;
      }
      return join '', @output;
  }
  
  sub min {
      my $min = shift;
      for (@_) { $min = $_ if $_ <= $min }
      return $min;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  URI::_punycode - encodes Unicode string in Punycode
  
  =head1 SYNOPSIS
  
    use URI::_punycode;
    $punycode = encode_punycode($unicode);
    $unicode  = decode_punycode($punycode);
  
  =head1 DESCRIPTION
  
  URI::_punycode is a module to encode / decode Unicode strings into
  Punycode, an efficient encoding of Unicode for use with IDNA.
  
  This module requires Perl 5.6.0 or over to handle UTF8 flagged Unicode
  strings.
  
  =head1 FUNCTIONS
  
  This module exports following functions by default.
  
  =over 4
  
  =item encode_punycode
  
    $punycode = encode_punycode($unicode);
  
  takes Unicode string (UTF8-flagged variable) and returns Punycode
  encoding for it.
  
  =item decode_punycode
  
    $unicode = decode_punycode($punycode)
  
  takes Punycode encoding and returns original Unicode string.
  
  =back
  
  These functions throw exceptions on failure. You can catch 'em via
  C<eval>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt> is the author of
  IDNA::Punycode v0.02 which was the basis for this module.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<IDNA::Punycode>, RFC 3492
  
  =cut
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;
  
  use strict;
  use warnings;
  
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($q);
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
          my $delim;
          my $r = $_[0];
          if (ref($r) eq "ARRAY") {
              $delim = $_[1];
              @_ = @$r;
          }
          elsif (ref($r) eq "HASH") {
              $delim = $_[1];
              @_ = map { $_ => $r->{$_} } sort keys %$r;
          }
          $delim = pop if @_ % 2;
  
          my @query;
          while (my($key,$vals) = splice(@_, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          if (@query) {
              unless ($delim) {
                  $delim = $1 if $old && $old =~ /([&;])/;
                  $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&";
              }
              $self->query(join($delim, @query));
          }
          else {
              $self->query(undef);
          }
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  sub equery { goto &query }
  
  1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  our $VERSION = "1.69";
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub _uric_escape {
      my($class, $str) = @_;
      if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	my($scheme, $host, $rest) = ($1, $2, $3);
  	my $ui = $host =~ s/(.*@)// ? $1 : "";
  	my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	if (_host_escape($host)) {
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $class->SUPER::_uric_escape($str);
  }
  
  sub _host_escape {
      return unless $_[0] =~ /[^$URI::uric]/;
      eval {
  	require URI::_idna;
  	$_[0] = URI::_idna::encode($_[0]);
      };
      return 0 if $@;
      return 1;
  }
  
  sub as_iri {
      my $self = shift;
      my $str = $self->SUPER::as_iri;
      if ($str =~ /\bxn--/) {
  	if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	    my($scheme, $host, $rest) = ($1, $2, $3);
  	    my $ui = $host =~ s/(.*@)// ? $1 : "";
  	    my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	    require URI::_idna;
  	    $host = URI::_idna::decode($host);
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $str;
  }
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/) {
  		$new =~ s/(:\d*)\z// || die "Assert";
  		$port = $1;
  	    }
  	    $new = "[$new]" if $new =~ /:/ && $new !~ /^\[/; # IPv6 address
  	    _host_escape($new);
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;          # remove the port
      $old =~ s{^\[(.*)\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)
      return uri_unescape($old);
  }
  
  sub ihost
  {
      my $self = shift;
      my $old = $self->host(@_);
      if ($old =~ /(^|\.)xn--/) {
  	require URI::_idna;
  	$old = URI::_idna::decode($old);
      }
      return $old;
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port should be treated the same a no port
      $old .= ":" . $self->port unless $old =~ /:\d+$/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use warnings;
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return undef unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return undef unless defined $info;
      return undef unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;  # RFC 2397
  
  use strict;
  use warnings;
  
  use parent 'URI';
  
  our $VERSION = '1.69';
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      $data = uri_unescape($data);
      return $base64 ? decode_base64($data) : $data;
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;
  
  use strict;
  use warnings;
  
  use parent 'URI::_generic';
  our $VERSION = "4.21";
  
  use URI::Escape qw(uri_unescape);
  
  our $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  our %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac classic (Mac OS 9 and earlier) used ":" as path separator,
  but not in the same way as a generic URI. ":foo" was a relative name.  "foo:bar"
  was an absolute name.  Also, path segments could contain the "/" character as well
  as the literal "." or "..".  So the mapping looks like this:
  
    Mac classic           URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distributed on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use warnings;
  
  use URI::Escape qw();
  
  our $VERSION = "1.69";
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn()) eq $host ||
  	lc(Net::Domain::hostname()) eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = "1.69";
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]), URI::Escape::escape_char($1),eg;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Win32';
  
  our $VERSION = "1.69";
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Unix';
  
  our $VERSION = "1.69";
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;
  
  use strict;
  use warnings;
  
  use parent 'URI::file::Base';
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  sub gtype { goto &gopher_type }  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_server';
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::http';
  
  sub default_port { 443 }
  
  sub secure { 1 }
  
  1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://tools.ietf.org/html/rfc2255>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::ldap';
  
  sub default_port { 636 }
  
  sub secure { 1 }
  
  1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent qw(URI URI::_query);
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::http';
  
  sub default_port { 1755 }
  
  1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return undef unless $old =~ /\@/;
      return $old;
  }
  
  1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::news';
  
  1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;   # RFC 2384
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_server';
  
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return undef unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return undef unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_login';
  
  sub default_port { 513 }
  
  1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::http';
  
  sub default_port { 554 }
  
  1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::rtsp';
  
  sub default_port { 554 }
  
  1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;
  
  use strict;
  use warnings;
  
  use parent 'URI::ssh';
  
  our $VERSION = "1.69";
  
  1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  use strict;
  use warnings;
  
  use parent qw(URI::_server URI::_userpass);
  
  use URI::Escape qw(uri_unescape);
  
  our $VERSION = "1.69";
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::sip';
  
  sub default_port { 5061 }
  
  sub secure { 1 }
  
  1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::news';
  
  sub default_port { 563 }
  
  sub secure { 1 }
  
  1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_login';
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  sub secure { 1 }
  
  1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::_login';
  
  sub default_port { 23 }
  
  1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;  # RFC 2141
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI';
  
  use Carp qw(carp);
  
  my %implementor;
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
  	    # Try to load it
  	    eval "require $impclass";
  	    die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  use strict;
  use warnings;
  
  use parent 'URI::urn';
  
  use Carp qw(carp);
  
  BEGIN {
      require Business::ISBN;
      
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      warn "Using Business::ISBN version " . Business::ISBN->VERSION . 
          " which is deprecated.\nUpgrade to Business::ISBN version 2\n"
          if Business::ISBN->VERSION < 2;
      }
      
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  BEGIN {
  my $group_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code';
      };
  
  sub isbn_group_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->$group_method;
  }
  }
  
  sub isbn_country_code {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn_group_code instead";
      
      no strict 'refs';
      &isbn_group_code;
  }
  
  BEGIN {
  my $isbn13_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean';
      };
  
  sub isbn13 {
      my $isbn = shift->_isbn || return undef;
      
      # Business::ISBN 1.x didn't put hyphens in the EAN, and it was just a string
      # Business::ISBN 2.0 doesn't do EAN, but it does ISBN-13 objects
      #   and it uses the hyphens, so call as_string with an empty anon array
      # or, adjust the test and features to say that it comes out with hyphens.
      my $thingy = $isbn->$isbn13_method;
      return eval { $thingy->can( 'as_string' ) } ? $thingy->as_string([]) : $thingy;
  }
  }
  
  sub isbn_as_ean {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn13 instead";
  
      no strict 'refs';
      &isbn13;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  use strict;
  use warnings;
  
  our $VERSION = "1.69";
  
  use parent 'URI::urn';
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
URI_URN_OID

$fatpacked{"auto/share/dist/Dancer2/skel/lib/AppFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTO_SHARE_DIST_DANCER2_SKEL_LIB_APPFILE';
  package [% appname %];
  use Dancer2;
  
  our $VERSION = '0.1';
  
  get '/' => sub {
      template 'index';
  };
  
  true;
AUTO_SHARE_DIST_DANCER2_SKEL_LIB_APPFILE

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP';
  package Class::MOP;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use 5.008003;
  
  use MRO::Compat;
  use Class::Load 0.07 ();
  use Scalar::Util  'weaken', 'isweak', 'blessed';
  use Data::OptList;
  
  use Class::MOP::Mixin::AttributeCore;
  use Class::MOP::Mixin::HasAttributes;
  use Class::MOP::Mixin::HasMethods;
  use Class::MOP::Mixin::HasOverloads;
  use Class::MOP::Class;
  use Class::MOP::Attribute;
  use Class::MOP::Method;
  
  BEGIN {
      *IS_RUNNING_ON_5_10 = ($] < 5.009_005)
          ? sub () { 0 }
          : sub () { 1 };
  
      # this is either part of core or set up appropriately by MRO::Compat
      *check_package_cache_flag = \&mro::get_pkg_gen;
  }
  
  XSLoader::load(
      'Moose',
      $VERSION,
  );
  
  {
      # Metaclasses are singletons, so we cache them here.
      # there is no need to worry about destruction though
      # because they should die only when the program dies.
      # After all, do package definitions even get reaped?
      # Anonymous classes manage their own destruction.
      my %METAS;
  
      sub get_all_metaclasses         {        %METAS         }
      sub get_all_metaclass_instances { values %METAS         }
      sub get_all_metaclass_names     { keys   %METAS         }
      sub get_metaclass_by_name       { $METAS{$_[0]}         }
      sub store_metaclass_by_name     { $METAS{$_[0]} = $_[1] }
      sub weaken_metaclass            { weaken($METAS{$_[0]}) }
      sub metaclass_is_weak           { isweak($METAS{$_[0]}) }
      sub does_metaclass_exist        { exists $METAS{$_[0]} && defined $METAS{$_[0]} }
      sub remove_metaclass_by_name    { delete $METAS{$_[0]}; return }
  
      # This handles instances as well as class names
      sub class_of {
          return unless defined $_[0];
          my $class = blessed($_[0]) || $_[0];
          return $METAS{$class};
      }
  
      # NOTE:
      # We only cache metaclasses, meaning instances of
      # Class::MOP::Class. We do not cache instance of
      # Class::MOP::Package or Class::MOP::Module. Mostly
      # because I don't yet see a good reason to do so.
  }
  
  sub load_class {
      Class::MOP::Deprecated::deprecated(
          message => 'Class::MOP::load_class is deprecated',
          feature => 'Class::Load wrapper functions',
      );
      require Class::Load;
      goto &Class::Load::load_class;
  }
  
  sub load_first_existing_class {
      Class::MOP::Deprecated::deprecated(
          message => 'Class::MOP::load_first_existing_class is deprecated',
          feature => 'Class::Load wrapper functions',
      );
      require Class::Load;
      goto &Class::Load::load_first_existing_class;
  }
  
  sub is_class_loaded {
      Class::MOP::Deprecated::deprecated(
          message => 'Class::MOP::is_class_loaded is deprecated',
          feature => 'Class::Load wrapper functions',
      );
      require Class::Load;
      goto &Class::Load::is_class_loaded;
  }
  
  sub _definition_context {
      my %context;
      @context{qw(package file line)} = caller(1);
  
      return (
          definition_context => \%context,
      );
  }
  
  ## ----------------------------------------------------------------------------
  ## Setting up our environment ...
  ## ----------------------------------------------------------------------------
  ## Class::MOP needs to have a few things in the global perl environment so
  ## that it can operate effectively. Those things are done here.
  ## ----------------------------------------------------------------------------
  
  # ... nothing yet actually ;)
  
  ## ----------------------------------------------------------------------------
  ## Bootstrapping
  ## ----------------------------------------------------------------------------
  ## The code below here is to bootstrap our MOP with itself. This is also
  ## sometimes called "tying the knot". By doing this, we make it much easier
  ## to extend the MOP through subclassing and such since now you can use the
  ## MOP itself to extend itself.
  ##
  ## Yes, I know, that's weird and insane, but it's a good thing, trust me :)
  ## ----------------------------------------------------------------------------
  
  # We need to add in the meta-attributes here so that
  # any subclass of Class::MOP::* will be able to
  # inherit them using _construct_instance
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::HasMethods
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('_methods' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              '_method_map' => \&Class::MOP::Mixin::HasMethods::_method_map
          },
          default => sub { {} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('method_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'method_metaclass' => \&Class::MOP::Mixin::HasMethods::method_metaclass
          },
          default  => 'Class::MOP::Method',
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('wrapped_method_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'wrapped_method_metaclass' => \&Class::MOP::Mixin::HasMethods::wrapped_method_metaclass
          },
          default  => 'Class::MOP::Method::Wrapped',
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::HasAttributes
  
  Class::MOP::Mixin::HasAttributes->meta->add_attribute(
      Class::MOP::Attribute->new('attributes' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              '_attribute_map' => \&Class::MOP::Mixin::HasAttributes::_attribute_map
          },
          default  => sub { {} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasAttributes->meta->add_attribute(
      Class::MOP::Attribute->new('attribute_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'attribute_metaclass' => \&Class::MOP::Mixin::HasAttributes::attribute_metaclass
          },
          default  => 'Class::MOP::Attribute',
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::HasOverloads
  
  Class::MOP::Mixin::HasOverloads->meta->add_attribute(
      Class::MOP::Attribute->new('_overload_map' => (
          reader   => {
              '_overload_map' => \&Class::MOP::Mixin::HasOverloads::_overload_map
          },
          clearer => '_clear_overload_map',
          default => sub { {} },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Package
  
  Class::MOP::Package->meta->add_attribute(
      Class::MOP::Attribute->new('package' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'name' => \&Class::MOP::Package::name
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Package->meta->add_attribute(
      Class::MOP::Attribute->new('namespace' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'namespace' => \&Class::MOP::Package::namespace
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Module
  
  # NOTE:
  # yeah this is kind of stretching things a bit,
  # but truthfully the version should be an attribute
  # of the Module, the weirdness comes from having to
  # stick to Perl 5 convention and store it in the
  # $VERSION package variable. Basically if you just
  # squint at it, it will look how you want it to look.
  # Either as a package variable, or as a attribute of
  # the metaclass, isn't abstraction great :)
  
  Class::MOP::Module->meta->add_attribute(
      Class::MOP::Attribute->new('version' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'version' => \&Class::MOP::Module::version
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  # NOTE:
  # By following the same conventions as version here,
  # we are opening up the possibility that people can
  # use the $AUTHORITY in non-Class::MOP modules as
  # well.
  
  Class::MOP::Module->meta->add_attribute(
      Class::MOP::Attribute->new('authority' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'authority' => \&Class::MOP::Module::authority
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Class
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('superclasses' => (
          accessor => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'superclasses' => \&Class::MOP::Class::superclasses
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('instance_metaclass' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'instance_metaclass' => \&Class::MOP::Class::instance_metaclass
          },
          default  => 'Class::MOP::Instance',
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('immutable_trait' => (
          reader   => {
              'immutable_trait' => \&Class::MOP::Class::immutable_trait
          },
          default => "Class::MOP::Class::Immutable::Trait",
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('constructor_name' => (
          reader   => {
              'constructor_name' => \&Class::MOP::Class::constructor_name,
          },
          default => "new",
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('constructor_class' => (
          reader   => {
              'constructor_class' => \&Class::MOP::Class::constructor_class,
          },
          default => "Class::MOP::Method::Constructor",
          _definition_context(),
      ))
  );
  
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('destructor_class' => (
          reader   => {
              'destructor_class' => \&Class::MOP::Class::destructor_class,
          },
          _definition_context(),
      ))
  );
  
  # NOTE:
  # we don't actually need to tie the knot with
  # Class::MOP::Class here, it is actually handled
  # within Class::MOP::Class itself in the
  # _construct_class_instance method.
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::AttributeCore
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('name' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'name' => \&Class::MOP::Mixin::AttributeCore::name
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('accessor' => (
          reader    => { 'accessor'     => \&Class::MOP::Mixin::AttributeCore::accessor     },
          predicate => { 'has_accessor' => \&Class::MOP::Mixin::AttributeCore::has_accessor },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('reader' => (
          reader    => { 'reader'     => \&Class::MOP::Mixin::AttributeCore::reader     },
          predicate => { 'has_reader' => \&Class::MOP::Mixin::AttributeCore::has_reader },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('initializer' => (
          reader    => { 'initializer'     => \&Class::MOP::Mixin::AttributeCore::initializer     },
          predicate => { 'has_initializer' => \&Class::MOP::Mixin::AttributeCore::has_initializer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('definition_context' => (
          reader    => { 'definition_context'     => \&Class::MOP::Mixin::AttributeCore::definition_context     },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('writer' => (
          reader    => { 'writer'     => \&Class::MOP::Mixin::AttributeCore::writer     },
          predicate => { 'has_writer' => \&Class::MOP::Mixin::AttributeCore::has_writer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('predicate' => (
          reader    => { 'predicate'     => \&Class::MOP::Mixin::AttributeCore::predicate     },
          predicate => { 'has_predicate' => \&Class::MOP::Mixin::AttributeCore::has_predicate },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('clearer' => (
          reader    => { 'clearer'     => \&Class::MOP::Mixin::AttributeCore::clearer     },
          predicate => { 'has_clearer' => \&Class::MOP::Mixin::AttributeCore::has_clearer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('builder' => (
          reader    => { 'builder'     => \&Class::MOP::Mixin::AttributeCore::builder     },
          predicate => { 'has_builder' => \&Class::MOP::Mixin::AttributeCore::has_builder },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('init_arg' => (
          reader    => { 'init_arg'     => \&Class::MOP::Mixin::AttributeCore::init_arg     },
          predicate => { 'has_init_arg' => \&Class::MOP::Mixin::AttributeCore::has_init_arg },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('default' => (
          # default has a custom 'reader' method ...
          predicate => { 'has_default' => \&Class::MOP::Mixin::AttributeCore::has_default },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('insertion_order' => (
          reader      => { 'insertion_order' => \&Class::MOP::Mixin::AttributeCore::insertion_order },
          writer      => { '_set_insertion_order' => \&Class::MOP::Mixin::AttributeCore::_set_insertion_order },
          predicate   => { 'has_insertion_order' => \&Class::MOP::Mixin::AttributeCore::has_insertion_order },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Attribute
  Class::MOP::Attribute->meta->add_attribute(
      Class::MOP::Attribute->new('associated_class' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'associated_class' => \&Class::MOP::Attribute::associated_class
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Attribute->meta->add_attribute(
      Class::MOP::Attribute->new('associated_methods' => (
          reader   => { 'associated_methods' => \&Class::MOP::Attribute::associated_methods },
          default  => sub { [] },
          _definition_context(),
      ))
  );
  
  Class::MOP::Attribute->meta->add_method('clone' => sub {
      my $self  = shift;
      $self->meta->clone_object($self, @_);
  });
  
  ## --------------------------------------------------------
  ## Class::MOP::Method
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('body' => (
          reader   => { 'body' => \&Class::MOP::Method::body },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass' => (
          reader   => { 'associated_metaclass' => \&Class::MOP::Method::associated_metaclass },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('package_name' => (
          reader   => { 'package_name' => \&Class::MOP::Method::package_name },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('name' => (
          reader   => { 'name' => \&Class::MOP::Method::name },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('original_method' => (
          reader   => { 'original_method'      => \&Class::MOP::Method::original_method },
          writer   => { '_set_original_method' => \&Class::MOP::Method::_set_original_method },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Wrapped
  
  # NOTE:
  # the way this item is initialized, this
  # really does not follow the standard
  # practices of attributes, but we put
  # it here for completeness
  Class::MOP::Method::Wrapped->meta->add_attribute(
      Class::MOP::Attribute->new('modifier_table' => (
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Generated
  
  Class::MOP::Method::Generated->meta->add_attribute(
      Class::MOP::Attribute->new('is_inline' => (
          reader   => { 'is_inline' => \&Class::MOP::Method::Generated::is_inline },
          default  => 0,
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Generated->meta->add_attribute(
      Class::MOP::Attribute->new('definition_context' => (
          reader   => { 'definition_context' => \&Class::MOP::Method::Generated::definition_context },
          _definition_context(),
      ))
  );
  
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Inlined
  
  Class::MOP::Method::Inlined->meta->add_attribute(
      Class::MOP::Attribute->new('_expected_method_class' => (
          reader   => { '_expected_method_class' => \&Class::MOP::Method::Inlined::_expected_method_class },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Accessor
  
  Class::MOP::Method::Accessor->meta->add_attribute(
      Class::MOP::Attribute->new('attribute' => (
          reader   => {
              'associated_attribute' => \&Class::MOP::Method::Accessor::associated_attribute
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Accessor->meta->add_attribute(
      Class::MOP::Attribute->new('accessor_type' => (
          reader   => { 'accessor_type' => \&Class::MOP::Method::Accessor::accessor_type },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Constructor
  
  Class::MOP::Method::Constructor->meta->add_attribute(
      Class::MOP::Attribute->new('options' => (
          reader   => {
              'options' => \&Class::MOP::Method::Constructor::options
          },
          default  => sub { +{} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Constructor->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass' => (
          init_arg => "metaclass", # FIXME alias and rename
          reader   => {
              'associated_metaclass' => \&Class::MOP::Method::Constructor::associated_metaclass
          },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Overload
  
  Class::MOP::Overload->meta->add_attribute(
      Class::MOP::Attribute->new(
          'operator' => (
              reader   => { 'operator' => \&Class::MOP::Overload::operator },
              required => 1,
              _definition_context(),
          )
      )
  );
  
  for my $attr (qw( method_name coderef coderef_package coderef_name method )) {
      Class::MOP::Overload->meta->add_attribute(
          Class::MOP::Attribute->new(
              $attr => (
                  reader    => { $attr => Class::MOP::Overload->can($attr) },
                  predicate => {
                      'has_'
                          . $attr => Class::MOP::Overload->can( 'has_' . $attr )
                  },
                  _definition_context(),
              )
          )
      );
  }
  
  Class::MOP::Overload->meta->add_attribute(
      Class::MOP::Attribute->new(
          'associated_metaclass' => (
              reader => {
                  'associated_metaclass' =>
                      \&Class::MOP::Overload::associated_metaclass
              },
              _definition_context(),
          )
      )
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Instance
  
  # NOTE:
  # these don't yet do much of anything, but are just
  # included for completeness
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass',
          reader   => { associated_metaclass => \&Class::MOP::Instance::associated_metaclass },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('_class_name',
          init_arg => undef,
          reader   => { _class_name => \&Class::MOP::Instance::_class_name },
          #lazy     => 1, # not yet supported by Class::MOP but out our version does it anyway
          #default  => sub { $_[0]->associated_metaclass->name },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('attributes',
          reader   => { attributes => \&Class::MOP::Instance::get_all_attributes },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('slots',
          reader   => { slots => \&Class::MOP::Instance::slots },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('slot_hash',
          reader   => { slot_hash => \&Class::MOP::Instance::slot_hash },
          _definition_context(),
      ),
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Object
  
  # need to replace the meta method there with a real meta method object
  Class::MOP::Object->meta->_add_meta_method('meta');
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin
  
  # need to replace the meta method there with a real meta method object
  Class::MOP::Mixin->meta->_add_meta_method('meta');
  
  require Class::MOP::Deprecated unless our $no_deprecated;
  
  # we need the meta instance of the meta instance to be created now, in order
  # for the constructor to be able to use it
  Class::MOP::Instance->meta->get_meta_instance;
  
  # pretend the add_method never happened. it hasn't yet affected anything
  undef Class::MOP::Instance->meta->{_package_cache_flag};
  
  ## --------------------------------------------------------
  ## Now close all the Class::MOP::* classes
  
  # NOTE: we don't need to inline the accessors this only lengthens the compile
  # time of the MOP, and gives us no actual benefits.
  
  $_->meta->make_immutable(
      inline_constructor  => 0,
      constructor_name    => "_new",
      inline_accessors => 0,
  ) for qw/
      Class::MOP::Package
      Class::MOP::Module
      Class::MOP::Class
  
      Class::MOP::Attribute
      Class::MOP::Method
      Class::MOP::Instance
  
      Class::MOP::Object
  
      Class::MOP::Method::Generated
      Class::MOP::Method::Inlined
  
      Class::MOP::Method::Accessor
      Class::MOP::Method::Constructor
      Class::MOP::Method::Wrapped
  
      Class::MOP::Method::Meta
  
      Class::MOP::Overload
  /;
  
  $_->meta->make_immutable(
      inline_constructor  => 0,
      constructor_name    => undef,
      inline_accessors => 0,
  ) for qw/
      Class::MOP::Mixin
      Class::MOP::Mixin::AttributeCore
      Class::MOP::Mixin::HasAttributes
      Class::MOP::Mixin::HasMethods
      Class::MOP::Mixin::HasOverloads
  /;
  
  1;
  
  # ABSTRACT: A Meta Object Protocol for Perl 5
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP - A Meta Object Protocol for Perl 5
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This module is a fully functioning meta object protocol for the
  Perl 5 object system. It makes no attempt to change the behavior or
  characteristics of the Perl 5 object system, only to create a
  protocol for its manipulation and introspection.
  
  That said, it does attempt to create the tools for building a rich set
  of extensions to the Perl 5 object system. Every attempt has been made
  to abide by the spirit of the Perl 5 object system that we all know
  and love.
  
  This documentation is sparse on conceptual details. We suggest looking
  at the items listed in the L<SEE ALSO> section for more
  information. In particular the book "The Art of the Meta Object
  Protocol" was very influential in the development of this system.
  
  =head2 What is a Meta Object Protocol?
  
  A meta object protocol is an API to an object system.
  
  To be more specific, it abstracts the components of an object system
  (classes, object, methods, object attributes, etc.). These
  abstractions can then be used to inspect and manipulate the object
  system which they describe.
  
  It can be said that there are two MOPs for any object system; the
  implicit MOP and the explicit MOP. The implicit MOP handles things
  like method dispatch or inheritance, which happen automatically as
  part of how the object system works. The explicit MOP typically
  handles the introspection/reflection features of the object system.
  
  All object systems have implicit MOPs. Without one, they would not
  work. Explicit MOPs are much less common, and depending on the
  language can vary from restrictive (Reflection in Java or C#) to wide
  open (CLOS is a perfect example).
  
  =head2 Yet Another Class Builder! Why?
  
  This is B<not> a class builder so much as a I<class builder
  B<builder>>. The intent is that an end user will not use this module
  directly, but instead this module is used by module authors to build
  extensions and features onto the Perl 5 object system.
  
  This system is used by L<Moose>, which supplies a powerful class
  builder system built entirely on top of C<Class::MOP>.
  
  =head2 Who is this module for?
  
  This module is for anyone who has ever created or wanted to create a
  module for the Class:: namespace. The tools which this module provides
  make doing complex Perl 5 wizardry simpler, by removing such barriers
  as the need to hack symbol tables, or understand the fine details of
  method dispatch.
  
  =head2 What changes do I have to make to use this module?
  
  This module was designed to be as unobtrusive as possible. Many of its
  features are accessible without B<any> change to your existing
  code. It is meant to be a complement to your existing code and not an
  intrusion on your code base. Unlike many other B<Class::> modules,
  this module B<does not> require you subclass it, or even that you
  C<use> it in within your module's package.
  
  The only features which require additions to your code are the
  attribute handling and instance construction features, and these are
  both completely optional features. The only reason for this is because
  Perl 5's object system does not actually have these features built
  in. More information about this feature can be found below.
  
  =head2 About Performance
  
  It is a common misconception that explicit MOPs are a performance hit.
  This is not a universal truth, it is a side-effect of some specific
  implementations. For instance, using Java reflection is slow because
  the JVM cannot take advantage of any compiler optimizations, and the
  JVM has to deal with much more runtime type information as well.
  
  Reflection in C# is marginally better as it was designed into the
  language and runtime (the CLR). In contrast, CLOS (the Common Lisp
  Object System) was built to support an explicit MOP, and so
  performance is tuned for it.
  
  This library in particular does its absolute best to avoid putting
  B<any> drain at all upon your code's performance. In fact, by itself
  it does nothing to affect your existing code. So you only pay for what
  you actually use.
  
  =head2 About Metaclass compatibility
  
  This module makes sure that all metaclasses created are both upwards
  and downwards compatible. The topic of metaclass compatibility is
  highly esoteric and is something only encountered when doing deep and
  involved metaclass hacking. There are two basic kinds of metaclass
  incompatibility; upwards and downwards.
  
  Upwards metaclass compatibility means that the metaclass of a
  given class is either the same as (or a subclass of) all of the
  metaclasses of the class's ancestors.
  
  Downward metaclass compatibility means that the metaclasses of a
  given class's ancestors are all the same as (or a subclass of) that
  class's metaclass.
  
  Here is a diagram showing a set of two classes (C<A> and C<B>) and
  two metaclasses (C<Meta::A> and C<Meta::B>) which have correct
  metaclass compatibility both upwards and downwards.
  
      +---------+     +---------+
      | Meta::A |<----| Meta::B |      <....... (instance of  )
      +---------+     +---------+      <------- (inherits from)
           ^               ^
           :               :
      +---------+     +---------+
      |    A    |<----|    B    |
      +---------+     +---------+
  
  In actuality, I<all> of a class's metaclasses must be compatible,
  not just the class metaclass. That includes the instance, attribute,
  and method metaclasses, as well as the constructor and destructor
  classes.
  
  C<Class::MOP> will attempt to fix some simple types of
  incompatibilities. If all the metaclasses for the parent class are
  I<subclasses> of the child's metaclasses then we can simply replace
  the child's metaclasses with the parent's. In addition, if the child
  is missing a metaclass that the parent has, we can also just make the
  child use the parent's metaclass.
  
  As I said this is a highly esoteric topic and one you will only run
  into if you do a lot of subclassing of L<Class::MOP::Class>. If you
  are interested in why this is an issue see the paper I<Uniform and
  safe metaclass composition> linked to in the L<SEE ALSO> section of
  this document.
  
  =head2 Using custom metaclasses
  
  Always use the L<metaclass> pragma when using a custom metaclass, this
  will ensure the proper initialization order and not accidentally
  create an incorrect type of metaclass for you. This is a very rare
  problem, and one which can only occur if you are doing deep metaclass
  programming. So in other words, don't worry about it.
  
  Note that if you're using L<Moose> we encourage you to I<not> use the
  L<metaclass> pragma, and instead use L<Moose::Util::MetaRole> to apply
  roles to a class's metaclasses. This topic is covered at length in
  various L<Moose::Cookbook> recipes.
  
  =head1 PROTOCOLS
  
  The meta-object protocol is divided into 4 main sub-protocols:
  
  =head2 The Class protocol
  
  This provides a means of manipulating and introspecting a Perl 5
  class. It handles symbol table hacking for you, and provides a rich
  set of methods that go beyond simple package introspection.
  
  See L<Class::MOP::Class> for more details.
  
  =head2 The Attribute protocol
  
  This provides a consistent representation for an attribute of a Perl 5
  class. Since there are so many ways to create and handle attributes in
  Perl 5 OO, the Attribute protocol provide as much of a unified
  approach as possible. Of course, you are always free to extend this
  protocol by subclassing the appropriate classes.
  
  See L<Class::MOP::Attribute> for more details.
  
  =head2 The Method protocol
  
  This provides a means of manipulating and introspecting methods in the
  Perl 5 object system. As with attributes, there are many ways to
  approach this topic, so we try to keep it pretty basic, while still
  making it possible to extend the system in many ways.
  
  See L<Class::MOP::Method> for more details.
  
  =head2 The Instance protocol
  
  This provides a layer of abstraction for creating object instances.
  Since the other layers use this protocol, it is relatively easy to
  change the type of your instances from the default hash reference to
  some other type of reference. Several examples are provided in the
  F<examples/> directory included in this distribution.
  
  See L<Class::MOP::Instance> for more details.
  
  =head1 FUNCTIONS
  
  Note that this module does not export any constants or functions.
  
  =head2 Utility functions
  
  Note that these are all called as B<functions, not methods>.
  
  =head3 Class::MOP::get_code_info($code)
  
  This function returns two values, the name of the package the C<$code>
  is from and the name of the C<$code> itself. This is used by several
  elements of the MOP to determine where a given C<$code> reference is
  from.
  
  =head3 Class::MOP::class_of($instance_or_class_name)
  
  This will return the metaclass of the given instance or class name.  If the
  class lacks a metaclass, no metaclass will be initialized, and C<undef> will be
  returned.
  
  You should almost certainly be using
  L<C<Moose::Util::find_meta>|Moose::Util/find_meta> instead.
  
  =head2 Metaclass cache functions
  
  C<Class::MOP> holds a cache of metaclasses. The following are functions
  (B<not methods>) which can be used to access that cache. It is not
  recommended that you mess with these. Bad things could happen, but if
  you are brave and willing to risk it: go for it!
  
  =head3 Class::MOP::get_all_metaclasses
  
  This will return a hash of all the metaclass instances that have
  been cached by L<Class::MOP::Class>, keyed by the package name.
  
  =head3 Class::MOP::get_all_metaclass_instances
  
  This will return a list of all the metaclass instances that have
  been cached by L<Class::MOP::Class>.
  
  =head3 Class::MOP::get_all_metaclass_names
  
  This will return a list of all the metaclass names that have
  been cached by L<Class::MOP::Class>.
  
  =head3 Class::MOP::get_metaclass_by_name($name)
  
  This will return a cached L<Class::MOP::Class> instance, or nothing
  if no metaclass exists with that C<$name>.
  
  =head3 Class::MOP::store_metaclass_by_name($name, $meta)
  
  This will store a metaclass in the cache at the supplied C<$key>.
  
  =head3 Class::MOP::weaken_metaclass($name)
  
  In rare cases (e.g. anonymous metaclasses) it is desirable to
  store a weakened reference in the metaclass cache. This
  function will weaken the reference to the metaclass stored
  in C<$name>.
  
  =head3 Class::MOP::metaclass_is_weak($name)
  
  Returns true if the metaclass for C<$name> has been weakened
  (via C<weaken_metaclass>).
  
  =head3 Class::MOP::does_metaclass_exist($name)
  
  This will return true of there exists a metaclass stored in the
  C<$name> key, and return false otherwise.
  
  =head3 Class::MOP::remove_metaclass_by_name($name)
  
  This will remove the metaclass stored in the C<$name> key.
  
  Some utility functions (such as C<Class::MOP::load_class>) that were
  previously defined in C<Class::MOP> regarding loading of classes have been
  extracted to L<Class::Load>. Please see L<Class::Load> for documentation.
  
  =head1 SEE ALSO
  
  =head2 Books
  
  There are very few books out on Meta Object Protocols and Metaclasses
  because it is such an esoteric topic. The following books are really
  the only ones I have found. If you know of any more, B<I<please>>
  email me and let me know, I would love to hear about them.
  
  =over 4
  
  =item I<The Art of the Meta Object Protocol>
  
  =item I<Advances in Object-Oriented Metalevel Architecture and Reflection>
  
  =item I<Putting MetaClasses to Work>
  
  =item I<Smalltalk: The Language>
  
  =back
  
  =head2 Papers
  
  =over 4
  
  =item "Uniform and safe metaclass composition"
  
  An excellent paper by the people who brought us the original Traits paper.
  This paper is on how Traits can be used to do safe metaclass composition,
  and offers an excellent introduction section which delves into the topic of
  metaclass compatibility.
  
  L<http://scg.unibe.ch/archive/papers/Duca05ySafeMetaclassTrait.pdf>
  
  =item "Safe Metaclass Programming"
  
  This paper seems to precede the above paper, and propose a mix-in based
  approach as opposed to the Traits based approach. Both papers have similar
  information on the metaclass compatibility problem space.
  
  L<http://citeseer.ist.psu.edu/37617.html>
  
  =back
  
  =head2 Prior Art
  
  =over 4
  
  =item The Perl 6 MetaModel work in the Pugs project
  
  =over 4
  
  =item L<http://svn.openfoundry.org/pugs/misc/Perl-MetaModel/>
  
  =item L<http://github.com/perl6/p5-modules/tree/master/Perl6-ObjectSpace/>
  
  =back
  
  =back
  
  =head2 Articles
  
  =over 4
  
  =item CPAN Module Review of Class::MOP
  
  L<http://www.oreillynet.com/onlamp/blog/2006/06/cpan_module_review_classmop.html>
  
  =back
  
  =head1 SIMILAR MODULES
  
  As I have said above, this module is a class-builder-builder, so it is
  not the same thing as modules like L<Class::Accessor> and
  L<Class::MethodMaker>. That being said there are very few modules on CPAN
  with similar goals to this module. The one I have found which is most
  like this module is L<Class::Meta>, although its philosophy and the MOP it
  creates are very different from this modules.
  
  =head1 BUGS
  
  All complex software has bugs lurking in it, and this module is no
  exception.
  
  Please report any bugs to C<bug-class-mop@rt.cpan.org>, or through the
  web interface at L<http://rt.cpan.org>.
  
  You can also discuss feature requests or possible bugs on the Moose
  mailing list (moose@perl.org) or on IRC at
  L<irc://irc.perl.org/#moose>.
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 4
  
  =item Rob Kinyon
  
  Thanks to Rob for actually getting the development of this module kick-started.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_ATTRIBUTE';
  package Class::MOP::Attribute;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::MOP::Method::Accessor;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Class::MOP::Object', 'Class::MOP::Mixin::AttributeCore';
  
  # NOTE: (meta-circularity)
  # This method will be replaced in the
  # boostrap section of Class::MOP, by
  # a new version which uses the
  # &Class::MOP::Class::construct_instance
  # method to build an attribute meta-object
  # which itself is described with attribute
  # meta-objects.
  #     - Ain't meta-circularity grand? :)
  sub new {
      my ( $class, @args ) = @_;
  
      unshift @args, "name" if @args % 2 == 1;
      my %options = @args;
  
      my $name = $options{name};
  
      (defined $name)
          || $class->_throw_exception( MOPAttributeNewNeedsAttributeName => class  => $class,
                                                                   params => \%options
                            );
  
      $options{init_arg} = $name
          if not exists $options{init_arg};
      if(exists $options{builder}){
          $class->_throw_exception( BuilderMustBeAMethodName => class  => $class,
                                                       params => \%options
                         )
              if ref $options{builder} || !(defined $options{builder});
          $class->_throw_exception( BothBuilderAndDefaultAreNotAllowed => class  => $class,
                                                                 params => \%options
                         )
              if exists $options{default};
      } else {
          ($class->is_default_a_coderef(\%options))
              || $class->_throw_exception( ReferencesAreNotAllowedAsDefault => class          => $class,
                                                                      params         => \%options,
                                                                      attribute_name => $options{name}
                                )
                  if exists $options{default} && ref $options{default};
      }
  
      if( $options{required} and not( defined($options{builder}) || defined($options{init_arg}) || exists $options{default} ) ) {
          $class->_throw_exception( RequiredAttributeLacksInitialization => class  => $class,
                                                                   params => \%options
                         );
      }
  
      $class->_new(\%options);
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $options = @_ == 1 ? $_[0] : {@_};
  
      bless {
          'name'               => $options->{name},
          'accessor'           => $options->{accessor},
          'reader'             => $options->{reader},
          'writer'             => $options->{writer},
          'predicate'          => $options->{predicate},
          'clearer'            => $options->{clearer},
          'builder'            => $options->{builder},
          'init_arg'           => $options->{init_arg},
          exists $options->{default}
              ? ('default'     => $options->{default})
              : (),
          'initializer'        => $options->{initializer},
          'definition_context' => $options->{definition_context},
          # keep a weakened link to the
          # class we are associated with
          'associated_class' => undef,
          # and a list of the methods
          # associated with this attr
          'associated_methods' => [],
          # this let's us keep track of
          # our order inside the associated
          # class
          'insertion_order'    => undef,
      }, $class;
  }
  
  # NOTE:
  # this is a primitive (and kludgy) clone operation
  # for now, it will be replaced in the Class::MOP
  # bootstrap with a proper one, however we know
  # that this one will work fine for now.
  sub clone {
      my $self    = shift;
      my %options = @_;
      (blessed($self))
          || confess "Can only clone an instance";
      # this implementation is overwritten by the bootstrap process,
      # so this exception will never trigger. If it ever does occur,
      # it indicates a gigantic problem with the most internal parts
      # of Moose, so we wouldn't want a Moose-based exception object anyway
  
      return bless { %{$self}, %options } => ref($self);
  }
  
  sub initialize_instance_slot {
      my ($self, $meta_instance, $instance, $params) = @_;
      my $init_arg = $self->{'init_arg'};
  
      # try to fetch the init arg from the %params ...
  
      # if nothing was in the %params, we can use the
      # attribute's default value (if it has one)
      if(defined $init_arg and exists $params->{$init_arg}){
          $self->_set_initial_slot_value(
              $meta_instance,
              $instance,
              $params->{$init_arg},
          );
      }
      elsif (exists $self->{'default'}) {
          $self->_set_initial_slot_value(
              $meta_instance,
              $instance,
              $self->default($instance),
          );
      }
      elsif (defined( my $builder = $self->{'builder'})) {
          if ($builder = $instance->can($builder)) {
              $self->_set_initial_slot_value(
                  $meta_instance,
                  $instance,
                  $instance->$builder,
              );
          }
          else {
              $self->_throw_exception( BuilderMethodNotSupportedForAttribute => attribute => $self,
                                                                        instance  => $instance
                             );
          }
      }
  }
  
  sub _set_initial_slot_value {
      my ($self, $meta_instance, $instance, $value) = @_;
  
      my $slot_name = $self->name;
  
      return $meta_instance->set_slot_value($instance, $slot_name, $value)
          unless $self->has_initializer;
  
      my $callback = $self->_make_initializer_writer_callback(
          $meta_instance, $instance, $slot_name
      );
  
      my $initializer = $self->initializer;
  
      # most things will just want to set a value, so make it first arg
      $instance->$initializer($value, $callback, $self);
  }
  
  sub _make_initializer_writer_callback {
      my $self = shift;
      my ($meta_instance, $instance, $slot_name) = @_;
  
      return sub {
          $meta_instance->set_slot_value($instance, $slot_name, $_[0]);
      };
  }
  
  sub get_read_method  {
      my $self   = shift;
      my $reader = $self->reader || $self->accessor;
      # normal case ...
      return $reader unless ref $reader;
      # the HASH ref case
      my ($name) = %$reader;
      return $name;
  }
  
  sub get_write_method {
      my $self   = shift;
      my $writer = $self->writer || $self->accessor;
      # normal case ...
      return $writer unless ref $writer;
      # the HASH ref case
      my ($name) = %$writer;
      return $name;
  }
  
  sub get_read_method_ref {
      my $self = shift;
      if ((my $reader = $self->get_read_method) && $self->associated_class) {
          return $self->associated_class->get_method($reader);
      }
      else {
          my $code = sub { $self->get_value(@_) };
          if (my $class = $self->associated_class) {
              return $class->method_metaclass->wrap(
                  $code,
                  package_name => $class->name,
                  name         => '__ANON__'
              );
          }
          else {
              return $code;
          }
      }
  }
  
  sub get_write_method_ref {
      my $self = shift;
      if ((my $writer = $self->get_write_method) && $self->associated_class) {
          return $self->associated_class->get_method($writer);
      }
      else {
          my $code = sub { $self->set_value(@_) };
          if (my $class = $self->associated_class) {
              return $class->method_metaclass->wrap(
                  $code,
                  package_name => $class->name,
                  name         => '__ANON__'
              );
          }
          else {
              return $code;
          }
      }
  }
  
  # slots
  
  sub slots { (shift)->name }
  
  # class association
  
  sub attach_to_class {
      my ($self, $class) = @_;
      (blessed($class) && $class->isa('Class::MOP::Class'))
          || $self->_throw_exception( AttachToClassNeedsAClassMOPClassInstanceOrASubclass => attribute => $self,
                                                                                     class     => $class
                            );
      weaken($self->{'associated_class'} = $class);
  }
  
  sub detach_from_class {
      my $self = shift;
      $self->{'associated_class'} = undef;
  }
  
  # method association
  
  sub associate_method {
      my ($self, $method) = @_;
      push @{$self->{'associated_methods'}} => $method;
  }
  
  ## Slot management
  
  sub set_initial_value {
      my ($self, $instance, $value) = @_;
      $self->_set_initial_slot_value(
          Class::MOP::Class->initialize(ref($instance))->get_meta_instance,
          $instance,
          $value
      );
  }
  
  sub set_value { shift->set_raw_value(@_) }
  
  sub set_raw_value {
      my $self = shift;
      my ($instance, $value) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->set_slot_value($instance, $self->name, $value);
  }
  
  sub _inline_set_value {
      my $self = shift;
      return $self->_inline_instance_set(@_) . ';';
  }
  
  sub _inline_instance_set {
      my $self = shift;
      my ($instance, $value) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_set_slot_value($instance, $self->name, $value);
  }
  
  sub get_value { shift->get_raw_value(@_) }
  
  sub get_raw_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->get_slot_value($instance, $self->name);
  }
  
  sub _inline_get_value {
      my $self = shift;
      return $self->_inline_instance_get(@_) . ';';
  }
  
  sub _inline_instance_get {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_get_slot_value($instance, $self->name);
  }
  
  sub has_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->is_slot_initialized($instance, $self->name);
  }
  
  sub _inline_has_value {
      my $self = shift;
      return $self->_inline_instance_has(@_) . ';';
  }
  
  sub _inline_instance_has {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_is_slot_initialized($instance, $self->name);
  }
  
  sub clear_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->deinitialize_slot($instance, $self->name);
  }
  
  sub _inline_clear_value {
      my $self = shift;
      return $self->_inline_instance_clear(@_) . ';';
  }
  
  sub _inline_instance_clear {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_deinitialize_slot($instance, $self->name);
  }
  
  ## load em up ...
  
  sub accessor_metaclass { 'Class::MOP::Method::Accessor' }
  
  sub _process_accessors {
      my ($self, $type, $accessor, $generate_as_inline_methods) = @_;
  
      my $method_ctx = { %{ $self->definition_context || {} } };
  
      if (ref($accessor)) {
          (ref($accessor) eq 'HASH')
              || $self->_throw_exception( BadOptionFormat => attribute    => $self,
                                                     option_value => $accessor,
                                                     option_name  => $type
                                );
  
          my ($name, $method) = %{$accessor};
  
          $method_ctx->{description} = $self->_accessor_description($name, $type);
  
          $method = $self->accessor_metaclass->wrap(
              $method,
              attribute    => $self,
              package_name => $self->associated_class->name,
              name         => $name,
              associated_metaclass => $self->associated_class,
              definition_context => $method_ctx,
          );
          $self->associate_method($method);
          return ($name, $method);
      }
      else {
          my $inline_me = ($generate_as_inline_methods && $self->associated_class->instance_metaclass->is_inlinable);
          my $method;
          try {
              $method_ctx->{description} = $self->_accessor_description($accessor, $type);
  
              $method = $self->accessor_metaclass->new(
                  attribute     => $self,
                  is_inline     => $inline_me,
                  accessor_type => $type,
                  package_name  => $self->associated_class->name,
                  name          => $accessor,
                  associated_metaclass => $self->associated_class,
                  definition_context => $method_ctx,
              );
          }
          catch {
              $self->_throw_exception( CouldNotCreateMethod => attribute    => $self,
                                                       option_value => $accessor,
                                                       option_name  => $type,
                                                       error        => $_
                             );
          };
          $self->associate_method($method);
          return ($accessor, $method);
      }
  }
  
  sub _accessor_description {
      my $self = shift;
      my ($name, $type) = @_;
  
      my $desc = "$type " . $self->associated_class->name . "::$name";
      if ( $name ne $self->name ) {
          $desc .= " of attribute " . $self->name;
      }
  
      return $desc;
  }
  
  sub install_accessors {
      my $self   = shift;
      my $inline = shift;
      my $class  = $self->associated_class;
  
      $class->add_method(
          $self->_process_accessors('accessor' => $self->accessor(), $inline)
      ) if $self->has_accessor();
  
      $class->add_method(
          $self->_process_accessors('reader' => $self->reader(), $inline)
      ) if $self->has_reader();
  
      $class->add_method(
          $self->_process_accessors('writer' => $self->writer(), $inline)
      ) if $self->has_writer();
  
      $class->add_method(
          $self->_process_accessors('predicate' => $self->predicate(), $inline)
      ) if $self->has_predicate();
  
      $class->add_method(
          $self->_process_accessors('clearer' => $self->clearer(), $inline)
      ) if $self->has_clearer();
  
      return;
  }
  
  {
      my $_remove_accessor = sub {
          my ($accessor, $class) = @_;
          if (ref($accessor) && ref($accessor) eq 'HASH') {
              ($accessor) = keys %{$accessor};
          }
          my $method = $class->get_method($accessor);
          $class->remove_method($accessor)
              if (ref($method) && $method->isa('Class::MOP::Method::Accessor'));
      };
  
      sub remove_accessors {
          my $self = shift;
          # TODO:
          # we really need to make sure to remove from the
          # associates methods here as well. But this is
          # such a slimly used method, I am not worried
          # about it right now.
          $_remove_accessor->($self->accessor(),  $self->associated_class()) if $self->has_accessor();
          $_remove_accessor->($self->reader(),    $self->associated_class()) if $self->has_reader();
          $_remove_accessor->($self->writer(),    $self->associated_class()) if $self->has_writer();
          $_remove_accessor->($self->predicate(), $self->associated_class()) if $self->has_predicate();
          $_remove_accessor->($self->clearer(),   $self->associated_class()) if $self->has_clearer();
          return;
      }
  
  }
  
  1;
  
  # ABSTRACT: Attribute Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Attribute - Attribute Meta Object
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    Class::MOP::Attribute->new(
        foo => (
            accessor  => 'foo',           # dual purpose get/set accessor
            predicate => 'has_foo',       # predicate check for defined-ness
            init_arg  => '-foo',          # class->new will look for a -foo key
            default   => 'BAR IS BAZ!'    # if no -foo key is provided, use this
        )
    );
  
    Class::MOP::Attribute->new(
        bar => (
            reader    => 'bar',           # getter
            writer    => 'set_bar',       # setter
            predicate => 'has_bar',       # predicate check for defined-ness
            init_arg  => ':bar',          # class->new will look for a :bar key
                                          # no default value means it is undef
        )
    );
  
  =head1 DESCRIPTION
  
  The Attribute Protocol is almost entirely an invention of
  C<Class::MOP>. Perl 5 does not have a consistent notion of
  attributes. There are so many ways in which this is done, and very few
  (if any) are easily discoverable by this module.
  
  With that said, this module attempts to inject some order into this
  chaos, by introducing a consistent API which can be used to create
  object attributes.
  
  =head1 METHODS
  
  =head2 Creation
  
  =over 4
  
  =item B<< Class::MOP::Attribute->new($name, ?%options) >>
  
  An attribute must (at the very least), have a C<$name>. All other
  C<%options> are added as key-value pairs.
  
  =over 8
  
  =item * init_arg
  
  This is a string value representing the expected key in an
  initialization hash. For instance, if we have an C<init_arg> value of
  C<-foo>, then the following code will Just Work.
  
    MyClass->meta->new_object( -foo => 'Hello There' );
  
  If an init_arg is not assigned, it will automatically use the
  attribute's name. If C<init_arg> is explicitly set to C<undef>, the
  attribute cannot be specified during initialization.
  
  =item * builder
  
  This provides the name of a method that will be called to initialize
  the attribute. This method will be called on the object after it is
  constructed. It is expected to return a valid value for the attribute.
  
  =item * default
  
  This can be used to provide an explicit default for initializing the
  attribute. If the default you provide is a subroutine reference, then
  this reference will be called I<as a method> on the object.
  
  If the value is a simple scalar (string or number), then it can be
  just passed as is. However, if you wish to initialize it with a HASH
  or ARRAY ref, then you need to wrap that inside a subroutine
  reference:
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub { [] },
        )
    );
  
    # or ...
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub { {} },
        )
    );
  
  If you wish to initialize an attribute with a subroutine reference
  itself, then you need to wrap that in a subroutine as well:
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub {
                sub { print "Hello World" }
            },
        )
    );
  
  And lastly, if the value of your attribute is dependent upon some
  other aspect of the instance structure, then you can take advantage of
  the fact that when the C<default> value is called as a method:
  
    Class::MOP::Attribute->new(
        'object_identity' => (
            default => sub { Scalar::Util::refaddr( $_[0] ) },
        )
    );
  
  Note that there is no guarantee that attributes are initialized in any
  particular order, so you cannot rely on the value of some other
  attribute when generating the default.
  
  =item * initializer
  
  This option can be either a method name or a subroutine
  reference. This method will be called when setting the attribute's
  value in the constructor. Unlike C<default> and C<builder>, the
  initializer is only called when a value is provided to the
  constructor. The initializer allows you to munge this value during
  object construction.
  
  The initializer is called as a method with three arguments. The first
  is the value that was passed to the constructor. The second is a
  subroutine reference that can be called to actually set the
  attribute's value, and the last is the associated
  C<Class::MOP::Attribute> object.
  
  This contrived example shows an initializer that sets the attribute to
  twice the given value.
  
    Class::MOP::Attribute->new(
        'doubled' => (
            initializer => sub {
                my ( $self, $value, $set, $attr ) = @_;
                $set->( $value * 2 );
            },
        )
    );
  
  Since an initializer can be a method name, you can easily make
  attribute initialization use the writer:
  
    Class::MOP::Attribute->new(
        'some_attr' => (
            writer      => 'some_attr',
            initializer => 'some_attr',
        )
    );
  
  Your writer (actually, a wrapper around the writer, using
  L<method modifications|Moose::Manual::MethodModifiers>) will need to examine
  C<@_> and determine under which
  context it is being called:
  
    around 'some_attr' => sub {
        my $orig = shift;
        my $self = shift;
        # $value is not defined if being called as a reader
        # $setter and $attr are only defined if being called as an initializer
        my ($value, $setter, $attr) = @_;
  
        # the reader behaves normally
        return $self->$orig if not @_;
  
        # mutate $value as desired
        # $value = <something($value);
  
        # if called as an initializer, set the value and we're done
        return $setter->($row) if $setter;
  
        # otherwise, call the real writer with the new value
        $self->$orig($row);
    };
  
  =back
  
  The C<accessor>, C<reader>, C<writer>, C<predicate> and C<clearer>
  options all accept the same parameters. You can provide the name of
  the method, in which case an appropriate default method will be
  generated for you. Or instead you can also provide hash reference
  containing exactly one key (the method name) and one value. The value
  should be a subroutine reference, which will be installed as the
  method itself.
  
  =over 8
  
  =item * accessor
  
  An C<accessor> is a standard Perl-style read/write accessor. It will
  return the value of the attribute, and if a value is passed as an
  argument, it will assign that value to the attribute.
  
  Note that C<undef> is a legitimate value, so this will work:
  
    $object->set_something(undef);
  
  =item * reader
  
  This is a basic read-only accessor. It returns the value of the
  attribute.
  
  =item * writer
  
  This is a basic write accessor, it accepts a single argument, and
  assigns that value to the attribute.
  
  Note that C<undef> is a legitimate value, so this will work:
  
    $object->set_something(undef);
  
  =item * predicate
  
  The predicate method returns a boolean indicating whether or not the
  attribute has been explicitly set.
  
  Note that the predicate returns true even if the attribute was set to
  a false value (C<0> or C<undef>).
  
  =item * clearer
  
  This method will uninitialize the attribute. After an attribute is
  cleared, its C<predicate> will return false.
  
  =item * definition_context
  
  Mostly, this exists as a hook for the benefit of Moose.
  
  This option should be a hash reference containing several keys which
  will be used when inlining the attribute's accessors. The keys should
  include C<line>, the line number where the attribute was created, and
  either C<file> or C<description>.
  
  This information will ultimately be used when eval'ing inlined
  accessor code so that error messages report a useful line and file
  name.
  
  =back
  
  =item B<< $attr->clone(%options) >>
  
  This clones the attribute. Any options you provide will override the
  settings of the original attribute. You can change the name of the new
  attribute by passing a C<name> key in C<%options>.
  
  =back
  
  =head2 Informational
  
  These are all basic read-only accessors for the values passed into
  the constructor.
  
  =over 4
  
  =item B<< $attr->name >>
  
  Returns the attribute's name.
  
  =item B<< $attr->accessor >>
  
  =item B<< $attr->reader >>
  
  =item B<< $attr->writer >>
  
  =item B<< $attr->predicate >>
  
  =item B<< $attr->clearer >>
  
  The C<accessor>, C<reader>, C<writer>, C<predicate>, and C<clearer>
  methods all return exactly what was passed to the constructor, so it
  can be either a string containing a method name, or a hash reference.
  
  =item B<< $attr->initializer >>
  
  Returns the initializer as passed to the constructor, so this may be
  either a method name or a subroutine reference.
  
  =item B<< $attr->init_arg >>
  
  =item B<< $attr->is_default_a_coderef >>
  
  =item B<< $attr->builder >>
  
  =item B<< $attr->default($instance) >>
  
  The C<$instance> argument is optional. If you don't pass it, the
  return value for this method is exactly what was passed to the
  constructor, either a simple scalar or a subroutine reference.
  
  If you I<do> pass an C<$instance> and the default is a subroutine
  reference, then the reference is called as a method on the
  C<$instance> and the generated value is returned.
  
  =item B<< $attr->slots >>
  
  Return a list of slots required by the attribute. This is usually just
  one, the name of the attribute.
  
  A slot is the name of the hash key used to store the attribute in an
  object instance.
  
  =item B<< $attr->get_read_method >>
  
  =item B<< $attr->get_write_method >>
  
  Returns the name of a method suitable for reading or writing the value
  of the attribute in the associated class.
  
  If an attribute is read- or write-only, then these methods can return
  C<undef> as appropriate.
  
  =item B<< $attr->has_read_method >>
  
  =item B<< $attr->has_write_method >>
  
  This returns a boolean indicating whether the attribute has a I<named>
  read or write method.
  
  =item B<< $attr->get_read_method_ref >>
  
  =item B<< $attr->get_write_method_ref >>
  
  Returns the subroutine reference of a method suitable for reading or
  writing the attribute's value in the associated class. These methods
  always return a subroutine reference, regardless of whether or not the
  attribute is read- or write-only.
  
  =item B<< $attr->insertion_order >>
  
  If this attribute has been inserted into a class, this returns a zero
  based index regarding the order of insertion.
  
  =back
  
  =head2 Informational predicates
  
  These are all basic predicate methods for the values passed into C<new>.
  
  =over 4
  
  =item B<< $attr->has_accessor >>
  
  =item B<< $attr->has_reader >>
  
  =item B<< $attr->has_writer >>
  
  =item B<< $attr->has_predicate >>
  
  =item B<< $attr->has_clearer >>
  
  =item B<< $attr->has_initializer >>
  
  =item B<< $attr->has_init_arg >>
  
  This will be I<false> if the C<init_arg> was set to C<undef>.
  
  =item B<< $attr->has_default >>
  
  This will be I<false> if the C<default> was set to C<undef>, since
  C<undef> is the default C<default> anyway.
  
  =item B<< $attr->has_builder >>
  
  =item B<< $attr->has_insertion_order >>
  
  This will be I<false> if this attribute has not be inserted into a class
  
  =back
  
  =head2 Value management
  
  These methods are basically "back doors" to the instance, and can be
  used to bypass the regular accessors, but still stay within the MOP.
  
  These methods are not for general use, and should only be used if you
  really know what you are doing.
  
  =over 4
  
  =item B<< $attr->initialize_instance_slot($meta_instance, $instance, $params) >>
  
  This method is used internally to initialize the attribute's slot in
  the object C<$instance>.
  
  The C<$params> is a hash reference of the values passed to the object
  constructor.
  
  It's unlikely that you'll need to call this method yourself.
  
  =item B<< $attr->set_value($instance, $value) >>
  
  Sets the value without going through the accessor. Note that this
  works even with read-only attributes.
  
  =item B<< $attr->set_raw_value($instance, $value) >>
  
  Sets the value with no side effects such as a trigger.
  
  This doesn't actually apply to Class::MOP attributes, only to subclasses.
  
  =item B<< $attr->set_initial_value($instance, $value) >>
  
  Sets the value without going through the accessor. This method is only
  called when the instance is first being initialized.
  
  =item B<< $attr->get_value($instance) >>
  
  Returns the value without going through the accessor. Note that this
  works even with write-only accessors.
  
  =item B<< $attr->get_raw_value($instance) >>
  
  Returns the value without any side effects such as lazy attributes.
  
  Doesn't actually apply to Class::MOP attributes, only to subclasses.
  
  =item B<< $attr->has_value($instance) >>
  
  Return a boolean indicating whether the attribute has been set in
  C<$instance>. This how the default C<predicate> method works.
  
  =item B<< $attr->clear_value($instance) >>
  
  This will clear the attribute's value in C<$instance>. This is what
  the default C<clearer> calls.
  
  Note that this works even if the attribute does not have any
  associated read, write or clear methods.
  
  =back
  
  =head2 Class association
  
  These methods allow you to manage the attributes association with
  the class that contains it. These methods should not be used
  lightly, nor are they very magical, they are mostly used internally
  and by metaclass instances.
  
  =over 4
  
  =item B<< $attr->associated_class >>
  
  This returns the L<Class::MOP::Class> with which this attribute is
  associated, if any.
  
  =item B<< $attr->attach_to_class($metaclass) >>
  
  This method stores a weakened reference to the C<$metaclass> object
  internally.
  
  This method does not remove the attribute from its old class,
  nor does it create any accessors in the new class.
  
  It is probably best to use the L<Class::MOP::Class> C<add_attribute>
  method instead.
  
  =item B<< $attr->detach_from_class >>
  
  This method removes the associate metaclass object from the attribute
  it has one.
  
  This method does not remove the attribute itself from the class, or
  remove its accessors.
  
  It is probably best to use the L<Class::MOP::Class>
  C<remove_attribute> method instead.
  
  =back
  
  =head2 Attribute Accessor generation
  
  =over 4
  
  =item B<< $attr->accessor_metaclass >>
  
  Accessor methods are generated using an accessor metaclass. By
  default, this is L<Class::MOP::Method::Accessor>. This method returns
  the name of the accessor metaclass that this attribute uses.
  
  =item B<< $attr->associate_method($method) >>
  
  This associates a L<Class::MOP::Method> object with the
  attribute. Typically, this is called internally when an attribute
  generates its accessors.
  
  =item B<< $attr->associated_methods >>
  
  This returns the list of methods which have been associated with the
  attribute.
  
  =item B<< $attr->install_accessors >>
  
  This method generates and installs code the attributes various
  accessors. It is typically called from the L<Class::MOP::Class>
  C<add_attribute> method.
  
  =item B<< $attr->remove_accessors >>
  
  This method removes all of the accessors associated with the
  attribute.
  
  This does not currently remove methods from the list returned by
  C<associated_methods>.
  
  =item B<< $attr->inline_get >>
  
  =item B<< $attr->inline_set >>
  
  =item B<< $attr->inline_has >>
  
  =item B<< $attr->inline_clear >>
  
  These methods return a code snippet suitable for inlining the relevant
  operation. They expect strings containing variable names to be used in the
  inlining, like C<'$self'> or C<'$_[1]'>.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Attribute->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_ATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_CLASS';
  package Class::MOP::Class;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::MOP::Instance;
  use Class::MOP::Method::Wrapped;
  use Class::MOP::Method::Accessor;
  use Class::MOP::Method::Constructor;
  use Class::MOP::MiniTrait;
  
  use Carp         'confess';
  use Module::Runtime 'use_package_optimistically';
  use Scalar::Util 'blessed';
  use Sub::Name    'subname';
  use Try::Tiny;
  use List::Util 1.33 'all';
  
  use parent 'Class::MOP::Module',
           'Class::MOP::Mixin::HasAttributes',
           'Class::MOP::Mixin::HasMethods',
           'Class::MOP::Mixin::HasOverloads';
  
  # Creation
  
  sub initialize {
      my $class = shift;
  
      my $package_name;
  
      if ( @_ % 2 ) {
          $package_name = shift;
      } else {
          my %options = @_;
          $package_name = $options{package};
      }
  
      ($package_name && !ref($package_name))
          || ($class||__PACKAGE__)->_throw_exception( InitializeTakesUnBlessedPackageName => package_name => $package_name );
      return Class::MOP::get_metaclass_by_name($package_name)
          || $class->_construct_class_instance(package => $package_name, @_);
  }
  
  sub reinitialize {
      my ( $class, @args ) = @_;
      unshift @args, "package" if @args % 2;
      my %options = @args;
      my $old_metaclass = blessed($options{package})
          ? $options{package}
          : Class::MOP::get_metaclass_by_name($options{package});
      $options{weaken} = Class::MOP::metaclass_is_weak($old_metaclass->name)
          if !exists $options{weaken}
          && blessed($old_metaclass)
          && $old_metaclass->isa('Class::MOP::Class');
      $old_metaclass->_remove_generated_metaobjects
          if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
      my $new_metaclass = $class->SUPER::reinitialize(%options);
      $new_metaclass->_restore_metaobjects_from($old_metaclass)
          if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
      return $new_metaclass;
  }
  
  # NOTE: (meta-circularity)
  # this is a special form of _construct_instance
  # (see below), which is used to construct class
  # meta-object instances for any Class::MOP::*
  # class. All other classes will use the more
  # normal &construct_instance.
  sub _construct_class_instance {
      my $class        = shift;
      my $options      = @_ == 1 ? $_[0] : {@_};
      my $package_name = $options->{package};
      (defined $package_name && $package_name)
          || $class->_throw_exception("ConstructClassInstanceTakesPackageName");
      # NOTE:
      # return the metaclass if we have it cached,
      # and it is still defined (it has not been
      # reaped by DESTROY yet, which can happen
      # annoyingly enough during global destruction)
  
      if (defined(my $meta = Class::MOP::get_metaclass_by_name($package_name))) {
          return $meta;
      }
  
      $class
          = ref $class
          ? $class->_real_ref_name
          : $class;
  
      # now create the metaclass
      my $meta;
      if ($class eq 'Class::MOP::Class') {
          $meta = $class->_new($options);
      }
      else {
          # NOTE:
          # it is safe to use meta here because
          # class will always be a subclass of
          # Class::MOP::Class, which defines meta
          $meta = $class->meta->_construct_instance($options)
      }
  
      # and check the metaclass compatibility
      $meta->_check_metaclass_compatibility();
  
      Class::MOP::store_metaclass_by_name($package_name, $meta);
  
      # NOTE:
      # we need to weaken any anon classes
      # so that they can call DESTROY properly
      Class::MOP::weaken_metaclass($package_name) if $options->{weaken};
  
      $meta;
  }
  
  sub _real_ref_name {
      my $self = shift;
  
      # NOTE: we need to deal with the possibility of class immutability here,
      # and then get the name of the class appropriately
      return $self->is_immutable
          ? $self->_get_mutable_metaclass_name()
          : ref $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Package
          'package' => $options->{package},
  
          # NOTE:
          # since the following attributes will
          # actually be loaded from the symbol
          # table, and actually bypass the instance
          # entirely, we can just leave these things
          # listed here for reference, because they
          # should not actually have a value associated
          # with the slot.
          'namespace' => \undef,
          'methods'   => {},
  
          # inherited from Class::MOP::Module
          'version'   => \undef,
          'authority' => \undef,
  
          # defined in Class::MOP::Class
          'superclasses' => \undef,
  
          'attributes' => {},
          'attribute_metaclass' =>
              ( $options->{'attribute_metaclass'} || 'Class::MOP::Attribute' ),
          'method_metaclass' =>
              ( $options->{'method_metaclass'} || 'Class::MOP::Method' ),
          'wrapped_method_metaclass' => (
              $options->{'wrapped_method_metaclass'}
                  || 'Class::MOP::Method::Wrapped'
          ),
          'instance_metaclass' =>
              ( $options->{'instance_metaclass'} || 'Class::MOP::Instance' ),
          'immutable_trait' => (
              $options->{'immutable_trait'}
                  || 'Class::MOP::Class::Immutable::Trait'
          ),
          'constructor_name' => ( $options->{constructor_name} || 'new' ),
          'constructor_class' => (
              $options->{constructor_class} || 'Class::MOP::Method::Constructor'
          ),
          'destructor_class' => $options->{destructor_class},
      }, $class;
  }
  
  ## Metaclass compatibility
  {
      my %base_metaclass = (
          attribute_metaclass      => 'Class::MOP::Attribute',
          method_metaclass         => 'Class::MOP::Method',
          wrapped_method_metaclass => 'Class::MOP::Method::Wrapped',
          instance_metaclass       => 'Class::MOP::Instance',
          constructor_class        => 'Class::MOP::Method::Constructor',
          destructor_class         => 'Class::MOP::Method::Destructor',
      );
  
      sub _base_metaclasses { %base_metaclass }
  }
  
  sub _check_metaclass_compatibility {
      my $self = shift;
  
      my @superclasses = $self->superclasses
          or return;
  
      $self->_fix_metaclass_incompatibility(@superclasses);
  
      my %base_metaclass = $self->_base_metaclasses;
  
      # this is always okay ...
      return
          if ref($self) eq 'Class::MOP::Class'
              && all {
                  my $meta = $self->$_;
                  !defined($meta) || $meta eq $base_metaclass{$_};
          }
          keys %base_metaclass;
  
      for my $superclass (@superclasses) {
          $self->_check_class_metaclass_compatibility($superclass);
      }
  
      for my $metaclass_type ( keys %base_metaclass ) {
          next unless defined $self->$metaclass_type;
          for my $superclass (@superclasses) {
              $self->_check_single_metaclass_compatibility( $metaclass_type,
                  $superclass );
          }
      }
  }
  
  sub _check_class_metaclass_compatibility {
      my $self = shift;
      my ( $superclass_name ) = @_;
  
      if (!$self->_class_metaclass_is_compatible($superclass_name)) {
          my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
  
          my $super_meta_type = $super_meta->_real_ref_name;
  
          $self->_throw_exception( IncompatibleMetaclassOfSuperclass => class_name           => $self->name,
                                                                class_meta_type      => ref( $self ),
                                                                superclass_name      => $superclass_name,
                                                                superclass_meta_type => $super_meta_type
                         );
      }
  }
  
  sub _class_metaclass_is_compatible {
      my $self = shift;
      my ( $superclass_name ) = @_;
  
      my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
          || return 1;
  
      my $super_meta_name = $super_meta->_real_ref_name;
  
      return $self->_is_compatible_with($super_meta_name);
  }
  
  sub _check_single_metaclass_compatibility {
      my $self = shift;
      my ( $metaclass_type, $superclass_name ) = @_;
  
      if (!$self->_single_metaclass_is_compatible($metaclass_type, $superclass_name)) {
          my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
  
          $self->_throw_exception( MetaclassTypeIncompatible => class_name      => $self->name,
                                                        superclass_name => $superclass_name,
                                                        metaclass_type  => $metaclass_type
                         );
      }
  }
  
  sub _single_metaclass_is_compatible {
      my $self = shift;
      my ( $metaclass_type, $superclass_name ) = @_;
  
      my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
          || return 1;
  
      # for instance, Moose::Meta::Class has a error_class attribute, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return 1 unless $super_meta->can($metaclass_type);
      # for instance, Moose::Meta::Class has a destructor_class, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return 1 unless defined $super_meta->$metaclass_type;
      # if metaclass is defined in superclass but not here, it's not compatible
      # this is a really odd case
      return 0 unless defined $self->$metaclass_type;
  
      return $self->$metaclass_type->_is_compatible_with($super_meta->$metaclass_type);
  }
  
  sub _fix_metaclass_incompatibility {
      my $self = shift;
      my @supers = map { Class::MOP::Class->initialize($_) } @_;
  
      my $necessary = 0;
      for my $super (@supers) {
          $necessary = 1
              if $self->_can_fix_metaclass_incompatibility($super);
      }
      return unless $necessary;
  
      for my $super (@supers) {
          if (!$self->_class_metaclass_is_compatible($super->name)) {
              $self->_fix_class_metaclass_incompatibility($super);
          }
      }
  
      my %base_metaclass = $self->_base_metaclasses;
      for my $metaclass_type (keys %base_metaclass) {
          for my $super (@supers) {
              if (!$self->_single_metaclass_is_compatible($metaclass_type, $super->name)) {
                  $self->_fix_single_metaclass_incompatibility(
                      $metaclass_type, $super
                  );
              }
          }
      }
  }
  
  sub _can_fix_metaclass_incompatibility {
      my $self = shift;
      my ($super_meta) = @_;
  
      return 1 if $self->_class_metaclass_can_be_made_compatible($super_meta);
  
      my %base_metaclass = $self->_base_metaclasses;
      for my $metaclass_type (keys %base_metaclass) {
          return 1 if $self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type);
      }
  
      return;
  }
  
  sub _class_metaclass_can_be_made_compatible {
      my $self = shift;
      my ($super_meta) = @_;
  
      return $self->_can_be_made_compatible_with($super_meta->_real_ref_name);
  }
  
  sub _single_metaclass_can_be_made_compatible {
      my $self = shift;
      my ($super_meta, $metaclass_type) = @_;
  
      my $specific_meta = $self->$metaclass_type;
  
      return unless $super_meta->can($metaclass_type);
      my $super_specific_meta = $super_meta->$metaclass_type;
  
      # for instance, Moose::Meta::Class has a destructor_class, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return unless defined $super_specific_meta;
  
      # if metaclass is defined in superclass but not here, it's fixable
      # this is a really odd case
      return 1 unless defined $specific_meta;
  
      return 1 if $specific_meta->_can_be_made_compatible_with($super_specific_meta);
  }
  
  sub _fix_class_metaclass_incompatibility {
      my $self = shift;
      my ( $super_meta ) = @_;
  
      if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
          ($self->is_pristine)
              || $self->_throw_exception( CannotFixMetaclassCompatibility => class_name => $self->name,
                                                                     superclass => $super_meta
                                );
  
          my $super_meta_name = $super_meta->_real_ref_name;
  
          $self->_make_compatible_with($super_meta_name);
      }
  }
  
  sub _fix_single_metaclass_incompatibility {
      my $self = shift;
      my ( $metaclass_type, $super_meta ) = @_;
  
      if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
          ($self->is_pristine)
              || $self->_throw_exception( CannotFixMetaclassCompatibility => class_name     => $self->name,
                                                                     superclass     => $super_meta,
                                                                     metaclass_type => $metaclass_type
                                );
  
          my $new_metaclass = $self->$metaclass_type
              ? $self->$metaclass_type->_get_compatible_metaclass($super_meta->$metaclass_type)
              : $super_meta->$metaclass_type;
          $self->{$metaclass_type} = $new_metaclass;
      }
  }
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->_restore_metamethods_from($old_meta);
      $self->_restore_metaattributes_from($old_meta);
  }
  
  sub _remove_generated_metaobjects {
      my $self = shift;
  
      for my $attr (map { $self->get_attribute($_) } $self->get_attribute_list) {
          $attr->remove_accessors;
      }
  }
  
  # creating classes with MOP ...
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{superclasses} eq 'ARRAY')
          || __PACKAGE__->_throw_exception( CreateMOPClassTakesArrayRefOfSuperclasses => class  => $class,
                                                                           params => \%options
                            )
              if exists $options{superclasses};
  
      (ref $options{attributes} eq 'ARRAY')
          || __PACKAGE__->_throw_exception( CreateMOPClassTakesArrayRefOfAttributes => class  => $class,
                                                                         params => \%options
                            )
              if exists $options{attributes};
  
      (ref $options{methods} eq 'HASH')
          || __PACKAGE__->_throw_exception( CreateMOPClassTakesHashRefOfMethods => class  => $class,
                                                                     params => \%options
                            )
              if exists $options{methods};
  
      my $package      = delete $options{package};
      my $superclasses = delete $options{superclasses};
      my $attributes   = delete $options{attributes};
      my $methods      = delete $options{methods};
      my $meta_name    = exists $options{meta_name}
                           ? delete $options{meta_name}
                           : 'meta';
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  
      $meta->superclasses(@{$superclasses})
          if defined $superclasses;
      # NOTE:
      # process attributes first, so that they can
      # install accessors, but locally defined methods
      # can then overwrite them. It is maybe a little odd, but
      # I think this should be the order of things.
      if (defined $attributes) {
          foreach my $attr (@{$attributes}) {
              $meta->add_attribute($attr);
          }
      }
      if (defined $methods) {
          foreach my $method_name (keys %{$methods}) {
              $meta->add_method($method_name, $methods->{$method_name});
          }
      }
      return $meta;
  }
  
  # XXX: something more intelligent here?
  sub _anon_package_prefix { 'Class::MOP::Class::__ANON__::SERIAL::' }
  
  sub create_anon_class { shift->create_anon(@_) }
  sub is_anon_class     { shift->is_anon(@_)     }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
      # Makes something like Super::Class|Super::Class::2
      return join '=' => (
          join( '|', sort @{ $options{superclasses} || [] } ),
      );
  }
  
  # Instance Construction & Cloning
  
  sub new_object {
      my $class = shift;
  
      # NOTE:
      # we need to protect the integrity of the
      # Class::MOP::Class singletons here, so we
      # delegate this to &construct_class_instance
      # which will deal with the singletons
      return $class->_construct_class_instance(@_)
          if $class->name->isa('Class::MOP::Class');
      return $class->_construct_instance(@_);
  }
  
  sub _construct_instance {
      my $class = shift;
      my $params = @_ == 1 ? $_[0] : {@_};
      my $meta_instance = $class->get_meta_instance();
      # FIXME:
      # the code below is almost certainly incorrect
      # but this is foreign inheritance, so we might
      # have to kludge it in the end.
      my $instance;
      if (my $instance_class = blessed($params->{__INSTANCE__})) {
          ($instance_class eq $class->name)
              || $class->_throw_exception( InstanceBlessedIntoWrongClass => class_name => $class->name,
                                                                   params     => $params,
                                                                   instance   => $params->{__INSTANCE__}
                                );
          $instance = $params->{__INSTANCE__};
      }
      elsif (exists $params->{__INSTANCE__}) {
          $class->_throw_exception( InstanceMustBeABlessedReference => class_name => $class->name,
                                                              params     => $params,
                                                              instance   => $params->{__INSTANCE__}
                         );
      }
      else {
          $instance = $meta_instance->create_instance();
      }
      foreach my $attr ($class->get_all_attributes()) {
          $attr->initialize_instance_slot($meta_instance, $instance, $params);
      }
      if (Class::MOP::metaclass_is_weak($class->name)) {
          $meta_instance->_set_mop_slot($instance, $class);
      }
      return $instance;
  }
  
  sub _inline_new_object {
      my $self = shift;
  
      return (
          'my $class = shift;',
          '$class = Scalar::Util::blessed($class) || $class;',
          $self->_inline_fallback_constructor('$class'),
          $self->_inline_params('$params', '$class'),
          $self->_inline_generate_instance('$instance', '$class'),
          $self->_inline_slot_initializers,
          $self->_inline_preserve_weak_metaclasses,
          $self->_inline_extra_init,
          'return $instance',
      );
  }
  
  sub _inline_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return (
          'return ' . $self->_generate_fallback_constructor($class),
              'if ' . $class . ' ne \'' . $self->name . '\';',
      );
  }
  
  sub _generate_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return 'Class::MOP::Class->initialize(' . $class . ')->new_object(@_)',
  }
  
  sub _inline_params {
      my $self = shift;
      my ($params, $class) = @_;
      return (
          'my ' . $params . ' = @_ == 1 ? $_[0] : {@_};',
      );
  }
  
  sub _inline_generate_instance {
      my $self = shift;
      my ($inst, $class) = @_;
      return (
          'my ' . $inst . ' = ' . $self->_inline_create_instance($class) . ';',
      );
  }
  
  sub _inline_create_instance {
      my $self = shift;
  
      return $self->get_meta_instance->inline_create_instance(@_);
  }
  
  sub _inline_slot_initializers {
      my $self = shift;
  
      my $idx = 0;
  
      return map { $self->_inline_slot_initializer($_, $idx++) }
                 sort { $a->name cmp $b->name } $self->get_all_attributes;
  }
  
  sub _inline_slot_initializer {
      my $self  = shift;
      my ($attr, $idx) = @_;
  
      if (defined(my $init_arg = $attr->init_arg)) {
          my @source = (
              'if (exists $params->{\'' . $init_arg . '\'}) {',
                  $self->_inline_init_attr_from_constructor($attr, $idx),
              '}',
          );
          if (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
              push @source, (
                  'else {',
                      @default,
                  '}',
              );
          }
          return @source;
      }
      elsif (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
          return (
              '{',
                  @default,
              '}',
          );
      }
      else {
          return ();
      }
  }
  
  sub _inline_init_attr_from_constructor {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my @initial_value = $attr->_inline_set_value(
          '$instance', '$params->{\'' . $attr->init_arg . '\'}',
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_init_attr_from_default {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my $default = $self->_inline_default_value($attr, $idx);
      return unless $default;
  
      my @initial_value = $attr->_inline_set_value('$instance', $default);
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_default_value {
      my $self = shift;
      my ($attr, $index) = @_;
  
      if ($attr->has_default) {
          # NOTE:
          # default values can either be CODE refs
          # in which case we need to call them. Or
          # they can be scalars (strings/numbers)
          # in which case we can just deal with them
          # in the code we eval.
          if ($attr->is_default_a_coderef) {
              return '$defaults->[' . $index . ']->($instance)';
          }
          else {
              return '$defaults->[' . $index . ']';
          }
      }
      elsif ($attr->has_builder) {
          return '$instance->' . $attr->builder;
      }
      else {
          return;
      }
  }
  
  sub _inline_preserve_weak_metaclasses {
      my $self = shift;
      if (Class::MOP::metaclass_is_weak($self->name)) {
          return (
              $self->_inline_set_mop_slot(
                  '$instance', 'Class::MOP::class_of($class)'
              ) . ';'
          );
      }
      else {
          return ();
      }
  }
  
  sub _inline_extra_init { }
  
  sub _eval_environment {
      my $self = shift;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
  
      my $defaults = [map { $_->default } @attrs];
  
      return {
          '$defaults' => \$defaults,
      };
  }
  
  
  sub get_meta_instance {
      my $self = shift;
      $self->{'_meta_instance'} ||= $self->_create_meta_instance();
  }
  
  sub _create_meta_instance {
      my $self = shift;
  
      my $instance = $self->instance_metaclass->new(
          associated_metaclass => $self,
          attributes => [ $self->get_all_attributes() ],
      );
  
      $self->add_meta_instance_dependencies()
          if $instance->is_dependent_on_superclasses();
  
      return $instance;
  }
  
  # TODO: this is actually not being used!
  sub _inline_rebless_instance {
      my $self = shift;
  
      return $self->get_meta_instance->inline_rebless_instance_structure(@_);
  }
  
  sub _inline_get_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_get_mop_slot(@_);
  }
  
  sub _inline_set_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_set_mop_slot(@_);
  }
  
  sub _inline_clear_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_clear_mop_slot(@_);
  }
  
  sub clone_object {
      my $class    = shift;
      my $instance = shift;
      (blessed($instance) && $instance->isa($class->name))
          || $class->_throw_exception( CloneObjectExpectsAnInstanceOfMetaclass => class_name => $class->name,
                                                                         instance   => $instance,
                            );
      # NOTE:
      # we need to protect the integrity of the
      # Class::MOP::Class singletons here, they
      # should not be cloned.
      return $instance if $instance->isa('Class::MOP::Class');
      $class->_clone_instance($instance, @_);
  }
  
  sub _clone_instance {
      my ($class, $instance, %params) = @_;
      (blessed($instance))
          || $class->_throw_exception( OnlyInstancesCanBeCloned => class_name => $class->name,
                                                          instance   => $instance,
                                                          params     => \%params
                            );
      my $meta_instance = $class->get_meta_instance();
      my $clone = $meta_instance->clone_instance($instance);
      foreach my $attr ($class->get_all_attributes()) {
          if ( defined( my $init_arg = $attr->init_arg ) ) {
              if (exists $params{$init_arg}) {
                  $attr->set_value($clone, $params{$init_arg});
              }
          }
      }
      return $clone;
  }
  
  sub _force_rebless_instance {
      my ($self, $instance, %params) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
  
      $old_metaclass->rebless_instance_away($instance, $self, %params)
          if $old_metaclass;
  
      my $meta_instance = $self->get_meta_instance;
  
      if (Class::MOP::metaclass_is_weak($old_metaclass->name)) {
          $meta_instance->_clear_mop_slot($instance);
      }
  
      # rebless!
      # we use $_[1] here because of t/cmop/rebless_overload.t regressions
      # on 5.8.8
      $meta_instance->rebless_instance_structure($_[1], $self);
  
      $self->_fixup_attributes_after_rebless($instance, $old_metaclass, %params);
  
      if (Class::MOP::metaclass_is_weak($self->name)) {
          $meta_instance->_set_mop_slot($instance, $self);
      }
  }
  
  sub rebless_instance {
      my ($self, $instance, %params) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
  
      my $old_class = $old_metaclass ? $old_metaclass->name : blessed($instance);
      $self->name->isa($old_class)
          || $self->_throw_exception( CanReblessOnlyIntoASubclass => class_name     => $self->name,
                                                             instance       => $instance,
                                                             instance_class => blessed( $instance ),
                                                             params         => \%params,
                            );
  
      $self->_force_rebless_instance($_[1], %params);
  
      return $instance;
  }
  
  sub rebless_instance_back {
      my ( $self, $instance ) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
      my $old_class
          = $old_metaclass ? $old_metaclass->name : blessed($instance);
      $old_class->isa( $self->name )
          || $self->_throw_exception( CanReblessOnlyIntoASuperclass => class_name     => $self->name,
                                                               instance       => $instance,
                                                               instance_class => blessed( $instance ),
                            );
  
      $self->_force_rebless_instance($_[1]);
  
      return $instance;
  }
  
  sub rebless_instance_away {
      # this intentionally does nothing, it is just a hook
  }
  
  sub _fixup_attributes_after_rebless {
      my $self = shift;
      my ($instance, $rebless_from, %params) = @_;
      my $meta_instance = $self->get_meta_instance;
  
      for my $attr ( $rebless_from->get_all_attributes ) {
          next if $self->find_attribute_by_name( $attr->name );
          $meta_instance->deinitialize_slot( $instance, $_ ) for $attr->slots;
      }
  
      foreach my $attr ( $self->get_all_attributes ) {
          if ( $attr->has_value($instance) ) {
              if ( defined( my $init_arg = $attr->init_arg ) ) {
                  $params{$init_arg} = $attr->get_value($instance)
                      unless exists $params{$init_arg};
              }
              else {
                  $attr->set_value($instance, $attr->get_value($instance));
              }
          }
      }
  
      foreach my $attr ($self->get_all_attributes) {
          $attr->initialize_instance_slot($meta_instance, $instance, \%params);
      }
  }
  
  sub _attach_attribute {
      my ($self, $attribute) = @_;
      $attribute->attach_to_class($self);
  }
  
  sub _post_add_attribute {
      my ( $self, $attribute ) = @_;
  
      $self->invalidate_meta_instances;
  
      # invalidate package flag here
      try {
          local $SIG{__DIE__};
          $attribute->install_accessors;
      }
      catch {
          $self->remove_attribute( $attribute->name );
          die $_;
      };
  }
  
  sub remove_attribute {
      my $self = shift;
  
      my $removed_attribute = $self->SUPER::remove_attribute(@_)
          or return;
  
      $self->invalidate_meta_instances;
  
      $removed_attribute->remove_accessors;
      $removed_attribute->detach_from_class;
  
      return$removed_attribute;
  }
  
  sub find_attribute_by_name {
      my ( $self, $attr_name ) = @_;
  
      foreach my $class ( $self->linearized_isa ) {
          # fetch the meta-class ...
          my $meta = Class::MOP::Class->initialize($class);
          return $meta->get_attribute($attr_name)
              if $meta->has_attribute($attr_name);
      }
  
      return;
  }
  
  sub get_all_attributes {
      my $self = shift;
      my %attrs = map { %{ Class::MOP::Class->initialize($_)->_attribute_map } }
          reverse $self->linearized_isa;
      return values %attrs;
  }
  
  # Inheritance
  
  sub superclasses {
      my $self     = shift;
  
      my $isa = $self->get_or_add_package_symbol('@ISA');
  
      if (@_) {
          my @supers = @_;
          @{$isa} = @supers;
  
          # NOTE:
          # on 5.8 and below, we need to call
          # a method to get Perl to detect
          # a cycle in the class hierarchy
          my $class = $self->name;
          $class->isa($class);
  
          # NOTE:
          # we need to check the metaclass
          # compatibility here so that we can
          # be sure that the superclass is
          # not potentially creating an issues
          # we don't know about
  
          $self->_check_metaclass_compatibility();
          $self->_superclasses_updated();
      }
  
      return @{$isa};
  }
  
  sub _superclasses_updated {
      my $self = shift;
      $self->update_meta_instance_dependencies();
      # keep strong references to all our parents, so they don't disappear if
      # they are anon classes and don't have any direct instances
      $self->_superclass_metas(
          map { Class::MOP::class_of($_) } $self->superclasses
      );
  }
  
  sub _superclass_metas {
      my $self = shift;
      $self->{_superclass_metas} = [@_];
  }
  
  sub subclasses {
      my $self = shift;
      my $super_class = $self->name;
  
      return @{ $super_class->mro::get_isarev() };
  }
  
  sub direct_subclasses {
      my $self = shift;
      my $super_class = $self->name;
  
      return grep {
          grep {
              $_ eq $super_class
          } Class::MOP::Class->initialize($_)->superclasses
      } $self->subclasses;
  }
  
  sub linearized_isa {
      return @{ mro::get_linear_isa( (shift)->name ) };
  }
  
  sub class_precedence_list {
      my $self = shift;
      my $name = $self->name;
  
      unless (Class::MOP::IS_RUNNING_ON_5_10()) {
          # NOTE:
          # We need to check for circular inheritance here
          # if we are not on 5.10, cause 5.8 detects it late.
          # This will do nothing if all is well, and blow up
          # otherwise. Yes, it's an ugly hack, better
          # suggestions are welcome.
          # - SL
          ($name || return)->isa('This is a test for circular inheritance')
      }
  
      # if our mro is c3, we can
      # just grab the linear_isa
      if (mro::get_mro($name) eq 'c3') {
          return @{ mro::get_linear_isa($name) }
      }
      else {
          # NOTE:
          # we can't grab the linear_isa for dfs
          # since it has all the duplicates
          # already removed.
          return (
              $name,
              map {
                  Class::MOP::Class->initialize($_)->class_precedence_list()
              } $self->superclasses()
          );
      }
  }
  
  sub _method_lookup_order {
      return (shift->linearized_isa, 'UNIVERSAL');
  }
  
  ## Methods
  
  {
      my $fetch_and_prepare_method = sub {
          my ($self, $method_name) = @_;
          my $wrapped_metaclass = $self->wrapped_method_metaclass;
          # fetch it locally
          my $method = $self->get_method($method_name);
          # if we don't have local ...
          unless ($method) {
              # try to find the next method
              $method = $self->find_next_method_by_name($method_name);
              # die if it does not exist
              (defined $method)
                  || $self->_throw_exception( MethodNameNotFoundInInheritanceHierarchy => class_name  => $self->name,
                                                                                  method_name => $method_name
                                    );
              # and now make sure to wrap it
              # even if it is already wrapped
              # because we need a new sub ref
              $method = $wrapped_metaclass->wrap($method,
                  package_name => $self->name,
                  name         => $method_name,
              );
          }
          else {
              # now make sure we wrap it properly
              $method = $wrapped_metaclass->wrap($method,
                  package_name => $self->name,
                  name         => $method_name,
              ) unless $method->isa($wrapped_metaclass);
          }
          $self->add_method($method_name => $method);
          return $method;
      };
  
      sub add_before_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || $self->_throw_exception( MethodModifierNeedsMethodName => class_name => $self->name );
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_before_modifier(
              subname(':before' => $method_modifier)
          );
      }
  
      sub add_after_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || $self->_throw_exception( MethodModifierNeedsMethodName => class_name => $self->name );
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_after_modifier(
              subname(':after' => $method_modifier)
          );
      }
  
      sub add_around_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || $self->_throw_exception( MethodModifierNeedsMethodName => class_name => $self->name );
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_around_modifier(
              subname(':around' => $method_modifier)
          );
      }
  
      # NOTE:
      # the methods above used to be named like this:
      #    ${pkg}::${method}:(before|after|around)
      # but this proved problematic when using one modifier
      # to wrap multiple methods (something which is likely
      # to happen pretty regularly IMO). So instead of naming
      # it like this, I have chosen to just name them purely
      # with their modifier names, like so:
      #    :(before|after|around)
      # The fact is that in a stack trace, it will be fairly
      # evident from the context what method they are attached
      # to, and so don't need the fully qualified name.
  }
  
  sub find_method_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || $self->_throw_exception( MethodNameNotGiven => class_name => $self->name );
      foreach my $class ($self->_method_lookup_order) {
          my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
          return $method if defined $method;
      }
      return;
  }
  
  sub get_all_methods {
      my $self = shift;
  
      my %methods;
      for my $class ( reverse $self->_method_lookup_order ) {
          my $meta = Class::MOP::Class->initialize($class);
  
          $methods{ $_->name } = $_ for $meta->_get_local_methods;
      }
  
      return values %methods;
  }
  
  sub get_all_method_names {
      my $self = shift;
      map { $_->name } $self->get_all_methods;
  }
  
  sub find_all_methods_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || $self->_throw_exception( MethodNameNotGiven => class_name => $self->name );
      my @methods;
      foreach my $class ($self->_method_lookup_order) {
          # fetch the meta-class ...
          my $meta = Class::MOP::Class->initialize($class);
          push @methods => {
              name  => $method_name,
              class => $class,
              code  => $meta->get_method($method_name)
          } if $meta->has_method($method_name);
      }
      return @methods;
  }
  
  sub find_next_method_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || $self->_throw_exception( MethodNameNotGiven => class_name => $self->name );
      my @cpl = ($self->_method_lookup_order);
      shift @cpl; # discard ourselves
      foreach my $class (@cpl) {
          my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
          return $method if defined $method;
      }
      return;
  }
  
  sub update_meta_instance_dependencies {
      my $self = shift;
  
      if ( $self->{meta_instance_dependencies} ) {
          return $self->add_meta_instance_dependencies;
      }
  }
  
  sub add_meta_instance_dependencies {
      my $self = shift;
  
      $self->remove_meta_instance_dependencies;
  
      my @attrs = $self->get_all_attributes();
  
      my %seen;
      my @classes = grep { not $seen{ $_->name }++ }
          map { $_->associated_class } @attrs;
  
      foreach my $class (@classes) {
          $class->add_dependent_meta_instance($self);
      }
  
      $self->{meta_instance_dependencies} = \@classes;
  }
  
  sub remove_meta_instance_dependencies {
      my $self = shift;
  
      if ( my $classes = delete $self->{meta_instance_dependencies} ) {
          foreach my $class (@$classes) {
              $class->remove_dependent_meta_instance($self);
          }
  
          return $classes;
      }
  
      return;
  
  }
  
  sub add_dependent_meta_instance {
      my ( $self, $metaclass ) = @_;
      push @{ $self->{dependent_meta_instances} }, $metaclass;
  }
  
  sub remove_dependent_meta_instance {
      my ( $self, $metaclass ) = @_;
      my $name = $metaclass->name;
      @$_ = grep { $_->name ne $name } @$_
          for $self->{dependent_meta_instances};
  }
  
  sub invalidate_meta_instances {
      my $self = shift;
      $_->invalidate_meta_instance()
          for $self, @{ $self->{dependent_meta_instances} };
  }
  
  sub invalidate_meta_instance {
      my $self = shift;
      undef $self->{_meta_instance};
  }
  
  # check if we can reinitialize
  sub is_pristine {
      my $self = shift;
  
      # if any local attr is defined
      return if $self->get_attribute_list;
  
      # or any non-declared methods
      for my $method ( map { $self->get_method($_) } $self->get_method_list ) {
          return if $method->isa("Class::MOP::Method::Generated");
          # FIXME do we need to enforce this too? return unless $method->isa( $self->method_metaclass );
      }
  
      return 1;
  }
  
  ## Class closing
  
  sub is_mutable   { 1 }
  sub is_immutable { 0 }
  
  sub immutable_options { %{ $_[0]{__immutable}{options} || {} } }
  
  sub _immutable_options {
      my ( $self, @args ) = @_;
  
      return (
          inline_accessors   => 1,
          inline_constructor => 1,
          inline_destructor  => 0,
          debug              => 0,
          immutable_trait    => $self->immutable_trait,
          constructor_name   => $self->constructor_name,
          constructor_class  => $self->constructor_class,
          destructor_class   => $self->destructor_class,
          @args,
      );
  }
  
  sub make_immutable {
      my ( $self, @args ) = @_;
  
      return $self unless $self->is_mutable;
  
      my ($file, $line) = (caller)[1..2];
  
      $self->_initialize_immutable(
          file => $file,
          line => $line,
          $self->_immutable_options(@args),
      );
      $self->_rebless_as_immutable(@args);
  
      return $self;
  }
  
  sub make_mutable {
      my $self = shift;
  
      if ( $self->is_immutable ) {
          my @args = $self->immutable_options;
          $self->_rebless_as_mutable();
          $self->_remove_inlined_code(@args);
          delete $self->{__immutable};
          return $self;
      }
      else {
          return;
      }
  }
  
  sub _rebless_as_immutable {
      my ( $self, @args ) = @_;
  
      $self->{__immutable}{original_class} = ref $self;
  
      bless $self => $self->_immutable_metaclass(@args);
  }
  
  sub _immutable_metaclass {
      my ( $self, %args ) = @_;
  
      if ( my $class = $args{immutable_metaclass} ) {
          return $class;
      }
  
      my $trait = $args{immutable_trait} = $self->immutable_trait
          || $self->_throw_exception( NoImmutableTraitSpecifiedForClass => class_name => $self->name,
                                                                   params     => \%args
                            );
  
      my $meta      = $self->meta;
      my $meta_attr = $meta->find_attribute_by_name("immutable_trait");
  
      my $class_name;
  
      if ( $meta_attr and $trait eq $meta_attr->default ) {
          # if the trait is the same as the default we try and pick a
          # predictable name for the immutable metaclass
          $class_name = 'Class::MOP::Class::Immutable::' . ref($self);
      }
      else {
          $class_name = join '::', 'Class::MOP::Class::Immutable::CustomTrait',
              $trait, 'ForMetaClass', ref($self);
      }
  
      return $class_name
          if Class::MOP::does_metaclass_exist($class_name);
  
      # If the metaclass is a subclass of CMOP::Class which has had
      # metaclass roles applied (via Moose), then we want to make sure
      # that we preserve that anonymous class (see Fey::ORM for an
      # example of where this matters).
      my $meta_name = $meta->_real_ref_name;
  
      my $immutable_meta = $meta_name->create(
          $class_name,
          superclasses => [ ref $self ],
      );
  
      Class::MOP::MiniTrait::apply( $immutable_meta, $trait );
  
      $immutable_meta->make_immutable(
          inline_constructor => 0,
          inline_accessors   => 0,
      );
  
      return $class_name;
  }
  
  sub _remove_inlined_code {
      my $self = shift;
  
      $self->remove_method( $_->name ) for $self->_inlined_methods;
  
      delete $self->{__immutable}{inlined_methods};
  }
  
  sub _inlined_methods { @{ $_[0]{__immutable}{inlined_methods} || [] } }
  
  sub _add_inlined_method {
      my ( $self, $method ) = @_;
  
      push @{ $self->{__immutable}{inlined_methods} ||= [] }, $method;
  }
  
  sub _initialize_immutable {
      my ( $self, %args ) = @_;
  
      $self->{__immutable}{options} = \%args;
      $self->_install_inlined_code(%args);
  }
  
  sub _install_inlined_code {
      my ( $self, %args ) = @_;
  
      # FIXME
      $self->_inline_accessors(%args)   if $args{inline_accessors};
      $self->_inline_constructor(%args) if $args{inline_constructor};
      $self->_inline_destructor(%args)  if $args{inline_destructor};
  }
  
  sub _rebless_as_mutable {
      my $self = shift;
  
      bless $self, $self->_get_mutable_metaclass_name;
  
      return $self;
  }
  
  sub _inline_accessors {
      my $self = shift;
  
      foreach my $attr_name ( $self->get_attribute_list ) {
          $self->get_attribute($attr_name)->install_accessors(1);
      }
  }
  
  sub _inline_constructor {
      my ( $self, %args ) = @_;
  
      my $name = $args{constructor_name};
      # A class may not even have a constructor, and that's okay.
      return unless defined $name;
  
      if ( $self->has_method($name) && !$args{replace_constructor} ) {
          my $class = $self->name;
          warn "Not inlining a constructor for $class since it defines"
              . " its own constructor.\n"
              . "If you are certain you don't need to inline your"
              . " constructor, specify inline_constructor => 0 in your"
              . " call to $class->meta->make_immutable\n";
          return;
      }
  
      my $constructor_class = $args{constructor_class};
  
      {
          local $@;
          use_package_optimistically($constructor_class);
      }
  
      my $constructor = $constructor_class->new(
          options      => \%args,
          metaclass    => $self,
          is_inline    => 1,
          package_name => $self->name,
          name         => $name,
          definition_context => {
              description => "constructor " . $self->name . "::" . $name,
              file        => $args{file},
              line        => $args{line},
          },
      );
  
      if ( $args{replace_constructor} or $constructor->can_be_inlined ) {
          $self->add_method( $name => $constructor );
          $self->_add_inlined_method($constructor);
      }
  }
  
  sub _inline_destructor {
      my ( $self, %args ) = @_;
  
      ( exists $args{destructor_class} && defined $args{destructor_class} )
          || $self->_throw_exception( NoDestructorClassSpecified => class_name => $self->name,
                                                            params     => \%args,
                            );
  
      if ( $self->has_method('DESTROY') && ! $args{replace_destructor} ) {
          my $class = $self->name;
          warn "Not inlining a destructor for $class since it defines"
              . " its own destructor.\n";
          return;
      }
  
      my $destructor_class = $args{destructor_class};
  
      {
          local $@;
          use_package_optimistically($destructor_class);
      }
  
      return unless $destructor_class->is_needed($self);
  
      my $destructor = $destructor_class->new(
          options      => \%args,
          metaclass    => $self,
          package_name => $self->name,
          name         => 'DESTROY',
          definition_context => {
              description => "destructor " . $self->name . "::DESTROY",
              file        => $args{file},
              line        => $args{line},
          },
      );
  
      if ( $args{replace_destructor} or $destructor->can_be_inlined ) {
          $self->add_method( 'DESTROY' => $destructor );
          $self->_add_inlined_method($destructor);
      }
  }
  
  1;
  
  # ABSTRACT: Class Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Class - Class Meta Object
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    # assuming that class Foo
    # has been defined, you can
  
    # use this for introspection ...
  
    # add a method to Foo ...
    Foo->meta->add_method( 'bar' => sub {...} )
  
    # get a list of all the classes searched
    # the method dispatcher in the correct order
    Foo->meta->class_precedence_list()
  
    # remove a method from Foo
    Foo->meta->remove_method('bar');
  
    # or use this to actually create classes ...
  
    Class::MOP::Class->create(
        'Bar' => (
            version      => '0.01',
            superclasses => ['Foo'],
            attributes   => [
                Class::MOP::Attribute->new('$bar'),
                Class::MOP::Attribute->new('$baz'),
            ],
            methods => {
                calculate_bar => sub {...},
                construct_baz => sub {...}
            }
        )
    );
  
  =head1 DESCRIPTION
  
  The Class Protocol is the largest and most complex part of the
  Class::MOP meta-object protocol. It controls the introspection and
  manipulation of Perl 5 classes, and it can create them as well. The
  best way to understand what this module can do is to read the
  documentation for each of its methods.
  
  =head1 INHERITANCE
  
  C<Class::MOP::Class> is a subclass of L<Class::MOP::Module>.
  
  =head1 METHODS
  
  =head2 Class construction
  
  These methods all create new C<Class::MOP::Class> objects. These
  objects can represent existing classes or they can be used to create
  new classes from scratch.
  
  The metaclass object for a given class is a singleton. If you attempt
  to create a metaclass for the same class twice, you will just get the
  existing object.
  
  =over 4
  
  =item B<< Class::MOP::Class->create($package_name, %options) >>
  
  This method creates a new C<Class::MOP::Class> object with the given
  package name. It accepts a number of options:
  
  =over 8
  
  =item * version
  
  An optional version number for the newly created package.
  
  =item * authority
  
  An optional authority for the newly created package.
  See L<Class::MOP::Module/authority> for more details.
  
  =item * superclasses
  
  An optional array reference of superclass names.
  
  =item * methods
  
  An optional hash reference of methods for the class. The keys of the
  hash reference are method names and values are subroutine references.
  
  =item * attributes
  
  An optional array reference of L<Class::MOP::Attribute> objects.
  
  =item * meta_name
  
  Specifies the name to install the C<meta> method for this class under.
  If it is not passed, C<meta> is assumed, and if C<undef> is explicitly
  given, no meta method will be installed.
  
  =item * weaken
  
  If true, the metaclass that is stored in the global cache will be a
  weak reference.
  
  Classes created in this way are destroyed once the metaclass they are
  attached to goes out of scope, and will be removed from Perl's internal
  symbol table.
  
  All instances of a class with a weakened metaclass keep a special
  reference to the metaclass object, which prevents the metaclass from
  going out of scope while any instances exist.
  
  This only works if the instance is based on a hash reference, however.
  
  =back
  
  =item B<< Class::MOP::Class->create_anon_class(%options) >>
  
  This method works just like C<< Class::MOP::Class->create >> but it
  creates an "anonymous" class. In fact, the class does have a name, but
  that name is a unique name generated internally by this module.
  
  It accepts the same C<superclasses>, C<methods>, and C<attributes>
  parameters that C<create> accepts.
  
  It also accepts a C<cache> option. If this is C<true>, then the anonymous class
  will be cached based on its superclasses and roles. If an existing anonymous
  class in the cache has the same superclasses and roles, it will be reused.
  
  Anonymous classes default to C<< weaken => 1 >> if cache is C<false>, although
  this can be overridden.
  
  =item B<< Class::MOP::Class->initialize($package_name, %options) >>
  
  This method will initialize a C<Class::MOP::Class> object for the
  named package. Unlike C<create>, this method I<will not> create a new
  class.
  
  The purpose of this method is to retrieve a C<Class::MOP::Class>
  object for introspecting an existing class.
  
  If an existing C<Class::MOP::Class> object exists for the named
  package, it will be returned, and any options provided will be
  ignored!
  
  If the object does not yet exist, it will be created.
  
  The valid options that can be passed to this method are
  C<attribute_metaclass>, C<method_metaclass>,
  C<wrapped_method_metaclass>, and C<instance_metaclass>. These are all
  optional, and default to the appropriate class in the C<Class::MOP>
  distribution.
  
  =back
  
  =head2 Object instance construction and cloning
  
  These methods are all related to creating and/or cloning object
  instances.
  
  =over 4
  
  =item B<< $metaclass->clone_object($instance, %params) >>
  
  This method clones an existing object instance. Any parameters you
  provide are will override existing attribute values in the object.
  
  This is a convenience method for cloning an object instance, then
  blessing it into the appropriate package.
  
  You could implement a clone method in your class, using this method:
  
    sub clone {
        my ($self, %params) = @_;
        $self->meta->clone_object($self, %params);
    }
  
  =item B<< $metaclass->rebless_instance($instance, %params) >>
  
  This method changes the class of C<$instance> to the metaclass's class.
  
  You can only rebless an instance into a subclass of its current
  class. If you pass any additional parameters, these will be treated
  like constructor parameters and used to initialize the object's
  attributes. Any existing attributes that are already set will be
  overwritten.
  
  Before reblessing the instance, this method will call
  C<rebless_instance_away> on the instance's current metaclass. This method
  will be passed the instance, the new metaclass, and any parameters
  specified to C<rebless_instance>. By default, C<rebless_instance_away>
  does nothing; it is merely a hook.
  
  =item B<< $metaclass->rebless_instance_back($instance) >>
  
  Does the same thing as C<rebless_instance>, except that you can only
  rebless an instance into one of its superclasses. Any attributes that
  do not exist in the superclass will be deinitialized.
  
  This is a much more dangerous operation than C<rebless_instance>,
  especially when multiple inheritance is involved, so use this carefully!
  
  =item B<< $metaclass->new_object(%params) >>
  
  This method is used to create a new object of the metaclass's
  class. Any parameters you provide are used to initialize the
  instance's attributes. A special C<__INSTANCE__> key can be passed to
  provide an already generated instance, rather than having Class::MOP
  generate it for you. This is mostly useful for using Class::MOP with
  foreign classes which generate instances using their own constructors.
  
  =item B<< $metaclass->instance_metaclass >>
  
  Returns the class name of the instance metaclass. See
  L<Class::MOP::Instance> for more information on the instance
  metaclass.
  
  =item B<< $metaclass->get_meta_instance >>
  
  Returns an instance of the C<instance_metaclass> to be used in the
  construction of a new instance of the class.
  
  =back
  
  =head2 Informational predicates
  
  These are a few predicate methods for asking information about the
  class itself.
  
  =over 4
  
  =item B<< $metaclass->is_anon_class >>
  
  This returns true if the class was created by calling C<<
  Class::MOP::Class->create_anon_class >>.
  
  =item B<< $metaclass->is_mutable >>
  
  This returns true if the class is still mutable.
  
  =item B<< $metaclass->is_immutable >>
  
  This returns true if the class has been made immutable.
  
  =item B<< $metaclass->is_pristine >>
  
  A class is I<not> pristine if it has non-inherited attributes or if it
  has any generated methods.
  
  =back
  
  =head2 Inheritance Relationships
  
  =over 4
  
  =item B<< $metaclass->superclasses(@superclasses) >>
  
  This is a read-write accessor which represents the superclass
  relationships of the metaclass's class.
  
  This is basically sugar around getting and setting C<@ISA>.
  
  =item B<< $metaclass->class_precedence_list >>
  
  This returns a list of all of the class's ancestor classes. The
  classes are returned in method dispatch order.
  
  =item B<< $metaclass->linearized_isa >>
  
  This returns a list based on C<class_precedence_list> but with all
  duplicates removed.
  
  =item B<< $metaclass->subclasses >>
  
  This returns a list of all subclasses for this class, even indirect
  subclasses.
  
  =item B<< $metaclass->direct_subclasses >>
  
  This returns a list of immediate subclasses for this class, which does not
  include indirect subclasses.
  
  =back
  
  =head2 Method introspection and creation
  
  These methods allow you to introspect a class's methods, as well as
  add, remove, or change methods.
  
  Determining what is truly a method in a Perl 5 class requires some
  heuristics (aka guessing).
  
  Methods defined outside the package with a fully qualified name (C<sub
  Package::name { ... }>) will be included. Similarly, methods named
  with a fully qualified name using L<Sub::Name> are also included.
  
  However, we attempt to ignore imported functions.
  
  Ultimately, we are using heuristics to determine what truly is a
  method in a class, and these heuristics may get the wrong answer in
  some edge cases. However, for most "normal" cases the heuristics work
  correctly.
  
  =over 4
  
  =item B<< $metaclass->get_method($method_name) >>
  
  This will return a L<Class::MOP::Method> for the specified
  C<$method_name>. If the class does not have the specified method, it
  returns C<undef>
  
  =item B<< $metaclass->has_method($method_name) >>
  
  Returns a boolean indicating whether or not the class defines the
  named method. It does not include methods inherited from parent
  classes.
  
  =item B<< $metaclass->get_method_list >>
  
  This will return a list of method I<names> for all methods defined in
  this class.
  
  =item B<< $metaclass->add_method($method_name, $method) >>
  
  This method takes a method name and a subroutine reference, and adds
  the method to the class.
  
  The subroutine reference can be a L<Class::MOP::Method>, and you are
  strongly encouraged to pass a meta method object instead of a code
  reference. If you do so, that object gets stored as part of the
  class's method map directly. If not, the meta information will have to
  be recreated later, and may be incorrect.
  
  If you provide a method object, this method will clone that object if
  the object's package name does not match the class name. This lets us
  track the original source of any methods added from other classes
  (notably Moose roles).
  
  =item B<< $metaclass->remove_method($method_name) >>
  
  Remove the named method from the class. This method returns the
  L<Class::MOP::Method> object for the method.
  
  =item B<< $metaclass->method_metaclass >>
  
  Returns the class name of the method metaclass, see
  L<Class::MOP::Method> for more information on the method metaclass.
  
  =item B<< $metaclass->wrapped_method_metaclass >>
  
  Returns the class name of the wrapped method metaclass, see
  L<Class::MOP::Method::Wrapped> for more information on the wrapped
  method metaclass.
  
  =item B<< $metaclass->get_all_methods >>
  
  This will traverse the inheritance hierarchy and return a list of all
  the L<Class::MOP::Method> objects for this class and its parents.
  
  =item B<< $metaclass->find_method_by_name($method_name) >>
  
  This will return a L<Class::MOP::Method> for the specified
  C<$method_name>. If the class does not have the specified method, it
  returns C<undef>
  
  Unlike C<get_method>, this method I<will> look for the named method in
  superclasses.
  
  =item B<< $metaclass->get_all_method_names >>
  
  This will return a list of method I<names> for all of this class's
  methods, including inherited methods.
  
  =item B<< $metaclass->find_all_methods_by_name($method_name) >>
  
  This method looks for the named method in the class and all of its
  parents. It returns every matching method it finds in the inheritance
  tree, so it returns a list of methods.
  
  Each method is returned as a hash reference with three keys. The keys
  are C<name>, C<class>, and C<code>. The C<code> key has a
  L<Class::MOP::Method> object as its value.
  
  The list of methods is distinct.
  
  =item B<< $metaclass->find_next_method_by_name($method_name) >>
  
  This method returns the first method in any superclass matching the
  given name. It is effectively the method that C<SUPER::$method_name>
  would dispatch to.
  
  =back
  
  =head2 Attribute introspection and creation
  
  Because Perl 5 does not have a core concept of attributes in classes,
  we can only return information about attributes which have been added
  via this class's methods. We cannot discover information about
  attributes which are defined in terms of "regular" Perl 5 methods.
  
  =over 4
  
  =item B<< $metaclass->get_attribute($attribute_name) >>
  
  This will return a L<Class::MOP::Attribute> for the specified
  C<$attribute_name>. If the class does not have the specified
  attribute, it returns C<undef>.
  
  NOTE that get_attribute does not search superclasses, for that you
  need to use C<find_attribute_by_name>.
  
  =item B<< $metaclass->has_attribute($attribute_name) >>
  
  Returns a boolean indicating whether or not the class defines the
  named attribute. It does not include attributes inherited from parent
  classes.
  
  =item B<< $metaclass->get_attribute_list >>
  
  This will return a list of attributes I<names> for all attributes
  defined in this class.  Note that this operates on the current class
  only, it does not traverse the inheritance hierarchy.
  
  =item B<< $metaclass->get_all_attributes >>
  
  This will traverse the inheritance hierarchy and return a list of all
  the L<Class::MOP::Attribute> objects for this class and its parents.
  
  =item B<< $metaclass->find_attribute_by_name($attribute_name) >>
  
  This will return a L<Class::MOP::Attribute> for the specified
  C<$attribute_name>. If the class does not have the specified
  attribute, it returns C<undef>.
  
  Unlike C<get_attribute>, this attribute I<will> look for the named
  attribute in superclasses.
  
  =item B<< $metaclass->add_attribute(...) >>
  
  This method accepts either an existing L<Class::MOP::Attribute>
  object or parameters suitable for passing to that class's C<new>
  method.
  
  The attribute provided will be added to the class.
  
  Any accessor methods defined by the attribute will be added to the
  class when the attribute is added.
  
  If an attribute of the same name already exists, the old attribute
  will be removed first.
  
  =item B<< $metaclass->remove_attribute($attribute_name) >>
  
  This will remove the named attribute from the class, and
  L<Class::MOP::Attribute> object.
  
  Removing an attribute also removes any accessor methods defined by the
  attribute.
  
  However, note that removing an attribute will only affect I<future>
  object instances created for this class, not existing instances.
  
  =item B<< $metaclass->attribute_metaclass >>
  
  Returns the class name of the attribute metaclass for this class. By
  default, this is L<Class::MOP::Attribute>.
  
  =back
  
  =head2 Overload introspection and creation
  
  These methods provide an API to the core L<overload> functionality.
  
  =over 4
  
  =item B<< $metaclass->is_overloaded >>
  
  Returns true if overloading is enabled for this class. Corresponds to
  L<Devel::OverloadInfo/is_overloaded>.
  
  =item B<< $metaclass->get_overloaded_operator($op) >>
  
  Returns the L<Class::MOP::Overload> object corresponding to the operator named
  C<$op>, if one exists for this class.
  
  =item B<< $metaclass->has_overloaded_operator($op) >>
  
  Returns whether or not the operator C<$op> is overloaded for this class.
  
  =item B<< $metaclass->get_overload_list >>
  
  Returns a list of operator names which have been overloaded (see
  L<overload/Overloadable Operations> for the list of valid operator names).
  
  =item B<< $metaclass->get_all_overloaded_operators >>
  
  Returns a list of L<Class::MOP::Overload> objects corresponding to the
  operators that have been overloaded.
  
  =item B<< $metaclass->add_overloaded_operator($op, $impl) >>
  
  Overloads the operator C<$op> for this class. The C<$impl> can be a coderef, a
  method name, or a L<Class::MOP::Overload> object. Corresponds to
  C<< use overload $op => $impl; >>
  
  =item B<< $metaclass->remove_overloaded_operator($op) >>
  
  Remove overloading for operator C<$op>. Corresponds to C<< no overload $op; >>
  
  =item B<< $metaclass->get_overload_fallback_value >>
  
  Returns the overload C<fallback> setting for the package.
  
  =item B<< $metaclass->set_overload_fallback_value($fallback) >>
  
  Sets the overload C<fallback> setting for the package.
  
  =back
  
  =head2 Class Immutability
  
  Making a class immutable "freezes" the class definition. You can no
  longer call methods which alter the class, such as adding or removing
  methods or attributes.
  
  Making a class immutable lets us optimize the class by inlining some
  methods, and also allows us to optimize some methods on the metaclass
  object itself.
  
  After immutabilization, the metaclass object will cache most informational
  methods that returns information about methods or attributes. Methods which
  would alter the class, such as C<add_attribute> and C<add_method>, will
  throw an error on an immutable metaclass object.
  
  The immutabilization system in L<Moose> takes much greater advantage
  of the inlining features than Class::MOP itself does.
  
  =over 4
  
  =item B<< $metaclass->make_immutable(%options) >>
  
  This method will create an immutable transformer and use it to make
  the class and its metaclass object immutable, and returns true
  (you should not rely on the details of this value apart from its truth).
  
  This method accepts the following options:
  
  =over 8
  
  =item * inline_accessors
  
  =item * inline_constructor
  
  =item * inline_destructor
  
  These are all booleans indicating whether the specified method(s)
  should be inlined.
  
  By default, accessors and the constructor are inlined, but not the
  destructor.
  
  =item * immutable_trait
  
  The name of a class which will be used as a parent class for the
  metaclass object being made immutable. This "trait" implements the
  post-immutability functionality of the metaclass (but not the
  transformation itself).
  
  This defaults to L<Class::MOP::Class::Immutable::Trait>.
  
  =item * constructor_name
  
  This is the constructor method name. This defaults to "new".
  
  =item * constructor_class
  
  The name of the method metaclass for constructors. It will be used to
  generate the inlined constructor. This defaults to
  "Class::MOP::Method::Constructor".
  
  =item * replace_constructor
  
  This is a boolean indicating whether an existing constructor should be
  replaced when inlining a constructor. This defaults to false.
  
  =item * destructor_class
  
  The name of the method metaclass for destructors. It will be used to
  generate the inlined destructor. This defaults to
  "Class::MOP::Method::Denstructor".
  
  =item * replace_destructor
  
  This is a boolean indicating whether an existing destructor should be
  replaced when inlining a destructor. This defaults to false.
  
  =back
  
  =item B<< $metaclass->immutable_options >>
  
  Returns a hash of the options used when making the class immutable, including
  both defaults and anything supplied by the user in the call to C<<
  $metaclass->make_immutable >>. This is useful if you need to temporarily make
  a class mutable and then restore immutability as it was before.
  
  =item B<< $metaclass->make_mutable >>
  
  Calling this method reverse the immutabilization transformation.
  
  =back
  
  =head2 Method Modifiers
  
  Method modifiers are hooks which allow a method to be wrapped with
  I<before>, I<after> and I<around> method modifiers. Every time a
  method is called, its modifiers are also called.
  
  A class can modify its own methods, as well as methods defined in
  parent classes.
  
  =head3 How method modifiers work?
  
  Method modifiers work by wrapping the original method and then
  replacing it in the class's symbol table. The wrappers will handle
  calling all the modifiers in the appropriate order and preserving the
  calling context for the original method.
  
  The return values of C<before> and C<after> modifiers are
  ignored. This is because their purpose is B<not> to filter the input
  and output of the primary method (this is done with an I<around>
  modifier).
  
  This may seem like an odd restriction to some, but doing this allows
  for simple code to be added at the beginning or end of a method call
  without altering the function of the wrapped method or placing any
  extra responsibility on the code of the modifier.
  
  Of course if you have more complex needs, you can use the C<around>
  modifier which allows you to change both the parameters passed to the
  wrapped method, as well as its return value.
  
  Before and around modifiers are called in last-defined-first-called
  order, while after modifiers are called in first-defined-first-called
  order. So the call tree might looks something like this:
  
    before 2
     before 1
      around 2
       around 1
        primary
       around 1
      around 2
     after 1
    after 2
  
  =head3 What is the performance impact?
  
  Of course there is a performance cost associated with method
  modifiers, but we have made every effort to make that cost directly
  proportional to the number of modifier features you use.
  
  The wrapping method does its best to B<only> do as much work as it
  absolutely needs to. In order to do this we have moved some of the
  performance costs to set-up time, where they are easier to amortize.
  
  All this said, our benchmarks have indicated the following:
  
    simple wrapper with no modifiers             100% slower
    simple wrapper with simple before modifier   400% slower
    simple wrapper with simple after modifier    450% slower
    simple wrapper with simple around modifier   500-550% slower
    simple wrapper with all 3 modifiers          1100% slower
  
  These numbers may seem daunting, but you must remember, every feature
  comes with some cost. To put things in perspective, just doing a
  simple C<AUTOLOAD> which does nothing but extract the name of the
  method called and return it costs about 400% over a normal method
  call.
  
  =over 4
  
  =item B<< $metaclass->add_before_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference. The modifier will be called as a method itself, and will
  receive the same arguments as are passed to the method.
  
  When the modifier exits, the wrapped method will be called.
  
  The return value of the modifier will be ignored.
  
  =item B<< $metaclass->add_after_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference. The modifier will be called as a method itself, and will
  receive the same arguments as are passed to the method.
  
  When the wrapped methods exits, the modifier will be called.
  
  The return value of the modifier will be ignored.
  
  =item B<< $metaclass->add_around_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference.
  
  The first argument passed to the modifier will be a subroutine
  reference to the wrapped method. The second argument is the object,
  and after that come any arguments passed when the method is called.
  
  The around modifier can choose to call the original method, as well as
  what arguments to pass if it does so.
  
  The return value of the modifier is what will be seen by the caller.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Class->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_CLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Class/Immutable/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_CLASS_IMMUTABLE_TRAIT';
  package Class::MOP::Class::Immutable::Trait;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use MRO::Compat;
  use Module::Runtime 'use_module';
  
  # the original class of the metaclass instance
  sub _get_mutable_metaclass_name { $_[0]{__immutable}{original_class} }
  
  sub is_mutable   { 0 }
  sub is_immutable { 1 }
  
  sub _immutable_metaclass { ref $_[1] }
  
  sub _immutable_read_only {
      my $name = shift;
      __throw_exception( CallingReadOnlyMethodOnAnImmutableInstance => method_name => $name );
  }
  
  sub _immutable_cannot_call {
      my $name = shift;
      __throw_exception( CallingMethodOnAnImmutableInstance => method_name => $name );
  }
  
  for my $name (qw/superclasses/) {
      no strict 'refs';
      *{__PACKAGE__."::$name"} = sub {
          my $orig = shift;
          my $self = shift;
          _immutable_read_only($name) if @_;
          $self->$orig;
      };
  }
  
  for my $name (qw/add_method alias_method remove_method add_attribute remove_attribute remove_package_symbol add_package_symbol/) {
      no strict 'refs';
      *{__PACKAGE__."::$name"} = sub { _immutable_cannot_call($name) };
  }
  
  sub class_precedence_list {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{class_precedence_list}
              ||= [ $self->$orig ] };
  }
  
  sub linearized_isa {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{linearized_isa} ||= [ $self->$orig ] };
  }
  
  sub get_all_methods {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_methods} ||= [ $self->$orig ] };
  }
  
  sub get_all_method_names {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_method_names} ||= [ $self->$orig ] };
  }
  
  sub get_all_attributes {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_attributes} ||= [ $self->$orig ] };
  }
  
  sub get_meta_instance {
      my $orig = shift;
      my $self = shift;
      $self->{__immutable}{get_meta_instance} ||= $self->$orig;
  }
  
  sub _method_map {
      my $orig = shift;
      my $self = shift;
      $self->{__immutable}{_method_map} ||= $self->$orig;
  }
  
  # private method, for this file only -
  # if we declare a method here, it will behave differently depending on what
  # class this trait is applied to, so we won't have a reliable parameter list.
  sub __throw_exception {
      my ($exception_type, @args_to_exception) = @_;
      die use_module( "Moose::Exception::$exception_type" )->new( @args_to_exception );
  }
  
  1;
  
  # ABSTRACT: Implements immutability for metaclass objects
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Class::Immutable::Trait - Implements immutability for metaclass objects
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class provides a pseudo-trait that is applied to immutable metaclass
  objects. In reality, it is simply a parent class.
  
  It implements caching and read-only-ness for various metaclass methods.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_CLASS_IMMUTABLE_TRAIT

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Deprecated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_DEPRECATED';
  package Class::MOP::Deprecated;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Package::DeprecationManager -deprecations => {
      'Class::Load wrapper functions' => '2.1100',
  };
  
  1;
  
  # ABSTRACT: Manages deprecation warnings for Class::MOP
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Deprecated - Manages deprecation warnings for Class::MOP
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
      use Class::MOP::Deprecated -api_version => $version;
  
  =head1 FUNCTIONS
  
  This module manages deprecation warnings for features that have been
  deprecated in Class::MOP.
  
  If you specify C<< -api_version => $version >>, you can use deprecated features
  without warnings. Note that this special treatment is limited to the package
  that loads C<Class::MOP::Deprecated>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_DEPRECATED

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_INSTANCE';
  package Class::MOP::Instance;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'isweak', 'weaken', 'blessed';
  
  use parent 'Class::MOP::Object';
  
  # make this not a valid method name, to avoid (most) attribute conflicts
  my $RESERVED_MOP_SLOT = '<<MOP>>';
  
  sub BUILDARGS {
      my ($class, @args) = @_;
  
      if ( @args == 1 ) {
          unshift @args, "associated_metaclass";
      } elsif ( @args >= 2 && blessed($args[0]) && $args[0]->isa("Class::MOP::Class") ) {
          # compat mode
          my ( $meta, @attrs ) = @args;
          @args = ( associated_metaclass => $meta, attributes => \@attrs );
      }
  
      my %options = @args;
      # FIXME lazy_build
      $options{slots} ||= [ map { $_->slots } @{ $options{attributes} || [] } ];
      $options{slot_hash} = { map { $_ => undef } @{ $options{slots} } }; # FIXME lazy_build
  
      return \%options;
  }
  
  sub new {
      my $class = shift;
      my $options = $class->BUILDARGS(@_);
  
      # FIXME replace with a proper constructor
      my $instance = $class->_new(%$options);
  
      # FIXME weak_ref => 1,
      weaken($instance->{'associated_metaclass'});
  
      return $instance;
  }
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
      return bless {
          # NOTE:
          # I am not sure that it makes
          # sense to pass in the meta
          # The ideal would be to just
          # pass in the class name, but
          # that is placing too much of
          # an assumption on bless(),
          # which is *probably* a safe
          # assumption,.. but you can
          # never tell <:)
          'associated_metaclass' => $params->{associated_metaclass},
          'attributes'           => $params->{attributes},
          'slots'                => $params->{slots},
          'slot_hash'            => $params->{slot_hash},
      } => $class;
  }
  
  sub _class_name { $_[0]->{_class_name} ||= $_[0]->associated_metaclass->name }
  
  sub create_instance {
      my $self = shift;
      bless {}, $self->_class_name;
  }
  
  sub clone_instance {
      my ($self, $instance) = @_;
  
      my $clone = $self->create_instance;
      for my $attr ($self->get_all_attributes) {
          next unless $attr->has_value($instance);
          for my $slot ($attr->slots) {
              my $val = $self->get_slot_value($instance, $slot);
              $self->set_slot_value($clone, $slot, $val);
              $self->weaken_slot_value($clone, $slot)
                  if $self->slot_value_is_weak($instance, $slot);
          }
      }
  
      $self->_set_mop_slot($clone, $self->_get_mop_slot($instance))
          if $self->_has_mop_slot($instance);
  
      return $clone;
  }
  
  # operations on meta instance
  
  sub get_all_slots {
      my $self = shift;
      return @{$self->{'slots'}};
  }
  
  sub get_all_attributes {
      my $self = shift;
      return @{$self->{attributes}};
  }
  
  sub is_valid_slot {
      my ($self, $slot_name) = @_;
      exists $self->{'slot_hash'}->{$slot_name};
  }
  
  # operations on created instances
  
  sub get_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $instance->{$slot_name};
  }
  
  sub set_slot_value {
      my ($self, $instance, $slot_name, $value) = @_;
      $instance->{$slot_name} = $value;
  }
  
  sub initialize_slot {
      my ($self, $instance, $slot_name) = @_;
      return;
  }
  
  sub deinitialize_slot {
      my ( $self, $instance, $slot_name ) = @_;
      delete $instance->{$slot_name};
  }
  
  sub initialize_all_slots {
      my ($self, $instance) = @_;
      foreach my $slot_name ($self->get_all_slots) {
          $self->initialize_slot($instance, $slot_name);
      }
  }
  
  sub deinitialize_all_slots {
      my ($self, $instance) = @_;
      foreach my $slot_name ($self->get_all_slots) {
          $self->deinitialize_slot($instance, $slot_name);
      }
  }
  
  sub is_slot_initialized {
      my ($self, $instance, $slot_name, $value) = @_;
      exists $instance->{$slot_name};
  }
  
  sub weaken_slot_value {
      my ($self, $instance, $slot_name) = @_;
      weaken $instance->{$slot_name};
  }
  
  sub slot_value_is_weak {
      my ($self, $instance, $slot_name) = @_;
      isweak $instance->{$slot_name};
  }
  
  sub strengthen_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->set_slot_value($instance, $slot_name, $self->get_slot_value($instance, $slot_name));
  }
  
  sub rebless_instance_structure {
      my ($self, $instance, $metaclass) = @_;
  
      # we use $_[1] here because of t/cmop/rebless_overload.t regressions
      # on 5.8.8
      bless $_[1], $metaclass->name;
  }
  
  sub is_dependent_on_superclasses {
      return; # for meta instances that require updates on inherited slot changes
  }
  
  sub _get_mop_slot {
      my ($self, $instance) = @_;
      $self->get_slot_value($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _has_mop_slot {
      my ($self, $instance) = @_;
      $self->is_slot_initialized($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _set_mop_slot {
      my ($self, $instance, $value) = @_;
      $self->set_slot_value($instance, $RESERVED_MOP_SLOT, $value);
  }
  
  sub _clear_mop_slot {
      my ($self, $instance) = @_;
      $self->deinitialize_slot($instance, $RESERVED_MOP_SLOT);
  }
  
  # inlinable operation snippets
  
  sub is_inlinable { 1 }
  
  sub inline_create_instance {
      my ($self, $class_variable) = @_;
      'bless {} => ' . $class_variable;
  }
  
  sub inline_slot_access {
      my ($self, $instance, $slot_name) = @_;
      sprintf q[%s->{"%s"}], $instance, quotemeta($slot_name);
  }
  
  sub inline_get_is_lvalue { 1 }
  
  sub inline_get_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_set_slot_value {
      my ($self, $instance, $slot_name, $value) = @_;
      $self->inline_slot_access($instance, $slot_name) . " = $value",
  }
  
  sub inline_initialize_slot {
      my ($self, $instance, $slot_name) = @_;
      return '';
  }
  
  sub inline_deinitialize_slot {
      my ($self, $instance, $slot_name) = @_;
      "delete " . $self->inline_slot_access($instance, $slot_name);
  }
  sub inline_is_slot_initialized {
      my ($self, $instance, $slot_name) = @_;
      "exists " . $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_weaken_slot_value {
      my ($self, $instance, $slot_name) = @_;
      sprintf "Scalar::Util::weaken( %s )", $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_strengthen_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->inline_set_slot_value($instance, $slot_name, $self->inline_slot_access($instance, $slot_name));
  }
  
  sub inline_rebless_instance_structure {
      my ($self, $instance, $class_variable) = @_;
      "bless $instance => $class_variable";
  }
  
  sub _inline_get_mop_slot {
      my ($self, $instance) = @_;
      $self->inline_get_slot_value($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _inline_set_mop_slot {
      my ($self, $instance, $value) = @_;
      $self->inline_set_slot_value($instance, $RESERVED_MOP_SLOT, $value);
  }
  
  sub _inline_clear_mop_slot {
      my ($self, $instance) = @_;
      $self->inline_deinitialize_slot($instance, $RESERVED_MOP_SLOT);
  }
  
  1;
  
  # ABSTRACT: Instance Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Instance - Instance Meta Object
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  The Instance Protocol controls the creation of object instances, and
  the storage of attribute values in those instances.
  
  Using this API directly in your own code violates encapsulation, and
  we recommend that you use the appropriate APIs in L<Class::MOP::Class>
  and L<Class::MOP::Attribute> instead. Those APIs in turn call the
  methods in this class as appropriate.
  
  This class also participates in generating inlined code by providing
  snippets of code to access an object instance.
  
  =head1 METHODS
  
  =head2 Object construction
  
  =over 4
  
  =item B<< Class::MOP::Instance->new(%options) >>
  
  This method creates a new meta-instance object.
  
  It accepts the following keys in C<%options>:
  
  =over 8
  
  =item * associated_metaclass
  
  The L<Class::MOP::Class> object for which instances will be created.
  
  =item * attributes
  
  An array reference of L<Class::MOP::Attribute> objects. These are the
  attributes which can be stored in each instance.
  
  =back
  
  =back
  
  =head2 Creating and altering instances
  
  =over 4
  
  =item B<< $metainstance->create_instance >>
  
  This method returns a reference blessed into the associated
  metaclass's class.
  
  The default is to use a hash reference. Subclasses can override this.
  
  =item B<< $metainstance->clone_instance($instance) >>
  
  Given an instance, this method creates a new object by making
  I<shallow> clone of the original.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< $metainstance->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object associated with the
  meta-instance object.
  
  =item B<< $metainstance->get_all_slots >>
  
  This returns a list of slot names stored in object instances. In
  almost all cases, slot names correspond directly attribute names.
  
  =item B<< $metainstance->is_valid_slot($slot_name) >>
  
  This will return true if C<$slot_name> is a valid slot name.
  
  =item B<< $metainstance->get_all_attributes >>
  
  This returns a list of attributes corresponding to the attributes
  passed to the constructor.
  
  =back
  
  =head2 Operations on Instance Structures
  
  It's important to understand that the meta-instance object is a
  different entity from the actual instances it creates. For this
  reason, any operations on the C<$instance_structure> always require
  that the object instance be passed to the method.
  
  =over 4
  
  =item B<< $metainstance->get_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->set_slot_value($instance_structure, $slot_name, $value) >>
  
  =item B<< $metainstance->initialize_slot($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->deinitialize_slot($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->initialize_all_slots($instance_structure) >>
  
  =item B<< $metainstance->deinitialize_all_slots($instance_structure) >>
  
  =item B<< $metainstance->is_slot_initialized($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->weaken_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->slot_value_is_weak($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->strengthen_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->rebless_instance_structure($instance_structure, $new_metaclass) >>
  
  The exact details of what each method does should be fairly obvious
  from the method name.
  
  =back
  
  =head2 Inlinable Instance Operations
  
  =over 4
  
  =item B<< $metainstance->is_inlinable >>
  
  This is a boolean that indicates whether or not slot access operations
  can be inlined. By default it is true, but subclasses can override
  this.
  
  =item B<< $metainstance->inline_create_instance($class_variable) >>
  
  This method expects a string that, I<when inlined>, will become a
  class name. This would literally be something like C<'$class'>, not an
  actual class name.
  
  It returns a snippet of code that creates a new object for the
  class. This is something like C< bless {}, $class_name >.
  
  =item B<< $metainstance->inline_get_is_lvalue >>
  
  Returns whether or not C<inline_get_slot_value> is a valid lvalue. This can be
  used to do extra optimizations when generating inlined methods.
  
  =item B<< $metainstance->inline_slot_access($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_get_slot_value($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_set_slot_value($instance_variable, $slot_name, $value) >>
  
  =item B<< $metainstance->inline_initialize_slot($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_deinitialize_slot($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_is_slot_initialized($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_weaken_slot_value($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_strengthen_slot_value($instance_variable, $slot_name) >>
  
  These methods all expect two arguments. The first is the name of a
  variable, than when inlined, will represent the object
  instance. Typically this will be a literal string like C<'$_[0]'>.
  
  The second argument is a slot name.
  
  The method returns a snippet of code that, when inlined, performs some
  operation on the instance.
  
  =item B<< $metainstance->inline_rebless_instance_structure($instance_variable, $class_variable) >>
  
  This takes the name of a variable that will, when inlined, represent the object
  instance, and the name of a variable that will represent the class to rebless
  into, and returns code to rebless an instance into a class.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Instance->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_INSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD';
  package Class::MOP::Method;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'weaken', 'reftype', 'blessed';
  
  use parent 'Class::MOP::Object';
  
  # NOTE:
  # if poked in the right way,
  # they should act like CODE refs.
  use overload
      '&{}' => sub { $_[0]->body },
      'bool' => sub { 1 },
      '""' => sub { overload::StrVal($_[0]) },
      fallback => 1;
  
  # construction
  
  sub wrap {
      my ( $class, @args ) = @_;
  
      unshift @args, 'body' if @args % 2 == 1;
  
      my %params = @args;
      my $code = $params{body};
  
      if (blessed($code) && $code->isa(__PACKAGE__)) {
          my $method = $code->clone;
          delete $params{body};
          Class::MOP::class_of($class)->rebless_instance($method, %params);
          return $method;
      }
      elsif (!ref $code || 'CODE' ne reftype($code)) {
          $class->_throw_exception( WrapTakesACodeRefToBless => params => \%params,
                                                                    class  => $class,
                                                                    code   => $code
                                      );
      }
  
      ($params{package_name} && $params{name})
          || $class->_throw_exception( PackageNameAndNameParamsNotGivenToWrap => params => \%params,
                                                                                     class  => $class,
                                                                                     code   => $code
                                         );
  
      my $self = $class->_new(\%params);
  
      weaken($self->{associated_metaclass}) if $self->{associated_metaclass};
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          'body'                 => $params->{body},
          'associated_metaclass' => $params->{associated_metaclass},
          'package_name'         => $params->{package_name},
          'name'                 => $params->{name},
          'original_method'      => $params->{original_method},
      } => $class;
  }
  
  ## accessors
  
  sub associated_metaclass { shift->{'associated_metaclass'} }
  
  sub attach_to_class {
      my ( $self, $class ) = @_;
      $self->{associated_metaclass} = $class;
      weaken($self->{associated_metaclass});
  }
  
  sub detach_from_class {
      my $self = shift;
      delete $self->{associated_metaclass};
  }
  
  sub fully_qualified_name {
      my $self = shift;
      $self->package_name . '::' . $self->name;
  }
  
  sub original_method { (shift)->{'original_method'} }
  
  sub _set_original_method { $_[0]->{'original_method'} = $_[1] }
  
  # It's possible that this could cause a loop if there is a circular
  # reference in here. That shouldn't ever happen in normal
  # circumstances, since original method only gets set when clone is
  # called. We _could_ check for such a loop, but it'd involve some sort
  # of package-lexical variable, and wouldn't be terribly subclassable.
  sub original_package_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_package_name
          : $self->package_name;
  }
  
  sub original_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_name
          : $self->name;
  }
  
  sub original_fully_qualified_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_fully_qualified_name
          : $self->fully_qualified_name;
  }
  
  sub execute {
      my $self = shift;
      $self->body->(@_);
  }
  
  # We used to go through use Class::MOP::Class->clone_instance to do this, but
  # this was awfully slow. This method may be called a number of times when
  # classes are loaded (especially during Moose role application), so it is
  # worth optimizing. - DR
  sub clone {
      my $self = shift;
  
      my $clone = bless { %{$self}, @_ }, blessed($self);
      weaken($clone->{associated_metaclass}) if $clone->{associated_metaclass};
  
      $clone->_set_original_method($self);
  
      return $clone;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method - Method Meta Object
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  The Method Protocol is very small, since methods in Perl 5 are just
  subroutines in a specific package. We provide a very basic
  introspection interface.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method->wrap($code, %options) >>
  
  This is the constructor. It accepts a method body in the form of
  either a code reference or a L<Class::MOP::Method> instance, followed
  by a hash of options.
  
  The options are:
  
  =over 8
  
  =item * name
  
  The method name (without a package name). This is required if C<$code>
  is a coderef.
  
  =item * package_name
  
  The package name for the method. This is required if C<$code> is a
  coderef.
  
  =item * associated_metaclass
  
  An optional L<Class::MOP::Class> object. This is the metaclass for the
  method's class.
  
  =back
  
  =item B<< $metamethod->clone(%params) >>
  
  This makes a shallow clone of the method object. In particular,
  subroutine reference itself is shared between all clones of a given
  method.
  
  When a method is cloned, the original method object will be available
  by calling C<original_method> on the clone.
  
  =item B<< $metamethod->body >>
  
  This returns a reference to the method's subroutine.
  
  =item B<< $metamethod->name >>
  
  This returns the method's name.
  
  =item B<< $metamethod->package_name >>
  
  This returns the method's package name.
  
  =item B<< $metamethod->fully_qualified_name >>
  
  This returns the method's fully qualified name (package name and
  method name).
  
  =item B<< $metamethod->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object for the method, if one
  exists.
  
  =item B<< $metamethod->original_method >>
  
  If this method object was created as a clone of some other method
  object, this returns the object that was cloned.
  
  =item B<< $metamethod->original_name >>
  
  This returns the method's original name, wherever it was first
  defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the name from the I<first> method in the chain of clones.
  
  =item B<< $metamethod->original_package_name >>
  
  This returns the method's original package name, wherever it was first
  defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the package name from the I<first> method in the chain of
  clones.
  
  =item B<< $metamethod->original_fully_qualified_name >>
  
  This returns the method's original fully qualified name, wherever it
  was first defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the fully qualified name from the I<first> method in the chain
  of clones.
  
  =item B<< $metamethod->is_stub >>
  
  Returns true if the method is just a stub:
  
    sub foo;
  
  =item B<< $metamethod->attach_to_class($metaclass) >>
  
  Given a L<Class::MOP::Class> object, this method sets the associated
  metaclass for the method. This will overwrite any existing associated
  metaclass.
  
  =item B<< $metamethod->detach_from_class >>
  
  Removes any associated metaclass object for the method.
  
  =item B<< $metamethod->execute(...) >>
  
  This executes the method. Any arguments provided will be passed on to
  the method itself.
  
  =item B<< Class::MOP::Method->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_ACCESSOR';
  package Class::MOP::Method::Accessor;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Class::MOP::Method::Generated';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (exists $options{attribute})
          || $class->_throw_exception( MustSupplyAnAttributeToConstructWith => params => \%options,
                                                                      class  => $class,
                            );
  
      (exists $options{accessor_type})
          || $class->_throw_exception( MustSupplyAnAccessorTypeToConstructWith => params => \%options,
                                                                         class  => $class,
                            );
  
      (blessed($options{attribute}) && $options{attribute}->isa('Class::MOP::Attribute'))
          || $class->_throw_exception( MustSupplyAClassMOPAttributeInstance => params => \%options,
                                                                      class  => $class
                            );
  
      ($options{package_name} && $options{name})
          || $class->_throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = $class->_new(\%options);
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'attribute'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          body                 => $params->{body},
          associated_metaclass => $params->{associated_metaclass},
          package_name         => $params->{package_name},
          name                 => $params->{name},
          original_method      => $params->{original_method},
  
          # inherit from Class::MOP::Generated
          is_inline            => $params->{is_inline} || 0,
          definition_context   => $params->{definition_context},
  
          # defined in this class
          attribute            => $params->{attribute},
          accessor_type        => $params->{accessor_type},
      } => $class;
  }
  
  ## accessors
  
  sub associated_attribute { (shift)->{'attribute'}     }
  sub accessor_type        { (shift)->{'accessor_type'} }
  
  ## factory
  
  sub _initialize_body {
      my $self = shift;
  
      my $method_name = join "_" => (
          '_generate',
          $self->accessor_type,
          'method',
          ($self->is_inline ? 'inline' : ())
      );
  
      $self->{'body'} = $self->$method_name();
  }
  
  ## generators
  
  sub _generate_accessor_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          if (@_ >= 2) {
              $attr->set_value($_[0], $_[1]);
          }
          $attr->get_value($_[0]);
      };
  }
  
  sub _generate_accessor_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  'if (@_ > 1) {',
                      $attr->_inline_set_value('$_[0]', '$_[1]'),
                  '}',
                  $attr->_inline_get_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "accessor"
                         );
      };
  }
  
  sub _generate_reader_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
      my $class = $attr->associated_class;
  
      return sub {
          $self->_throw_exception( CannotAssignValueToReadOnlyAccessor => class_name => $class->name,
                                                                  value      => $_[1],
                                                                  attribute  => $attr
                         )
              if @_ > 1;
          $attr->get_value($_[0]);
      };
  }
  
  sub _generate_reader_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
      my $attr_name = $attr->name;
  
      return try {
          $self->_compile_code([
              'sub {',
                  'if (@_ > 1) {',
                      $self->_inline_throw_exception( CannotAssignValueToReadOnlyAccessor =>
                                                      'class_name                          => ref $_[0],'.
                                                      'value                               => $_[1],'.
                                                      "attribute_name                      => '".$attr_name."'",
                      ) . ';',
                  '}',
                  $attr->_inline_get_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "reader"
                         );
      };
  }
  
  sub _inline_throw_exception {
      my ( $self, $exception_type, $throw_args ) = @_;
      return 'die Module::Runtime::use_module("Moose::Exception::' . $exception_type . '")->new(' . ($throw_args || '') . ')';
  }
  
  sub _generate_writer_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->set_value($_[0], $_[1]);
      };
  }
  
  sub _generate_writer_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_set_value('$_[0]', '$_[1]'),
              '}',
          ]);
      }
      catch {
          $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "writer"
                         );
      };
  }
  
  sub _generate_predicate_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->has_value($_[0])
      };
  }
  
  sub _generate_predicate_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_has_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "predicate"
                         );
      };
  }
  
  sub _generate_clearer_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->clear_value($_[0])
      };
  }
  
  sub _generate_clearer_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_clear_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          $self->_throw_exception( CouldNotGenerateInlineAttributeMethod => instance => $self,
                                                                    error    => $_,
                                                                    option   => "clearer"
                         );
      };
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for accessors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Accessor - Method Meta Object for accessors
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
      use Class::MOP::Method::Accessor;
  
      my $reader = Class::MOP::Method::Accessor->new(
          attribute     => $attribute,
          is_inline     => 1,
          accessor_type => 'reader',
      );
  
      $reader->body->execute($instance); # call the reader method
  
  =head1 DESCRIPTION
  
  This is a subclass of C<Class::MOP::Method> which is used by
  C<Class::MOP::Attribute> to generate accessor code. It handles
  generation of readers, writers, predicates and clearers. For each type
  of method, it can either create a subroutine reference, or actually
  inline code by generating a string and C<eval>'ing it.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Accessor->new(%options) >>
  
  This returns a new C<Class::MOP::Method::Accessor> based on the
  C<%options> provided.
  
  =over 4
  
  =item * attribute
  
  This is the C<Class::MOP::Attribute> for which accessors are being
  generated. This option is required.
  
  =item * accessor_type
  
  This is a string which should be one of "reader", "writer",
  "accessor", "predicate", or "clearer". This is the type of method
  being generated. This option is required.
  
  =item * is_inline
  
  This indicates whether or not the accessor should be inlined. This
  defaults to false.
  
  =item * name
  
  The method name (without a package name). This is required.
  
  =item * package_name
  
  The package name for the method. This is required.
  
  =back
  
  =item B<< $metamethod->accessor_type >>
  
  Returns the accessor type which was passed to C<new>.
  
  =item B<< $metamethod->is_inline >>
  
  Returns a boolean indicating whether or not the accessor is inlined.
  
  =item B<< $metamethod->associated_attribute >>
  
  This returns the L<Class::MOP::Attribute> object which was passed to
  C<new>.
  
  =item B<< $metamethod->body >>
  
  The method itself is I<generated> when the accessor object is
  constructed.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_ACCESSOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_CONSTRUCTOR';
  package Class::MOP::Method::Constructor;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Class::MOP::Method::Inlined';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (blessed $options{metaclass} && $options{metaclass}->isa('Class::MOP::Class'))
          || $class->_throw_exception( MustSupplyAMetaclass => params => \%options,
                                                      class  => $class
                            )
              if $options{is_inline};
  
      ($options{package_name} && $options{name})
          || $class->_throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = $class->_new(\%options);
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          body                 => $params->{body},
          # associated_metaclass => $params->{associated_metaclass}, # overridden
          package_name         => $params->{package_name},
          name                 => $params->{name},
          original_method      => $params->{original_method},
  
          # inherited from Class::MOP::Generated
          is_inline            => $params->{is_inline} || 0,
          definition_context   => $params->{definition_context},
  
          # inherited from Class::MOP::Inlined
          _expected_method_class => $params->{_expected_method_class},
  
          # defined in this subclass
          options              => $params->{options} || {},
          associated_metaclass => $params->{metaclass},
      }, $class;
  }
  
  ## accessors
  
  sub options              { (shift)->{'options'}              }
  sub associated_metaclass { (shift)->{'associated_metaclass'} }
  
  ## method
  
  sub _initialize_body {
      my $self        = shift;
      my $method_name = '_generate_constructor_method';
  
      $method_name .= '_inline' if $self->is_inline;
  
      $self->{'body'} = $self->$method_name;
  }
  
  sub _eval_environment {
      my $self = shift;
      return $self->associated_metaclass->_eval_environment;
  }
  
  sub _generate_constructor_method {
      return sub { Class::MOP::Class->initialize(shift)->new_object(@_) }
  }
  
  sub _generate_constructor_method_inline {
      my $self = shift;
  
      my $meta = $self->associated_metaclass;
  
      my @source = (
          'sub {',
              $meta->_inline_new_object,
          '}',
      );
  
      warn join("\n", @source) if $self->options->{debug};
  
      my $code = try {
          $self->_compile_code(\@source);
      }
      catch {
          my $source = join("\n", @source);
          $self->_throw_exception( CouldNotEvalConstructor => constructor_method => $self,
                                                      source             => $source,
                                                      error              => $_
                         );
      };
  
      return $code;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for constructors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Constructor - Method Meta Object for constructors
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    use Class::MOP::Method::Constructor;
  
    my $constructor = Class::MOP::Method::Constructor->new(
        metaclass => $metaclass,
        options   => {
            debug => 1, # this is all for now
        },
    );
  
    # calling the constructor ...
    $constructor->body->execute($metaclass->name, %params);
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Class::MOP::Method> which generates
  constructor methods.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Constructor->new(%options) >>
  
  This creates a new constructor object. It accepts a hash reference of
  options.
  
  =over 8
  
  =item * metaclass
  
  This should be a L<Class::MOP::Class> object. It is required.
  
  =item * name
  
  The method name (without a package name). This is required.
  
  =item * package_name
  
  The package name for the method. This is required.
  
  =item * is_inline
  
  This indicates whether or not the constructor should be inlined. This
  defaults to false.
  
  =back
  
  =item B<< $metamethod->is_inline >>
  
  Returns a boolean indicating whether or not the constructor is
  inlined.
  
  =item B<< $metamethod->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object for the method.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_CONSTRUCTOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Generated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_GENERATED';
  package Class::MOP::Method::Generated;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Eval::Closure;
  
  use parent 'Class::MOP::Method';
  
  ## accessors
  
  sub new {
      $_[0]->_throw_exception( CannotCallAnAbstractBaseMethod => package_name => __PACKAGE__ );
  }
  
  sub _initialize_body {
      $_[0]->_throw_exception( NoBodyToInitializeInAnAbstractBaseClass => package_name => __PACKAGE__ );
  }
  
  sub _generate_description {
      my ( $self, $context ) = @_;
      $context ||= $self->definition_context;
  
      my $desc = "generated method";
      my $origin = "unknown origin";
  
      if (defined $context) {
          if (defined $context->{description}) {
              $desc = $context->{description};
          }
  
          if (defined $context->{file} || defined $context->{line}) {
              $origin = "defined at "
                      . (defined $context->{file}
                          ? $context->{file} : "<unknown file>")
                      . " line "
                      . (defined $context->{line}
                          ? $context->{line} : "<unknown line>");
          }
      }
  
      return "$desc ($origin)";
  }
  
  sub _compile_code {
      my ( $self, @args ) = @_;
      unshift @args, 'source' if @args % 2;
      my %args = @args;
  
      my $context = delete $args{context};
      my $environment = $self->can('_eval_environment')
          ? $self->_eval_environment
          : {};
  
      return eval_closure(
          environment => $environment,
          description => $self->_generate_description($context),
          %args,
      );
  }
  
  1;
  
  # ABSTRACT: Abstract base class for generated methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Generated - Abstract base class for generated methods
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This is a C<Class::MOP::Method> subclass which is subclassed by
  C<Class::MOP::Method::Accessor> and
  C<Class::MOP::Method::Constructor>.
  
  It is not intended to be used directly.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_GENERATED

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Inlined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_INLINED';
  package Class::MOP::Method::Inlined;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'refaddr';
  
  use parent 'Class::MOP::Method::Generated';
  
  sub _uninlined_body {
      my $self = shift;
  
      my $super_method
          = $self->associated_metaclass->find_next_method_by_name( $self->name )
          or return;
  
      if ( $super_method->isa(__PACKAGE__) ) {
          return $super_method->_uninlined_body;
      }
      else {
          return $super_method->body;
      }
  }
  
  sub can_be_inlined {
      my $self      = shift;
      my $metaclass = $self->associated_metaclass;
      my $class     = $metaclass->name;
  
      # If we don't find an inherited method, this is a rather weird
      # case where we have no method in the inheritance chain even
      # though we're expecting one to be there
      my $inherited_method
          = $metaclass->find_next_method_by_name( $self->name );
  
      if (   $inherited_method
          && $inherited_method->isa('Class::MOP::Method::Wrapped') ) {
          warn "Not inlining '"
              . $self->name
              . "' for $class since it "
              . "has method modifiers which would be lost if it were inlined\n";
  
          return 0;
      }
  
      my $expected_class = $self->_expected_method_class
          or return 1;
  
      # if we are shadowing a method we first verify that it is
      # compatible with the definition we are replacing it with
      my $expected_method = $expected_class->can( $self->name );
  
      if ( ! $expected_method ) {
          warn "Not inlining '"
              . $self->name
              . "' for $class since ${expected_class}::"
              . $self->name
              . " is not defined\n";
  
          return 0;
      }
  
      my $actual_method = $class->can( $self->name )
          or return 1;
  
      # the method is what we wanted (probably Moose::Object::new)
      return 1
          if refaddr($expected_method) == refaddr($actual_method);
  
      # otherwise we have to check that the actual method is an inlined
      # version of what we're expecting
      if ( $inherited_method->isa(__PACKAGE__) ) {
          if ( $inherited_method->_uninlined_body
               && refaddr( $inherited_method->_uninlined_body )
               == refaddr($expected_method) ) {
              return 1;
          }
      }
      elsif ( refaddr( $inherited_method->body )
              == refaddr($expected_method) ) {
          return 1;
      }
  
      my $warning
          = "Not inlining '"
          . $self->name
          . "' for $class since it is not"
          . " inheriting the default ${expected_class}::"
          . $self->name . "\n";
  
      if ( $self->isa("Class::MOP::Method::Constructor") ) {
  
          # FIXME kludge, refactor warning generation to a method
          $warning
              .= "If you are certain you don't need to inline your"
              . " constructor, specify inline_constructor => 0 in your"
              . " call to $class->meta->make_immutable\n";
      }
  
      warn $warning;
  
      return 0;
  }
  
  1;
  
  # ABSTRACT: Method base class for methods which have been inlined
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Inlined - Method base class for methods which have been inlined
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method::Generated> subclass for methods which
  can be inlined.
  
  =head1 METHODS
  
  =head2 $metamethod->can_be_inlined
  
  This method returns true if the method in question can be inlined in
  the associated metaclass.
  
  If it cannot be inlined, it spits out a warning and returns false.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_INLINED

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_META';
  package Class::MOP::Method::Meta;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  
  use constant DEBUG_NO_META => $ENV{DEBUG_NO_META} ? 1 : 0;
  
  use parent 'Class::MOP::Method';
  
  sub _is_caller_mop_internal {
      my $self = shift;
      my ($caller) = @_;
      return $caller =~ /^(?:Class::MOP|metaclass)(?:::|$)/;
  }
  
  sub _generate_meta_method {
      my $method_self = shift;
      my $metaclass   = shift;
      weaken($metaclass);
  
      sub {
          # this will be compiled out if the env var wasn't set
          if (DEBUG_NO_META) {
              confess "'meta' method called by MOP internals"
                  # it's okay to call meta methods on metaclasses, since we
                  # explicitly ask for them
                  if !$_[0]->isa('Class::MOP::Object')
                  && !$_[0]->isa('Class::MOP::Mixin')
                  # it's okay if the test itself calls ->meta, we only care about
                  # if the mop internals call ->meta
                  && $method_self->_is_caller_mop_internal(scalar caller);
          }
          # we must re-initialize so that it
          # works as expected in subclasses,
          # since metaclass instances are
          # singletons, this is not really a
          # big deal anyway.
          $metaclass->initialize(blessed($_[0]) || $_[0])
      };
  }
  
  sub wrap {
      my ($class, @args) = @_;
  
      unshift @args, 'body' if @args % 2 == 1;
      my %params = @args;
      $class->_throw_exception( CannotOverrideBodyOfMetaMethods => params => \%params,
                                                                       class  => $class
                                  )
          if $params{body};
  
      my $metaclass_class = $params{associated_metaclass}->meta;
      $params{body} = $class->_generate_meta_method($metaclass_class);
      return $class->SUPER::wrap(%params);
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is that CMOP::Method::Meta
      # objects are subclasses of CMOP::Method, but when we get to moose, they'll
      # need to be compatible with Moose::Meta::Method, which isn't possible. the
      # right solution here is to make ::Meta into a role that gets applied to
      # whatever the method_metaclass happens to be and get rid of
      # _meta_method_metaclass entirely, but that's not going to happen until
      # we ditch cmop and get roles into the bootstrapping, so. i'm not
      # maintaining the previous behavior of turning them into instances of the
      # new method_metaclass because that's equally broken, and at least this way
      # any issues will at least be detectable and potentially fixable. -doy
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for C<meta> methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Meta - Method Meta Object for C<meta> methods
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method> subclass which represents C<meta>
  methods installed into classes by Class::MOP.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Wrapped->wrap($metamethod, %options) >>
  
  This is the constructor. It accepts a L<Class::MOP::Method> object and
  a hash of options. The options accepted are identical to the ones
  accepted by L<Class::MOP::Method>, except that C<body> cannot be passed
  (it will be generated automatically).
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_META

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Method/Wrapped.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_WRAPPED';
  package Class::MOP::Method::Wrapped;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  use Sub::Name 'subname';
  
  use parent 'Class::MOP::Method';
  
  # NOTE:
  # this ugly beast is the result of trying
  # to micro optimize this as much as possible
  # while not completely loosing maintainability.
  # At this point it's "fast enough", after all
  # you can't get something for nothing :)
  my $_build_wrapped_method = sub {
      my $modifier_table = shift;
      my ($before, $after, $around) = (
          $modifier_table->{before},
          $modifier_table->{after},
          $modifier_table->{around},
      );
      if (@$before && @$after) {
          $modifier_table->{cache} = sub {
              for my $c (@$before) { $c->(@_) };
              my @rval;
              ((defined wantarray) ?
                  ((wantarray) ?
                      (@rval = $around->{cache}->(@_))
                      :
                      ($rval[0] = $around->{cache}->(@_)))
                  :
                  $around->{cache}->(@_));
              for my $c (@$after) { $c->(@_) };
              return unless defined wantarray;
              return wantarray ? @rval : $rval[0];
          }
      }
      elsif (@$before && !@$after) {
          $modifier_table->{cache} = sub {
              for my $c (@$before) { $c->(@_) };
              return $around->{cache}->(@_);
          }
      }
      elsif (@$after && !@$before) {
          $modifier_table->{cache} = sub {
              my @rval;
              ((defined wantarray) ?
                  ((wantarray) ?
                      (@rval = $around->{cache}->(@_))
                      :
                      ($rval[0] = $around->{cache}->(@_)))
                  :
                  $around->{cache}->(@_));
              for my $c (@$after) { $c->(@_) };
              return unless defined wantarray;
              return wantarray ? @rval : $rval[0];
          }
      }
      else {
          $modifier_table->{cache} = $around->{cache};
      }
  };
  
  sub wrap {
      my ( $class, $code, %params ) = @_;
  
      (blessed($code) && $code->isa('Class::MOP::Method'))
          || $class->_throw_exception( CanOnlyWrapBlessedCode => params => \%params,
                                                        class  => $class,
                                                        code   => $code
                            );
  
      my $modifier_table = {
          cache  => undef,
          orig   => $code->body,
          before => [],
          after  => [],
          around => {
              cache   => $code->body,
              methods => [],
          },
      };
      $_build_wrapped_method->($modifier_table);
  
      # get these from the original unless explicitly overridden
      my $pkg_name    = $params{package_name} || $code->package_name;
      my $method_name = $params{name}         || $code->name;
  
      return $class->SUPER::wrap(
          sub {
              my $wrapped = subname "${pkg_name}::_wrapped_${method_name}" => $modifier_table->{cache};
              return $wrapped->(@_) ;
          },
          package_name    => $pkg_name,
          name            => $method_name,
          original_method => $code,
          modifier_table  => $modifier_table,
      );
  }
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          'body'                 => $params->{body},
          'associated_metaclass' => $params->{associated_metaclass},
          'package_name'         => $params->{package_name},
          'name'                 => $params->{name},
          'original_method'      => $params->{original_method},
  
          # defined in this class
          'modifier_table'       => $params->{modifier_table}
      } => $class;
  }
  
  sub get_original_method {
      my $code = shift;
      $code->original_method;
  }
  
  sub add_before_modifier {
      my $code     = shift;
      my $modifier = shift;
      unshift @{$code->{'modifier_table'}->{before}} => $modifier;
      $_build_wrapped_method->($code->{'modifier_table'});
  }
  
  sub before_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{before}};
  }
  
  sub add_after_modifier {
      my $code     = shift;
      my $modifier = shift;
      push @{$code->{'modifier_table'}->{after}} => $modifier;
      $_build_wrapped_method->($code->{'modifier_table'});
  }
  
  sub after_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{after}};
  }
  
  {
      # NOTE:
      # this is another possible candidate for
      # optimization as well. There is an overhead
      # associated with the currying that, if
      # eliminated might make around modifiers
      # more manageable.
      my $compile_around_method = sub {{
          my $f1 = pop;
          return $f1 unless @_;
          my $f2 = pop;
          push @_, sub { $f2->( $f1, @_ ) };
          redo;
      }};
  
      sub add_around_modifier {
          my $code     = shift;
          my $modifier = shift;
          unshift @{$code->{'modifier_table'}->{around}->{methods}} => $modifier;
          $code->{'modifier_table'}->{around}->{cache} = $compile_around_method->(
              @{$code->{'modifier_table'}->{around}->{methods}},
              $code->{'modifier_table'}->{orig}
          );
          $_build_wrapped_method->($code->{'modifier_table'});
      }
  }
  
  sub around_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{around}->{methods}};
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is that CMOP::Method::Wrapped
      # objects are subclasses of CMOP::Method, but when we get to moose, they'll
      # need to be compatible with Moose::Meta::Method, which isn't possible. the
      # right solution here is to make ::Wrapped into a role that gets applied to
      # whatever the method_metaclass happens to be and get rid of
      # wrapped_method_metaclass entirely, but that's not going to happen until
      # we ditch cmop and get roles into the bootstrapping, so. i'm not
      # maintaining the previous behavior of turning them into instances of the
      # new method_metaclass because that's equally broken, and at least this way
      # any issues will at least be detectable and potentially fixable. -doy
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for methods with before/after/around modifiers
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Method::Wrapped - Method Meta Object for methods with before/after/around modifiers
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method> subclass which implements before,
  after, and around method modifiers.
  
  =head1 METHODS
  
  =head2 Class::MOP::Method::Wrapped->wrap($metamethod, %options)
  
  This is the constructor. It accepts a L<Class::MOP::Method> object and
  a hash of options.
  
  The options are:
  
  =over 4
  
  =item * name
  
  The method name (without a package name). This will be taken from the
  provided L<Class::MOP::Method> object if it is not provided.
  
  =item * package_name
  
  The package name for the method. This will be taken from the provided
  L<Class::MOP::Method> object if it is not provided.
  
  =item * associated_metaclass
  
  An optional L<Class::MOP::Class> object. This is the metaclass for the
  method's class.
  
  =back
  
  =head2 $metamethod->get_original_method
  
  This returns the L<Class::MOP::Method> object that was passed to the
  constructor.
  
  =head2 $metamethod->add_before_modifier($code)
  
  =head2 $metamethod->add_after_modifier($code)
  
  =head2 $metamethod->add_around_modifier($code)
  
  These methods all take a subroutine reference and apply it as a
  modifier to the original method.
  
  =head2 $metamethod->before_modifiers
  
  =head2 $metamethod->after_modifiers
  
  =head2 $metamethod->around_modifiers
  
  These methods all return a list of subroutine references which are
  acting as the specified type of modifier.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_METHOD_WRAPPED

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/MiniTrait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MINITRAIT';
  package Class::MOP::MiniTrait;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Module::Runtime 'use_package_optimistically';
  
  sub apply {
      my ( $to_class, $trait ) = @_;
  
      for ( grep { !ref } $to_class, $trait ) {
          use_package_optimistically($_);
          $_ = Class::MOP::Class->initialize($_);
      }
  
      for my $meth ( grep { $_->package_name ne 'UNIVERSAL' } $trait->get_all_methods ) {
          my $meth_name = $meth->name;
          next if index($meth_name, '__') == 0;   # skip private subs
  
          if ( $to_class->find_method_by_name($meth_name) ) {
              $to_class->add_around_method_modifier( $meth_name, $meth->body );
          }
          else {
              $to_class->add_method( $meth_name, $meth->clone );
          }
      }
  }
  
  # We can't load this with use, since it may be loaded and used from Class::MOP
  # (via CMOP::Class, etc). However, if for some reason this module is loaded
  # _without_ first loading Class::MOP we need to require Class::MOP so we can
  # use it and CMOP::Class.
  require Class::MOP;
  
  1;
  
  # ABSTRACT: Extremely limited trait application
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::MiniTrait - Extremely limited trait application
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This package provides a single function, C<apply>, which does a half-assed job
  of applying a trait to a class. It exists solely for use inside Class::MOP and
  L<Moose> core classes.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MINITRAIT

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Mixin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN';
  package Class::MOP::Mixin;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  use Module::Runtime 'use_module';
  
  sub meta {
      require Class::MOP::Class;
      Class::MOP::Class->initialize( blessed( $_[0] ) || $_[0] );
  }
  
  sub _throw_exception {
      my ($class, $exception_type, @args_to_exception) = @_;
      die use_module( "Moose::Exception::$exception_type" )->new( @args_to_exception );
  }
  
  1;
  
  # ABSTRACT: Base class for mixin classes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin - Base class for mixin classes
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class provides a few methods which are useful in all metaclasses.
  
  =head1 METHODS
  
  =head2 Class::MOP::Mixin->meta
  
  This returns a L<Class::MOP::Class> object for the mixin class.
  
  =head2 Class::MOP::Mixin->_throw_exception
  
  Throws an exception in the L<Moose::Exception> family. This should ONLY be
  used internally -- any callers outside Class::MOP::* should be using the
  version in L<Moose::Util> instead.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Mixin/AttributeCore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_ATTRIBUTECORE';
  package Class::MOP::Mixin::AttributeCore;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  
  use parent 'Class::MOP::Mixin';
  
  sub has_accessor        { defined $_[0]->{'accessor'} }
  sub has_reader          { defined $_[0]->{'reader'} }
  sub has_writer          { defined $_[0]->{'writer'} }
  sub has_predicate       { defined $_[0]->{'predicate'} }
  sub has_clearer         { defined $_[0]->{'clearer'} }
  sub has_builder         { defined $_[0]->{'builder'} }
  sub has_init_arg        { defined $_[0]->{'init_arg'} }
  sub has_default         { exists  $_[0]->{'default'} }
  sub has_initializer     { defined $_[0]->{'initializer'} }
  sub has_insertion_order { defined $_[0]->{'insertion_order'} }
  
  sub _set_insertion_order { $_[0]->{'insertion_order'} = $_[1] }
  
  sub has_read_method  { $_[0]->has_reader || $_[0]->has_accessor }
  sub has_write_method { $_[0]->has_writer || $_[0]->has_accessor }
  
  sub is_default_a_coderef {
      # Uber hack because it is called from CMOP::Attribute constructor as
      # $class->is_default_a_coderef(\%options)
      my ($value) = ref $_[0] ? $_[0]->{'default'} : $_[1]->{'default'};
  
      return unless ref($value);
  
      return ref($value) eq 'CODE'
          || ( blessed($value) && $value->isa('Class::MOP::Method') );
  }
  
  sub default {
      my ( $self, $instance ) = @_;
      if ( defined $instance && $self->is_default_a_coderef ) {
          # if the default is a CODE ref, then we pass in the instance and
          # default can return a value based on that instance. Somewhat crude,
          # but works.
          return $self->{'default'}->($instance);
      }
      $self->{'default'};
  }
  
  1;
  
  # ABSTRACT: Core attributes shared by attribute metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin::AttributeCore - Core attributes shared by attribute metaclasses
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class implements the core attributes (aka properties) shared by all
  attributes. See the L<Class::MOP::Attribute> documentation for API details.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_ATTRIBUTECORE

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Mixin/HasAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_HASATTRIBUTES';
  package Class::MOP::Mixin::HasAttributes;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  
  use parent 'Class::MOP::Mixin';
  
  sub add_attribute {
      my $self = shift;
  
      my $attribute
          = blessed( $_[0] ) ? $_[0] : $self->attribute_metaclass->new(@_);
  
      ( $attribute->isa('Class::MOP::Mixin::AttributeCore') )
          || $self->_throw_exception( AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass => attribute  => $attribute,
                                                                                       class_name => $self->name,
                            );
  
      $self->_attach_attribute($attribute);
  
      my $attr_name = $attribute->name;
  
      $self->remove_attribute($attr_name)
          if $self->has_attribute($attr_name);
  
      my $order = ( scalar keys %{ $self->_attribute_map } );
      $attribute->_set_insertion_order($order);
  
      $self->_attribute_map->{$attr_name} = $attribute;
  
      # This method is called to allow for installing accessors. Ideally, we'd
      # use method overriding, but then the subclass would be responsible for
      # making the attribute, which would end up with lots of code
      # duplication. Even more ideally, we'd use augment/inner, but this is
      # Class::MOP!
      $self->_post_add_attribute($attribute)
          if $self->can('_post_add_attribute');
  
      return $attribute;
  }
  
  sub has_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || $self->_throw_exception( MustDefineAnAttributeName => class_name => $self->name );
  
      exists $self->_attribute_map->{$attribute_name};
  }
  
  sub get_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || $self->_throw_exception( MustDefineAnAttributeName => class_name => $self->name );
  
      return $self->_attribute_map->{$attribute_name};
  }
  
  sub remove_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || $self->_throw_exception( MustDefineAnAttributeName => class_name => $self->name );
  
      my $removed_attribute = $self->_attribute_map->{$attribute_name};
      return unless defined $removed_attribute;
  
      delete $self->_attribute_map->{$attribute_name};
  
      return $removed_attribute;
  }
  
  sub get_attribute_list {
      my $self = shift;
      keys %{ $self->_attribute_map };
  }
  
  sub _restore_metaattributes_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      for my $attr (sort { $a->insertion_order <=> $b->insertion_order }
                         map { $old_meta->get_attribute($_) }
                             $old_meta->get_attribute_list) {
          $attr->_make_compatible_with($self->attribute_metaclass);
          $self->add_attribute($attr);
      }
  }
  
  1;
  
  # ABSTRACT: Methods for metaclasses which have attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin::HasAttributes - Methods for metaclasses which have attributes
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class implements methods for metaclasses which have attributes
  (L<Class::MOP::Class> and L<Moose::Meta::Role>). See L<Class::MOP::Class> for
  API details.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_HASATTRIBUTES

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Mixin/HasMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_HASMETHODS';
  package Class::MOP::Mixin::HasMethods;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::MOP::Method::Meta;
  
  use Scalar::Util 'blessed', 'reftype';
  use Sub::Name 'subname';
  
  use parent 'Class::MOP::Mixin';
  
  sub _meta_method_class { 'Class::MOP::Method::Meta' }
  
  sub _add_meta_method {
      my $self = shift;
      my ($name) = @_;
      my $existing_method = $self->can('find_method_by_name')
                                ? $self->find_method_by_name($name)
                                : $self->get_method($name);
      return if $existing_method
             && $existing_method->isa($self->_meta_method_class);
      $self->add_method(
          $name => $self->_meta_method_class->wrap(
              name                 => $name,
              package_name         => $self->name,
              associated_metaclass => $self,
          )
      );
  }
  
  sub wrap_method_body {
      my ( $self, %args ) = @_;
  
      ( $args{body} && 'CODE' eq reftype $args{body} )
          || $self->_throw_exception( CodeBlockMustBeACodeRef => instance => $self,
                                                                      params   => \%args
                                         );
      $self->method_metaclass->wrap(
          package_name => $self->name,
          %args,
      );
  }
  
  sub add_method {
      my ( $self, $method_name, $method ) = @_;
      ( defined $method_name && length $method_name )
          || $self->_throw_exception( MustDefineAMethodName => instance => $self );
  
      my $package_name = $self->name;
  
      my $body;
      if ( blessed($method) && $method->isa('Class::MOP::Method') ) {
          $body = $method->body;
          if ( $method->package_name ne $package_name ) {
              $method = $method->clone(
                  package_name => $package_name,
                  name         => $method_name,
              );
          }
  
          $method->attach_to_class($self);
      }
      else {
          # If a raw code reference is supplied, its method object is not created.
          # The method object won't be created until required.
          $body = $method;
      }
  
      $self->_method_map->{$method_name} = $method;
  
      my ($current_package, $current_name) = Class::MOP::get_code_info($body);
  
      subname($package_name . '::' . $method_name, $body)
          unless defined $current_name && $current_name !~ /^__ANON__/;
  
      $self->add_package_symbol("&$method_name", $body);
  
      # we added the method to the method map too, so it's still valid
      $self->update_package_cache_flag;
  }
  
  sub _code_is_mine {
      my ( $self, $code ) = @_;
  
      my ( $code_package, $code_name ) = Class::MOP::get_code_info($code);
  
      return ( $code_package && $code_package eq $self->name )
          || ( $code_package eq 'constant' && $code_name eq '__ANON__' );
  }
  
  sub has_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || $self->_throw_exception( MustDefineAMethodName => instance => $self );
  
      my $method = $self->_get_maybe_raw_method($method_name);
      return if not $method;
  
      return defined($self->_method_map->{$method_name} = $method);
  }
  
  sub get_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || $self->_throw_exception( MustDefineAMethodName => instance => $self );
  
      my $method = $self->_get_maybe_raw_method($method_name);
      return if not $method;
  
      return $method if blessed($method) && $method->isa('Class::MOP::Method');
  
      return $self->_method_map->{$method_name} = $self->wrap_method_body(
          body                 => $method,
          name                 => $method_name,
          associated_metaclass => $self,
      );
  }
  
  sub _get_maybe_raw_method {
      my ( $self, $method_name ) = @_;
  
      my $map_entry = $self->_method_map->{$method_name};
      return $map_entry if defined $map_entry;
  
      my $code = $self->get_package_symbol("&$method_name");
  
      return unless $code && $self->_code_is_mine($code);
  
      return $code;
  }
  
  sub remove_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || $self->_throw_exception( MustDefineAMethodName => instance => $self );
  
      my $removed_method = delete $self->_method_map->{$method_name};
  
      $self->remove_package_symbol("&$method_name");
  
      $removed_method->detach_from_class
          if blessed($removed_method) && $removed_method->isa('Class::MOP::Method');
  
      # still valid, since we just removed the method from the map
      $self->update_package_cache_flag;
  
      return $removed_method;
  }
  
  sub get_method_list {
      my $self = shift;
  
      return keys %{ $self->_full_method_map };
  }
  
  sub _get_local_methods {
      my $self = shift;
  
      return values %{ $self->_full_method_map };
  }
  
  sub _restore_metamethods_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      my $package_name = $self->name;
  
      # Check if Perl debugger is enabled
      my $debugger_enabled = ($^P & 0x10);
      my $debug_method_info;
  
      for my $method ($old_meta->_get_local_methods) {
          my $method_name = $method->name;
  
          # Track DB::sub information for this method if debugger is enabled.
          # This contains original method filename and line numbers.
          $debug_method_info = '';
          if ($debugger_enabled) {
              $debug_method_info = $DB::sub{$package_name . "::" . $method_name}
          }
  
          $method->_make_compatible_with($self->method_metaclass);
          $self->add_method($method_name => $method);
  
          # Restore method debug information, which can be clobbered by add_method.
          # Note that we handle this here instead of in add_method, because we
          # only want to preserve the original debug info in cases where we are
          # restoring a method, not overwriting a method.
          if ($debugger_enabled && $debug_method_info) {
              $DB::sub{$package_name . "::" . $method_name} = $debug_method_info;
          }
      }
  }
  
  sub reset_package_cache_flag  { (shift)->{'_package_cache_flag'} = undef }
  sub update_package_cache_flag {
      my $self = shift;
      # NOTE:
      # we can manually update the cache number
      # since we are actually adding the method
      # to our cache as well. This avoids us
      # having to regenerate the method_map.
      # - SL
      $self->{'_package_cache_flag'} = Class::MOP::check_package_cache_flag($self->name);
  }
  
  sub _full_method_map {
      my $self = shift;
  
      my $pkg_gen = Class::MOP::check_package_cache_flag($self->name);
  
      if (($self->{_package_cache_flag_full} || -1) != $pkg_gen) {
          # forcibly reify all method map entries
          $self->get_method($_)
              for $self->list_all_package_symbols('CODE');
          $self->{_package_cache_flag_full} = $pkg_gen;
      }
  
      return $self->_method_map;
  }
  
  1;
  
  # ABSTRACT: Methods for metaclasses which have methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin::HasMethods - Methods for metaclasses which have methods
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class implements methods for metaclasses which have methods
  (L<Class::MOP::Class> and L<Moose::Meta::Role>). See L<Class::MOP::Class> for
  API details.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_HASMETHODS

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Mixin/HasOverloads.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_HASOVERLOADS';
  package Class::MOP::Mixin::HasOverloads;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::MOP::Overload;
  
  use Devel::OverloadInfo 0.004 'overload_info';
  use Scalar::Util 'blessed';
  use Sub::Identify 'sub_name', 'stash_name';
  
  use overload ();
  
  use parent 'Class::MOP::Mixin';
  
  sub is_overloaded {
      my $self = shift;
      Devel::OverloadInfo::is_overloaded($self->name);
  }
  
  sub get_overload_list {
      my $self = shift;
  
      my $info = $self->_overload_info;
      return grep { $_ ne 'fallback' } keys %{$info}
  }
  
  sub get_all_overloaded_operators {
      my $self = shift;
      return map { $self->_overload_for($_) } $self->get_overload_list;
  }
  
  sub has_overloaded_operator {
      my $self = shift;
      my ($op) = @_;
      return defined $self->_overload_info->{$op};
  }
  
  sub _overload_map {
      $_[0]->{_overload_map} ||= {};
  }
  
  sub get_overloaded_operator {
      my $self = shift;
      my ($op) = @_;
      return $self->_overload_map->{$op} ||= $self->_overload_for($op);
  }
  
  use constant _SET_FALLBACK_EACH_TIME => $] < 5.120;
  
  sub add_overloaded_operator {
      my $self = shift;
      my ( $op, $overload ) = @_;
  
      my %p = ( associated_metaclass => $self );
      if ( !ref $overload ) {
          %p = (
              %p,
              operator             => $op,
              method_name          => $overload,
              associated_metaclass => $self,
          );
          $p{method} = $self->get_method($overload)
              if $self->has_method($overload);
          $overload = Class::MOP::Overload->new(%p);
      }
      elsif ( !blessed $overload) {
          $overload = Class::MOP::Overload->new(
              operator        => $op,
              coderef         => $overload,
              coderef_name    => sub_name($overload),
              coderef_package => stash_name($overload),
              %p,
          );
      }
  
      $overload->attach_to_class($self);
      $self->_overload_map->{$op} = $overload;
  
      my %overload = (
            $op => $overload->has_coderef
          ? $overload->coderef
          : $overload->method_name
      );
  
      # Perl 5.10 and earlier appear to have a bug where setting a new
      # overloading operator wipes out the fallback value unless we pass it each
      # time.
      if (_SET_FALLBACK_EACH_TIME) {
          $overload{fallback} = $self->get_overload_fallback_value;
      }
  
      $self->name->overload::OVERLOAD(%overload);
  }
  
  sub remove_overloaded_operator {
      my $self = shift;
      my ($op) = @_;
  
      delete $self->_overload_map->{$op};
  
      # overload.pm provides no api for this - but the problem that makes this
      # necessary has been fixed in 5.18
      $self->get_or_add_package_symbol('%OVERLOAD')->{dummy}++
          if $] < 5.017000;
  
      $self->remove_package_symbol('&(' . $op);
  }
  
  sub get_overload_fallback_value {
      my $self = shift;
      return $self->_overload_info->{fallback}{value};
  }
  
  sub set_overload_fallback_value {
      my $self  = shift;
      my $value = shift;
  
      $self->name->overload::OVERLOAD( fallback => $value );
  }
  
  # We could cache this but we'd need some logic to clear it at all the right
  # times, which seems more tedious than it's worth.
  sub _overload_info {
      my $self = shift;
      return overload_info( $self->name ) || {};
  }
  
  sub _overload_for {
      my $self = shift;
      my $op   = shift;
  
      my $map = $self->_overload_map;
      return $map->{$op} if $map->{$op};
  
      my $info = $self->_overload_info->{$op};
      return unless $info;
  
      my %p = (
          operator             => $op,
          associated_metaclass => $self,
      );
  
      if ( $info->{code} && !$info->{method_name} ) {
          $p{coderef} = $info->{code};
          @p{ 'coderef_package', 'coderef_name' }
              = $info->{code_name} =~ /(.+)::([^:]+)/;
      }
      else {
          $p{method_name} = $info->{method_name};
          if ( $self->has_method( $p{method_name} ) ) {
              $p{method} = $self->get_method( $p{method_name} );
          }
      }
  
      return $map->{$op} = Class::MOP::Overload->new(%p);
  }
  
  1;
  
  # ABSTRACT: Methods for metaclasses which have overloads
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Mixin::HasOverloads - Methods for metaclasses which have overloads
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class implements methods for metaclasses which have overloads
  (L<Class::MOP::Clas> and L<Moose::Meta::Role>). See L<Class::MOP::Class> for
  API details.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MIXIN_HASOVERLOADS

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MODULE';
  package Class::MOP::Module;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use parent 'Class::MOP::Package';
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
      return bless {
          # Need to quote package to avoid a problem with PPI mis-parsing this
          # as a package statement.
  
          # from Class::MOP::Package
          'package' => $params->{package},
          namespace => \undef,
  
          # attributes
          version   => \undef,
          authority => \undef
      } => $class;
  }
  
  sub version {
      my $self = shift;
      ${$self->get_or_add_package_symbol('$VERSION')};
  }
  
  sub authority {
      my $self = shift;
      ${$self->get_or_add_package_symbol('$AUTHORITY')};
  }
  
  sub identifier {
      my $self = shift;
      join '-' => (
          $self->name,
          ($self->version   || ()),
          ($self->authority || ()),
      );
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      my $package   = delete $options{package};
      my $version   = delete $options{version};
      my $authority = delete $options{authority};
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_instantiate_module($version, $authority);
  
      return $meta;
  }
  
  sub _anon_package_prefix { 'Class::MOP::Module::__ANON__::SERIAL::' }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
      $class->_throw_exception( PackagesAndModulesAreNotCachable => class_name => $class,
                                                           params     => \%options,
                                                           is_module  => 1
                     );
  }
  
  sub _instantiate_module {
      my($self, $version, $authority) = @_;
      my $package_name = $self->name;
  
      $self->add_package_symbol('$VERSION' => $version)
          if defined $version;
      $self->add_package_symbol('$AUTHORITY' => $authority)
          if defined $authority;
  
      return;
  }
  
  1;
  
  # ABSTRACT: Module Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Module - Module Meta Object
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  A module is essentially a L<Class::MOP::Package> with metadata, in our
  case the version and authority.
  
  =head1 INHERITANCE
  
  B<Class::MOP::Module> is a subclass of L<Class::MOP::Package>.
  
  =head1 METHODS
  
  =head2 Class::MOP::Module->create($package, %options)
  
  Overrides C<create> from L<Class::MOP::Package> to provide these additional
  options:
  
  =over 4
  
  =item C<version>
  
  A version number, to be installed in the C<$VERSION> package global variable.
  
  =item C<authority>
  
  An authority, to be installed in the C<$AUTHORITY> package global variable.
  
  This is a legacy field and its use is not recommended.
  
  =back
  
  =head2 $metamodule->version
  
  This is a read-only attribute which returns the C<$VERSION> of the
  package, if one exists.
  
  =head2 $metamodule->authority
  
  This is a read-only attribute which returns the C<$AUTHORITY> of the
  package, if one exists.
  
  =head2 $metamodule->identifier
  
  This constructs a string which combines the name, version and
  authority.
  
  =head2 Class::MOP::Module->meta
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_MODULE

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_OBJECT';
  package Class::MOP::Object;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use parent 'Class::MOP::Mixin';
  use Scalar::Util 'blessed';
  use Module::Runtime;
  
  # introspection
  
  sub throw_error {
      shift->_throw_exception( Legacy => message => join('', @_) );
  }
  
  sub _inline_throw_error {
      my ( $self, $message ) = @_;
      return 'die Module::Runtime::use_module("Moose::Exception::Legacy")->new(message => ' . $message. ')';
  }
  
  sub _new {
      Class::MOP::class_of(shift)->new_object(@_);
  }
  
  # RANT:
  # Cmon, how many times have you written
  # the following code while debugging:
  #
  #  use Data::Dumper;
  #  warn Dumper $obj;
  #
  # It can get seriously annoying, so why
  # not just do this ...
  sub dump {
      my $self = shift;
      require Data::Dumper;
      local $Data::Dumper::Maxdepth = shift || 1;
      Data::Dumper::Dumper $self;
  }
  
  sub _real_ref_name {
      my $self = shift;
      return blessed($self);
  }
  
  sub _is_compatible_with {
      my $self = shift;
      my ($other_name) = @_;
  
      return $self->isa($other_name);
  }
  
  sub _can_be_made_compatible_with {
      my $self = shift;
      return !$self->_is_compatible_with(@_)
          && defined($self->_get_compatible_metaclass(@_));
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other_name) = @_;
  
      my $new_metaclass = $self->_get_compatible_metaclass($other_name);
  
      unless ( defined $new_metaclass ) {
          $self->_throw_exception( CannotMakeMetaclassCompatible => superclass_name => $other_name,
                                                                         class           => $self,
                                      );
      }
  
      # can't use rebless_instance here, because it might not be an actual
      # subclass in the case of, e.g. moose role reconciliation
      $new_metaclass->meta->_force_rebless_instance($self)
          if blessed($self) ne $new_metaclass;
  
      return $self;
  }
  
  sub _get_compatible_metaclass {
      my $self = shift;
      my ($other_name) = @_;
  
      return $self->_get_compatible_metaclass_by_subclassing($other_name);
  }
  
  sub _get_compatible_metaclass_by_subclassing {
      my $self = shift;
      my ($other_name) = @_;
      my $meta_name = blessed($self) ? $self->_real_ref_name : $self;
  
      if ($meta_name->isa($other_name)) {
          return $meta_name;
      }
      elsif ($other_name->isa($meta_name)) {
          return $other_name;
      }
  
      return;
  }
  
  1;
  
  # ABSTRACT: Base class for metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Object - Base class for metaclasses
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class is a very minimal base class for metaclasses.
  
  =head1 METHODS
  
  This class provides a few methods which are useful in all metaclasses.
  
  =head2 Class::MOP::???->meta
  
  This returns a L<Class::MOP::Class> object.
  
  =head2 $metaobject->dump($max_depth)
  
  This method uses L<Data::Dumper> to dump the object. You can pass an
  optional maximum depth, which will set C<$Data::Dumper::Maxdepth>. The
  default maximum depth is 1.
  
  =head2 $metaclass->throw_error($message)
  
  This method calls L<Class::MOP::Mixin/_throw_exception> internally, with an object
  of class L<Moose::Exception::Legacy>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_OBJECT

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Overload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_OVERLOAD';
  package Class::MOP::Overload;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use overload ();
  use Scalar::Util qw( blessed weaken );
  use Try::Tiny;
  
  use parent 'Class::MOP::Object';
  
  my %Operators = (
      map { $_ => 1 }
      grep { $_ ne 'fallback' }
      map  { split /\s+/ } values %overload::ops
  );
  
  sub new {
      my ( $class, %params ) = @_;
  
      unless ( defined $params{operator} ) {
          $class->_throw_exception('OverloadRequiresAnOperator');
      }
      unless ( $Operators{ $params{operator} } ) {
          $class->_throw_exception(
              'InvalidOverloadOperator',
              operator => $params{operator},
          );
      }
  
      unless ( defined $params{method_name} || $params{coderef} ) {
          $class->_throw_exception(
              'OverloadRequiresAMethodNameOrCoderef',
              operator => $params{operator},
          );
      }
  
      if ( $params{coderef} ) {
          unless ( defined $params{coderef_package}
              && defined $params{coderef_name} ) {
  
              $class->_throw_exception('OverloadRequiresNamesForCoderef');
          }
      }
  
      if ( $params{method}
          && !try { $params{method}->isa('Class::MOP::Method') } ) {
  
          $class->_throw_exception('OverloadRequiresAMetaMethod');
      }
  
      if ( $params{associated_metaclass}
          && !try { $params{associated_metaclass}->isa('Class::MOP::Module') } )
      {
  
          $class->_throw_exception('OverloadRequiresAMetaClass');
      }
  
      my @optional_attrs
          = qw( method_name coderef coderef_package coderef_name method associated_metaclass );
  
      return bless {
          operator => $params{operator},
          map { defined $params{$_} ? ( $_ => $params{$_} ) : () }
              @optional_attrs
          },
          $class;
  }
  
  sub operator { $_[0]->{operator} }
  
  sub method_name { $_[0]->{method_name} }
  sub has_method_name { exists $_[0]->{method_name} }
  
  sub method { $_[0]->{method} }
  sub has_method { exists $_[0]->{method} }
  
  sub coderef { $_[0]->{coderef} }
  sub has_coderef { exists $_[0]->{coderef} }
  
  sub coderef_package { $_[0]->{coderef_package} }
  sub has_coderef_package { exists $_[0]->{coderef_package} }
  
  sub coderef_name { $_[0]->{coderef_name} }
  sub has_coderef_name { exists $_[0]->{coderef_name} }
  
  sub associated_metaclass { $_[0]->{associated_metaclass} }
  
  sub is_anonymous {
      my $self = shift;
      return $self->has_coderef && $self->coderef_name eq '__ANON__';
  }
  
  sub attach_to_class {
      my ( $self, $class ) = @_;
      $self->{associated_metaclass} = $class;
      weaken $self->{associated_metaclass};
  }
  
  sub clone {
      my $self = shift;
  
      my $clone = bless { %{$self}, @_ }, blessed($self);
      weaken $clone->{associated_metaclass} if $clone->{associated_metaclass};
  
      $clone->_set_original_overload($self);
  
      return $clone;
  }
  
  sub original_overload { $_[0]->{original_overload} }
  sub _set_original_overload { $_[0]->{original_overload} = $_[1] }
  
  sub _is_equal_to {
      my $self  = shift;
      my $other = shift;
  
      if ( $self->has_coderef ) {
          return unless $other->has_coderef;
          return $self->coderef == $other->coderef;
      }
      else {
          return $self->method_name eq $other->method_name;
      }
  }
  
  1;
  
  # ABSTRACT: Overload Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Overload - Overload Meta Object
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
      my $meta     = Class->meta;
      my $overload = $meta->get_overloaded_operator('+');
  
      if ( $overload->has_method_name ) {
          print 'Method for + is ', $overload->method_name, "\n";
      }
      else {
          print 'Overloading for + is implemented by ',
              $overload->coderef_name, " sub\n";
      }
  
  =head1 DESCRIPTION
  
  This class provides meta information for overloading in classes and roles.
  
  =head1 INHERITANCE
  
  C<Class::MOP::Overload> is a subclass of L<Class::MOP::Object>.
  
  =head1 METHODS
  
  =head2 Class::MOP::Overload->new(%options)
  
  This method creates a new C<Class::MOP::Overload> object. It accepts a number
  of options:
  
  =over 4
  
  =item * operator
  
  This is a string that matches an operator known by the L<overload> module,
  such as C<""> or C<+>. This is required.
  
  =item * method_name
  
  The name of the method which implements the overloading. Note that this does
  not need to actually correspond to a real method, since it's okay to declare a
  not-yet-implemented overloading.
  
  Either this or the C<coderef> option must be passed.
  
  =item * method
  
  A L<Class::MOP::Method> object for the method which implements the
  overloading.
  
  This is optional.
  
  =item * coderef
  
  A coderef which implements the overloading.
  
  Either this or the C<method_name> option must be passed.
  
  =item * coderef_package
  
  The package where the coderef was defined.
  
  This is required if C<coderef> is passed.
  
  =item * coderef_name
  
  The name of the coderef. This can be "__ANON__".
  
  This is required if C<coderef> is passed.
  
  =item * associated_metaclass
  
  A L<Class::MOP::Module> object for the associated class or role.
  
  This is optional.
  
  =back
  
  =head2 $overload->operator
  
  Returns the operator for this overload object.
  
  =head2 $overload->method_name
  
  Returns the method name that implements overloading, if it has one.
  
  =head2 $overload->has_method_name
  
  Returns true if the object has a method name.
  
  =head2 $overload->method
  
  Returns the L<Class::MOP::Method> that implements overloading, if it has one.
  
  =head2 $overload->has_method
  
  Returns true if the object has a method.
  
  =head2 $overload->coderef
  
  Returns the coderef that implements overloading, if it has one.
  
  =head2 $overload->has_coderef
  
  Returns true if the object has a coderef.
  
  =head2 $overload->coderef_package
  
  Returns the package for the coderef that implements overloading, if it has
  one.
  
  =head2 $overload->has_coderef
  
  Returns true if the object has a coderef package.
  
  =head2 $overload->coderef_name
  
  Returns the sub name for the coderef that implements overloading, if it has
  one.
  
  =head2 $overload->has_coderef_name
  
  Returns true if the object has a coderef name.
  
  =head2 $overload->is_anonymous
  
  Returns true if the overloading is implemented by an anonymous coderef.
  
  =head2 $overload->associated_metaclass
  
  Returns the L<Class::MOP::Module> (class or role) that is associated with the
  overload object.
  
  =head2 $overload->clone
  
  Clones the overloading object, setting C<original_overload> in the process.
  
  =head2 $overload->original_overload
  
  For cloned objects, this returns the L<Class::MOP::Overload> object from which
  they were cloned. This can be used to determine the source of an overloading
  in a class that came from a role, for example.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_OVERLOAD

$fatpacked{"x86_64-linux-gnu-thread-multi/Class/MOP/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_PACKAGE';
  package Class::MOP::Package;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'weaken';
  use Devel::GlobalDestruction 'in_global_destruction';
  use Module::Runtime 'module_notional_filename';
  use Package::Stash;
  
  use parent 'Class::MOP::Object';
  
  # creation ...
  
  sub initialize {
      my ( $class, @args ) = @_;
  
      unshift @args, "package" if @args % 2;
  
      my %options = @args;
      my $package_name = delete $options{package};
  
      # we hand-construct the class until we can bootstrap it
      if ( my $meta = Class::MOP::get_metaclass_by_name($package_name) ) {
          return $meta;
      } else {
          my $meta = ( ref $class || $class )->_new({
              'package'   => $package_name,
              %options,
          });
          Class::MOP::store_metaclass_by_name($package_name, $meta);
  
          Class::MOP::weaken_metaclass($package_name) if $options{weaken};
  
  
          return $meta;
      }
  }
  
  sub reinitialize {
      my ( $class, @args ) = @_;
  
      unshift @args, "package" if @args % 2;
  
      my %options = @args;
      my $package_name = delete $options{package};
  
      (defined $package_name && $package_name
        && (!blessed $package_name || $package_name->isa('Class::MOP::Package')))
          || $class->_throw_exception( MustPassAPackageNameOrAnExistingClassMOPPackageInstance => params => \%options,
                                                                                         class  => $class
                            );
  
      $package_name = $package_name->name
          if blessed $package_name;
  
      Class::MOP::remove_metaclass_by_name($package_name);
  
      $class->initialize($package_name, %options); # call with first arg form for compat
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      my $meta = $class->initialize(@args);
      my $filename = module_notional_filename($meta->name);
      $INC{$filename} = '(set by Moose)'
          unless exists $INC{$filename};
  
      return $meta;
  }
  
  ## ANON packages
  
  {
      # NOTE:
      # this should be sufficient, if you have a
      # use case where it is not, write a test and
      # I will change it.
      my $ANON_SERIAL = 0;
  
      my %ANON_PACKAGE_CACHE;
  
      # NOTE:
      # we need a sufficiently annoying prefix
      # this should suffice for now, this is
      # used in a couple of places below, so
      # need to put it up here for now.
      sub _anon_package_prefix { 'Class::MOP::Package::__ANON__::SERIAL::' }
  
      sub is_anon {
          my $self = shift;
          no warnings 'uninitialized';
          my $prefix = $self->_anon_package_prefix;
          $self->name =~ /^\Q$prefix/;
      }
  
      sub create_anon {
          my ($class, %options) = @_;
  
          my $cache_ok = delete $options{cache};
          $options{weaken} = !$cache_ok unless exists $options{weaken};
  
          my $cache_key;
          if ($cache_ok) {
              $cache_key = $class->_anon_cache_key(%options);
              undef $cache_ok if !defined($cache_key);
          }
  
          if ($cache_ok) {
              if (defined $ANON_PACKAGE_CACHE{$cache_key}) {
                  return $ANON_PACKAGE_CACHE{$cache_key};
              }
          }
  
          my $package_name = $class->_anon_package_prefix . ++$ANON_SERIAL;
  
          my $meta = $class->create($package_name, %options);
  
          if ($cache_ok) {
              $ANON_PACKAGE_CACHE{$cache_key} = $meta;
              weaken($ANON_PACKAGE_CACHE{$cache_key});
          }
  
          return $meta;
      }
  
      sub _anon_cache_key {
          my $class = shift;
          my %options = @_;
          $class->_throw_exception( PackagesAndModulesAreNotCachable => class_name => $class,
                                                               params     => \%options,
                                                               is_module  => 0
                         );
      }
  
      sub DESTROY {
          my $self = shift;
  
          return if in_global_destruction(); # it'll happen soon anyway and this just makes things more complicated
  
          $self->_free_anon
              if $self->is_anon;
      }
  
      sub _free_anon {
          my $self = shift;
          my $name = $self->name;
  
          # Moose does a weird thing where it replaces the metaclass for
          # class when fixing metaclass incompatibility. In that case,
          # we don't want to clean out the namespace now. We can detect
          # that because Moose will explicitly update the singleton
          # cache in Class::MOP using store_metaclass_by_name, which
          # means that the new metaclass will already exist in the cache
          # by this point.
          # The other options here are that $current_meta can be undef if
          # remove_metaclass_by_name is called explicitly (since the hash
          # entry is removed first, and then this destructor is called),
          # or that $current_meta can be the same as $self, which happens
          # when the metaclass goes out of scope (since the weak reference
          # in the metaclass cache won't be freed until after this
          # destructor runs).
          my $current_meta = Class::MOP::get_metaclass_by_name($name);
          return if defined($current_meta) && $current_meta ne $self;
  
          my ($first_fragments, $last_fragment) = ($name =~ /^(.*)::(.*)$/);
  
          no strict 'refs';
          # clear @ISA first, to avoid a memory leak
          # see https://rt.perl.org/rt3/Public/Bug/Display.html?id=92708
          @{$name . '::ISA'} = ();
          %{$name . '::'}    = ();
          delete ${$first_fragments . '::'}{$last_fragment . '::'};
  
          Class::MOP::remove_metaclass_by_name($name);
  
          delete $INC{module_notional_filename($name)};
      }
  
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # Need to quote package to avoid a problem with PPI mis-parsing this
          # as a package statement.
          'package' => $params->{package},
  
          # NOTE:
          # because of issues with the Perl API
          # to the typeglob in some versions, we
          # need to just always grab a new
          # reference to the hash in the accessor.
          # Ideally we could just store a ref and
          # it would Just Work, but oh well :\
  
          namespace => \undef,
  
      } => $class;
  }
  
  # Attributes
  
  # NOTE:
  # all these attribute readers will be bootstrapped
  # away in the Class::MOP bootstrap section
  
  sub _package_stash {
      $_[0]->{_package_stash} ||= Package::Stash->new($_[0]->name)
  }
  sub namespace {
      $_[0]->_package_stash->namespace
  }
  
  # Class attributes
  
  # ... these functions have to touch the symbol table itself,.. yuk
  
  sub add_package_symbol {
      my $self = shift;
      $self->_package_stash->add_symbol(@_);
  }
  
  sub remove_package_glob {
      my $self = shift;
      $self->_package_stash->remove_glob(@_);
  }
  
  # ... these functions deal with stuff on the namespace level
  
  sub has_package_symbol {
      my $self = shift;
      $self->_package_stash->has_symbol(@_);
  }
  
  sub get_package_symbol {
      my $self = shift;
      $self->_package_stash->get_symbol(@_);
  }
  
  sub get_or_add_package_symbol {
      my $self = shift;
      $self->_package_stash->get_or_add_symbol(@_);
  }
  
  sub remove_package_symbol {
      my $self = shift;
      $self->_package_stash->remove_symbol(@_);
  }
  
  sub list_all_package_symbols {
      my $self = shift;
      $self->_package_stash->list_all_symbols(@_);
  }
  
  sub get_all_package_symbols {
      my $self = shift;
      $self->_package_stash->get_all_symbols(@_);
  }
  
  1;
  
  # ABSTRACT: Package Meta Object
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::MOP::Package - Package Meta Object
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  The Package Protocol provides an abstraction of a Perl 5 package. A
  package is basically namespace, and this module provides methods for
  looking at and changing that namespace's symbol table.
  
  =head1 METHODS
  
  =head2 Class::MOP::Package->initialize($package_name, %options)
  
  This method creates a new C<Class::MOP::Package> instance which
  represents specified package. If an existing metaclass object exists
  for the package, that will be returned instead. No options are valid at the
  package level.
  
  =head2 Class::MOP::Package->reinitialize($package, %options)
  
  This method forcibly removes any existing metaclass for the package
  before calling C<initialize>. In contrast to C<initialize>, you may
  also pass an existing C<Class::MOP::Package> instance instead of just
  a package name as C<$package>.
  
  Do not call this unless you know what you are doing.
  
  =head2 Class::MOP::Package->create($package, %options)
  
  Creates a new C<Class::MOP::Package> instance which represents the specified
  package, and also does some initialization of that package. Currently, this
  just does the same thing as C<initialize>, but is overridden in subclasses,
  such as C<Class::MOP::Class>.
  
  =head2 Class::MOP::Package->create_anon(%options)
  
  Creates a new anonymous package. Valid keys for C<%options> are:
  
  =over 4
  
  =item C<cache>
  
  If this will be C<true> (the default is C<false>), the instance will be cached
  in C<Class::MOP>'s metaclass cache.
  
  =item C<weaken>
  
  If this is C<true> (the default C<true> when L<cache> is C<false>), the instance
  stored in C<Class::MOP>'s metaclass cache will be weakened, so that the
  anonymous package will be garbage collected when the returned instance goes out
  of scope.
  
  =back
  
  =head2 $metapackage->is_anon
  
  Returns true if the package is an anonymous package.
  
  =head2 $metapackage->name
  
  This is returns the package's name, as passed to the constructor.
  
  =head2 $metapackage->namespace
  
  This returns a hash reference to the package's symbol table. The keys
  are symbol names and the values are typeglob references.
  
  =head2 $metapackage->add_package_symbol($variable_name, $initial_value)
  
  This method accepts a variable name and an optional initial value. The
  C<$variable_name> must contain a leading sigil.
  
  This method creates the variable in the package's symbol table, and
  sets it to the initial value if one was provided.
  
  =head2 $metapackage->get_package_symbol($variable_name)
  
  Given a variable name, this method returns the variable as a reference
  or undef if it does not exist. The C<$variable_name> must contain a
  leading sigil.
  
  =head2 $metapackage->get_or_add_package_symbol($variable_name)
  
  Given a variable name, this method returns the variable as a reference.
  If it does not exist, a default value will be generated if possible. The
  C<$variable_name> must contain a leading sigil.
  
  =head2 $metapackage->has_package_symbol($variable_name)
  
  Returns true if there is a package variable defined for
  C<$variable_name>. The C<$variable_name> must contain a leading sigil.
  
  =head2 $metapackage->remove_package_symbol($variable_name)
  
  This will remove the package variable specified C<$variable_name>. The
  C<$variable_name> must contain a leading sigil.
  
  =head2 $metapackage->remove_package_glob($glob_name)
  
  Given the name of a glob, this will remove that glob from the
  package's symbol table. Glob names do not include a sigil. Removing
  the glob removes all variables and subroutines with the specified
  name.
  
  =head2 $metapackage->list_all_package_symbols($type_filter)
  
  This will list all the glob names associated with the current
  package. These names do not have leading sigils.
  
  You can provide an optional type filter, which should be one of
  'SCALAR', 'ARRAY', 'HASH', or 'CODE'.
  
  =head2 $metapackage->get_all_package_symbols($type_filter)
  
  This works much like C<list_all_package_symbols>, but it returns a
  hash reference. The keys are glob names and the values are references
  to the value for that name.
  
  =head2 Class::MOP::Package->meta
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CLASS_MOP_PACKAGE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE';
  use strict;
  use warnings;
  package Moose; # git description: 2.1602-5-g942b58b
  our $VERSION = '2.1603';
  our $AUTHORITY = 'cpan:STEVAN';
  
  use 5.008003;
  
  use Scalar::Util ();
  use Carp         'carp';
  use Module::Runtime 'module_notional_filename';
  use Class::Load  'is_class_loaded';
  
  use Moose::Deprecated;
  use Moose::Exporter;
  
  use Class::MOP;
  
  BEGIN {
      die "Class::MOP version $Moose::VERSION required--this is version $Class::MOP::VERSION"
          if $Moose::VERSION && $Class::MOP::VERSION ne $Moose::VERSION;
  }
  
  use Moose::Meta::Class;
  use Moose::Meta::TypeConstraint;
  use Moose::Meta::TypeCoercion;
  use Moose::Meta::Attribute;
  use Moose::Meta::Instance;
  
  use Moose::Object;
  
  use Moose::Meta::Role;
  use Moose::Meta::Role::Composite;
  use Moose::Meta::Role::Application;
  use Moose::Meta::Role::Application::RoleSummation;
  use Moose::Meta::Role::Application::ToClass;
  use Moose::Meta::Role::Application::ToRole;
  use Moose::Meta::Role::Application::ToInstance;
  
  use Moose::Util::TypeConstraints;
  use Moose::Util 'throw_exception';
  
  use Moose::Meta::Attribute::Native;
  
  sub extends {
      my $meta = shift;
  
      unless ( @_ )
      {
          throw_exception( ExtendsMissingArgs => class_name => $meta->name );
      }
      # this checks the metaclass to make sure
      # it is correct, sometimes it can get out
      # of sync when the classes are being built
      $meta->superclasses(@_);
  }
  
  sub with {
      Moose::Util::apply_all_roles(shift, @_);
  }
  
  sub throw_error {
      shift;
      Class::MOP::Object->throw_error(@_);
  }
  
  sub has {
      my $meta = shift;
      my $name = shift;
  
      my %context = Moose::Util::_caller_info;
      $context{context} = 'has declaration';
      $context{type} = 'class';
      my @options = ( definition_context => \%context, @_ );
      my $attrs = ( ref($name) eq 'ARRAY' ) ? $name : [ ($name) ];
      $meta->add_attribute( $_, @options ) for @$attrs;
  }
  
  sub before {
      Moose::Util::add_method_modifier(shift, 'before', \@_);
  }
  
  sub after {
      Moose::Util::add_method_modifier(shift, 'after', \@_);
  }
  
  sub around {
      Moose::Util::add_method_modifier(shift, 'around', \@_);
  }
  
  our $SUPER_PACKAGE;
  our $SUPER_BODY;
  our @SUPER_ARGS;
  
  sub super {
      if (@_) {
          carp 'Arguments passed to super() are ignored';
      }
  
      # This check avoids a recursion loop - see
      # t/bugs/super_recursion.t
      return if defined $SUPER_PACKAGE && $SUPER_PACKAGE ne caller();
      return unless $SUPER_BODY; $SUPER_BODY->(@SUPER_ARGS);
  }
  
  sub override {
      my $meta = shift;
      my ( $name, $method ) = @_;
      $meta->add_override_method_modifier( $name => $method );
  }
  
  sub inner {
      my $pkg = caller();
      our ( %INNER_BODY, %INNER_ARGS );
  
      if ( my $body = $INNER_BODY{$pkg} ) {
          my @args = @{ $INNER_ARGS{$pkg} };
          local $INNER_ARGS{$pkg};
          local $INNER_BODY{$pkg};
          return $body->(@args);
      } else {
          return;
      }
  }
  
  sub augment {
      my $meta = shift;
      my ( $name, $method ) = @_;
      $meta->add_augment_method_modifier( $name => $method );
  }
  
  Moose::Exporter->setup_import_methods(
      with_meta => [
          qw( extends with has before after around override augment )
      ],
      as_is => [
          qw( super inner ),
          'Carp::confess',
          'Scalar::Util::blessed',
      ],
  );
  
  sub init_meta {
      shift;
      my %args = @_;
  
      my $class = $args{for_class}
          or throw_exception( InitMetaRequiresClass => params => \%args );
  
      my $base_class = $args{base_class} || 'Moose::Object';
      my $metaclass  = $args{metaclass}  || 'Moose::Meta::Class';
      my $meta_name  = exists $args{meta_name} ? $args{meta_name} : 'meta';
  
      throw_exception( MetaclassNotLoaded => class_name => $metaclass )
          unless is_class_loaded($metaclass);
  
      throw_exception( MetaclassMustBeASubclassOfMooseMetaClass => class_name => $metaclass )
          unless $metaclass->isa('Moose::Meta::Class');
  
      # make a subtype for each Moose class
      class_type($class)
          unless find_type_constraint($class);
  
      my $meta;
  
      if ( $meta = Class::MOP::get_metaclass_by_name($class) ) {
          unless ( $meta->isa("Moose::Meta::Class") ) {
              if ( $meta->isa('Moose::Meta::Role') ) {
                  throw_exception( MetaclassIsARoleNotASubclassOfGivenMetaclass => role_name => $class,
                                                                                   metaclass => $metaclass,
                                                                                   role      => $meta
                                 );
              } else {
                  throw_exception( MetaclassIsNotASubclassOfGivenMetaclass => class_name => $class,
                                                                              metaclass  => $metaclass,
                                                                              class      => $meta
                                 );
              }
          }
      } else {
          # no metaclass
  
          # now we check whether our ancestors have metaclass, and if so borrow that
          my ( undef, @isa ) = @{ mro::get_linear_isa($class) };
  
          foreach my $ancestor ( @isa ) {
              my $ancestor_meta = Class::MOP::get_metaclass_by_name($ancestor) || next;
  
              my $ancestor_meta_class = $ancestor_meta->_real_ref_name;
  
              # if we have an ancestor metaclass that inherits $metaclass, we use
              # that. This is like _fix_metaclass_incompatibility, but we can do it now.
  
              # the case of having an ancestry is not very common, but arises in
              # e.g. Reaction
              unless ( $metaclass->isa( $ancestor_meta_class ) ) {
                  if ( $ancestor_meta_class->isa($metaclass) ) {
                      $metaclass = $ancestor_meta_class;
                  }
              }
          }
  
          $meta = $metaclass->initialize($class);
          my $filename = module_notional_filename($meta->name);
          $INC{$filename} = '(set by Moose)'
              unless exists $INC{$filename};
      }
  
      if (defined $meta_name) {
          # also check for inherited non moose 'meta' method?
          my $existing = $meta->get_method($meta_name);
          if ($existing && !$existing->isa('Class::MOP::Method::Meta')) {
              Carp::cluck "Moose is overwriting an existing method named "
                        . "$meta_name in class $class with a method "
                        . "which returns the class's metaclass. If this is "
                        . "actually what you want, you should remove the "
                        . "existing method, otherwise, you should rename or "
                        . "disable this generated method using the "
                        . "'-meta_name' option to 'use Moose'.";
          }
          $meta->_add_meta_method($meta_name);
      }
  
      # make sure they inherit from Moose::Object
      $meta->superclasses($base_class)
        unless $meta->superclasses();
  
      return $meta;
  }
  
  # This may be used in some older MooseX extensions.
  sub _get_caller {
      goto &Moose::Exporter::_get_caller;
  }
  
  ## make 'em all immutable
  
  $_->make_immutable(
      inline_constructor => 1,
      constructor_name   => "_new",
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { $_->meta }
      qw(
      Moose::Meta::Attribute
      Moose::Meta::Class
      Moose::Meta::Instance
  
      Moose::Meta::TypeCoercion
      Moose::Meta::TypeCoercion::Union
  
      Moose::Meta::Method
      Moose::Meta::Method::Constructor
      Moose::Meta::Method::Destructor
      Moose::Meta::Method::Overridden
      Moose::Meta::Method::Augmented
  
      Moose::Meta::Role
      Moose::Meta::Role::Attribute
      Moose::Meta::Role::Method
      Moose::Meta::Role::Method::Required
      Moose::Meta::Role::Method::Conflicting
  
      Moose::Meta::Role::Composite
  
      Moose::Meta::Role::Application
      Moose::Meta::Role::Application::RoleSummation
      Moose::Meta::Role::Application::ToClass
      Moose::Meta::Role::Application::ToRole
      Moose::Meta::Role::Application::ToInstance
  );
  
  $_->make_immutable(
      inline_constructor => 0,
      constructor_name   => undef,
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { $_->meta }
      qw(
      Moose::Meta::Method::Accessor
      Moose::Meta::Method::Delegation
      Moose::Meta::Mixin::AttributeCore
  );
  
  1;
  
  # ABSTRACT: A postmodern object system for Perl 5
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose - A postmodern object system for Perl 5
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package Point;
    use Moose; # automatically turns on strict and warnings
  
    has 'x' => (is => 'rw', isa => 'Int');
    has 'y' => (is => 'rw', isa => 'Int');
  
    sub clear {
        my $self = shift;
        $self->x(0);
        $self->y(0);
    }
  
    package Point3D;
    use Moose;
  
    extends 'Point';
  
    has 'z' => (is => 'rw', isa => 'Int');
  
    after 'clear' => sub {
        my $self = shift;
        $self->z(0);
    };
  
  =head1 DESCRIPTION
  
  Moose is an extension of the Perl 5 object system.
  
  The main goal of Moose is to make Perl 5 Object Oriented programming
  easier, more consistent, and less tedious. With Moose you can think
  more about what you want to do and less about the mechanics of OOP.
  
  Additionally, Moose is built on top of L<Class::MOP>, which is a
  metaclass system for Perl 5. This means that Moose not only makes
  building normal Perl 5 objects better, but it provides the power of
  metaclass programming as well.
  
  =head2 New to Moose?
  
  If you're new to Moose, the best place to start is the
  L<Moose::Manual> docs, followed by the L<Moose::Cookbook>. The intro
  will show you what Moose is, and how it makes Perl 5 OO better.
  
  The cookbook recipes on Moose basics will get you up to speed with
  many of Moose's features quickly. Once you have an idea of what Moose
  can do, you can use the API documentation to get more detail on
  features which interest you.
  
  =head2 Moose Extensions
  
  The C<MooseX::> namespace is the official place to find Moose extensions.
  These extensions can be found on the CPAN.  The easiest way to find them
  is to search for them (L<https://metacpan.org/search?q=MooseX::>),
  or to examine L<Task::Moose> which aims to keep an up-to-date, easily
  installable list of Moose extensions.
  
  =head1 TRANSLATIONS
  
  Much of the Moose documentation has been translated into other languages.
  
  =over 4
  
  =item Japanese
  
  Japanese docs can be found at
  L<http://perldoc.perlassociation.org/pod/Moose-Doc-JA/index.html>. The
  source POD files can be found in GitHub:
  L<http://github.com/jpa/Moose-Doc-JA>
  
  =back
  
  =head1 BUILDING CLASSES WITH MOOSE
  
  Moose makes every attempt to provide as much convenience as possible during
  class construction/definition, but still stay out of your way if you want it
  to. Here are a few items to note when building classes with Moose.
  
  When you C<use Moose>, Moose will set the class's parent class to
  L<Moose::Object>, I<unless> the class using Moose already has a parent
  class. In addition, specifying a parent with C<extends> will change the parent
  class.
  
  Moose will also manage all attributes (including inherited ones) that are
  defined with C<has>. And (assuming you call C<new>, which is inherited from
  L<Moose::Object>) this includes properly initializing all instance slots,
  setting defaults where appropriate, and performing any type constraint checking
  or coercion.
  
  =head1 PROVIDED METHODS
  
  Moose provides a number of methods to all your classes, mostly through the
  inheritance of L<Moose::Object>. There is however, one exception. By default,
  Moose will install a method named C<meta> in any class which uses
  C<Moose>. This method returns the current class's metaclass.
  
  If you'd like to rename this method, you can do so by passing the
  C<-meta_name> option when using Moose:
  
      use Moose -meta_name => 'my_meta';
  
  However, the L<Moose::Object> class I<also> provides a method named C<meta>
  which does the same thing. If your class inherits from L<Moose::Object> (which
  is the default), then you will still have a C<meta> method. However, if your
  class inherits from a parent which provides a C<meta> method of its own, your
  class will inherit that instead.
  
  If you'd like for Moose to not install a meta method at all, you can pass
  C<undef> as the C<-meta_name> option:
  
      use Moose -meta_name => undef;
  
  Again, you will still inherit C<meta> from L<Moose::Object> in this case.
  
  =head1 EXPORTED FUNCTIONS
  
  Moose will export a number of functions into the class's namespace which
  may then be used to set up the class. These functions all work directly
  on the current class.
  
  =head2 extends (@superclasses)
  
  This function will set the superclass(es) for the current class. If the parent
  classes are not yet loaded, then C<extends> tries to load them.
  
  This approach is recommended instead of C<use L<base>>/C<use L<parent>>, because
  C<use base> actually C<push>es onto the class's C<@ISA>, whereas C<extends> will
  replace it. This is important to ensure that classes which do not have
  superclasses still properly inherit from L<Moose::Object>.
  
  Each superclass can be followed by a hash reference with options. Currently,
  only L<-version|Class::MOP/Class Loading Options> is recognized:
  
      extends 'My::Parent'      => { -version => 0.01 },
              'My::OtherParent' => { -version => 0.03 };
  
  An exception will be thrown if the version requirements are not
  satisfied.
  
  =head2 with (@roles)
  
  This will apply a given set of C<@roles> to the local class.
  
  Like with C<extends>, each specified role can be followed by a hash
  reference with a L<-version|Class::MOP/Class Loading Options> option:
  
      with 'My::Role'      => { -version => 0.32 },
           'My::Otherrole' => { -version => 0.23 };
  
  The specified version requirements must be satisfied, otherwise an
  exception will be thrown.
  
  If your role takes options or arguments, they can be passed along in the
  hash reference as well.
  
  =head2 has $name|@$names =E<gt> %options
  
  This will install an attribute of a given C<$name> into the current class. If
  the first parameter is an array reference, it will create an attribute for
  every C<$name> in the list. The C<%options> will be passed to the constructor
  for L<Moose::Meta::Attribute> (which inherits from L<Class::MOP::Attribute>),
  so the full documentation for the valid options can be found there. These are
  the most commonly used options:
  
  =over 4
  
  =item I<is =E<gt> 'rw'|'ro'>
  
  The I<is> option accepts either I<rw> (for read/write) or I<ro> (for read
  only). These will create either a read/write accessor or a read-only
  accessor respectively, using the same name as the C<$name> of the attribute.
  
  If you need more control over how your accessors are named, you can
  use the L<reader|Class::MOP::Attribute/reader>,
  L<writer|Class::MOP::Attribute/writer> and
  L<accessor|Class::MOP::Attribute/accessor> options inherited from
  L<Class::MOP::Attribute>, however if you use those, you won't need the
  I<is> option.
  
  =item I<isa =E<gt> $type_name>
  
  The I<isa> option uses Moose's type constraint facilities to set up runtime
  type checking for this attribute. Moose will perform the checks during class
  construction, and within any accessors. The C<$type_name> argument must be a
  string. The string may be either a class name or a type defined using
  Moose's type definition features. (Refer to L<Moose::Util::TypeConstraints>
  for information on how to define a new type, and how to retrieve type meta-data).
  
  =item I<coerce =E<gt> (1|0)>
  
  This will attempt to use coercion with the supplied type constraint to change
  the value passed into any accessors or constructors. You B<must> supply a type
  constraint, and that type constraint B<must> define a coercion. See
  L<Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion> for an example.
  
  =item I<does =E<gt> $role_name>
  
  This will accept the name of a role which the value stored in this attribute
  is expected to have consumed.
  
  =item I<required =E<gt> (1|0)>
  
  This marks the attribute as being required. This means a value must be
  supplied during class construction, I<or> the attribute must be lazy
  and have either a default or a builder. Note that c<required> does not
  say anything about the attribute's value, which can be C<undef>.
  
  =item I<weak_ref =E<gt> (1|0)>
  
  This will tell the class to store the value of this attribute as a weakened
  reference. If an attribute is a weakened reference, it B<cannot> also be
  coerced. Note that when a weak ref expires, the attribute's value becomes
  undefined, and is still considered to be set for purposes of predicate,
  default, etc.
  
  =item I<lazy =E<gt> (1|0)>
  
  This will tell the class to not create this slot until absolutely necessary.
  If an attribute is marked as lazy it B<must> have a default or builder
  supplied.
  
  =item I<trigger =E<gt> $code>
  
  The I<trigger> option is a CODE reference which will be called after
  the value of the attribute is set. The CODE ref is passed the
  instance itself, the updated value, and the original value if the
  attribute was already set.
  
  You B<can> have a trigger on a read-only attribute.
  
  B<NOTE:> Triggers will only fire when you B<assign> to the attribute,
  either in the constructor, or using the writer. Default and built values will
  B<not> cause the trigger to be fired.
  
  =item I<handles =E<gt> ARRAY | HASH | REGEXP | ROLE | ROLETYPE | DUCKTYPE | CODE>
  
  The I<handles> option provides Moose classes with automated delegation features.
  This is a pretty complex and powerful option. It accepts many different option
  formats, each with its own benefits and drawbacks.
  
  B<NOTE:> The class being delegated to does not need to be a Moose based class,
  which is why this feature is especially useful when wrapping non-Moose classes.
  
  All I<handles> option formats share the following traits:
  
  You cannot override a locally defined method with a delegated method; an
  exception will be thrown if you try. That is to say, if you define C<foo> in
  your class, you cannot override it with a delegated C<foo>. This is almost never
  something you would want to do, and if it is, you should do it by hand and not
  use Moose.
  
  You cannot override any of the methods found in Moose::Object, or the C<BUILD>
  and C<DEMOLISH> methods. These will not throw an exception, but will silently
  move on to the next method in the list. My reasoning for this is that you would
  almost never want to do this, since it usually breaks your class. As with
  overriding locally defined methods, if you do want to do this, you should do it
  manually, not with Moose.
  
  You do not I<need> to have a reader (or accessor) for the attribute in order
  to delegate to it. Moose will create a means of accessing the value for you,
  however this will be several times B<less> efficient then if you had given
  the attribute a reader (or accessor) to use.
  
  Below is the documentation for each option format:
  
  =over 4
  
  =item C<ARRAY>
  
  This is the most common usage for I<handles>. You basically pass a list of
  method names to be delegated, and Moose will install a delegation method
  for each one.
  
  =item C<HASH>
  
  This is the second most common usage for I<handles>. Instead of a list of
  method names, you pass a HASH ref where each key is the method name you
  want installed locally, and its value is the name of the original method
  in the class being delegated to.
  
  This can be very useful for recursive classes like trees. Here is a
  quick example (soon to be expanded into a Moose::Cookbook recipe):
  
    package Tree;
    use Moose;
  
    has 'node' => (is => 'rw', isa => 'Any');
  
    has 'children' => (
        is      => 'ro',
        isa     => 'ArrayRef',
        default => sub { [] }
    );
  
    has 'parent' => (
        is          => 'rw',
        isa         => 'Tree',
        weak_ref    => 1,
        handles     => {
            parent_node => 'node',
            siblings    => 'children',
        }
    );
  
  In this example, the Tree package gets C<parent_node> and C<siblings> methods,
  which delegate to the C<node> and C<children> methods (respectively) of the Tree
  instance stored in the C<parent> slot.
  
  You may also use an array reference to curry arguments to the original method.
  
    has 'thing' => (
        ...
        handles => { set_foo => [ set => 'foo' ] },
    );
  
    # $self->set_foo(...) calls $self->thing->set('foo', ...)
  
  The first element of the array reference is the original method name, and the
  rest is a list of curried arguments.
  
  =item C<REGEXP>
  
  The regexp option works very similar to the ARRAY option, except that it builds
  the list of methods for you. It starts by collecting all possible methods of the
  class being delegated to, then filters that list using the regexp supplied here.
  
  B<NOTE:> An I<isa> option is required when using the regexp option format. This
  is so that we can determine (at compile time) the method list from the class.
  Without an I<isa> this is just not possible.
  
  =item C<ROLE> or C<ROLETYPE>
  
  With the role option, you specify the name of a role or a
  L<role type|Moose::Meta::TypeConstraint::Role> whose "interface" then becomes
  the list of methods to handle. The "interface" can be defined as; the methods
  of the role and any required methods of the role. It should be noted that this
  does B<not> include any method modifiers or generated attribute methods (which
  is consistent with role composition).
  
  =item C<DUCKTYPE>
  
  With the duck type option, you pass a duck type object whose "interface" then
  becomes the list of methods to handle. The "interface" can be defined as the
  list of methods passed to C<duck_type> to create a duck type object. For more
  information on C<duck_type> please check
  L<Moose::Util::TypeConstraints>.
  
  =item C<CODE>
  
  This is the option to use when you really want to do something funky. You should
  only use it if you really know what you are doing, as it involves manual
  metaclass twiddling.
  
  This takes a code reference, which should expect two arguments. The first is the
  attribute meta-object this I<handles> is attached to. The second is the
  metaclass of the class being delegated to. It expects you to return a hash (not
  a HASH ref) of the methods you want mapped.
  
  =back
  
  =item I<traits =E<gt> [ @role_names ]>
  
  This tells Moose to take the list of C<@role_names> and apply them to the
  attribute meta-object. Custom attribute metaclass traits are useful for
  extending the capabilities of the I<has> keyword: they are the simplest way to
  extend the MOP, but they are still a fairly advanced topic and too much to
  cover here.
  
  See L<Metaclass and Trait Name Resolution> for details on how a trait name is
  resolved to a role name.
  
  Also see L<Moose::Cookbook::Meta::Labeled_AttributeTrait> for a metaclass
  trait example.
  
  =item I<builder> => Str
  
  The value of this key is the name of the method that will be called to obtain
  the value used to initialize the attribute. See the L<builder option docs in
  Class::MOP::Attribute|Class::MOP::Attribute/builder> and/or
  L<Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild> for more
  information.
  
  =item I<default> => SCALAR | CODE
  
  The value of this key is the default value which will initialize the attribute.
  
  NOTE: If the value is a simple scalar (string or number), then it can
  be just passed as is.  However, if you wish to initialize it with a
  HASH or ARRAY ref, then you need to wrap that inside a CODE reference.
  See the L<default option docs in
  Class::MOP::Attribute|Class::MOP::Attribute/default> for more
  information.
  
  =item I<clearer> => Str
  
  Creates a method allowing you to clear the value. See the L<clearer option
  docs in Class::MOP::Attribute|Class::MOP::Attribute/clearer> for more
  information.
  
  =item I<predicate> => Str
  
  Creates a method to perform a basic test to see if a value has been set in the
  attribute. See the L<predicate option docs in
  Class::MOP::Attribute|Class::MOP::Attribute/predicate> for more information.
  
  Note that the predicate will return true even for a C<weak_ref> attribute
  whose value has expired.
  
  =item I<documentation> => $string
  
  An arbitrary string that can be retrieved later by calling C<<
  $attr->documentation >>.
  
  =back
  
  =head2 has +$name =E<gt> %options
  
  This is variation on the normal attribute creator C<has> which allows you to
  clone and extend an attribute from a superclass or from a role. Here is an
  example of the superclass usage:
  
    package Foo;
    use Moose;
  
    has 'message' => (
        is      => 'rw',
        isa     => 'Str',
        default => 'Hello, I am a Foo'
    );
  
    package My::Foo;
    use Moose;
  
    extends 'Foo';
  
    has '+message' => (default => 'Hello I am My::Foo');
  
  What is happening here is that B<My::Foo> is cloning the C<message> attribute
  from its parent class B<Foo>, retaining the C<is =E<gt> 'rw'> and C<isa =E<gt>
  'Str'> characteristics, but changing the value in C<default>.
  
  Here is another example, but within the context of a role:
  
    package Foo::Role;
    use Moose::Role;
  
    has 'message' => (
        is      => 'rw',
        isa     => 'Str',
        default => 'Hello, I am a Foo'
    );
  
    package My::Foo;
    use Moose;
  
    with 'Foo::Role';
  
    has '+message' => (default => 'Hello I am My::Foo');
  
  In this case, we are basically taking the attribute which the role supplied
  and altering it within the bounds of this feature.
  
  Note that you can only extend an attribute from either a superclass or a role,
  you cannot extend an attribute in a role that composes over an attribute from
  another role.
  
  Aside from where the attributes come from (one from superclass, the other
  from a role), this feature works exactly the same. This feature is restricted
  somewhat, so as to try and force at least I<some> sanity into it. Most options work the same, but there are some exceptions:
  
  =over 4
  
  =item I<reader>
  
  =item I<writer>
  
  =item I<accessor>
  
  =item I<clearer>
  
  =item I<predicate>
  
  These options can be added, but cannot override a superclass definition.
  
  =item I<traits>
  
  You are allowed to B<add> additional traits to the C<traits> definition.
  These traits will be composed into the attribute, but preexisting traits
  B<are not> overridden, or removed.
  
  =back
  
  =head2 before $name|@names|\@names|qr/.../ =E<gt> sub { ... }
  
  =head2 after $name|@names|\@names|qr/.../ =E<gt> sub { ... }
  
  =head2 around $name|@names|\@names|qr/.../ =E<gt> sub { ... }
  
  These three items are syntactic sugar for the before, after, and around method
  modifier features that L<Class::MOP> provides. More information on these may be
  found in L<Moose::Manual::MethodModifiers> and the
  L<Class::MOP::Class documentation|Class::MOP::Class/"Method Modifiers">.
  
  =head2 override ($name, &sub)
  
  An C<override> method is a way of explicitly saying "I am overriding this
  method from my superclass". You can call C<super> within this method, and
  it will work as expected. The same thing I<can> be accomplished with a normal
  method call and the C<SUPER::> pseudo-package; it is really your choice.
  
  =head2 super
  
  The keyword C<super> is a no-op when called outside of an C<override> method. In
  the context of an C<override> method, it will call the next most appropriate
  superclass method with the same arguments as the original method.
  
  =head2 augment ($name, &sub)
  
  An C<augment> method, is a way of explicitly saying "I am augmenting this
  method from my superclass". Once again, the details of how C<inner> and
  C<augment> work is best described in the
  L<Moose::Cookbook::Basics::Document_AugmentAndInner>.
  
  =head2 inner
  
  The keyword C<inner>, much like C<super>, is a no-op outside of the context of
  an C<augment> method. You can think of C<inner> as being the inverse of
  C<super>; the details of how C<inner> and C<augment> work is best described in
  the L<Moose::Cookbook::Basics::Document_AugmentAndInner>.
  
  =head2 blessed
  
  This is the C<Scalar::Util::blessed> function. It is highly recommended that
  this is used instead of C<ref> anywhere you need to test for an object's class
  name.
  
  =head2 confess
  
  This is the C<Carp::confess> function, and exported here for historical
  reasons.
  
  =head1 METACLASS
  
  When you use Moose, you can specify traits which will be applied to your
  metaclass:
  
      use Moose -traits => 'My::Trait';
  
  This is very similar to the attribute traits feature. When you do
  this, your class's C<meta> object will have the specified traits
  applied to it. See L<Metaclass and Trait Name Resolution> for more
  details.
  
  =head2 Metaclass and Trait Name Resolution
  
  By default, when given a trait name, Moose simply tries to load a
  class of the same name. If such a class does not exist, it then looks
  for a class matching
  B<Moose::Meta::$type::Custom::Trait::$trait_name>. The C<$type>
  variable here will be one of B<Attribute> or B<Class>, depending on
  what the trait is being applied to.
  
  If a class with this long name exists, Moose checks to see if it has
  the method C<register_implementation>. This method is expected to
  return the I<real> class name of the trait. If there is no
  C<register_implementation> method, it will fall back to using
  B<Moose::Meta::$type::Custom::Trait::$trait> as the trait name.
  
  The lookup method for metaclasses is the same, except that it looks
  for a class matching B<Moose::Meta::$type::Custom::$metaclass_name>.
  
  If all this is confusing, take a look at
  L<Moose::Cookbook::Meta::Labeled_AttributeTrait>, which demonstrates how to
  create an attribute trait.
  
  =head1 UNIMPORTING FUNCTIONS
  
  =head2 B<unimport>
  
  Moose offers a way to remove the keywords it exports, through the C<unimport>
  method. You simply have to say C<no Moose> at the bottom of your code for this
  to work. Here is an example:
  
      package Person;
      use Moose;
  
      has 'first_name' => (is => 'rw', isa => 'Str');
      has 'last_name'  => (is => 'rw', isa => 'Str');
  
      sub full_name {
          my $self = shift;
          $self->first_name . ' ' . $self->last_name
      }
  
      no Moose; # keywords are removed from the Person package
  
  =head1 EXTENDING AND EMBEDDING MOOSE
  
  To learn more about extending Moose, we recommend checking out the
  "Extending" recipes in the L<Moose::Cookbook>, starting with
  L<Moose::Cookbook::Extending::ExtensionOverview>, which provides an overview of
  all the different ways you might extend Moose. L<Moose::Exporter> and
  L<Moose::Util::MetaRole> are the modules which provide the majority of the
  extension functionality, so reading their documentation should also be helpful.
  
  =head2 The MooseX:: namespace
  
  Generally if you're writing an extension I<for> Moose itself you'll want
  to put your extension in the C<MooseX::> namespace. This namespace is
  specifically for extensions that make Moose better or different in some
  fundamental way. It is traditionally B<not> for a package that just happens
  to use Moose. This namespace follows from the examples of the C<LWPx::>
  and C<DBIx::> namespaces that perform the same function for C<LWP> and C<DBI>
  respectively.
  
  =head1 METACLASS COMPATIBILITY AND MOOSE
  
  Metaclass compatibility is a thorny subject. You should start by
  reading the "About Metaclass compatibility" section in the
  L<Class::MOP> docs.
  
  Moose will attempt to resolve a few cases of metaclass incompatibility
  when you set the superclasses for a class, in addition to the cases that
  L<Class::MOP> handles.
  
  Moose tries to determine if the metaclasses only "differ by roles". This
  means that the parent and child's metaclass share a common ancestor in
  their respective hierarchies, and that the subclasses under the common
  ancestor are only different because of role applications. This case is
  actually fairly common when you mix and match various C<MooseX::*>
  modules, many of which apply roles to the metaclass.
  
  If the parent and child do differ by roles, Moose replaces the
  metaclass in the child with a newly created metaclass. This metaclass
  is a subclass of the parent's metaclass which does all of the roles that
  the child's metaclass did before being replaced. Effectively, this
  means the new metaclass does all of the roles done by both the
  parent's and child's original metaclasses.
  
  Ultimately, this is all transparent to you except in the case of an
  unresolvable conflict.
  
  =head1 CAVEATS
  
  It should be noted that C<super> and C<inner> B<cannot> be used in the same
  method. However, they may be combined within the same class hierarchy; see
  F<t/basics/override_augment_inner_super.t> for an example.
  
  The reason for this is that C<super> is only valid within a method
  with the C<override> modifier, and C<inner> will never be valid within an
  C<override> method. In fact, C<augment> will skip over any C<override> methods
  when searching for its appropriate C<inner>.
  
  This might seem like a restriction, but I am of the opinion that keeping these
  two features separate (yet interoperable) actually makes them easy to use, since
  their behavior is then easier to predict. Time will tell whether I am right or
  not (UPDATE: so far so good).
  
  =head1 GETTING HELP
  
  We offer both a mailing list and a very active IRC channel.
  
  The mailing list is L<mailto:moose@perl.org>. You must be subscribed to send
  a message. To subscribe, send an empty message to
  L<mailto:moose-subscribe@perl.org>
  
  You can also visit us at C<#moose> on L<irc://irc.perl.org/#moose>
  This channel is quite active, and questions at all levels (on Moose-related
  topics ;) are welcome.
  
  =head1 WHAT DOES MOOSE STAND FOR?
  
  Moose doesn't stand for one thing in particular, however, if you want, here
  are a few of our favorites. Feel free to contribute more!
  
  =over 4
  
  =item * Make Other Object Systems Envious
  
  =item * Makes Object Orientation So Easy
  
  =item * Makes Object Orientation Spiffy- Er (sorry ingy)
  
  =item * Most Other Object Systems Emasculate
  
  =item * Moose Often Ovulate Sorta Early
  
  =item * Moose Offers Often Super Extensions
  
  =item * Meta Object Obligates Salivary Excitation
  
  =item * Meta Object Orientation Syntax Extensions
  
  =item * Moo, Only Overengineered, Slow, and Execrable (blame rjbs!)
  
  =item * Massive Object-Oriented Stacktrace Emitter
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 4
  
  =item I blame Sam Vilain for introducing me to the insanity that is meta-models.
  
  =item I blame Audrey Tang for then encouraging my meta-model habit in #perl6.
  
  =item Without Yuval "nothingmuch" Kogman this module would not be possible,
  and it certainly wouldn't have this name ;P
  
  =item The basis of the TypeContraints module was Rob Kinyon's idea
  originally, I just ran with it.
  
  =item Thanks to mst & chansen and the whole #moose posse for all the
  early ideas/feature-requests/encouragement/bug-finding.
  
  =item Thanks to David "Theory" Wheeler for meta-discussions and spelling fixes.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<http://moose.perl.org/>
  
  This is the official web home of Moose. It contains links to our public git
  repository, as well as links to a number of talks and articles on Moose and
  Moose related technologies.
  
  =item the L<Moose manual|Moose::Manual>
  
  This is an introduction to Moose which covers most of the basics.
  
  =item Modern Perl, by chromatic
  
  This is an introduction to modern Perl programming, which includes a section on
  Moose. It is available in print and as a free download from
  L<http://onyxneon.com/books/modern_perl/>.
  
  =item The Moose is flying, a tutorial by Randal Schwartz
  
  Part 1 - L<http://www.stonehenge.com/merlyn/LinuxMag/col94.html>
  
  Part 2 - L<http://www.stonehenge.com/merlyn/LinuxMag/col95.html>
  
  =item Several Moose extension modules in the C<MooseX::> namespace.
  
  See L<https://metacpan.org/search?q=MooseX::> for extensions.
  
  =back
  
  =head2 Books
  
  =over 4
  
  =item The Art of the MetaObject Protocol
  
  I mention this in the L<Class::MOP> docs too, as this book was critical in
  the development of both modules and is highly recommended.
  
  =back
  
  =head2 Papers
  
  =over 4
  
  =item L<http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf>
  
  This paper (suggested by lbr on #moose) was what lead to the implementation
  of the C<super>/C<override> and C<inner>/C<augment> features. If you really
  want to understand them, I suggest you read this.
  
  =back
  
  =head1 BUGS
  
  All complex software has bugs lurking in it, and this module is no
  exception.
  
  Please report any bugs to C<bug-moose@rt.cpan.org>, or through the web
  interface at L<http://rt.cpan.org>. You can also submit a C<TODO> test as a
  pull request at L<https://github.com/moose/Moose>.
  
  You can also discuss feature requests or possible bugs on the Moose mailing
  list (moose@perl.org) or on IRC at L<irc://irc.perl.org/#moose>.
  
  =head1 FEATURE REQUESTS
  
  We are very strict about what features we add to the Moose core, especially
  the user-visible features. Instead we have made sure that the underlying
  meta-system of Moose is as extensible as possible so that you can add your
  own features easily.
  
  That said, occasionally there is a feature needed in the meta-system
  to support your planned extension, in which case you should either
  email the mailing list (moose@perl.org) or join us on IRC at
  L<irc://irc.perl.org/#moose> to discuss. The
  L<Moose::Manual::Contributing> has more detail about how and when you
  can contribute.
  
  =head1 CABAL
  
  There are only a few people with the rights to release a new version
  of Moose. The Moose Cabal are the people to go to with questions regarding
  the wider purview of Moose. They help maintain not just the code
  but the community as well. See the list below under C<AUTHORS>.
  
  =head1 CONTRIBUTORS
  
  Moose is a community project, and as such, involves the work of many, many
  members of the community beyond just the members in the cabal. In particular:
  
  Dave (autarch) Rolsky wrote most of the documentation in L<Moose::Manual>.
  
  John (jgoulah) Goulah wrote L<Moose::Cookbook::Snack::Keywords>.
  
  Jess (castaway) Robinson wrote L<Moose::Cookbook::Snack::Types>.
  
  Aran (bluefeet) Clary Deltac wrote
  L<Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion>.
  
  Anders (Debolaz) Nor Berle contributed L<Test::Moose> and L<Moose::Util>.
  
  Also, the code in L<Moose::Meta::Attribute::Native> is based on code from the
  L<MooseX::AttributeHelpers> distribution, which had contributions from:
  
  Chris (perigrin) Prather
  
  Cory (gphat) Watson
  
  Evan Carroll
  
  Florian (rafl) Ragwitz
  
  Jason May
  
  Jay Hannah
  
  Jesse (doy) Luehrs
  
  Paul (frodwith) Driver
  
  Robert (rlb3) Boone
  
  Robert Buels
  
  Robert (phaylon) Sedlacek
  
  Shawn (Sartak) Moore
  
  Stevan Little
  
  Tom (dec) Lanyon
  
  Yuval Kogman
  
  Finally, these people also contributed various tests, bug fixes,
  documentation, and features to the Moose codebase:
  
  Aankhen
  
  Adam (Alias) Kennedy
  
  Christian (chansen) Hansen
  
  Cory (gphat) Watson
  
  Dylan Hardison (doc fixes)
  
  Eric (ewilhelm) Wilhelm
  
  Evan Carroll
  
  Guillermo (groditi) Roditi
  
  Jason May
  
  Jay Hannah
  
  Jonathan (jrockway) Rockway
  
  Matt (mst) Trout
  
  Nathan (kolibrie) Gray
  
  Paul (frodwith) Driver
  
  Piotr (dexter) Roszatycki
  
  Robert Buels
  
  Robert (phaylon) Sedlacek
  
  Robert (rlb3) Boone
  
  Sam (mugwump) Vilain
  
  Scott (konobi) McWhirter
  
  Shlomi (rindolf) Fish
  
  Tom (dec) Lanyon
  
  Wallace (wreis) Reis
  
  ... and many other #moose folks
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_CONFLICTS';
  package # hide from PAUSE
      Moose::Conflicts;
  
  use strict;
  use warnings;
  
  # this module was generated with Dist::Zilla::Plugin::Conflicts 0.17
  
  use Dist::CheckConflicts
      -dist      => 'Moose',
      -conflicts => {
          'Catalyst' => '5.90049999',
          'Config::MVP' => '2.200004',
          'Devel::REPL' => '1.003020',
          'Dist::Zilla::Plugin::Git' => '2.016',
          'Fey' => '0.36',
          'Fey::ORM' => '0.42',
          'File::ChangeNotify' => '0.15',
          'HTTP::Throwable' => '0.017',
          'KiokuDB' => '0.51',
          'Markdent' => '0.16',
          'Mason' => '2.18',
          'MooseX::ABC' => '0.05',
          'MooseX::Aliases' => '0.08',
          'MooseX::AlwaysCoerce' => '0.13',
          'MooseX::App' => '1.22',
          'MooseX::Attribute::Deflator' => '2.1.7',
          'MooseX::Attribute::Dependent' => '1.1.0',
          'MooseX::Attribute::Prototype' => '0.10',
          'MooseX::AttributeHelpers' => '0.22',
          'MooseX::AttributeIndexes' => '1.0.0',
          'MooseX::AttributeInflate' => '0.02',
          'MooseX::CascadeClearing' => '0.03',
          'MooseX::ClassAttribute' => '0.26',
          'MooseX::Constructor::AllErrors' => '0.021',
          'MooseX::Declare' => '0.35',
          'MooseX::FollowPBP' => '0.02',
          'MooseX::Getopt' => '0.56',
          'MooseX::InstanceTracking' => '0.04',
          'MooseX::LazyRequire' => '0.06',
          'MooseX::Meta::Attribute::Index' => '0.04',
          'MooseX::Meta::Attribute::Lvalue' => '0.05',
          'MooseX::Method::Signatures' => '0.44',
          'MooseX::MethodAttributes' => '0.22',
          'MooseX::NonMoose' => '0.24',
          'MooseX::Object::Pluggable' => '0.0011',
          'MooseX::POE' => '0.214',
          'MooseX::Params::Validate' => '0.05',
          'MooseX::PrivateSetters' => '0.03',
          'MooseX::Role::Cmd' => '0.06',
          'MooseX::Role::Parameterized' => '1.00',
          'MooseX::Role::WithOverloading' => '0.14',
          'MooseX::Runnable' => '0.03',
          'MooseX::Scaffold' => '0.05',
          'MooseX::SemiAffordanceAccessor' => '0.05',
          'MooseX::SetOnce' => '0.100473',
          'MooseX::Singleton' => '0.25',
          'MooseX::SlurpyConstructor' => '1.1',
          'MooseX::Storage' => '0.42',
          'MooseX::StrictConstructor' => '0.12',
          'MooseX::Traits' => '0.11',
          'MooseX::Types' => '0.19',
          'MooseX::Types::Parameterizable' => '0.05',
          'MooseX::Types::Set::Object' => '0.03',
          'MooseX::Types::Signal' => '1.101930',
          'MooseX::UndefTolerant' => '0.11',
          'PRANG' => '0.14',
          'Pod::Elemental' => '0.093280',
          'Pod::Weaver' => '3.101638',
          'Reaction' => '0.002003',
          'Test::Able' => '0.10',
          'Test::CleanNamespaces' => '0.03',
          'Test::Moose::More' => '0.022',
          'Test::TempDir' => '0.05',
          'Throwable' => '0.102080',
          'namespace::autoclean' => '0.08',
      },
      -also => [ qw(
          Carp
          Class::Load
          Class::Load::XS
          Data::OptList
          Devel::GlobalDestruction
          Devel::OverloadInfo
          Devel::StackTrace
          Dist::CheckConflicts
          Eval::Closure
          List::MoreUtils
          List::Util
          MRO::Compat
          Module::Runtime
          Module::Runtime::Conflicts
          Package::DeprecationManager
          Package::Stash
          Package::Stash::XS
          Params::Util
          Scalar::Util
          Sub::Exporter
          Sub::Identify
          Sub::Name
          Task::Weaken
          Try::Tiny
          parent
          strict
          warnings
      ) ],
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for Moose
  # Dist::Zilla: -PodWeaver
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_CONFLICTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Deprecated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_DEPRECATED';
  package Moose::Deprecated;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Package::DeprecationManager 0.07 -deprecations => {
      'non-arrayref form of enum'         => '2.1100',
      'non-arrayref form of duck_type'    => '2.1100',
      },
      -ignore => [qr/^(?:Class::MOP|Moose)(?:::)?/],
      ;
  
  1;
  
  # ABSTRACT: Manages deprecation warnings for Moose
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Deprecated - Manages deprecation warnings for Moose
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
      use Moose::Deprecated -api_version => $version;
  
  =head1 FUNCTIONS
  
  This module manages deprecation warnings for features that have been
  deprecated in Moose.
  
  If you specify C<< -api_version => $version >>, you can use deprecated features
  without warnings. Note that this special treatment is limited to the package
  that loads C<Moose::Deprecated>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_DEPRECATED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION';
  package Moose::Exception;
  our $VERSION = '2.1603';
  
  use Moose;
  use Devel::StackTrace 1.33;
  
  has 'trace' => (
      is            => 'ro',
      isa           => 'Devel::StackTrace',
      builder       => '_build_trace',
      lazy          => 1,
      documentation => "This attribute is read-only and isa L<Devel::StackTrace>. ".
                       'It is lazy & dependent on $exception->message.'
  );
  
  has 'message' => (
      is            => 'ro',
      isa           => 'Str',
      builder       => '_build_message',
      lazy          => 1,
      documentation => "This attribute is read-only and isa Str. ".
                       "It is lazy and has a default value 'Error'."
  );
  
  use overload(
      q{""}    => 'as_string',
      fallback => 1,
  );
  
  sub _build_trace {
      my $self = shift;
  
      # skip frames that are method calls on the exception object, which include
      # the object itself in the arguments (but Devel::LeakTrace really ought to
      # be weakening all references in its frames)
      my $skip = 0;
      while (my @c = caller(++$skip)) {
          last if $c[3] =~ /^(.*)::new$/ && $self->isa($1);
      }
      $skip++;
  
      Devel::StackTrace->new(
          message => $self->message,
          indent  => 1,
          skip_frames => $skip,
          no_refs => 1,
      );
  }
  
  sub _build_message {
      "Error";
  }
  
  sub BUILD {
      my $self = shift;
      $self->trace;
  }
  
  sub as_string {
      my $self = shift;
  
      if ( $ENV{MOOSE_FULL_EXCEPTION} ) {
          return $self->trace->as_string;
      }
  
      my @frames;
      my $last_frame;
      my $in_moose = 1;
      for my $frame ( $self->trace->frames ) {
          if ( $in_moose && $frame->package =~ /^(?:Moose|Class::MOP)(?::|$)/ )
          {
              $last_frame = $frame;
              next;
          }
          elsif ($last_frame) {
              push @frames, $last_frame;
              undef $last_frame;
          }
  
          $in_moose = 0;
          push @frames, $frame;
      }
  
      # This would be a somewhat pathological case, but who knows
      return $self->trace->as_string unless @frames;
  
      my $message = ( shift @frames )->as_string( 1, {} ) . "\n";
      $message .= join q{}, map { $_->as_string( 0, {} ) . "\n" } @frames;
  
      return $message;
  }
  
  1;
  
  # ABSTRACT: Superclass for Moose internal exceptions
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Exception - Superclass for Moose internal exceptions
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class contains attributes which are common to all Moose internal
  exception classes.
  
  =head1 WARNING WARNING WARNING
  
  If you're writing your own exception classes, you should instead prefer
  the L<Throwable> role or the L<Throwable::Error> superclass - this is
  effectively a cut-down internal fork of the latter, and not designed
  for use in user code.
  
  Of course if you're writing metaclass traits, it would then make sense to
  subclass the relevant Moose exceptions - but only then.
  
  =head1 METHODS
  
  =head2 $exception->message
  
  This attribute contains the exception message.
  
  Every subclass of L<Moose::Exception> is expected to override
  C<_build_message> method in order to construct this value.
  
  =head2 $exception->trace
  
  This attribute contains the stack trace for the given exception. It returns a
  L<Devel::StackTrace> object.
  
  =head2 $exception->as_string
  
  This method returns a stringified form of the exception, including a stack
  trace. By default, this method skips Moose-internal stack frames until it sees
  a caller outside of the Moose core. If the C<MOOSE_FULL_EXCEPTION> environment
  variable is true, these frames are included.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Moose::Manual::Exceptions>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AccessorMustReadWrite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ACCESSORMUSTREADWRITE';
  package Moose::Exception::AccessorMustReadWrite;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Cannot define an accessor name on a read-only attribute, accessors are read/write";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ACCESSORMUSTREADWRITE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AddParameterizableTypeTakesParameterizableType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDPARAMETERIZABLETYPETAKESPARAMETERIZABLETYPE';
  package Moose::Exception::AddParameterizableTypeTakesParameterizableType;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'type_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Type must be a Moose::Meta::TypeConstraint::Parameterizable not ".$self->type_name;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDPARAMETERIZABLETYPETAKESPARAMETERIZABLETYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AddRoleTakesAMooseMetaRoleInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETAKESAMOOSEMETAROLEINSTANCE';
  package Moose::Exception::AddRoleTakesAMooseMetaRoleInstance;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'role_to_be_added' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "Roles must be instances of Moose::Meta::Role";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETAKESAMOOSEMETAROLEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AddRoleToARoleTakesAMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETOAROLETAKESAMOOSEMETAROLE';
  package Moose::Exception::AddRoleToARoleTakesAMooseMetaRole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'role_to_be_added' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "Roles must be instances of Moose::Meta::Role";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ADDROLETOAROLETAKESAMOOSEMETAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ApplyTakesABlessedInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_APPLYTAKESABLESSEDINSTANCE';
  package Moose::Exception::ApplyTakesABlessedInstance;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'param' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "You must pass in an blessed instance";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_APPLYTAKESABLESSEDINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttachToClassNeedsAClassMOPClassInstanceOrASubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTACHTOCLASSNEEDSACLASSMOPCLASSINSTANCEORASUBCLASS';
  package Moose::Exception::AttachToClassNeedsAClassMOPClassInstanceOrASubclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "You must pass a Class::MOP::Class instance (or a subclass)";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTACHTOCLASSNEEDSACLASSMOPCLASSINSTANCEORASUBCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeConflictInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINROLES';
  package Moose::Exception::AttributeConflictInRoles;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'second_role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self             = shift;
      my $role_name        = $self->role_name;
      my $second_role_name = $self->second_role_name;
      my $attribute_name   = $self->attribute_name;
      "Role '$role_name' has encountered an attribute conflict"
      . " while being composed into '$second_role_name'."
      . " This is a fatal error and cannot be disambiguated."
      . " The conflicting attribute is named '$attribute_name'.";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINROLES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeConflictInSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINSUMMATION';
  package Moose::Exception::AttributeConflictInSummation;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::AttributeName';
  
  has 'second_role_name' => (
      is         => 'ro',
      isa        => 'Str',
      required   => 1,
  );
  
  sub _build_message {
      my $self = shift;
  
      my $role1     = $self->role_name;
      my $role2     = $self->second_role_name;
      my $attr_name = $self->attribute_name;
  
      return "We have encountered an attribute conflict with '$attr_name'"
             . " during role composition. "
             . " This attribute is defined in both $role1 and $role2."
             . " This is a fatal error and cannot be disambiguated.";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTECONFLICTINSUMMATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeExtensionIsNotSupportedInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEEXTENSIONISNOTSUPPORTEDINROLES';
  package Moose::Exception::AttributeExtensionIsNotSupportedInRoles;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      "has '+attr' is not supported in roles";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEEXTENSIONISNOTSUPPORTEDINROLES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeIsRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEISREQUIRED';
  package Moose::Exception::AttributeIsRequired;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'attribute_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching attribute instance:\n".
                       "    my \$class = Moose::Util::find_meta( \$exception->class_name );\n".
                       "    my \$attribute = \$class->get_attribute( \$exception->attribute_name );\n",
  );
  
  has 'params' => (
      is        => 'ro',
      isa       => 'HashRef',
      predicate => 'has_params',
  );
  
  sub _build_message {
      my $self = shift;
      "Attribute (".$self->attribute_name.") is required";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEISREQUIRED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEMUSTBEANCLASSMOPMIXINATTRIBUTECOREORSUBCLASS';
  package Moose::Exception::AttributeMustBeAnClassMOPMixinAttributeCoreOrSubclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'attribute' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "Your attribute must be an instance of Class::MOP::Mixin::AttributeCore (or a subclass)";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEMUSTBEANCLASSMOPMIXINATTRIBUTECOREORSUBCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeNamesDoNotMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTENAMESDONOTMATCH';
  package Moose::Exception::AttributeNamesDoNotMatch;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has attribute_name => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  has attribute => (
      is       => 'ro',
      isa      => 'Class::MOP::Attribute',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "attribute_name (".$self-> attribute_name.") does not match attribute->name (".$self->attribute->name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTENAMESDONOTMATCH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeValueIsNotAnObject.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTANOBJECT';
  package Moose::Exception::AttributeValueIsNotAnObject;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Attribute';
  
  has 'method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method::Delegation',
      required => 1,
  );
  
  has 'given_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot delegate ".$self->method->name." to "
      .$self->method->delegate_to_method." because the value of "
      . $self->attribute->name . " is not an object (got '".$self->given_value."')";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTANOBJECT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AttributeValueIsNotDefined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTDEFINED';
  package Moose::Exception::AttributeValueIsNotDefined;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Attribute';
  
  has 'method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method::Delegation',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot delegate ".$self->method->name." to "
      .$self->method->delegate_to_method." because the value of "
      . $self->attribute->name . " is not defined";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ATTRIBUTEVALUEISNOTDEFINED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/AutoDeRefNeedsArrayRefOrHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_AUTODEREFNEEDSARRAYREFORHASHREF';
  package Moose::Exception::AutoDeRefNeedsArrayRefOrHashRef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot auto-dereference anything other than a ArrayRef or HashRef on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_AUTODEREFNEEDSARRAYREFORHASHREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BadOptionFormat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BADOPTIONFORMAT';
  package Moose::Exception::BadOptionFormat;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'option_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'option_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "bad accessor/reader/writer/predicate/clearer format, must be a HASH ref";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BADOPTIONFORMAT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BothBuilderAndDefaultAreNotAllowed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BOTHBUILDERANDDEFAULTARENOTALLOWED';
  package Moose::Exception::BothBuilderAndDefaultAreNotAllowed;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Setting both default and builder is not allowed.";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BOTHBUILDERANDDEFAULTARENOTALLOWED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BuilderDoesNotExist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERDOESNOTEXIST';
  package Moose::Exception::BuilderDoesNotExist;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      blessed($self->instance)." does not support builder method '".$self->attribute->builder."' for attribute '".$self->attribute->name."'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERDOESNOTEXIST

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BuilderMethodNotSupportedForAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORATTRIBUTE';
  package Moose::Exception::BuilderMethodNotSupportedForAttribute;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      blessed($self->instance)." does not support builder method '". $self->attribute->builder ."' for attribute '" . $self->attribute->name . "'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BuilderMethodNotSupportedForInlineAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORINLINEATTRIBUTE';
  package Moose::Exception::BuilderMethodNotSupportedForInlineAttribute;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::Class';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'builder' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      $self->class_name." does not support builder method '". $self->builder ."' for attribute '" . $self->attribute_name . "'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMETHODNOTSUPPORTEDFORINLINEATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/BuilderMustBeAMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMUSTBEAMETHODNAME';
  package Moose::Exception::BuilderMustBeAMethodName;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "builder must be a defined scalar value which is a method name";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_BUILDERMUSTBEAMETHODNAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CallingMethodOnAnImmutableInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGMETHODONANIMMUTABLEINSTANCE';
  package Moose::Exception::CallingMethodOnAnImmutableInstance;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The '".$self->method_name."' method cannot be called on an immutable instance";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGMETHODONANIMMUTABLEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CallingReadOnlyMethodOnAnImmutableInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGREADONLYMETHODONANIMMUTABLEINSTANCE';
  package Moose::Exception::CallingReadOnlyMethodOnAnImmutableInstance;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The '".$self->method_name."' method is read-only when called on an immutable instance";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CALLINGREADONLYMETHODONANIMMUTABLEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CanExtendOnlyClasses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANEXTENDONLYCLASSES';
  package Moose::Exception::CanExtendOnlyClasses;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      my $self      = shift;
      my $role_name = $self->role_name;
      return "You cannot inherit from a Moose Role ($role_name)";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANEXTENDONLYCLASSES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CanOnlyConsumeRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYCONSUMEROLE';
  package Moose::Exception::CanOnlyConsumeRole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "You can only consume roles, ".$self->role_name." is not a Moose role";
  }
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYCONSUMEROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CanOnlyWrapBlessedCode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYWRAPBLESSEDCODE';
  package Moose::Exception::CanOnlyWrapBlessedCode;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'code' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "Can only wrap blessed CODE";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANONLYWRAPBLESSEDCODE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CanReblessOnlyIntoASubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUBCLASS';
  package Moose::Exception::CanReblessOnlyIntoASubclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::InstanceClass';
  
  sub _build_message {
      my $self           = shift;
      my $instance_class = $self->instance_class;
      "You may rebless only into a subclass of ($instance_class), of which (". $self->class_name .") isn't."
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUBCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CanReblessOnlyIntoASuperclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUPERCLASS';
  package Moose::Exception::CanReblessOnlyIntoASuperclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::InstanceClass';
  
  sub _build_message {
      my $self = shift;
      "You may rebless only into a superclass of (".blessed( $self->instance )."), of which (". $self->class_name .") isn't."
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANREBLESSONLYINTOASUPERCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAddAdditionalTypeCoercionsToUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDADDITIONALTYPECOERCIONSTOUNION';
  package Moose::Exception::CannotAddAdditionalTypeCoercionsToUnion;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'type_coercion_union_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeCoercion::Union',
      required => 1
  );
  
  sub _build_message {
      return "Cannot add additional type coercions to Union types";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDADDITIONALTYPECOERCIONSTOUNION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAddAsAnAttributeToARole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDASANATTRIBUTETOAROLE';
  package Moose::Exception::CannotAddAsAnAttributeToARole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'attribute_class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot add a ".$self->attribute_class." as an attribute to a role";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTADDASANATTRIBUTETOAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotApplyBaseClassRolesToRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAPPLYBASECLASSROLESTOROLE';
  package Moose::Exception::CannotApplyBaseClassRolesToRole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "You can only apply base class roles to a Moose class, not a role.";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAPPLYBASECLASSROLESTOROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAssignValueToReadOnlyAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTASSIGNVALUETOREADONLYACCESSOR';
  package Moose::Exception::CannotAssignValueToReadOnlyAccessor;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::EitherAttributeOrAttributeName';
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot assign a value to a read-only accessor";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTASSIGNVALUETOREADONLYACCESSOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAugmentIfLocalMethodPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTIFLOCALMETHODPRESENT';
  package Moose::Exception::CannotAugmentIfLocalMethodPresent;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Method';
  
  sub _build_message {
      "Cannot add an augment method if a local method is already present";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTIFLOCALMETHODPRESENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAugmentNoSuperMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTNOSUPERMETHOD';
  package Moose::Exception::CannotAugmentNoSuperMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You cannot augment '".$self->method_name."' because it has no super method";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUGMENTNOSUPERMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAutoDerefWithoutIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFWITHOUTISA';
  package Moose::Exception::CannotAutoDerefWithoutIsa;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot auto-dereference without specifying a type constraint on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFWITHOUTISA

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotAutoDereferenceTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFERENCETYPECONSTRAINT';
  package Moose::Exception::CannotAutoDereferenceTypeConstraint;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Instance', 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Can not auto de-reference the type constraint '" . $self->type_name . "'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTAUTODEREFERENCETYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCalculateNativeType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALCULATENATIVETYPE';
  package Moose::Exception::CannotCalculateNativeType;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      "Cannot calculate native type for " . ref $self->instance;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALCULATENATIVETYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCallAnAbstractBaseMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTBASEMETHOD';
  package Moose::Exception::CannotCallAnAbstractBaseMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      $self->package_name. " is an abstract base class, you must provide a constructor.";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTBASEMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCallAnAbstractMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTMETHOD';
  package Moose::Exception::CannotCallAnAbstractMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Abstract method";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCALLANABSTRACTMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCoerceAWeakRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEAWEAKREF';
  package Moose::Exception::CannotCoerceAWeakRef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot have a weak reference to a coerced value on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEAWEAKREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCoerceAttributeWhichHasNoCoercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEATTRIBUTEWHICHHASNOCOERCION';
  package Moose::Exception::CannotCoerceAttributeWhichHasNoCoercion;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions', 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      my $name = $self->attribute_name;
      my $type = $self->type_name;
  
      return "You cannot coerce an attribute ($name) unless its type ($type) has a coercion";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCOERCEATTRIBUTEWHICHHASNOCOERCION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCreateHigherOrderTypeWithoutATypeParameter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEHIGHERORDERTYPEWITHOUTATYPEPARAMETER';
  package Moose::Exception::CannotCreateHigherOrderTypeWithoutATypeParameter;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      "You cannot create a Higher Order type without a type parameter";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEHIGHERORDERTYPEWITHOUTATYPEPARAMETER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCreateMethodAliasLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENT';
  package Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresent;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Method';
  
  has 'role_being_applied_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'aliased_method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Cannot create a method alias if a local method of the same name exists";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotCreateMethodAliasLocalMethodIsPresentInClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENTINCLASS';
  package Moose::Exception::CannotCreateMethodAliasLocalMethodIsPresentInClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Method', 'Moose::Exception::Role::Class';
  
  has 'aliased_method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Cannot create a method alias if a local method of the same name exists";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTCREATEMETHODALIASLOCALMETHODISPRESENTINCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotDelegateLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATELOCALMETHODISPRESENT';
  package Moose::Exception::CannotDelegateLocalMethodIsPresent;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute', 'Moose::Exception::Role::Method';
  
  sub _build_message {
      my $self = shift;
      "You cannot overwrite a locally defined method (".$self->method->name.") with a delegation";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATELOCALMETHODISPRESENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotDelegateWithoutIsa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATEWITHOUTISA';
  package Moose::Exception::CannotDelegateWithoutIsa;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  sub _build_message {
      "Cannot delegate methods based on a Regexp without a type constraint (isa)";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTDELEGATEWITHOUTISA

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotFindDelegateMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDDELEGATEMETACLASS';
  package Moose::Exception::CannotFindDelegateMetaclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  sub _build_message {
      my $self = shift;
      "Cannot find delegate metaclass for attribute ".$self->attribute->name;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDDELEGATEMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotFindType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPE';
  package Moose::Exception::CannotFindType;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'type_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot find type '".$self->type_name."', perhaps you forgot to load it";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotFindTypeGivenToMatchOnType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPEGIVENTOMATCHONTYPE';
  package Moose::Exception::CannotFindTypeGivenToMatchOnType;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'action' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type = $self->type;
  
      return "Cannot find or parse the type '$type'"
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFINDTYPEGIVENTOMATCHONTYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotFixMetaclassCompatibility.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFIXMETACLASSCOMPATIBILITY';
  package Moose::Exception::CannotFixMetaclassCompatibility;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'superclass' => (
      is       => 'ro',
      isa      => 'Object',
      required => 1
  );
  
  has 'metaclass_type' => (
      is       => 'ro',
      isa      => 'Str',
  );
  
  sub _build_message {
      my $self = shift;
      my $class_name = $self->class_name;
      "Can't fix metaclass incompatibility for $class_name because it is not pristine.";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTFIXMETACLASSCOMPATIBILITY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotGenerateInlineConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTGENERATEINLINECONSTRAINT';
  package Moose::Exception::CannotGenerateInlineConstraint;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  has 'parameterizable_type_object_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching parameterizable type constraint(Moose::Meta::TypeConstraint::Parameterizable):\n".
                       "    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->type_name );\n",
  );
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type = $self->type_name;
  
      return "Can't generate an inline constraint for $type, since none was defined";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTGENERATEINLINECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotInitializeMooseMetaRoleComposite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINITIALIZEMOOSEMETAROLECOMPOSITE';
  package Moose::Exception::CannotInitializeMooseMetaRoleComposite;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'role_composite' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role::Composite',
      required => 1
  );
  
  has 'old_meta' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'args' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      'Moose::Meta::Role::Composite instances can only be reinitialized from an existing metaclass instance';
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINITIALIZEMOOSEMETAROLECOMPOSITE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotInlineTypeConstraintCheck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINLINETYPECONSTRAINTCHECK';
  package Moose::Exception::CannotInlineTypeConstraintCheck;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      'Cannot inline a type constraint check for ' . $self->type_name;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTINLINETYPECONSTRAINTCHECK

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotLocatePackageInINC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTLOCATEPACKAGEININC';
  package Moose::Exception::CannotLocatePackageInINC;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'INC' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'possible_packages' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'metaclass_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      my $possible_packages = $self->possible_packages;
      my @inc = @{$self->INC};
  
      return "Can't locate $possible_packages in \@INC (\@INC contains: @INC)."
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTLOCATEPACKAGEININC

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotMakeMetaclassCompatible.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTMAKEMETACLASSCOMPATIBLE';
  package Moose::Exception::CannotMakeMetaclassCompatible;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'superclass_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class_name = $self->class_name;
      my $superclass = $self->superclass_name;
  
      return "Can't make $class_name compatible with metaclass $superclass";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTMAKEMETACLASSCOMPATIBLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotOverrideALocalMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEALOCALMETHOD';
  package Moose::Exception::CannotOverrideALocalMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot add an override of method '".$self->method_name."' because there is a local version of '".$self->method_name."'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEALOCALMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotOverrideBodyOfMetaMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEBODYOFMETAMETHODS';
  package Moose::Exception::CannotOverrideBodyOfMetaMethods;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "Overriding the body of meta methods is not allowed";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDEBODYOFMETAMETHODS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotOverrideLocalMethodIsPresent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDELOCALMETHODISPRESENT';
  package Moose::Exception::CannotOverrideLocalMethodIsPresent;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Method';
  
  sub _build_message {
      "Cannot add an override method if a local method is already present";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDELOCALMETHODISPRESENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotOverrideNoSuperMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDENOSUPERMETHOD';
  package Moose::Exception::CannotOverrideNoSuperMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You cannot override '".$self->method_name."' because it has no super method";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTOVERRIDENOSUPERMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotRegisterUnnamedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTREGISTERUNNAMEDTYPECONSTRAINT';
  package Moose::Exception::CannotRegisterUnnamedTypeConstraint;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "can't register an unnamed type constraint";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTREGISTERUNNAMEDTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CannotUseLazyBuildAndDefaultSimultaneously.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTUSELAZYBUILDANDDEFAULTSIMULTANEOUSLY';
  package Moose::Exception::CannotUseLazyBuildAndDefaultSimultaneously;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You can not use lazy_build and default for the same attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CANNOTUSELAZYBUILDANDDEFAULTSIMULTANEOUSLY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CircularReferenceInAlso.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CIRCULARREFERENCEINALSO';
  package Moose::Exception::CircularReferenceInAlso;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'also_parameter' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'stack' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $also_member = $self->also_parameter;
  
      my @stack = @{$self->stack};
      my $existing_stack = join( ', ', @stack);
  
      return "Circular reference in 'also' parameter to Moose::Exporter between "
             ."$existing_stack and $also_member";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CIRCULARREFERENCEINALSO

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ClassDoesNotHaveInitMeta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESNOTHAVEINITMETA';
  package Moose::Exception::ClassDoesNotHaveInitMeta;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'traits' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class = $self->class_name;
  
      return "Cannot provide traits when $class does not have an init_meta() method";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESNOTHAVEINITMETA

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ClassDoesTheExcludedRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESTHEEXCLUDEDROLE';
  package Moose::Exception::ClassDoesTheExcludedRole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role', 'Moose::Exception::Role::Class';
  
  has 'excluded_role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self               = shift;
      my $excluded_role_name = $self->excluded_role_name;
      my $class_name         = $self->class_name;
      return "The class $class_name does the excluded role '$excluded_role_name'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSDOESTHEEXCLUDEDROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ClassNamesDoNotMatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSNAMESDONOTMATCH';
  package Moose::Exception::ClassNamesDoNotMatch;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has class_name => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  has class => (
      is       => 'ro',
      isa      => 'Class::MOP::Class',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "class_name (".$self-> class_name.") does not match class->name (".$self->class->name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLASSNAMESDONOTMATCH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CloneObjectExpectsAnInstanceOfMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLONEOBJECTEXPECTSANINSTANCEOFMETACLASS';
  package Moose::Exception::CloneObjectExpectsAnInstanceOfMetaclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "You must pass an instance of the metaclass (" .$self->class_name. "), not (".$self->instance.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CLONEOBJECTEXPECTSANINSTANCEOFMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CodeBlockMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CODEBLOCKMUSTBEACODEREF';
  package Moose::Exception::CodeBlockMustBeACodeRef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      "Your code block must be a CODE reference";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CODEBLOCKMUSTBEACODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CoercingWithoutCoercions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCINGWITHOUTCOERCIONS';
  package Moose::Exception::CoercingWithoutCoercions;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Cannot coerce without a type coercion";
  }
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCINGWITHOUTCOERCIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CoercionAlreadyExists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONALREADYEXISTS';
  package Moose::Exception::CoercionAlreadyExists;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'constraint_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "A coercion action already exists for '".$self->constraint_name."'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONALREADYEXISTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CoercionNeedsTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONNEEDSTYPECONSTRAINT';
  package Moose::Exception::CoercionNeedsTypeConstraint;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot have coercion without specifying a type constraint on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COERCIONNEEDSTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ConflictDetectedInCheckRoleExclusions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONS';
  package Moose::Exception::ConflictDetectedInCheckRoleExclusions;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'excluded_role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self               = shift;
      my $role_name          = $self->role_name;
      my $excluded_role_name = $self->excluded_role_name;
      return "Conflict detected: $role_name excludes role '$excluded_role_name'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ConflictDetectedInCheckRoleExclusionsInToClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONSINTOCLASS';
  package Moose::Exception::ConflictDetectedInCheckRoleExclusionsInToClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';
  
  sub _build_message {
      my $self       = shift;
      my $class_name = $self->class_name;
      my $role_name  = $self->role_name;
      return "Conflict detected: $class_name excludes role '$role_name'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONFLICTDETECTEDINCHECKROLEEXCLUSIONSINTOCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ConstructClassInstanceTakesPackageName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONSTRUCTCLASSINSTANCETAKESPACKAGENAME';
  package Moose::Exception::ConstructClassInstanceTakesPackageName;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You must pass a package name";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CONSTRUCTCLASSINSTANCETAKESPACKAGENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotCreateMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEMETHOD';
  package Moose::Exception::CouldNotCreateMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'option_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'option_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Could not create the '".$self->option_name."' method for " . $self->attribute->name . " because : ".$self->error;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotCreateWriter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEWRITER';
  package Moose::Exception::CouldNotCreateWriter;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::EitherAttributeOrAttributeName', 'Moose::Exception::Role::Instance';
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = $self->error;
      my $attribute_name = $self->attribute_name;
  
      return "Could not create writer for '$attribute_name' "
          . "because $error";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTCREATEWRITER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotEvalConstructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALCONSTRUCTOR';
  package Moose::Exception::CouldNotEvalConstructor;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'constructor_method' => (
      is       => 'ro',
      isa      => 'Class::MOP::Method::Constructor',
      required => 1
  );
  
  has 'source' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = $self->error;
      my $source = $self->source;
  
      return "Could not eval the constructor :\n\n$source\n\nbecause :\n\n$error";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALCONSTRUCTOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotEvalDestructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALDESTRUCTOR';
  package Moose::Exception::CouldNotEvalDestructor;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_destructor_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method::Destructor',
      required => 1
  );
  
  has 'source' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = $self->error;
      my $source = $self->source;
  
      return "Could not eval the destructor :\n\n$source\n\nbecause :\n\n$error";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTEVALDESTRUCTOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotFindTypeConstraintToCoerceFrom.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTFINDTYPECONSTRAINTTOCOERCEFROM';
  package Moose::Exception::CouldNotFindTypeConstraintToCoerceFrom;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'constraint_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Could not find the type constraint (".$self->constraint_name.") to coerce from";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTFINDTYPECONSTRAINTTOCOERCEFROM

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotGenerateInlineAttributeMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTGENERATEINLINEATTRIBUTEMETHOD';
  package Moose::Exception::CouldNotGenerateInlineAttributeMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'option' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'error' => (
      is       => 'ro',
      isa      => 'Str|Moose::Exception',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Could not generate inline ".$self->option." because : ".$self->error;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTGENERATEINLINEATTRIBUTEMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotLocateTypeConstraintForUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTLOCATETYPECONSTRAINTFORUNION';
  package Moose::Exception::CouldNotLocateTypeConstraintForUnion;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not locate type constraint (".$self->type_name.") for the union";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTLOCATETYPECONSTRAINTFORUNION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CouldNotParseType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTPARSETYPE';
  package Moose::Exception::CouldNotParseType;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'position' => (
      is       => 'ro',
      isa      => 'Int',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type = $self->type;
      my $length = length($type);
      my $position = $self->position;
  
      return "'$type' didn't parse (parse-pos=$position"
          . " and str-length=$length)";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_COULDNOTPARSETYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateMOPClassTakesArrayRefOfAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFATTRIBUTES';
  package Moose::Exception::CreateMOPClassTakesArrayRefOfAttributes;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreateMOPClass';
  
  sub _build_message {
      "You must pass an ARRAY ref of attributes";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFATTRIBUTES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateMOPClassTakesArrayRefOfSuperclasses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFSUPERCLASSES';
  package Moose::Exception::CreateMOPClassTakesArrayRefOfSuperclasses;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreateMOPClass';
  
  sub _build_message {
      "You must pass an ARRAY ref of superclasses";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESARRAYREFOFSUPERCLASSES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateMOPClassTakesHashRefOfMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESHASHREFOFMETHODS';
  package Moose::Exception::CreateMOPClassTakesHashRefOfMethods;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreateMOPClass';
  
  sub _build_message {
      "You must pass an HASH ref of methods";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATEMOPCLASSTAKESHASHREFOFMETHODS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateTakesArrayRefOfRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESARRAYREFOFROLES';
  package Moose::Exception::CreateTakesArrayRefOfRoles;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreate';
  
  sub _build_message {
      "You must pass an ARRAY ref of roles";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESARRAYREFOFROLES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateTakesHashRefOfAttributes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFATTRIBUTES';
  package Moose::Exception::CreateTakesHashRefOfAttributes;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreate';
  
  sub _build_message {
      "You must pass a HASH ref of attributes";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFATTRIBUTES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/CreateTakesHashRefOfMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFMETHODS';
  package Moose::Exception::CreateTakesHashRefOfMethods;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::RoleForCreate';
  
  sub _build_message {
      "You must pass a HASH ref of methods";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_CREATETAKESHASHREFOFMETHODS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/DefaultToMatchOnTypeMustBeCodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DEFAULTTOMATCHONTYPEMUSTBECODEREF';
  package Moose::Exception::DefaultToMatchOnTypeMustBeCodeRef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'default_action' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'cases_to_be_matched' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $default = $self->default_action;
  
      return "Default case must be a CODE ref, not $default";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DEFAULTTOMATCHONTYPEMUSTBECODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/DelegationToAClassWhichIsNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOACLASSWHICHISNOTLOADED';
  package Moose::Exception::DelegationToAClassWhichIsNotLoaded;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'class_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "The ".$self->attribute->name." attribute is trying to delegate to a class which has not been loaded - ".$self->class_name;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOACLASSWHICHISNOTLOADED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/DelegationToARoleWhichIsNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOAROLEWHICHISNOTLOADED';
  package Moose::Exception::DelegationToARoleWhichIsNotLoaded;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "The ".$self->attribute->name." attribute is trying to delegate to a role which has not been loaded - ".$self->role_name;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOAROLEWHICHISNOTLOADED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/DelegationToATypeWhichIsNotAClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOATYPEWHICHISNOTACLASS';
  package Moose::Exception::DelegationToATypeWhichIsNotAClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  sub _build_message {
      my $self = shift;
      "The ".$self->attribute->name." attribute is trying to delegate to a type (".$self->attribute->type_constraint->name.") that is not backed by a class";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DELEGATIONTOATYPEWHICHISNOTACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/DoesRequiresRoleName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DOESREQUIRESROLENAME';
  package Moose::Exception::DoesRequiresRoleName;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must supply a role name to does()";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_DOESREQUIRESROLENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/EnumCalledWithAnArrayRefAndAdditionalArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ENUMCALLEDWITHANARRAYREFANDADDITIONALARGS';
  package Moose::Exception::EnumCalledWithAnArrayRefAndAdditionalArgs;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'array' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'args' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      "enum called with an array reference and additional arguments. Did you mean to parenthesize the enum call's parameters?";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ENUMCALLEDWITHANARRAYREFANDADDITIONALARGS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/EnumValuesMustBeString.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ENUMVALUESMUSTBESTRING';
  package Moose::Exception::EnumValuesMustBeString;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Enum values must be strings, not ".( defined $self->value ? "'".$self->value."'" : "undef" );
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ENUMVALUESMUSTBESTRING

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ExtendsMissingArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_EXTENDSMISSINGARGS';
  package Moose::Exception::ExtendsMissingArgs;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "Must derive at least one class";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_EXTENDSMISSINGARGS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/HandlesMustBeAHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_HANDLESMUSTBEAHASHREF';
  package Moose::Exception::HandlesMustBeAHashRef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'given_handles' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The 'handles' option must be a HASH reference, not ".$self->given_handles;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_HANDLESMUSTBEAHASHREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/IllegalInheritedOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALINHERITEDOPTIONS';
  package Moose::Exception::IllegalInheritedOptions;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'illegal_options' => (
      is       => 'ro',
      traits   => ['Array'],
      handles  => {
          _join_options => 'join',
      },
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Illegal inherited options => (".$self->_join_options(', ').")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALINHERITEDOPTIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/IllegalMethodTypeToAddMethodModifier.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALMETHODTYPETOADDMETHODMODIFIER';
  package Moose::Exception::IllegalMethodTypeToAddMethodModifier;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'class_or_object' => (
      is       => 'ro',
      isa      => "Any",
      required => 1,
  );
  
  has 'params' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1,
  );
  
  has 'modifier_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Methods passed to ".$self->modifier_name." must be provided as a list, arrayref or regex, not ".$self->params->[0];
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ILLEGALMETHODTYPETOADDMETHODMODIFIER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/IncompatibleMetaclassOfSuperclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INCOMPATIBLEMETACLASSOFSUPERCLASS';
  package Moose::Exception::IncompatibleMetaclassOfSuperclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has [qw/superclass_name superclass_meta_type class_meta_type/] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self            = shift;
      my $class_name      = $self->class_name;
      my $class_meta_type = $self->class_meta_type;
      my $superclass_name = $self->superclass_name;
      my $supermeta_type  = $self->superclass_meta_type;
  
      return "The metaclass of $class_name ($class_meta_type)" .
             " is not compatible with the metaclass of its superclass, " .
             "$superclass_name ($supermeta_type)";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INCOMPATIBLEMETACLASSOFSUPERCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InitMetaRequiresClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INITMETAREQUIRESCLASS';
  package Moose::Exception::InitMetaRequiresClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  sub _build_message {
      "Cannot call init_meta without specifying a for_class";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INITMETAREQUIRESCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InitializeTakesUnBlessedPackageName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INITIALIZETAKESUNBLESSEDPACKAGENAME';
  package Moose::Exception::InitializeTakesUnBlessedPackageName;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      "You must pass a package name and it cannot be blessed";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INITIALIZETAKESUNBLESSEDPACKAGENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InstanceBlessedIntoWrongClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEBLESSEDINTOWRONGCLASS';
  package Moose::Exception::InstanceBlessedIntoWrongClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      my $self = shift;
      "Objects passed as the __INSTANCE__ parameter must already be blessed into the correct class, but ".$self->instance." is not a " . $self->class_name;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEBLESSEDINTOWRONGCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InstanceMustBeABlessedReference.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEMUSTBEABLESSEDREFERENCE';
  package Moose::Exception::InstanceMustBeABlessedReference;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class';
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The __INSTANCE__ parameter must be a blessed reference, not ". $self->instance;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INSTANCEMUSTBEABLESSEDREFERENCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidArgPassedToMooseUtilMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGPASSEDTOMOOSEUTILMETAROLE';
  package Moose::Exception::InvalidArgPassedToMooseUtilMetaRole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'argument' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $error = 'When using Moose::Util::MetaRole, you must pass a Moose class name,'
          . ' role name, metaclass object, or metarole object.';
  
      my $arg = $self->argument;
      my $found = blessed $arg ? $arg : Class::MOP::class_of($arg);
  
      my $error2;
  
      if ( defined $found && blessed $found ) {
          $error2 = " You passed ".$arg.", and we resolved this to a "
              . ( blessed $found )
              . ' object.';
      }
      elsif ( !defined $found ) {
          $error2 = " You passed ".( defined $arg ? $arg : "undef" ).", and this did not resolve to a metaclass or metarole."
              . ' Maybe you need to call Moose->init_meta to initialize the metaclass first?';
      }
      else {
          $error2 = " You passed an undef."
              . ' Maybe you need to call Moose->init_meta to initialize the metaclass first?';
      }
  
      $error.$error2;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGPASSEDTOMOOSEUTILMETAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidArgumentToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTTOMETHOD';
  package Moose::Exception::InvalidArgumentToMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'argument' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has [qw(type type_of_argument method_name)] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'ordinal' => (
      is        => 'ro',
      isa       => 'Str',
      predicate => 'is_ordinal_set'
  );
  
  has 'argument_noun' => (
      is      => 'ro',
      isa     => 'Str',
      default => 'argument'
  );
  
  sub _build_message {
      my $self = shift;
      my $article = ( $self->type_of_argument =~ /^[aeiou]/ ? 'an ' : 'a ');
      my $arg_noun = $self->argument_noun;
  
      if( $self->is_ordinal_set ) {
          "The ".$self->ordinal." $arg_noun passed to ".$self->method_name." must be ".$article.$self->type_of_argument;
      }
      else {
          "The $arg_noun passed to ".$self->method_name." must be ".$article.$self->type_of_argument;
      }
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTTOMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidArgumentsToTraitAliases.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTSTOTRAITALIASES';
  package Moose::Exception::InvalidArgumentsToTraitAliases;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  use Scalar::Util qw(reftype);
  
  has 'alias' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $alias = $self->alias;
      my $reftype_alias = reftype($alias);
  
      return "$reftype_alias references are not "
          . "valid arguments to the 'trait_aliases' option";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDARGUMENTSTOTRAITALIASES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidBaseTypeGivenToCreateParameterizedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDBASETYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT';
  package Moose::Exception::InvalidBaseTypeGivenToCreateParameterizedTypeConstraint;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not locate the base type (".$self->type_name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDBASETYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidHandleValue.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHANDLEVALUE';
  package Moose::Exception::InvalidHandleValue;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  has 'handle_value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "All values passed to handles must be strings or ARRAY references, not ".$self->handle_value;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHANDLEVALUE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidHasProvidedInARole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHASPROVIDEDINAROLE';
  package Moose::Exception::InvalidHasProvidedInARole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      "Usage: has 'name' => ( key => value, ... )";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDHASPROVIDEDINAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidNameForType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDNAMEFORTYPE';
  package Moose::Exception::InvalidNameForType;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      $self->name." contains invalid characters for a type name. Names can contain alphanumeric character, ':', and '.'";
  }
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDNAMEFORTYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidOverloadOperator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDOVERLOADOPERATOR';
  package Moose::Exception::InvalidOverloadOperator;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has operator => (
      is       => 'ro',
      isa      => 'Defined',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      'The operator parameter you passed to the Moose::Meta::Overload constructor ('
          . $self->operator()
          . ') was not a valid overloading operator';
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDOVERLOADOPERATOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidRoleApplication.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDROLEAPPLICATION';
  package Moose::Exception::InvalidRoleApplication;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'application' => (
      is       => 'ro',
      isa      => "Any",
      required => 1,
  );
  
  sub _build_message {
      "Role applications must be instances of Moose::Meta::Role::Application::ToClass";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDROLEAPPLICATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPECONSTRAINT';
  package Moose::Exception::InvalidTypeConstraint;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'registry_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeConstraint::Registry',
      required => 1
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      return "No type supplied / type is not a valid type constraint";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidTypeGivenToCreateParameterizedTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT';
  package Moose::Exception::InvalidTypeGivenToCreateParameterizedTypeConstraint;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not parse type name (".$self->type_name.") correctly";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDTYPEGIVENTOCREATEPARAMETERIZEDTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/InvalidValueForIs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDVALUEFORIS';
  package Moose::Exception::InvalidValueForIs;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "I do not understand this option (is => ".$self->params->{is}.") on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_INVALIDVALUEFORIS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/IsaDoesNotDoTheRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ISADOESNOTDOTHEROLE';
  package Moose::Exception::IsaDoesNotDoTheRole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Cannot have an isa option and a does option if the isa does not do the does on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ISADOESNOTDOTHEROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/IsaLacksDoesMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ISALACKSDOESMETHOD';
  package Moose::Exception::IsaLacksDoesMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Cannot have an isa option which cannot ->does() on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ISALACKSDOESMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/LazyAttributeNeedsADefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_LAZYATTRIBUTENEEDSADEFAULT';
  package Moose::Exception::LazyAttributeNeedsADefault;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::EitherAttributeOrAttributeName';
  
  sub _build_message {
      my $self = shift;
      "You cannot have a lazy attribute (".$self->attribute_name.") without specifying a default value for it";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_LAZYATTRIBUTENEEDSADEFAULT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_LEGACY';
  package Moose::Exception::Legacy;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_LEGACY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MOPAttributeNewNeedsAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MOPATTRIBUTENEWNEEDSATTRIBUTENAME';
  package Moose::Exception::MOPAttributeNewNeedsAttributeName;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must provide a name for the attribute";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MOPATTRIBUTENEWNEEDSATTRIBUTENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MatchActionMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MATCHACTIONMUSTBEACODEREF';
  package Moose::Exception::MatchActionMustBeACodeRef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  has 'action' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $action = $self->action;
  
      return "Match action must be a CODE ref, not $action";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MATCHACTIONMUSTBEACODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MessageParameterMustBeCodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MESSAGEPARAMETERMUSTBECODEREF';
  package Moose::Exception::MessageParameterMustBeCodeRef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "The 'message' parameter must be a coderef";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MESSAGEPARAMETERMUSTBECODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassIsAClassNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISACLASSNOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsAClassNotASubclassOfGivenMetaclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  use Moose::Util 'find_meta';
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class = find_meta( $self->class_name );
      $self->class_name." already has a metaclass, but it does not inherit ".$self->metaclass.
          " ($class). You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISACLASSNOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassIsARoleNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISAROLENOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsARoleNotASubclassOfGivenMetaclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  use Moose::Util 'find_meta';
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $role_name = $self->role_name;
      my $role      = find_meta( $role_name );
      my $metaclass = $self->metaclass;
      return "$role_name already has a metaclass, but it does not inherit $metaclass ($role). "
          ."You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISAROLENOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassIsNotASubclassOfGivenMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISNOTASUBCLASSOFGIVENMETACLASS';
  package Moose::Exception::MetaclassIsNotASubclassOfGivenMetaclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  use Moose::Util 'find_meta';
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class = find_meta( $self->class_name );
      $self->class_name." already has a metaclass, but it does not inherit ".$self->metaclass." ($class).";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSISNOTASUBCLASSOFGIVENMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassMustBeASubclassOfMooseMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETACLASS';
  package Moose::Exception::MetaclassMustBeASubclassOfMooseMetaClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      my $self = shift;
      "The Metaclass ".$self->class_name." must be a subclass of Moose::Meta::Class."
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassMustBeASubclassOfMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETAROLE';
  package Moose::Exception::MetaclassMustBeASubclassOfMooseMetaRole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      my $self = shift;
      "The Metaclass ".$self->role_name." must be a subclass of Moose::Meta::Role."
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEASUBCLASSOFMOOSEMETAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassMustBeDerivedFromClassMOPClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEDERIVEDFROMCLASSMOPCLASS';
  package Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'class_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The metaclass (".$self->class_name.") must be derived from Class::MOP::Class";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSMUSTBEDERIVEDFROMCLASSMOPCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassNotLoaded.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSNOTLOADED';
  package Moose::Exception::MetaclassNotLoaded;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      my $self = shift;
      "The Metaclass ".$self->class_name." must be loaded. (Perhaps you forgot to 'use ".$self->class_name."'?)";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSNOTLOADED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MetaclassTypeIncompatible.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSTYPEINCOMPATIBLE';
  package Moose::Exception::MetaclassTypeIncompatible;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  use Moose::Util 'find_meta';
  
  has [qw(superclass_name metaclass_type)] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $class_name = $self->class_name;
      my $superclass_name = $self->superclass_name;
      my $metaclass_type = $self->metaclass_type;
  
      my $metaclass_type_name = $metaclass_type;
      $metaclass_type_name =~ s/_(?:meta)?class$//;
      $metaclass_type_name =~ s/_/ /g;
  
      my $class = find_meta( $class_name );
  
      my $self_metaclass_type = $class->$metaclass_type;
  
      my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
      my $super_metatype = $super_meta->$metaclass_type;
  
     return "The $metaclass_type metaclass for $class_name"
     . " ($self_metaclass_type) is not compatible with the $metaclass_type_name"
     . " metaclass of its superclass, $superclass_name ($super_metatype)";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METACLASSTYPEINCOMPATIBLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodExpectedAMetaclassObject.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTEDAMETACLASSOBJECT';
  package Moose::Exception::MethodExpectedAMetaclassObject;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'metaclass' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "The is_needed method expected a metaclass object as its arugment";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTEDAMETACLASSOBJECT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodExpectsFewerArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSFEWERARGS';
  package Moose::Exception::MethodExpectsFewerArgs;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  has 'maximum_args' => (
      is       => 'ro',
      isa      => 'Int',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      my $max = $self->maximum_args;
      "Cannot call ".$self->method_name." with ".
          ( $max ? "more than $max" : 'any'). " argument".( $max == 1 ? '' : 's' );
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSFEWERARGS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodExpectsMoreArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSMOREARGS';
  package Moose::Exception::MethodExpectsMoreArgs;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'minimum_args' => (
      is       => 'ro',
      isa      => 'Int',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Cannot call ".$self->method_name." without at least ".$self->minimum_args." argument".($self->minimum_args == 1 ? '' : 's');
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODEXPECTSMOREARGS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodModifierNeedsMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODMODIFIERNEEDSMETHODNAME';
  package Moose::Exception::MethodModifierNeedsMethodName;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must pass in a method name";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODMODIFIERNEEDSMETHODNAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodNameConflictInRoles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMECONFLICTINROLES';
  package Moose::Exception::MethodNameConflictInRoles;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'conflict' => (
      traits     => ['Array'],
      is         => 'ro',
      isa        => 'ArrayRef[Moose::Meta::Role::Method::Conflicting]',
      handles    => { conflict_methods_count => 'count',
                      get_method_at          => 'get',
                      get_all_methods        => 'elements',
      },
      required   => 1
  );
  
  sub _get_method_names {
      my $self = shift;
  
      return ( $self->conflict_methods_count == 1 ?
          "'".$self->get_method_at(0)->name."'":
          Moose::Util::english_list( map { q{'} . $_->name . q{'} } $self->get_all_methods ) );
  }
  
  sub _build_message {
      my $self = shift;
      my $count = $self->conflict_methods_count;
      my $roles = $self->get_method_at(0)->roles_as_english_list;
  
      if( $count == 1 )
      {
          "Due to a method name conflict in roles "
          .$roles.", the method ".$self->_get_method_names
          ." must be implemented or excluded by '".$self->class_name."'";
      }
      else
      {
          "Due to method name conflicts in roles "
          .$roles.", the methods ".$self->_get_method_names
          ." must be implemented or excluded by '".$self->class_name."'";
      }
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMECONFLICTINROLES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodNameNotFoundInInheritanceHierarchy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTFOUNDININHERITANCEHIERARCHY';
  package Moose::Exception::MethodNameNotFoundInInheritanceHierarchy;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The method '".$self->method_name."' was not found in the inheritance hierarchy for ".$self->class_name;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTFOUNDININHERITANCEHIERARCHY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MethodNameNotGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTGIVEN';
  package Moose::Exception::MethodNameNotGiven;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must define a method name to find";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_METHODNAMENOTGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustDefineAMethodName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEAMETHODNAME';
  package Moose::Exception::MustDefineAMethodName;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      "You must define a method name";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEAMETHODNAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustDefineAnAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEANATTRIBUTENAME';
  package Moose::Exception::MustDefineAnAttributeName;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must define an attribute name";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEANATTRIBUTENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustDefineAnOverloadOperator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEANOVERLOADOPERATOR';
  package Moose::Exception::MustDefineAnOverloadOperator;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Instance';
  
  sub _build_message {
      "You must define an overload operator";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTDEFINEANOVERLOADOPERATOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustHaveAtLeastOneValueToEnumerate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTHAVEATLEASTONEVALUETOENUMERATE';
  package Moose::Exception::MustHaveAtLeastOneValueToEnumerate;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must have at least one value to enumerate through";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTHAVEATLEASTONEVALUETOENUMERATE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustPassAHashOfOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAHASHOFOPTIONS';
  package Moose::Exception::MustPassAHashOfOptions;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must pass a hash of options";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAHASHOFOPTIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustPassAMooseMetaRoleInstanceOrSubclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAMOOSEMETAROLEINSTANCEORSUBCLASS';
  package Moose::Exception::MustPassAMooseMetaRoleInstanceOrSubclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'role' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "You must pass a Moose::Meta::Role instance (or a subclass)";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAMOOSEMETAROLEINSTANCEORSUBCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustPassAPackageNameOrAnExistingClassMOPPackageInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAPACKAGENAMEORANEXISTINGCLASSMOPPACKAGEINSTANCE';
  package Moose::Exception::MustPassAPackageNameOrAnExistingClassMOPPackageInstance;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      "You must pass a package name or an existing Class::MOP::Package instance";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSAPACKAGENAMEORANEXISTINGCLASSMOPPACKAGEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustPassEvenNumberOfArguments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFARGUMENTS';
  package Moose::Exception::MustPassEvenNumberOfArguments;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'args' => (
      is         => 'ro',
      isa        => 'ArrayRef',
      required   => 1
  );
  
  has 'method_name' => (
      is         => 'ro',
      isa        => 'Str',
      required   => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must pass an even number of arguments to ".$self->method_name;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFARGUMENTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustPassEvenNumberOfAttributeOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFATTRIBUTEOPTIONS';
  package Moose::Exception::MustPassEvenNumberOfAttributeOptions;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'options' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      return 'You must pass an even number of attribute options';
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPASSEVENNUMBEROFATTRIBUTEOPTIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustProvideANameForTheAttribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPROVIDEANAMEFORTHEATTRIBUTE';
  package Moose::Exception::MustProvideANameForTheAttribute;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must provide a name for the attribute";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTPROVIDEANAMEFORTHEATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSpecifyAtleastOneMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEMETHOD';
  package Moose::Exception::MustSpecifyAtleastOneMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "Must specify at least one method";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSpecifyAtleastOneRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLE';
  package Moose::Exception::MustSpecifyAtleastOneRole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "Must specify at least one role";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSpecifyAtleastOneRoleToApplicant.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLETOAPPLICANT';
  package Moose::Exception::MustSpecifyAtleastOneRoleToApplicant;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'applicant' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Must specify at least one role to apply to ".$self->applicant;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSPECIFYATLEASTONEROLETOAPPLICANT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyAClassMOPAttributeInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYACLASSMOPATTRIBUTEINSTANCE';
  package Moose::Exception::MustSupplyAClassMOPAttributeInstance;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an attribute which is a 'Class::MOP::Attribute' instance";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYACLASSMOPATTRIBUTEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyADelegateToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYADELEGATETOMETHOD';
  package Moose::Exception::MustSupplyADelegateToMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply a delegate_to_method which is a method name or a CODE reference";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYADELEGATETOMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyAMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMETACLASS';
  package Moose::Exception::MustSupplyAMetaclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must pass a metaclass instance if you want to inline";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyAMooseMetaAttributeInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMOOSEMETAATTRIBUTEINSTANCE';
  package Moose::Exception::MustSupplyAMooseMetaAttributeInstance;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an attribute which is a 'Moose::Meta::Attribute' instance";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYAMOOSEMETAATTRIBUTEINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyAnAccessorTypeToConstructWith.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANACCESSORTYPETOCONSTRUCTWITH';
  package Moose::Exception::MustSupplyAnAccessorTypeToConstructWith;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an accessor_type to construct with";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANACCESSORTYPETOCONSTRUCTWITH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyAnAttributeToConstructWith.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANATTRIBUTETOCONSTRUCTWITH';
  package Moose::Exception::MustSupplyAnAttributeToConstructWith;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply an attribute to construct with";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYANATTRIBUTETOCONSTRUCTWITH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyArrayRefAsCurriedArguments.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYARRAYREFASCURRIEDARGUMENTS';
  package Moose::Exception::MustSupplyArrayRefAsCurriedArguments;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash', 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must supply a curried_arguments which is an ARRAY reference";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYARRAYREFASCURRIEDARGUMENTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/MustSupplyPackageNameAndName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYPACKAGENAMEANDNAME';
  package Moose::Exception::MustSupplyPackageNameAndName;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must supply the package_name and name parameters";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_MUSTSUPPLYPACKAGENAMEANDNAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NeedsTypeConstraintUnionForTypeCoercionUnion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEEDSTYPECONSTRAINTUNIONFORTYPECOERCIONUNION';
  package Moose::Exception::NeedsTypeConstraintUnionForTypeCoercionUnion;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  # use Moose::Util::TypeConstraints 'find_type_constraint';
  
  has 'type_coercion_union_object' => (
      is       => 'ro',
      isa      => 'Moose::Meta::TypeCoercion::Union',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type_constraint = $self->type_name;
  
      return "You can only create a Moose::Meta::TypeCoercion::Union for a " .
             "Moose::Meta::TypeConstraint::Union, not a $type_constraint"
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEEDSTYPECONSTRAINTUNIONFORTYPECOERCIONUNION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NeitherAttributeNorAttributeNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERATTRIBUTENORATTRIBUTENAMEISGIVEN';
  package Moose::Exception::NeitherAttributeNorAttributeNameIsGiven;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give attribute or attribute_name or both";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERATTRIBUTENORATTRIBUTENAMEISGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NeitherClassNorClassNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERCLASSNORCLASSNAMEISGIVEN';
  package Moose::Exception::NeitherClassNorClassNameIsGiven;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give class or class_name or both";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERCLASSNORCLASSNAMEISGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NeitherRoleNorRoleNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERROLENORROLENAMEISGIVEN';
  package Moose::Exception::NeitherRoleNorRoleNameIsGiven;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give role or role_name or both";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERROLENORROLENAMEISGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NeitherTypeNorTypeNameIsGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERTYPENORTYPENAMEISGIVEN';
  package Moose::Exception::NeitherTypeNorTypeNameIsGiven;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You need to give type or type_name or both";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NEITHERTYPENORTYPENAMEISGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoAttributeFoundInSuperClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOATTRIBUTEFOUNDINSUPERCLASS';
  package Moose::Exception::NoAttributeFoundInSuperClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Could not find an attribute by the name of '".$self->attribute_name."' to inherit from in ".$self->class_name;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOATTRIBUTEFOUNDINSUPERCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoBodyToInitializeInAnAbstractBaseClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOBODYTOINITIALIZEINANABSTRACTBASECLASS';
  package Moose::Exception::NoBodyToInitializeInAnAbstractBaseClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'package_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "No body to initialize, " .$self->package_name. " is an abstract base class";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOBODYTOINITIALIZEINANABSTRACTBASECLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoCasesMatched.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOCASESMATCHED';
  package Moose::Exception::NoCasesMatched;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'to_match' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'cases_to_be_matched' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $to_match = $self->to_match;
  
      return "No cases matched for $to_match";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOCASESMATCHED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoConstraintCheckForTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOCONSTRAINTCHECKFORTYPECONSTRAINT';
  package Moose::Exception::NoConstraintCheckForTypeConstraint;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      my $self = shift;
      "Could not compile type constraint '".$self->type_name."' because no constraint check";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOCONSTRAINTCHECKFORTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoDestructorClassSpecified.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NODESTRUCTORCLASSSPECIFIED';
  package Moose::Exception::NoDestructorClassSpecified;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  sub _build_message {
      "The 'inline_destructor' option is present, but no destructor class was specified";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NODESTRUCTORCLASSSPECIFIED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoImmutableTraitSpecifiedForClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOIMMUTABLETRAITSPECIFIEDFORCLASS';
  package Moose::Exception::NoImmutableTraitSpecifiedForClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  use Moose::Util 'find_meta';
  
  sub _build_message {
      my $self  = shift;
      my $class = find_meta( $self->class_name );
      "no immutable trait specified for $class";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOIMMUTABLETRAITSPECIFIEDFORCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/NoParentGivenToSubtype.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOPARENTGIVENTOSUBTYPE';
  package Moose::Exception::NoParentGivenToSubtype;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "A subtype cannot consist solely of a name, it must have a parent";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_NOPARENTGIVENTOSUBTYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OnlyInstancesCanBeCloned.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ONLYINSTANCESCANBECLONED';
  package Moose::Exception::OnlyInstancesCanBeCloned;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "You can only clone instances, (".$self->instance.") is not a blessed instance";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ONLYINSTANCESCANBECLONED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OperatorIsRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OPERATORISREQUIRED';
  package Moose::Exception::OperatorIsRequired;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "operator is required";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OPERATORISREQUIRED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OverloadConflictInSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADCONFLICTINSUMMATION';
  package Moose::Exception::OverloadConflictInSummation;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  use Moose::Util 'find_meta';
  
  has 'role_application' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role::Application::RoleSummation',
      required => 1
  );
  
  has 'role_names' => (
      traits  => ['Array'],
      is      => 'bare',
      isa     => 'ArrayRef[Str]',
      handles => {
          role_names => 'elements',
      },
      required => 1,
      documentation =>
          "This attribute is an ArrayRef containing role names, if you want metaobjects\n"
          . "associated with these role names, then call method roles on the exception object.\n",
  );
  
  has 'overloaded_op' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub roles {
      my $self = shift;
      my @role_names = $self->role_names;
      my @roles = map { find_meta($_) } @role_names;
      return @roles;
  }
  
  sub _build_message {
      my $self = shift;
  
      my @roles = $self->role_names;
      my $role_names = join "|", @roles;
  
      my $op = $self->overloaded_op;
      if ( $op eq 'fallback' ) {
          return
                'We have encountered an overloading conflict for the fallback '
              . 'during composition. This is a fatal error.';
      }
      else {
          return
                "Role '$role_names' has encountered an overloading conflict "
              . "during composition. The two roles both overload the '$op' operator. "
              . 'This is a fatal error.';
      }
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADCONFLICTINSUMMATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OverloadRequiresAMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETACLASS';
  package Moose::Exception::OverloadRequiresAMetaClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'If you provide an associated_metaclass parameter to the Moose::Meta::Overload constructor it must be a Class::MOP::Module object';
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OverloadRequiresAMetaMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETAMETHOD';
  package Moose::Exception::OverloadRequiresAMetaMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'If you provide a method parameter to the Moose::Meta::Overload constructor it must be a Class::MOP::Method object';
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETAMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OverloadRequiresAMetaOverload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETAOVERLOAD';
  package Moose::Exception::OverloadRequiresAMetaOverload;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'If you provide an original_overload parameter to the Moose::Meta::Overload constructor it must be a Moose::Meta::Overload object';
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETAOVERLOAD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OverloadRequiresAMethodNameOrCoderef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETHODNAMEORCODEREF';
  package Moose::Exception::OverloadRequiresAMethodNameOrCoderef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'You must provide a method_name or coderef parameter when constructing a Moose::Meta::Overload object';
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESAMETHODNAMEORCODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OverloadRequiresAnOperator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESANOPERATOR';
  package Moose::Exception::OverloadRequiresAnOperator;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'You must provide an operator parameter when constructing a Moose::Meta::Overload object';
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESANOPERATOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OverloadRequiresNamesForCoderef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESNAMESFORCODEREF';
  package Moose::Exception::OverloadRequiresNamesForCoderef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      my $self = shift;
      'If you provide a coderef parameter to the Moose::Meta::Overload constructor you must also provide coderef_package and coderef_name parameters';
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERLOADREQUIRESNAMESFORCODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OverrideConflictInComposition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINCOMPOSITION';
  package Moose::Exception::OverrideConflictInComposition;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'role_being_applied_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'two_overrides_found' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1,
      default  => 0
  );
  
  sub _build_message {
      my $self = shift;
  
      if( $self->two_overrides_found ) {
          return "Role '" . $self->role_being_applied_name . "' has encountered an 'override' method conflict " .
                 "during composition (Two 'override' methods of the same name encountered). " .
                 "This is a fatal error.";
      }
      else {
          return "Role '".$self->role_being_applied_name."' has encountered an 'override' method conflict ".
                 "during composition (A local method of the same name as been found). ".
                 "This is a fatal error.";
      }
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINCOMPOSITION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/OverrideConflictInSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINSUMMATION';
  package Moose::Exception::OverrideConflictInSummation;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  use Moose::Util 'find_meta';
  
  has 'role_application' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role::Application::RoleSummation',
      required => 1
  );
  
  has 'role_names' => (
      traits   => ['Array'],
      is       => 'bare',
      isa      => 'ArrayRef[Str]',
      handles  => {
          role_names      => 'elements',
      },
      required => 1,
      documentation => "This attribute is an ArrayRef containing role names, if you want metaobjects\n".
                       "associated with these role names, then call method roles on the exception object.\n",
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'two_overrides_found' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1,
      default  => 0
  );
  
  sub roles {
      my $self = shift;
      my @role_names = $self->role_names;
      my @roles = map { find_meta($_) } @role_names;
      return @roles;
  }
  
  sub _build_message {
      my $self = shift;
  
      my @roles = $self->role_names;
      my $role_names = join "|", @roles;
  
      if( $self->two_overrides_found ) {
          return "We have encountered an 'override' method conflict ".
                 "during composition (Two 'override' methods of the same name encountered). ".
                 "This is a fatal error.";
      }
      else {
          return "Role '$role_names' has encountered an 'override' method conflict " .
                 "during composition (A local method of the same name has been found). This " .
                 "is a fatal error." ;
      }
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_OVERRIDECONFLICTINSUMMATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/PackageDoesNotUseMooseExporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGEDOESNOTUSEMOOSEEXPORTER';
  package Moose::Exception::PackageDoesNotUseMooseExporter;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'package' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'is_loaded' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $package = $self->package;
      return "Package in also ($package) does not seem to "
             . "use Moose::Exporter"
             . ( $self->is_loaded ? "" : " (is it loaded?)" );
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGEDOESNOTUSEMOOSEEXPORTER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/PackageNameAndNameParamsNotGivenToWrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGENAMEANDNAMEPARAMSNOTGIVENTOWRAP';
  package Moose::Exception::PackageNameAndNameParamsNotGivenToWrap;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'code' => (
      is       => 'ro',
      isa      => 'CodeRef',
      required => 1
  );
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "You must supply the package_name and name parameters";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGENAMEANDNAMEPARAMSNOTGIVENTOWRAP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/PackagesAndModulesAreNotCachable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGESANDMODULESARENOTCACHABLE';
  package Moose::Exception::PackagesAndModulesAreNotCachable;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::ParamsHash';
  
  has 'is_module' => (
      is       => 'ro',
      isa      => 'Bool',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $is_module = $self->is_module;
  
      if( $is_module ) {
          return "Modules are not cacheable";
      } else {
          return "Packages are not cacheable";
      }
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PACKAGESANDMODULESARENOTCACHABLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ParameterIsNotSubtypeOfParent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PARAMETERISNOTSUBTYPEOFPARENT';
  package Moose::Exception::ParameterIsNotSubtypeOfParent;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  use Moose::Util::TypeConstraints qw/find_type_constraint/;
  
  has 'type_parameter' => (
      is => 'ro',
      isa => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $type_parameter = $self->type_parameter;
      my $type           = find_type_constraint( $self->type_name );
      my $parent         = $type->parent->type_parameter;
  
      return "$type_parameter is not a subtype of $parent";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_PARAMETERISNOTSUBTYPEOFPARENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ReferencesAreNotAllowedAsDefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REFERENCESARENOTALLOWEDASDEFAULT';
  package Moose::Exception::ReferencesAreNotAllowedAsDefault;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "References are not allowed as default values, you must wrap the default of '".
          $self->attribute_name."' in a CODE reference (ex: sub { [] } and not [])";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REFERENCESARENOTALLOWEDASDEFAULT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RequiredAttributeLacksInitialization.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTELACKSINITIALIZATION';
  package Moose::Exception::RequiredAttributeLacksInitialization;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      "A required attribute must have either 'init_arg', 'builder', or 'default'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTELACKSINITIALIZATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RequiredAttributeNeedsADefault.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTENEEDSADEFAULT';
  package Moose::Exception::RequiredAttributeNeedsADefault;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "You cannot have a required attribute (".$self->attribute_name.") without a default, builder, or an init_arg";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDATTRIBUTENEEDSADEFAULT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RequiredMethodsImportedByClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSIMPORTEDBYCLASS';
  package Moose::Exception::RequiredMethodsImportedByClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';
  
  has 'missing_methods' => (
      traits   => ['Array'],
      is       => 'ro',
      isa      => 'ArrayRef[Moose::Meta::Role::Method::Required]',
      handles  => { method_count    => 'count',
                    get_method_at   => 'get',
                    get_all_methods => 'elements',
      },
      required => 1
  );
  
  has 'imported_method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Role::Method::Required',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
  
      my $noun = $self->method_count == 1 ? 'method' : 'methods';
      my $list = Moose::Util::english_list( map { q{'} . $_ . q{'} } $self->get_all_methods );
  
      my ($class, $role, $method) = ($self->class_name,
                                     $self->role_name,
                                     $self->imported_method);
  
      my ($class_quoted, $role_quoted) = ("'".$class."'","'".$role."'");
  
      "$role_quoted requires the $noun $list "
          . "to be implemented by $class_quoted. "
          . "If you imported functions intending to use them as "
          . "methods, you need to explicitly mark them as such, via "
          . "$class->meta->add_method($method"
          . " => \\&$method)";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSIMPORTEDBYCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RequiredMethodsNotImplementedByClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSNOTIMPLEMENTEDBYCLASS';
  package Moose::Exception::RequiredMethodsNotImplementedByClass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class', 'Moose::Exception::Role::Role';
  
  has 'missing_methods' => (
      traits     => ['Array'],
      is         => 'ro',
      isa        => 'ArrayRef[Moose::Meta::Role::Method::Required]',
      handles    => { method_count    => 'count',
                      get_method_at   => 'get',
                      get_all_methods => 'elements',
      },
      required   => 1
  );
  
  sub _build_message {
      my $self = shift;
  
      my $noun = $self->method_count == 1 ? 'method' : 'methods';
      my $list = Moose::Util::english_list( map { q{'} . $_ . q{'} } $self->get_all_methods );
      my ($role_name, $class_name) = ($self->role_name, $self->class_name);
  
      return "'$role_name' requires the $noun $list "
          . "to be implemented by '$class_name'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_REQUIREDMETHODSNOTIMPLEMENTEDBYCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTE';
  package Moose::Exception::Role::Attribute;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  
  has 'attribute' => (
      is        => 'ro',
      isa       => 'Class::MOP::Attribute',
      predicate => 'is_attribute_set'
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/AttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTENAME';
  package Moose::Exception::Role::AttributeName;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ATTRIBUTENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_CLASS';
  package Moose::Exception::Role::Class;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  
  has 'class_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching metaclass instance:\n".
                       "    my \$metaclass_instance = Moose::Util::find_meta( \$exception->class_name );\n",
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_CLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/EitherAttributeOrAttributeName.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_EITHERATTRIBUTEORATTRIBUTENAME';
  package Moose::Exception::Role::EitherAttributeOrAttributeName;
  our $VERSION = '2.1603';
  
  use Moose::Util 'throw_exception';
  use Moose::Role;
  
  has 'attribute_name' => (
      is         => 'ro',
      isa        => 'Str',
      lazy_build => 1
  );
  
  has 'attribute' => (
      is        => 'ro',
      isa       => 'Class::MOP::Attribute',
      predicate => 'has_attribute'
  );
  
  has 'params' => (
      is        => 'ro',
      isa       => 'HashRef',
      predicate => 'has_params',
  );
  
  sub _build_attribute_name {
      my $self = shift;
  
      if( !$self->has_attribute )
      {
          throw_exception("NeitherAttributeNorAttributeNameIsGiven");
      }
  
      return $self->attribute->name;
  }
  
  after "BUILD" => sub {
      my $self = $_[0];
  
      if( $self->has_attribute_name &&
          $self->has_attribute &&
          ( $self->attribute->name ne $self->attribute_name ) )
      {
          throw_exception( AttributeNamesDoNotMatch => attribute_name => $self->attribute_name,
                                                       attribute      => $self->attribute
                         );
      }
  };
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_EITHERATTRIBUTEORATTRIBUTENAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INSTANCE';
  package Moose::Exception::Role::Instance;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  
  has 'instance' => (
      is       => 'ro',
      isa      => 'Object',
      required => 1,
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/InstanceClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INSTANCECLASS';
  package Moose::Exception::Role::InstanceClass;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  
  has 'instance_class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INSTANCECLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/InvalidAttributeOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INVALIDATTRIBUTEOPTIONS';
  package Moose::Exception::Role::InvalidAttributeOptions;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_INVALIDATTRIBUTEOPTIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_METHOD';
  package Moose::Exception::Role::Method;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  
  has 'method' => (
      is       => 'ro',
      isa      => 'Moose::Meta::Method',
      required => 1,
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_METHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/ParamsHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_PARAMSHASH';
  package Moose::Exception::Role::ParamsHash;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  
  has 'params' => (
      is       => 'ro',
      isa      => 'HashRef',
      required => 1,
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_PARAMSHASH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLE';
  package Moose::Exception::Role::Role;
  our $VERSION = '2.1603';
  
  # use Moose::Util 'throw_exception';
  use Moose::Role;
  
  has 'role_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching the class's metaclass instance:\n".
                       "    my \$metaclass_instance = Moose::Util::find_meta( \$exception->role_name );\n",
  
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/RoleForCreate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATE';
  package Moose::Exception::Role::RoleForCreate;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'attribute_class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/RoleForCreateMOPClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATEMOPCLASS';
  package Moose::Exception::Role::RoleForCreateMOPClass;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_ROLEFORCREATEMOPCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/Role/TypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_TYPECONSTRAINT';
  package Moose::Exception::Role::TypeConstraint;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  
  has 'type_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching type constraint(Moose::Meta::TypeConstraint):\n".
                       "    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->type_name );\n",
  );
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLE_TYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RoleDoesTheExcludedRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLEDOESTHEEXCLUDEDROLE';
  package Moose::Exception::RoleDoesTheExcludedRole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'excluded_role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'second_role_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self               = shift;
      my $role_name          = $self->role_name;
      my $excluded_role_name = $self->excluded_role_name;
      return "The role $role_name does the excluded role '$excluded_role_name'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLEDOESTHEEXCLUDEDROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RoleExclusionConflict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLEEXCLUSIONCONFLICT';
  package Moose::Exception::RoleExclusionConflict;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'roles' => (
      is         => 'ro',
      isa        => 'ArrayRef',
      required   => 1,
  );
  
  sub _build_message {
      my $self = shift;
  
      my @roles_array = @{$self->roles};
      my $role_noun = "Role".( @roles_array == 1 ? '' : 's');
      my $all_roles = join(', ', @roles_array);
      my $verb = "exclude".( @roles_array == 1 ? 's' : '' );
      my $role_name = $self->role_name;
  
      return "Conflict detected: $role_noun $all_roles $verb role '$role_name'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLEEXCLUSIONCONFLICT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RoleNameRequired.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIRED';
  package Moose::Exception::RoleNameRequired;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  sub _build_message {
      "You must supply a role name to look for";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIRED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RoleNameRequiredForMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIREDFORMOOSEMETAROLE';
  package Moose::Exception::RoleNameRequiredForMooseMetaRole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  sub _build_message {
      "You must supply a role name to look for";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLENAMEREQUIREDFORMOOSEMETAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesDoNotSupportAugment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTAUGMENT';
  package Moose::Exception::RolesDoNotSupportAugment;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Roles cannot support 'augment'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTAUGMENT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesDoNotSupportExtends.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTEXTENDS';
  package Moose::Exception::RolesDoNotSupportExtends;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Roles do not support 'extends' (you can use 'with' to specialize a role)";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTEXTENDS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesDoNotSupportInner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTINNER';
  package Moose::Exception::RolesDoNotSupportInner;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Roles cannot support 'inner'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTINNER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesDoNotSupportRegexReferencesForMethodModifiers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTREGEXREFERENCESFORMETHODMODIFIERS';
  package Moose::Exception::RolesDoNotSupportRegexReferencesForMethodModifiers;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Role';
  
  has 'modifier_type' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Roles do not currently support regex references for ".$self->modifier_type." method modifiers";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESDONOTSUPPORTREGEXREFERENCESFORMETHODMODIFIERS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesInCreateTakesAnArrayRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESINCREATETAKESANARRAYREF';
  package Moose::Exception::RolesInCreateTakesAnArrayRef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  sub _build_message {
      my $self = shift;
      "You must pass an ARRAY ref of roles";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESINCREATETAKESANARRAYREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/RolesListMustBeInstancesOfMooseMetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESLISTMUSTBEINSTANCESOFMOOSEMETAROLE';
  package Moose::Exception::RolesListMustBeInstancesOfMooseMetaRole;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'role' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The list of roles must be instances of Moose::Meta::Role, not ".$self->role;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_ROLESLISTMUSTBEINSTANCESOFMOOSEMETAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/SingleParamsToNewMustBeHashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_SINGLEPARAMSTONEWMUSTBEHASHREF';
  package Moose::Exception::SingleParamsToNewMustBeHashRef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "Single parameters to new() must be a HASH ref";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_SINGLEPARAMSTONEWMUSTBEHASHREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/TriggerMustBeACodeRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TRIGGERMUSTBEACODEREF';
  package Moose::Exception::TriggerMustBeACodeRef;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::InvalidAttributeOptions';
  
  sub _build_message {
      my $self = shift;
      "Trigger must be a CODE ref on attribute (".$self->attribute_name.")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TRIGGERMUSTBEACODEREF

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/TypeConstraintCannotBeUsedForAParameterizableType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTCANNOTBEUSEDFORAPARAMETERIZABLETYPE';
  package Moose::Exception::TypeConstraintCannotBeUsedForAParameterizableType;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  has 'parent_type_name' => (
      is            => 'ro',
      isa           => 'Str',
      required      => 1,
      documentation => "This attribute can be used for fetching type constraint(Moose::Meta::TypeConstraint):\n".
                       "    my \$type_constraint =  Moose::Util::TypeConstraints::find_type_constraint( \$exception->parent_type_name );\n",
  );
  
  sub _build_message {
      my $self             = shift;
      my $type_name        = $self->type_name;
      my $parent_type_name = $self->parent_type_name;
      "The $type_name constraint cannot be used, because "
          . "$parent_type_name doesn't subtype or coerce from a parameterizable type.";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTCANNOTBEUSEDFORAPARAMETERIZABLETYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/TypeConstraintIsAlreadyCreated.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTISALREADYCREATED';
  package Moose::Exception::TypeConstraintIsAlreadyCreated;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  use Moose::Util::TypeConstraints 'find_type_constraint';
  
  has 'package_defined_in' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self                    = shift;
      my $type_name               = $self->type_name;
      my $type                    = find_type_constraint( $type_name );
      my $type_package_defined_in = $type->_package_defined_in;
      my $package_defined_in      = $self->package_defined_in;
      return "The type constraint '$type_name' has already been created in $type_package_defined_in and cannot be created again in $package_defined_in";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPECONSTRAINTISALREADYCREATED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/TypeParameterMustBeMooseMetaType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPEPARAMETERMUSTBEMOOSEMETATYPE';
  package Moose::Exception::TypeParameterMustBeMooseMetaType;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::TypeConstraint';
  
  sub _build_message {
      "The type parameter must be a Moose meta type";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_TYPEPARAMETERMUSTBEMOOSEMETATYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UnableToCanonicalizeHandles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZEHANDLES';
  package Moose::Exception::UnableToCanonicalizeHandles;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'handles' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Unable to canonicalize the 'handles' option with ".$self->handles;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZEHANDLES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UnableToCanonicalizeNonRolePackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZENONROLEPACKAGE';
  package Moose::Exception::UnableToCanonicalizeNonRolePackage;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'handles' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1,
  );
  
  sub _build_message {
      my $self = shift;
      "Unable to canonicalize the 'handles' option with ".$self->handles." because its metaclass is not a Moose::Meta::Role";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETOCANONICALIZENONROLEPACKAGE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UnableToRecognizeDelegateMetaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETORECOGNIZEDELEGATEMETACLASS';
  package Moose::Exception::UnableToRecognizeDelegateMetaclass;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'delegate_metaclass' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      my $meta = $self->delegate_metaclass;
  
      return "Unable to recognize the delegate metaclass '$meta'";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNABLETORECOGNIZEDELEGATEMETACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UndefinedHashKeysPassedToMethod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNDEFINEDHASHKEYSPASSEDTOMETHOD';
  package Moose::Exception::UndefinedHashKeysPassedToMethod;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'hash_keys' => (
      is         => 'ro',
      isa        => 'ArrayRef',
      required   => 1
  );
  
  has 'method_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "Hash keys passed to ".$self->method_name." must be defined";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNDEFINEDHASHKEYSPASSEDTOMETHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UnionCalledWithAnArrayRefAndAdditionalArgs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNIONCALLEDWITHANARRAYREFANDADDITIONALARGS';
  package Moose::Exception::UnionCalledWithAnArrayRefAndAdditionalArgs;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  has 'array' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  has 'args' => (
      is       => 'ro',
      isa      => 'ArrayRef',
      required => 1
  );
  
  sub _build_message {
      "union called with an array reference and additional arguments";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNIONCALLEDWITHANARRAYREFANDADDITIONALARGS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/UnionTakesAtleastTwoTypeNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNIONTAKESATLEASTTWOTYPENAMES';
  package Moose::Exception::UnionTakesAtleastTwoTypeNames;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  
  sub _build_message {
      "You must pass in at least 2 type names to make a union";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_UNIONTAKESATLEASTTWOTYPENAMES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ValidationFailedForInlineTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORINLINETYPECONSTRAINT';
  package Moose::Exception::ValidationFailedForInlineTypeConstraint;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Class';
  
  has 'type_constraint_message' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'attribute_name' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'new_member' => (
      is        => 'ro',
      isa       => 'Bool',
      default   => 0,
      predicate => 'is_a_new_member'
  );
  
  sub _build_message {
      my $self = shift;
  
      my $line1;
  
      if( $self->new_member ) {
          $line1 = "A new member value for ".$self->attribute_name." does not pass its type constraint because: "
      }
      else {
          $line1 = "Attribute (".$self->attribute_name.") does not pass the type constraint because: ";
      }
  
      return $line1 . $self->type_constraint_message;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORINLINETYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/ValidationFailedForTypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORTYPECONSTRAINT';
  package Moose::Exception::ValidationFailedForTypeConstraint;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::Attribute';
  
  has 'value' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1,
  );
  
  has 'type' => (
      is       => 'ro',
      isa      => Moose::Util::TypeConstraints->duck_type(["get_message", "name"]),
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
  
      my $error = $self->type->get_message( $self->value );
  
      return $error unless $self->is_attribute_set;
  
      my $attribute_name = $self->attribute->name;
      return
          "Attribute ($attribute_name) does not pass the type constraint because: $error";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_VALIDATIONFAILEDFORTYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/WrapTakesACodeRefToBless.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_WRAPTAKESACODEREFTOBLESS';
  package Moose::Exception::WrapTakesACodeRefToBless;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has 'code' => (
      is       => 'ro',
      isa      => 'Any',
      required => 1
  );
  
  has 'class' => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "You must supply a CODE reference to bless, not (" . ( $self->code ? $self->code : 'undef' ) . ")";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_WRAPTAKESACODEREFTOBLESS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exception/WrongTypeConstraintGiven.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_WRONGTYPECONSTRAINTGIVEN';
  package Moose::Exception::WrongTypeConstraintGiven;
  our $VERSION = '2.1603';
  
  use Moose;
  extends 'Moose::Exception';
  with 'Moose::Exception::Role::ParamsHash';
  
  has [qw/required_type given_type attribute_name/] => (
      is       => 'ro',
      isa      => 'Str',
      required => 1
  );
  
  sub _build_message {
      my $self = shift;
      "The type constraint for ".$self->attribute_name." must be a subtype of "
      .$self->required_type." but it's a ".$self->given_type;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXCEPTION_WRONGTYPECONSTRAINTGIVEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXPORTER';
  package Moose::Exporter;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::Load qw(is_class_loaded);
  use Class::MOP;
  use List::MoreUtils qw( first_index uniq );
  use Moose::Util::MetaRole;
  use Scalar::Util 1.11 qw(reftype);
  use Sub::Exporter 0.980;
  use Sub::Name qw(subname);
  
  use Moose::Util 'throw_exception';
  
  my %EXPORT_SPEC;
  
  sub setup_import_methods {
      my ( $class, %args ) = @_;
  
      $args{exporting_package} ||= caller();
  
      $class->build_import_methods(
          %args,
          install => [qw(import unimport init_meta)]
      );
  }
  
  # A reminder to intrepid Moose hackers
  # there may be more than one level of exporter
  # don't make doy cry. -- perigrin
  
  sub build_import_methods {
      my ( $class, %args ) = @_;
  
      my $exporting_package = $args{exporting_package} ||= caller();
  
      my $meta_lookup = $args{meta_lookup} || sub { Class::MOP::class_of(shift) };
  
      $EXPORT_SPEC{$exporting_package} = \%args;
  
      my @exports_from = $class->_follow_also($exporting_package);
  
      my $export_recorder = {};
      my $is_reexport     = {};
  
      my $exports = $class->_make_sub_exporter_params(
          [ $exporting_package, @exports_from ],
          $export_recorder,
          $is_reexport,
          $args{meta_lookup}, # so that we don't pass through the default
      );
  
      my $exporter = $class->_make_exporter(
          $exports,
          $is_reexport,
          $meta_lookup,
      );
  
      my %methods;
      $methods{import} = $class->_make_import_sub(
          $exporting_package,
          $exporter,
          \@exports_from,
          $is_reexport,
          $meta_lookup,
      );
  
      $methods{unimport} = $class->_make_unimport_sub(
          $exporting_package,
          $exports,
          $export_recorder,
          $is_reexport,
          $meta_lookup,
      );
  
      $methods{init_meta} = $class->_make_init_meta(
          $exporting_package,
          \%args,
          $meta_lookup,
      );
  
      my $package = Class::MOP::Package->initialize($exporting_package);
      for my $to_install ( @{ $args{install} || [] } ) {
          my $symbol = '&' . $to_install;
  
          next
              unless $methods{$to_install}
                  && !$package->has_package_symbol($symbol);
          $package->add_package_symbol(
              $symbol,
              subname(
                  $exporting_package . '::' . $to_install, $methods{$to_install}
              )
          );
      }
  
      return ( $methods{import}, $methods{unimport}, $methods{init_meta} );
  }
  
  sub _make_exporter {
      my ($class, $exports, $is_reexport, $meta_lookup) = @_;
  
      return Sub::Exporter::build_exporter(
          {
              exports   => $exports,
              groups    => { default => [':all'] },
              installer => sub {
                  my ($arg, $to_export) = @_;
                  my $meta = $meta_lookup->($arg->{into});
  
                  goto &Sub::Exporter::default_installer unless $meta;
  
                  # don't overwrite existing symbols with our magically flagged
                  # version of it if we would install the same sub that's already
                  # in the importer
  
                  my @filtered_to_export;
                  my %installed;
                  for (my $i = 0; $i < @{ $to_export }; $i += 2) {
                      my ($as, $cv) = @{ $to_export }[$i, $i + 1];
  
                      next if !ref($as)
                           && $meta->has_package_symbol('&' . $as)
                           && $meta->get_package_symbol('&' . $as) == $cv;
  
                      push @filtered_to_export, $as, $cv;
                      $installed{$as} = 1 unless ref $as;
                  }
  
                  Sub::Exporter::default_installer($arg, \@filtered_to_export);
  
                  for my $name ( keys %{$is_reexport} ) {
                      no strict 'refs';
                      no warnings 'once';
                      next unless exists $installed{$name};
                      _flag_as_reexport( \*{ join q{::}, $arg->{into}, $name } );
                  }
              },
          }
      );
  }
  
  sub _follow_also {
      my $class             = shift;
      my $exporting_package = shift;
  
      _die_if_cycle_found_in_also_list_for_package($exporting_package);
  
      return uniq( _follow_also_real($exporting_package) );
  }
  
  sub _follow_also_real {
      my $exporting_package = shift;
      my @also              = _also_list_for_package($exporting_package);
  
      return map { $_, _follow_also_real($_) } @also;
  }
  
  sub _also_list_for_package {
      my $package = shift;
  
      if ( !exists $EXPORT_SPEC{$package} ) {
          my $loaded = is_class_loaded($package);
  
          throw_exception( PackageDoesNotUseMooseExporter => package   => $package,
                                                             is_loaded => $loaded
                         );
      }
  
      my $also = $EXPORT_SPEC{$package}{also};
  
      return unless defined $also;
  
      return ref $also ? @$also : $also;
  }
  
  # this is no Tarjan algorithm, but for the list sizes expected,
  # brute force will probably be fine (and more maintainable)
  sub _die_if_cycle_found_in_also_list_for_package {
      my $package = shift;
      _die_if_also_list_cycles_back_to_existing_stack(
          [ _also_list_for_package($package) ],
          [$package],
      );
  }
  
  sub _die_if_also_list_cycles_back_to_existing_stack {
      my ( $also_list, $existing_stack ) = @_;
  
      return unless @$also_list && @$existing_stack;
  
      for my $also_member (@$also_list) {
          for my $stack_member (@$existing_stack) {
              next unless $also_member eq $stack_member;
  
              throw_exception( CircularReferenceInAlso => also_parameter => $also_member,
                                                          stack          => $existing_stack
                             );
          }
  
          _die_if_also_list_cycles_back_to_existing_stack(
              [ _also_list_for_package($also_member) ],
              [ $also_member, @$existing_stack ],
          );
      }
  }
  
  sub _parse_trait_aliases {
      my $class   = shift;
      my ($package, $aliases) = @_;
  
      my @ret;
      for my $alias (@$aliases) {
          my $name;
          if (ref($alias)) {
              reftype($alias) eq 'ARRAY'
                  or throw_exception( InvalidArgumentsToTraitAliases => class_name   => $class,
                                                                        package_name => $package,
                                                                        alias        => $alias
                                    );
              ($alias, $name) = @$alias;
          }
          else {
              ($name = $alias) =~ s/.*:://;
          }
          push @ret, subname "${package}::${name}" => sub () { $alias };
      }
  
      return @ret;
  }
  
  sub _make_sub_exporter_params {
      my $class                = shift;
      my $packages             = shift;
      my $export_recorder      = shift;
      my $is_reexport          = shift;
      my $meta_lookup_override = shift;
  
      my %exports;
      my $current_meta_lookup;
  
      for my $package ( @{$packages} ) {
          my $args = $EXPORT_SPEC{$package}
              or die "The $package package does not use Moose::Exporter\n";
  
          $current_meta_lookup = $meta_lookup_override || $args->{meta_lookup};
          $meta_lookup_override = $current_meta_lookup;
  
          my $meta_lookup = $current_meta_lookup
                         || sub { Class::MOP::class_of(shift) };
  
          for my $name ( @{ $args->{with_meta} } ) {
              my $sub = $class->_sub_from_package( $package, $name )
                  or next;
  
              my $fq_name = $package . '::' . $name;
  
              $exports{$name} = $class->_make_wrapped_sub_with_meta(
                  $fq_name,
                  $sub,
                  $export_recorder,
                  $meta_lookup,
              ) unless exists $exports{$name};
          }
  
          for my $name ( @{ $args->{with_caller} } ) {
              my $sub = $class->_sub_from_package( $package, $name )
                  or next;
  
              my $fq_name = $package . '::' . $name;
  
              $exports{$name} = $class->_make_wrapped_sub(
                  $fq_name,
                  $sub,
                  $export_recorder,
              ) unless exists $exports{$name};
          }
  
          my @extra_exports = $class->_parse_trait_aliases(
              $package, $args->{trait_aliases},
          );
          for my $name ( @{ $args->{as_is} }, @extra_exports ) {
              my ( $sub, $coderef_name );
  
              if ( ref $name ) {
                  $sub = $name;
  
                  my $coderef_pkg;
                  ( $coderef_pkg, $coderef_name )
                      = Class::MOP::get_code_info($name);
  
                  if ( $coderef_pkg ne $package ) {
                      $is_reexport->{$coderef_name} = 1;
                  }
              }
              elsif ( $name =~ /^(.*)::([^:]+)$/ ) {
                  $sub = $class->_sub_from_package( "$1", "$2" )
                      or next;
  
                  $coderef_name = "$2";
  
                  if ( $1 ne $package ) {
                      $is_reexport->{$coderef_name} = 1;
                  }
              }
              else {
                  $sub = $class->_sub_from_package( $package, $name )
                      or next;
  
                  $coderef_name = $name;
              }
  
              $export_recorder->{$sub} = 1;
  
              $exports{$coderef_name} = sub { $sub }
                  unless exists $exports{$coderef_name};
          }
      }
  
      return \%exports;
  }
  
  sub _sub_from_package {
      my $sclass  = shift;
      my $package = shift;
      my $name    = shift;
  
      my $sub = do {
          no strict 'refs';
          \&{ $package . '::' . $name };
      };
  
      return $sub if defined &$sub;
  
      Carp::cluck "Trying to export undefined sub ${package}::${name}";
  
      return;
  }
  
  our $CALLER;
  
  sub _make_wrapped_sub {
      my $self            = shift;
      my $fq_name         = shift;
      my $sub             = shift;
      my $export_recorder = shift;
  
      # We need to set the package at import time, so that when
      # package Foo imports has(), we capture "Foo" as the
      # package. This lets other packages call Foo::has() and get
      # the right package. This is done for backwards compatibility
      # with existing production code, not because this is a good
      # idea ;)
      return sub {
          my $caller = $CALLER;
  
          my $wrapper = $self->_curry_wrapper( $sub, $fq_name, $caller );
  
          my $sub = subname( $fq_name => $wrapper );
  
          $export_recorder->{$sub} = 1;
  
          return $sub;
      };
  }
  
  sub _make_wrapped_sub_with_meta {
      my $self            = shift;
      my $fq_name         = shift;
      my $sub             = shift;
      my $export_recorder = shift;
      my $meta_lookup     = shift;
  
      return sub {
          my $caller = $CALLER;
  
          my $wrapper = $self->_late_curry_wrapper(
              $sub, $fq_name,
              $meta_lookup => $caller
          );
  
          my $sub = subname( $fq_name => $wrapper );
  
          $export_recorder->{$sub} = 1;
  
          return $sub;
      };
  }
  
  sub _curry_wrapper {
      my $class   = shift;
      my $sub     = shift;
      my $fq_name = shift;
      my @extra   = @_;
  
      my $wrapper = sub { $sub->( @extra, @_ ) };
      if ( my $proto = prototype $sub ) {
  
          # XXX - Perl's prototype sucks. Use & to make set_prototype
          # ignore the fact that we're passing "private variables"
          &Scalar::Util::set_prototype( $wrapper, $proto );
      }
      return $wrapper;
  }
  
  sub _late_curry_wrapper {
      my $class   = shift;
      my $sub     = shift;
      my $fq_name = shift;
      my $extra   = shift;
      my @ex_args = @_;
  
      my $wrapper = sub {
  
          # resolve curried arguments at runtime via this closure
          my @curry = ( $extra->(@ex_args) );
          return $sub->( @curry, @_ );
      };
  
      if ( my $proto = prototype $sub ) {
  
          # XXX - Perl's prototype sucks. Use & to make set_prototype
          # ignore the fact that we're passing "private variables"
          &Scalar::Util::set_prototype( $wrapper, $proto );
      }
      return $wrapper;
  }
  
  sub _make_import_sub {
      shift;
      my $exporting_package = shift;
      my $exporter          = shift;
      my $exports_from      = shift;
      my $is_reexport       = shift;
      my $meta_lookup       = shift;
  
      return sub {
  
          # I think we could use Sub::Exporter's collector feature
          # to do this, but that would be rather gross, since that
          # feature isn't really designed to return a value to the
          # caller of the exporter sub.
          #
          # Also, this makes sure we preserve backwards compat for
          # _get_caller, so it always sees the arguments in the
          # expected order.
          my $traits;
          ( $traits, @_ ) = _strip_traits(@_);
  
          my $metaclass;
          ( $metaclass, @_ ) = _strip_metaclass(@_);
          $metaclass
              = Moose::Util::resolve_metaclass_alias( 'Class' => $metaclass )
              if defined $metaclass && length $metaclass;
  
          my $meta_name;
          ( $meta_name, @_ ) = _strip_meta_name(@_);
  
          # Normally we could look at $_[0], but in some weird cases
          # (involving goto &Moose::import), $_[0] ends as something
          # else (like Squirrel).
          my $class = $exporting_package;
  
          $CALLER = _get_caller(@_);
  
          # this works because both pragmas set $^H (see perldoc
          # perlvar) which affects the current compilation -
          # i.e. the file who use'd us - which is why we don't need
          # to do anything special to make it affect that file
          # rather than this one (which is already compiled)
  
          strict->import;
          warnings->import;
  
          my $did_init_meta;
          for my $c ( grep { $_->can('init_meta') } $class, @{$exports_from} ) {
  
              # init_meta can apply a role, which when loaded uses
              # Moose::Exporter, which in turn sets $CALLER, so we need
              # to protect against that.
              local $CALLER = $CALLER;
              $c->init_meta(
                  for_class => $CALLER,
                  metaclass => $metaclass,
                  meta_name => $meta_name,
              );
              $did_init_meta = 1;
          }
  
          {
              # The metaroles will use Moose::Role, which in turn uses
              # Moose::Exporter, which in turn sets $CALLER, so we need
              # to protect against that.
              local $CALLER = $CALLER;
              _apply_metaroles(
                  $CALLER,
                  [$class, @$exports_from],
                  $meta_lookup
              );
          }
  
          if ( $did_init_meta && @{$traits} ) {
  
              # The traits will use Moose::Role, which in turn uses
              # Moose::Exporter, which in turn sets $CALLER, so we need
              # to protect against that.
              local $CALLER = $CALLER;
              _apply_meta_traits( $CALLER, $traits, $meta_lookup );
          }
          elsif ( @{$traits} ) {
              throw_exception( ClassDoesNotHaveInitMeta => class_name => $class,
                                                           traits     => $traits
                             );
          }
  
          my ( undef, @args ) = @_;
          my $extra = shift @args if ref $args[0] eq 'HASH';
  
          $extra ||= {};
          if ( !$extra->{into} ) {
              $extra->{into_level} ||= 0;
              $extra->{into_level}++;
          }
  
          $class->$exporter( $extra, @args );
      };
  }
  
  sub _strip_traits {
      my $idx = first_index { ( $_ || '' ) eq '-traits' } @_;
  
      return ( [], @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
  
      my $traits = $_[ $idx + 1 ];
  
      splice @_, $idx, 2;
  
      $traits = [$traits] unless ref $traits;
  
      return ( $traits, @_ );
  }
  
  sub _strip_metaclass {
      my $idx = first_index { ( $_ || '' ) eq '-metaclass' } @_;
  
      return ( undef, @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
  
      my $metaclass = $_[ $idx + 1 ];
  
      splice @_, $idx, 2;
  
      return ( $metaclass, @_ );
  }
  
  sub _strip_meta_name {
      my $idx = first_index { ( $_ || '' ) eq '-meta_name' } @_;
  
      return ( 'meta', @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
  
      my $meta_name = $_[ $idx + 1 ];
  
      splice @_, $idx, 2;
  
      return ( $meta_name, @_ );
  }
  
  sub _apply_metaroles {
      my ($class, $exports_from, $meta_lookup) = @_;
  
      my $metaroles = _collect_metaroles($exports_from);
      my $base_class_roles = delete $metaroles->{base_class_roles};
  
      my $meta = $meta_lookup->($class);
      # for instance, Moose.pm uses Moose::Util::TypeConstraints
      return unless $meta;
  
      Moose::Util::MetaRole::apply_metaroles(
          for => $meta,
          %$metaroles,
      ) if keys %$metaroles;
  
      Moose::Util::MetaRole::apply_base_class_roles(
          for   => $meta,
          roles => $base_class_roles,
      ) if $meta->isa('Class::MOP::Class')
        && $base_class_roles && @$base_class_roles;
  }
  
  sub _collect_metaroles {
      my ($exports_from) = @_;
  
      my @old_style_role_types = map { "${_}_roles" } qw(
          metaclass
          attribute_metaclass
          method_metaclass
          wrapped_method_metaclass
          instance_metaclass
          constructor_class
          destructor_class
          error_class
      );
  
      my %class_metaroles;
      my %role_metaroles;
      my @base_class_roles;
      my %old_style_roles;
  
      for my $exporter (@$exports_from) {
          my $data = $EXPORT_SPEC{$exporter};
  
          if (exists $data->{class_metaroles}) {
              for my $type (keys %{ $data->{class_metaroles} }) {
                  push @{ $class_metaroles{$type} ||= [] },
                       @{ $data->{class_metaroles}{$type} };
              }
          }
  
          if (exists $data->{role_metaroles}) {
              for my $type (keys %{ $data->{role_metaroles} }) {
                  push @{ $role_metaroles{$type} ||= [] },
                       @{ $data->{role_metaroles}{$type} };
              }
          }
  
          if (exists $data->{base_class_roles}) {
              push @base_class_roles, @{ $data->{base_class_roles} };
          }
  
          for my $type (@old_style_role_types) {
              if (exists $data->{$type}) {
                  push @{ $old_style_roles{$type} ||= [] },
                       @{ $data->{$type} };
              }
          }
      }
  
      return {
          (keys(%class_metaroles)
              ? (class_metaroles  => \%class_metaroles)
              : ()),
          (keys(%role_metaroles)
              ? (role_metaroles   => \%role_metaroles)
              : ()),
          (@base_class_roles
              ? (base_class_roles => \@base_class_roles)
              : ()),
          %old_style_roles,
      };
  }
  
  sub _apply_meta_traits {
      my ( $class, $traits, $meta_lookup ) = @_;
  
      return unless @{$traits};
  
      my $meta = $meta_lookup->($class);
  
      my $type = $meta->isa('Moose::Meta::Role') ? 'Role'
               : $meta->isa('Class::MOP::Class') ? 'Class'
               : confess('Cannot determine metaclass type for '
                             . 'trait application. Meta isa '
                             . ref $meta);
  
      my @resolved_traits = map {
          ref $_
              ? $_
              : Moose::Util::resolve_metatrait_alias( $type => $_ )
      } @$traits;
  
      return unless @resolved_traits;
  
      my %args = ( for => $class );
  
      if ( $meta->isa('Moose::Meta::Role') ) {
          $args{role_metaroles} = { role => \@resolved_traits };
      }
      else {
          $args{class_metaroles} = { class => \@resolved_traits };
      }
  
      Moose::Util::MetaRole::apply_metaroles(%args);
  }
  
  sub _get_caller {
  
      # 1 extra level because it's called by import so there's a layer
      # of indirection
      my $offset = 1;
  
      return
            ( ref $_[1] && defined $_[1]->{into} ) ? $_[1]->{into}
          : ( ref $_[1] && defined $_[1]->{into_level} )
          ? caller( $offset + $_[1]->{into_level} )
          : caller($offset);
  }
  
  sub _make_unimport_sub {
      shift;
      my $exporting_package = shift;
      my $exports           = shift;
      my $export_recorder   = shift;
      my $is_reexport       = shift;
      my $meta_lookup       = shift;
  
      return sub {
          my $caller = scalar caller();
          Moose::Exporter->_remove_keywords(
              $caller,
              [ keys %{$exports} ],
              $export_recorder,
              $is_reexport,
          );
      };
  }
  
  sub _remove_keywords {
      shift;
      my $package          = shift;
      my $keywords         = shift;
      my $recorded_exports = shift;
      my $is_reexport      = shift;
  
      no strict 'refs';
  
      foreach my $name ( @{$keywords} ) {
          if ( defined &{ $package . '::' . $name } ) {
              my $sub = \&{ $package . '::' . $name };
  
              # make sure it is from us
              next unless $recorded_exports->{$sub};
  
              if ( $is_reexport->{$name} ) {
                  no strict 'refs';
                  next
                      unless _export_is_flagged(
                              \*{ join q{::} => $package, $name } );
              }
  
              # and if it is from us, then undef the slot
              delete ${ $package . '::' }{$name};
          }
      }
  }
  
  # maintain this for now for backcompat
  # make sure to return a sub to install in the same circumstances as previously
  # but this functionality now happens at the end of ->import
  sub _make_init_meta {
      shift;
      my $class          = shift;
      my $args           = shift;
      my $meta_lookup    = shift;
  
      my %old_style_roles;
      for my $role (
          map {"${_}_roles"}
          qw(
          metaclass
          attribute_metaclass
          method_metaclass
          wrapped_method_metaclass
          instance_metaclass
          constructor_class
          destructor_class
          error_class
          )
          ) {
          $old_style_roles{$role} = $args->{$role}
              if exists $args->{$role};
      }
  
      my %base_class_roles;
      %base_class_roles = ( roles => $args->{base_class_roles} )
          if exists $args->{base_class_roles};
  
      my %new_style_roles = map { $_ => $args->{$_} }
          grep { exists $args->{$_} } qw( class_metaroles role_metaroles );
  
      return unless %new_style_roles || %old_style_roles || %base_class_roles;
  
      return sub {
          shift;
          my %opts = @_;
          $meta_lookup->($opts{for_class});
      };
  }
  
  sub import {
      strict->import;
      warnings->import;
  }
  
  1;
  
  # ABSTRACT: make an import() and unimport() just like Moose.pm
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Exporter - make an import() and unimport() just like Moose.pm
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package MyApp::Moose;
  
    use Moose ();
    use Moose::Exporter;
    use Some::Random ();
  
    Moose::Exporter->setup_import_methods(
        with_meta => [ 'has_rw', 'sugar2' ],
        as_is     => [ 'sugar3', \&Some::Random::thing, 'Some::Random::other_thing' ],
        also      => 'Moose',
    );
  
    sub has_rw {
        my ( $meta, $name, %options ) = @_;
        $meta->add_attribute(
            $name,
            is => 'rw',
            %options,
        );
    }
  
    # then later ...
    package MyApp::User;
  
    use MyApp::Moose;
  
    has 'name' => ( is => 'ro' );
    has_rw 'size';
    thing;
    other_thing;
  
    no MyApp::Moose;
  
  =head1 DESCRIPTION
  
  This module encapsulates the exporting of sugar functions in a
  C<Moose.pm>-like manner. It does this by building custom C<import> and
  C<unimport> methods for your module, based on a spec you provide.
  
  It also lets you "stack" Moose-alike modules so you can export Moose's sugar
  as well as your own, along with sugar from any random C<MooseX> module, as
  long as they all use C<Moose::Exporter>. This feature exists to let you bundle
  a set of MooseX modules into a policy module that developers can use directly
  instead of using Moose itself.
  
  To simplify writing exporter modules, C<Moose::Exporter> also imports
  C<strict> and C<warnings> into your exporter module, as well as into
  modules that use it.
  
  =head1 METHODS
  
  This module provides two public methods:
  
  =head2 Moose::Exporter->setup_import_methods(...)
  
  When you call this method, C<Moose::Exporter> builds custom C<import> and
  C<unimport> methods for your module. The C<import> method
  will export the functions you specify, and can also re-export functions
  exported by some other module (like C<Moose.pm>). If you pass any parameters
  for L<Moose::Util::MetaRole>, the C<import> method will also call
  L<Moose::Util::MetaRole::apply_metaroles|Moose::Util::MetaRole/apply_metaroles> and
  L<Moose::Util::MetaRole::apply_base_class_roles|Moose::Util::MetaRole/apply_base_class_roles> as needed, after making
  sure the metaclass is initialized.
  
  The C<unimport> method cleans the caller's namespace of all the exported
  functions. This includes any functions you re-export from other
  packages. However, if the consumer of your package also imports those
  functions from the original package, they will I<not> be cleaned.
  
  Note that if any of these methods already exist, they will not be
  overridden, you will have to use C<build_import_methods> to get the
  coderef that would be installed.
  
  This method accepts the following parameters:
  
  =over 4
  
  =item * with_meta => [ ... ]
  
  This list of function I<names only> will be wrapped and then exported. The
  wrapper will pass the metaclass object for the caller as its first argument.
  
  Many sugar functions will need to use this metaclass object to do something to
  the calling package.
  
  =item * as_is => [ ... ]
  
  This list of function names or sub references will be exported as-is. You can
  identify a subroutine by reference, which is handy to re-export some other
  module's functions directly by reference (C<\&Some::Package::function>).
  
  If you do export some other package's function, this function will never be
  removed by the C<unimport> method. The reason for this is we cannot know if
  the caller I<also> explicitly imported the sub themselves, and therefore wants
  to keep it.
  
  =item * trait_aliases => [ ... ]
  
  This is a list of package names which should have shortened aliases exported,
  similar to the functionality of L<aliased>. Each element in the list can be
  either a package name, in which case the export will be named as the last
  namespace component of the package, or an arrayref, whose first element is the
  package to alias to, and second element is the alias to export.
  
  =item * also => $name or \@names
  
  This is a list of modules which contain functions that the caller
  wants to export. These modules must also use C<Moose::Exporter>. The
  most common use case will be to export the functions from C<Moose.pm>.
  Functions specified by C<with_meta> or C<as_is> take precedence over
  functions exported by modules specified by C<also>, so that a module
  can selectively override functions exported by another module.
  
  C<Moose::Exporter> also makes sure all these functions get removed
  when C<unimport> is called.
  
  =item * meta_lookup => sub { ... }
  
  This is a function which will be called to provide the metaclass
  to be operated upon by the exporter. This is an advanced feature
  intended for use by package generator modules in the vein of
  L<MooseX::Role::Parameterized> in order to simplify reusing sugar
  from other modules that use C<Moose::Exporter>. This function is
  used, for example, to select the metaclass to bind to functions
  that are exported using the C<with_meta> option.
  
  This function will receive one parameter: the class name into which
  the sugar is being exported. The default implementation is:
  
      sub { Class::MOP::class_of(shift) }
  
  Accordingly, this function is expected to return a metaclass.
  
  =back
  
  You can also provide parameters for L<Moose::Util::MetaRole::apply_metaroles|Moose::Util::MetaRole/apply_metaroles>
  and L<Moose::Util::MetaRole::apply_base_class_roles|Moose::Util::MetaRole/apply_base_class_roles>. Specifically, valid parameters
  are "class_metaroles", "role_metaroles", and "base_class_roles".
  
  =head2 Moose::Exporter->build_import_methods(...)
  
  Returns three code refs, one for C<import>, one for C<unimport> and one for
  C<init_meta>.
  
  Accepts the additional C<install> option, which accepts an arrayref of method
  names to install into your exporting package. The valid options are C<import>
  and C<unimport>. Calling C<setup_import_methods> is equivalent
  to calling C<build_import_methods> with C<< install => [qw(import unimport)] >>
  except that it doesn't also return the methods.
  
  The C<import> method is built using L<Sub::Exporter>. This means that it can
  take a hashref of the form C<< { into => $package } >> to specify the package
  it operates on.
  
  Used by C<setup_import_methods>.
  
  =head1 IMPORTING AND init_meta
  
  If you want to set an alternative base object class or metaclass class, see
  above for details on how this module can call L<Moose::Util::MetaRole> for
  you.
  
  If you want to do something that is not supported by this module, simply
  define an C<init_meta> method in your class. The C<import> method that
  C<Moose::Exporter> generates for you will call this method (if it exists). It
  will always pass the caller to this method via the C<for_class> parameter.
  
  Most of the time, your C<init_meta> method will probably just call C<<
  Moose->init_meta >> to do the real work:
  
    sub init_meta {
        shift; # our class name
        return Moose->init_meta( @_, metaclass => 'My::Metaclass' );
    }
  
  =head1 METACLASS TRAITS
  
  The C<import> method generated by C<Moose::Exporter> will allow the
  user of your module to specify metaclass traits in a C<-traits>
  parameter passed as part of the import:
  
    use Moose -traits => 'My::Meta::Trait';
  
    use Moose -traits => [ 'My::Meta::Trait', 'My::Other::Trait' ];
  
  These traits will be applied to the caller's metaclass
  instance. Providing traits for an exporting class that does not create
  a metaclass for the caller is an error.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_EXPORTER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE';
  use strict;
  use warnings;
  package Moose::Meta::Attribute;
  our $VERSION = '2.1603';
  
  use B ();
  use Scalar::Util 'blessed';
  use List::Util 1.33 'any';
  use Try::Tiny;
  use overload     ();
  
  use Moose::Deprecated;
  use Moose::Meta::Method::Accessor;
  use Moose::Meta::Method::Delegation;
  use Moose::Util 'throw_exception';
  use Moose::Util::TypeConstraints ();
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Attribute', 'Moose::Meta::Mixin::AttributeCore';
  
  use Carp 'confess';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  __PACKAGE__->meta->add_attribute('traits' => (
      reader    => 'applied_traits',
      predicate => 'has_applied_traits',
      Class::MOP::_definition_context(),
  ));
  
  # we need to have a ->does method in here to
  # more easily support traits, and the introspection
  # of those traits. We extend the does check to look
  # for metatrait aliases.
  sub does {
      my ($self, $role_name) = @_;
      my $name = try {
          Moose::Util::resolve_metatrait_alias(Attribute => $role_name)
      };
      return 0 if !defined($name); # failed to load class
      return $self->Moose::Object::does($name);
  }
  
  sub _inline_throw_exception {
      my ( $self, $exception_type, $throw_args ) = @_;
      return 'die Module::Runtime::use_module("Moose::Exception::' . $exception_type . '")->new(' . ($throw_args || '') . ')';
  }
  
  sub new {
      my ($class, $name, %options) = @_;
      $class->_process_options($name, \%options) unless $options{__hack_no_process_options}; # used from clone()... YECHKKK FIXME ICKY YUCK GROSS
  
      delete $options{__hack_no_process_options};
  
      my %attrs =
          ( map { $_ => 1 }
            grep { defined }
            map { $_->init_arg() }
            $class->meta()->get_all_attributes()
          );
  
      my @bad = sort grep { ! $attrs{$_} }  keys %options;
  
      if (@bad)
      {
          my $s = @bad > 1 ? 's' : '';
          my $list = join "', '", @bad;
  
          my $package = $options{definition_context}{package};
          my $context = $options{definition_context}{context}
                     || 'attribute constructor';
          my $type = $options{definition_context}{type} || 'class';
  
          my $location = '';
          if (defined($package)) {
              $location = " in ";
              $location .= "$type " if $type;
              $location .= $package;
          }
  
          Carp::cluck "Found unknown argument$s '$list' in the $context for '$name'$location";
      }
  
      return $class->SUPER::new($name, %options);
  }
  
  sub interpolate_class_and_new {
      my $class = shift;
      my $name  = shift;
  
      throw_exception( MustPassEvenNumberOfAttributeOptions => attribute_name => $name,
                                                               options        => \@_
                     )
          if @_ % 2 == 1;
  
      my %args = @_;
  
      my ( $new_class, @traits ) = $class->interpolate_class(\%args);
      $new_class->new($name, %args, ( scalar(@traits) ? ( traits => \@traits ) : () ) );
  }
  
  sub interpolate_class {
      my ($class, $options) = @_;
  
      $class = ref($class) || $class;
  
      if ( my $metaclass_name = delete $options->{metaclass} ) {
          my $new_class = Moose::Util::resolve_metaclass_alias( Attribute => $metaclass_name );
  
          if ( $class ne $new_class ) {
              if ( $new_class->can("interpolate_class") ) {
                  return $new_class->interpolate_class($options);
              } else {
                  $class = $new_class;
              }
          }
      }
  
      my @traits;
  
      if (my $traits = $options->{traits}) {
          my $i = 0;
          my $has_foreign_options = 0;
  
          while ($i < @$traits) {
              my $trait = $traits->[$i++];
              next if ref($trait); # options to a trait we discarded
  
              $trait = Moose::Util::resolve_metatrait_alias(Attribute => $trait)
                    || $trait;
  
              next if $class->does($trait);
  
              push @traits, $trait;
  
              # are there options?
              if ($traits->[$i] && ref($traits->[$i])) {
                  $has_foreign_options = 1
                      if any { $_ ne '-alias' && $_ ne '-excludes' } keys %{ $traits->[$i] };
  
                  push @traits, $traits->[$i++];
              }
          }
  
          if (@traits) {
              my %options = (
                  superclasses => [ $class ],
                  roles        => [ @traits ],
              );
  
              if ($has_foreign_options) {
                  $options{weaken} = 0;
              }
              else {
                  $options{cache} = 1;
              }
  
              my $anon_class = Moose::Meta::Class->create_anon_class(%options);
              $class = $anon_class->name;
          }
      }
  
      return ( wantarray ? ( $class, @traits ) : $class );
  }
  
  # ...
  
  # method-generating options shouldn't be overridden
  sub illegal_options_for_inheritance {
      qw(reader writer accessor clearer predicate)
  }
  
  # NOTE/TODO
  # This method *must* be able to handle
  # Class::MOP::Attribute instances as
  # well. Yes, I know that is wrong, but
  # apparently we didn't realize it was
  # doing that and now we have some code
  # which is dependent on it. The real
  # solution of course is to push this
  # feature back up into Class::MOP::Attribute
  # but I not right now, I am too lazy.
  # However if you are reading this and
  # looking for something to do,.. please
  # be my guest.
  # - stevan
  sub clone_and_inherit_options {
      my ($self, %options) = @_;
  
      # NOTE:
      # we may want to extends a Class::MOP::Attribute
      # in which case we need to be able to use the
      # core set of legal options that have always
      # been here. But we allows Moose::Meta::Attribute
      # instances to changes them.
      # - SL
      my @illegal_options = $self->can('illegal_options_for_inheritance')
          ? $self->illegal_options_for_inheritance
          : ();
  
      my @found_illegal_options = grep { exists $options{$_} && exists $self->{$_} ? $_ : undef } @illegal_options;
      (scalar @found_illegal_options == 0)
          || throw_exception( IllegalInheritedOptions => illegal_options => \@found_illegal_options,
                                                         params          => \%options
                            );
  
      $self->_process_isa_option( $self->name, \%options );
      $self->_process_does_option( $self->name, \%options );
  
      # NOTE:
      # this doesn't apply to Class::MOP::Attributes,
      # so we can ignore it for them.
      # - SL
      if ($self->can('interpolate_class')) {
          ( $options{metaclass}, my @traits ) = $self->interpolate_class(\%options);
  
          my %seen;
          my @all_traits = grep { $seen{$_}++ } @{ $self->applied_traits || [] }, @traits;
          $options{traits} = \@all_traits if @all_traits;
      }
  
      # This method can be called on a CMOP::Attribute object, so we need to
      # make sure we can call this method.
      $self->_process_lazy_build_option( $self->name, \%options )
          if $self->can('_process_lazy_build_option');
  
      $self->clone(%options);
  }
  
  sub clone {
      my ( $self, %params ) = @_;
  
      my $class = delete $params{metaclass} || ref $self;
  
      my ( @init, @non_init );
  
      foreach my $attr ( grep { $_->has_value($self) } Class::MOP::class_of($self)->get_all_attributes ) {
          push @{ $attr->has_init_arg ? \@init : \@non_init }, $attr;
      }
  
      my %new_params = ( ( map { $_->init_arg => $_->get_value($self) } @init ), %params );
  
      my $name = delete $new_params{name};
  
      my $clone = $class->new($name, %new_params, __hack_no_process_options => 1 );
  
      foreach my $attr ( @non_init ) {
          $attr->set_value($clone, $attr->get_value($self));
      }
  
      return $clone;
  }
  
  sub _process_options {
      my ( $class, $name, $options ) = @_;
  
      $class->_process_is_option( $name, $options );
      $class->_process_isa_option( $name, $options );
      $class->_process_does_option( $name, $options );
      $class->_process_coerce_option( $name, $options );
      $class->_process_trigger_option( $name, $options );
      $class->_process_auto_deref_option( $name, $options );
      $class->_process_lazy_build_option( $name, $options );
      $class->_process_lazy_option( $name, $options );
      $class->_process_required_option( $name, $options );
  }
  
  sub _process_is_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{is};
  
      ### -------------------------
      ## is => ro, writer => _foo    # turns into (reader => foo, writer => _foo) as before
      ## is => rw, writer => _foo    # turns into (reader => foo, writer => _foo)
      ## is => rw, accessor => _foo  # turns into (accessor => _foo)
      ## is => ro, accessor => _foo  # error, accesor is rw
      ### -------------------------
  
      if ( $options->{is} eq 'ro' ) {
          throw_exception("AccessorMustReadWrite" => attribute_name => $name,
                                                     params         => $options,
                         )
              if exists $options->{accessor};
          $options->{reader} ||= $name;
      }
      elsif ( $options->{is} eq 'rw' ) {
          if ( $options->{writer} ) {
              $options->{reader} ||= $name;
          }
          else {
              $options->{accessor} ||= $name;
          }
      }
      elsif ( $options->{is} eq 'bare' ) {
          return;
          # do nothing, but don't complain (later) about missing methods
      }
      else {
          throw_exception( InvalidValueForIs => attribute_name => $name,
                                                params         => $options,
                         );
      }
  }
  
  sub _process_isa_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{isa};
  
      if ( exists $options->{does} ) {
          if ( try { $options->{isa}->can('does') } ) {
              ( $options->{isa}->does( $options->{does} ) )
                  || throw_exception( IsaDoesNotDoTheRole => attribute_name => $name,
                                                             params         => $options,
                                    );
          }
          else {
              throw_exception( IsaLacksDoesMethod => attribute_name => $name,
                                                     params         => $options,
                             );
          }
      }
  
      # allow for anon-subtypes here ...
      #
      # Checking for Specio explicitly is completely revolting. At some point
      # this needs to be refactored so that Moose core defines a standard type
      # API that all types must implement. Unfortunately, the current core API
      # is _not_ the right API, so we probably need to A) come up with the new
      # API (Specio is a good start); B) refactor the core types to implement
      # that API; C) do duck type checking on type objects.
      if ( blessed( $options->{isa} )
          && $options->{isa}->isa('Moose::Meta::TypeConstraint') ) {
          $options->{type_constraint} = $options->{isa};
      }
      elsif (
          blessed( $options->{isa} )
          && $options->{isa}->can('does')
          && $options->{isa}->does('Specio::Constraint::Role::Interface')
          ) {
          $options->{type_constraint} = $options->{isa};
      }
      else {
          $options->{type_constraint}
              = Moose::Util::TypeConstraints::find_or_create_isa_type_constraint(
              $options->{isa},
              { package_defined_in => $options->{definition_context}->{package} }
          );
      }
  }
  
  sub _process_does_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{does} && ! exists $options->{isa};
  
      # allow for anon-subtypes here ...
      if ( blessed( $options->{does} )
          && $options->{does}->isa('Moose::Meta::TypeConstraint') ) {
          $options->{type_constraint} = $options->{does};
      }
      else {
          $options->{type_constraint}
              = Moose::Util::TypeConstraints::find_or_create_does_type_constraint(
              $options->{does},
              { package_defined_in => $options->{definition_context}->{package} }
          );
      }
  }
  
  sub _process_coerce_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{coerce};
  
      ( exists $options->{type_constraint} )
          || throw_exception( CoercionNeedsTypeConstraint => attribute_name => $name,
                                                             params         => $options,
                            );
  
      throw_exception( CannotCoerceAWeakRef => attribute_name => $name,
                                               params         => $options,
                     )
          if $options->{weak_ref};
  
      unless ( $options->{type_constraint}->has_coercion ) {
          my $type = $options->{type_constraint}->name;
  
          throw_exception( CannotCoerceAttributeWhichHasNoCoercion => attribute_name => $name,
                                                                      type_name      => $type,
                                                                      params         => $options
                         );
      }
  }
  
  sub _process_trigger_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{trigger};
  
      ( 'CODE' eq ref $options->{trigger} )
          || throw_exception( TriggerMustBeACodeRef => attribute_name => $name,
                                                       params         => $options,
                            );
  }
  
  sub _process_auto_deref_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{auto_deref};
  
      ( exists $options->{type_constraint} )
          || throw_exception( CannotAutoDerefWithoutIsa => attribute_name => $name,
                                                           params         => $options,
                            );
  
      ( $options->{type_constraint}->is_a_type_of('ArrayRef')
        || $options->{type_constraint}->is_a_type_of('HashRef') )
          || throw_exception( AutoDeRefNeedsArrayRefOrHashRef => attribute_name => $name,
                                                                 params         => $options,
                            );
  }
  
  sub _process_lazy_build_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{lazy_build};
  
      throw_exception( CannotUseLazyBuildAndDefaultSimultaneously => attribute_name => $name,
                                                                     params         => $options,
                     )
          if exists $options->{default};
  
      $options->{lazy} = 1;
      $options->{builder} ||= "_build_${name}";
  
      if ( $name =~ /^_/ ) {
          $options->{clearer}   ||= "_clear${name}";
          $options->{predicate} ||= "_has${name}";
      }
      else {
          $options->{clearer}   ||= "clear_${name}";
          $options->{predicate} ||= "has_${name}";
      }
  }
  
  sub _process_lazy_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{lazy};
  
      ( exists $options->{default} || defined $options->{builder} )
          || throw_exception( LazyAttributeNeedsADefault => params         => $options,
                                                            attribute_name => $name,
                            );
  }
  
  sub _process_required_option {
      my ( $class, $name, $options ) = @_;
  
      if (
          $options->{required}
          && !(
              ( !exists $options->{init_arg} || defined $options->{init_arg} )
              || exists $options->{default}
              || defined $options->{builder}
          )
          ) {
          throw_exception( RequiredAttributeNeedsADefault => params         => $options,
                                                             attribute_name => $name,
                         );
      }
  }
  
  sub initialize_instance_slot {
      my ($self, $meta_instance, $instance, $params) = @_;
      my $init_arg = $self->init_arg();
      # try to fetch the init arg from the %params ...
  
      my $val;
      my $value_is_set;
      if ( defined($init_arg) and exists $params->{$init_arg}) {
          $val = $params->{$init_arg};
          $value_is_set = 1;
      }
      else {
          # skip it if it's lazy
          return if $self->is_lazy;
          # and die if it's required and doesn't have a default value
          my $class_name = blessed( $instance );
          throw_exception(AttributeIsRequired => attribute_name => $self->name,
                                                 class_name     => $class_name,
                                                 params         => $params,
                         )
              if $self->is_required && !$self->has_default && !$self->has_builder;
  
          # if nothing was in the %params, we can use the
          # attribute's default value (if it has one)
          if ($self->has_default) {
              $val = $self->default($instance);
              $value_is_set = 1;
          }
          elsif ($self->has_builder) {
              $val = $self->_call_builder($instance);
              $value_is_set = 1;
          }
      }
  
      return unless $value_is_set;
  
      $val = $self->_coerce_and_verify( $val, $instance );
  
      $self->set_initial_value($instance, $val);
  
      if ( ref $val && $self->is_weak_ref ) {
          $self->_weaken_value($instance);
      }
  }
  
  sub _call_builder {
      my ( $self, $instance ) = @_;
  
      my $builder = $self->builder();
  
      return $instance->$builder()
          if $instance->can( $self->builder );
  
      throw_exception( BuilderDoesNotExist => instance  => $instance,
                                              attribute => $self,
                     );
  }
  
  ## Slot management
  
  sub _make_initializer_writer_callback {
      my $self = shift;
      my ($meta_instance, $instance, $slot_name) = @_;
      my $old_callback = $self->SUPER::_make_initializer_writer_callback(@_);
      return sub {
          $old_callback->($self->_coerce_and_verify($_[0], $instance));
      };
  }
  
  sub set_value {
      my ($self, $instance, @args) = @_;
      my $value = $args[0];
  
      my $attr_name = quotemeta($self->name);
  
      my $class_name = blessed( $instance );
      if ($self->is_required and not @args) {
          throw_exception( AttributeIsRequired => attribute_name => $self->name,
                                                  class_name     => $class_name,
                         );
      }
  
      $value = $self->_coerce_and_verify( $value, $instance );
  
      my @old;
      if ( $self->has_trigger && $self->has_value($instance) ) {
          @old = $self->get_value($instance, 'for trigger');
      }
  
      $self->SUPER::set_value($instance, $value);
  
      if ( ref $value && $self->is_weak_ref ) {
          $self->_weaken_value($instance);
      }
  
      if ($self->has_trigger) {
          $self->trigger->($instance, $value, @old);
      }
  }
  
  sub _inline_set_value {
      my $self = shift;
      my ($instance, $value, $tc, $coercion, $message, $for_constructor) = @_;
  
      my $old     = '@old';
      my $copy    = '$val';
      $tc       ||= '$type_constraint';
      $coercion ||= '$type_coercion';
      $message  ||= '$type_message';
  
      my @code;
      if ($self->_writer_value_needs_copy) {
          push @code, $self->_inline_copy_value($value, $copy);
          $value = $copy;
      }
  
      # constructors already handle required checks
      push @code, $self->_inline_check_required
          unless $for_constructor;
  
      push @code, $self->_inline_tc_code($value, $tc, $coercion, $message);
  
      # constructors do triggers all at once at the end
      push @code, $self->_inline_get_old_value_for_trigger($instance, $old)
          unless $for_constructor;
  
      push @code, (
          $self->SUPER::_inline_set_value($instance, $value),
          $self->_inline_weaken_value($instance, $value),
      );
  
      # constructors do triggers all at once at the end
      push @code, $self->_inline_trigger($instance, $value, $old)
          unless $for_constructor;
  
      return @code;
  }
  
  sub _writer_value_needs_copy {
      my $self = shift;
      return $self->should_coerce;
  }
  
  sub _inline_copy_value {
      my $self = shift;
      my ($value, $copy) = @_;
  
      return 'my ' . $copy . ' = ' . $value . ';'
  }
  
  sub _inline_check_required {
      my $self = shift;
  
      return unless $self->is_required;
  
      my $attr_name = quotemeta($self->name);
  
      return (
          'if (@_ < 2) {',
              $self->_inline_throw_exception( AttributeIsRequired =>
                                              'attribute_name      => "'.$attr_name.'",'.
                                              'class_name          => $class_name'
              ) . ';',
          '}',
      );
  }
  
  sub _inline_tc_code {
      my $self = shift;
      my ($value, $tc, $coercion, $message, $is_lazy) = @_;
      return (
          $self->_inline_check_coercion(
              $value, $tc, $coercion, $is_lazy,
          ),
          $self->_inline_check_constraint(
              $value, $tc, $message, $is_lazy,
          ),
      );
  }
  
  sub _inline_check_coercion {
      my $self = shift;
      my ($value, $tc, $coercion) = @_;
  
      return unless $self->should_coerce && $self->type_constraint->has_coercion;
  
      if ( $self->type_constraint->can_be_inlined ) {
          return (
              'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
                  $value . ' = ' . $coercion . '->(' . $value . ');',
              '}',
          );
      }
      else {
          return (
              'if (!' . $tc . '->(' . $value . ')) {',
                  $value . ' = ' . $coercion . '->(' . $value . ');',
              '}',
          );
      }
  }
  
  sub _inline_check_constraint {
      my $self = shift;
      my ($value, $tc, $message) = @_;
  
      return unless $self->has_type_constraint;
  
      my $attr_name = quotemeta($self->name);
  
      if ( $self->type_constraint->can_be_inlined ) {
          return (
              'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
                  'my $msg = do { local $_ = ' . $value . '; '
                  . $message . '->(' . $value . ');'
                  . '};'.
                  $self->_inline_throw_exception( ValidationFailedForInlineTypeConstraint =>
                                                  'type_constraint_message => $msg , '.
                                                  'class_name              => $class_name, '.
                                                  'attribute_name          => "'.$attr_name.'",'.
                                                  'value                   => '.$value
                  ).';',
              '}',
          );
      }
      else {
          return (
              'if (!' . $tc . '->(' . $value . ')) {',
                  'my $msg = do { local $_ = ' . $value . '; '
                  . $message . '->(' . $value . ');'
                  . '};'.
                  $self->_inline_throw_exception( ValidationFailedForInlineTypeConstraint =>
                                                  'type_constraint_message => $msg , '.
                                                  'class_name              => $class_name, '.
                                                  'attribute_name          => "'.$attr_name.'",'.
                                                  'value                   => '.$value
                  ).';',
              '}',
          );
      }
  }
  
  sub _inline_get_old_value_for_trigger {
      my $self = shift;
      my ($instance, $old) = @_;
  
      return unless $self->has_trigger;
  
      return (
          'my ' . $old . ' = ' . $self->_inline_instance_has($instance),
              '? ' . $self->_inline_instance_get($instance),
              ': ();',
      );
  }
  
  sub _inline_weaken_value {
      my $self = shift;
      my ($instance, $value) = @_;
  
      return unless $self->is_weak_ref;
  
      my $mi = $self->associated_class->get_meta_instance;
      return (
          $mi->inline_weaken_slot_value($instance, $self->name),
              'if ref ' . $value . ';',
      );
  }
  
  sub _inline_trigger {
      my $self = shift;
      my ($instance, $value, $old) = @_;
  
      return unless $self->has_trigger;
  
      return '$trigger->(' . $instance . ', ' . $value . ', ' . $old . ');';
  }
  
  sub _eval_environment {
      my $self = shift;
  
      my $env = { };
  
      $env->{'$trigger'} = \($self->trigger)
          if $self->has_trigger;
      $env->{'$attr_default'} = \($self->default)
          if $self->has_default;
  
      if ($self->has_type_constraint) {
          my $tc_obj = $self->type_constraint;
  
          $env->{'$type_constraint'} = \(
              $tc_obj->_compiled_type_constraint
          ) unless $tc_obj->can_be_inlined;
          # these two could probably get inlined versions too
          $env->{'$type_coercion'} = \(
              $tc_obj->coercion->_compiled_type_coercion
          ) if $tc_obj->has_coercion;
          $env->{'$type_message'} = \(
              $tc_obj->has_message ? $tc_obj->message : $tc_obj->_default_message
          );
  
          $env = { %$env, %{ $tc_obj->inline_environment } };
      }
  
      $env->{'$class_name'} = \($self->associated_class->name);
  
      # XXX ugh, fix these
      $env->{'$attr'} = \$self
          if $self->has_initializer && $self->is_lazy;
      # pretty sure this is only going to be closed over if you use a custom
      # error class at this point, but we should still get rid of this
      # at some point
      $env->{'$meta'} = \($self->associated_class);
  
      return $env;
  }
  
  sub _weaken_value {
      my ( $self, $instance ) = @_;
  
      my $meta_instance = Class::MOP::Class->initialize( blessed($instance) )
          ->get_meta_instance;
  
      $meta_instance->weaken_slot_value( $instance, $self->name );
  }
  
  sub get_value {
      my ($self, $instance, $for_trigger) = @_;
  
      if ($self->is_lazy) {
          unless ($self->has_value($instance)) {
              my $value;
              if ($self->has_default) {
                  $value = $self->default($instance);
              } elsif ( $self->has_builder ) {
                  $value = $self->_call_builder($instance);
              }
  
              $value = $self->_coerce_and_verify( $value, $instance );
  
              $self->set_initial_value($instance, $value);
  
              if ( ref $value && $self->is_weak_ref ) {
                  $self->_weaken_value($instance);
              }
          }
      }
  
      if ( $self->should_auto_deref && ! $for_trigger ) {
  
          my $type_constraint = $self->type_constraint;
  
          if ($type_constraint->is_a_type_of('ArrayRef')) {
              my $rv = $self->SUPER::get_value($instance);
              return unless defined $rv;
              return wantarray ? @{ $rv } : $rv;
          }
          elsif ($type_constraint->is_a_type_of('HashRef')) {
              my $rv = $self->SUPER::get_value($instance);
              return unless defined $rv;
              return wantarray ? %{ $rv } : $rv;
          }
          else {
              throw_exception( CannotAutoDereferenceTypeConstraint => type_name => $type_constraint->name,
                                                                      instance  => $instance,
                                                                      attribute => $self
                             );
          }
  
      }
      else {
  
          return $self->SUPER::get_value($instance);
      }
  }
  
  sub _inline_get_value {
      my $self = shift;
      my ($instance, $tc, $coercion, $message) = @_;
  
      my $slot_access = $self->_inline_instance_get($instance);
      $tc           ||= '$type_constraint';
      $coercion     ||= '$type_coercion';
      $message      ||= '$type_message';
  
      return (
          $self->_inline_check_lazy($instance, $tc, $coercion, $message),
          $self->_inline_return_auto_deref($slot_access),
      );
  }
  
  sub _inline_check_lazy {
      my $self = shift;
      my ($instance, $tc, $coercion, $message) = @_;
  
      return unless $self->is_lazy;
  
      my $slot_exists = $self->_inline_instance_has($instance);
  
      return (
          'if (!' . $slot_exists . ') {',
              $self->_inline_init_from_default($instance, '$default', $tc, $coercion, $message, 'lazy'),
          '}',
      );
  }
  
  sub _inline_init_from_default {
      my $self = shift;
      my ($instance, $default, $tc, $coercion, $message, $for_lazy) = @_;
  
      if (!($self->has_default || $self->has_builder)) {
          throw_exception( LazyAttributeNeedsADefault => attribute => $self );
      }
  
      return (
          $self->_inline_generate_default($instance, $default),
          # intentionally not using _inline_tc_code, since that can be overridden
          # to do things like possibly only do member tc checks, which isn't
          # appropriate for checking the result of a default
          $self->has_type_constraint
              ? ($self->_inline_check_coercion($default, $tc, $coercion, $for_lazy),
                 $self->_inline_check_constraint($default, $tc, $message, $for_lazy))
              : (),
          $self->_inline_init_slot($instance, $default),
          $self->_inline_weaken_value($instance, $default),
      );
  }
  
  sub _inline_generate_default {
      my $self = shift;
      my ($instance, $default) = @_;
  
      if ($self->has_default) {
          my $source = 'my ' . $default . ' = $attr_default';
          $source .= '->(' . $instance . ')'
              if $self->is_default_a_coderef;
          return $source . ';';
      }
      elsif ($self->has_builder) {
          my $builder = B::perlstring($self->builder);
          my $builder_str = quotemeta($self->builder);
          my $attr_name_str = quotemeta($self->name);
          return (
              'my ' . $default . ';',
              'if (my $builder = ' . $instance . '->can(' . $builder . ')) {',
                  $default . ' = ' . $instance . '->$builder;',
              '}',
              'else {',
                  'my $class = ref(' . $instance . ') || ' . $instance . ';',
                  $self->_inline_throw_exception(
                      BuilderMethodNotSupportedForInlineAttribute =>
                      'class_name     => $class,'.
                      'attribute_name => "'.$attr_name_str.'",'.
                      'instance       => '.$instance.','.
                      'builder        => "'.$builder_str.'"'
                  ) . ';',
              '}',
          );
      }
      else {
          confess(
              "Can't generate a default for " . $self->name
            . " since no default or builder was specified"
          );
      }
  }
  
  sub _inline_init_slot {
      my $self = shift;
      my ($inv, $value) = @_;
  
      if ($self->has_initializer) {
          return '$attr->set_initial_value(' . $inv . ', ' . $value . ');';
      }
      else {
          return $self->_inline_instance_set($inv, $value) . ';';
      }
  }
  
  sub _inline_return_auto_deref {
      my $self = shift;
  
      return 'return ' . $self->_auto_deref(@_) . ';';
  }
  
  sub _auto_deref {
      my $self = shift;
      my ($ref_value) = @_;
  
      return $ref_value unless $self->should_auto_deref;
  
      my $type_constraint = $self->type_constraint;
  
      my $sigil;
      if ($type_constraint->is_a_type_of('ArrayRef')) {
          $sigil = '@';
      }
      elsif ($type_constraint->is_a_type_of('HashRef')) {
          $sigil = '%';
      }
      else {
          confess(
              'Can not auto de-reference the type constraint \''
            . $type_constraint->name
            . '\''
          );
      }
  
      return 'wantarray '
               . '? ' . $sigil . '{ (' . $ref_value . ') || return } '
               . ': (' . $ref_value . ')';
  }
  
  ## installing accessors
  
  sub accessor_metaclass { 'Moose::Meta::Method::Accessor' }
  
  sub install_accessors {
      my $self = shift;
      $self->SUPER::install_accessors(@_);
      $self->install_delegation if $self->has_handles;
      return;
  }
  
  sub _check_associated_methods {
      my $self = shift;
      unless (
          @{ $self->associated_methods }
          || ($self->_is_metadata || '') eq 'bare'
      ) {
          Carp::cluck(
              'Attribute (' . $self->name . ') of class '
              . $self->associated_class->name
              . ' has no associated methods'
              . ' (did you mean to provide an "is" argument?)'
              . "\n"
          )
      }
  }
  
  sub _process_accessors {
      my $self = shift;
      my ($type, $accessor, $generate_as_inline_methods) = @_;
  
      $accessor = ( keys %$accessor )[0] if ( ref($accessor) || '' ) eq 'HASH';
      my $method = $self->associated_class->get_method($accessor);
  
      if (   $method
          && $method->isa('Class::MOP::Method::Accessor')
          && $method->associated_attribute->name ne $self->name ) {
  
          my $other_attr_name = $method->associated_attribute->name;
          my $name            = $self->name;
  
          Carp::cluck(
              "You are overwriting an accessor ($accessor) for the $other_attr_name attribute"
                  . " with a new accessor method for the $name attribute" );
      }
  
      if (
             $method
          && !$method->is_stub
          && !$method->isa('Class::MOP::Method::Accessor')
          && (  !$self->definition_context
              || $method->package_name eq $self->definition_context->{package} )
          ) {
  
          Carp::cluck(
              "You are overwriting a locally defined method ($accessor) with "
                  . "an accessor" );
      }
  
      if (  !$self->associated_class->has_method($accessor)
          && $self->associated_class->has_package_symbol( '&' . $accessor ) ) {
  
          Carp::cluck(
              "You are overwriting a locally defined function ($accessor) with "
                  . "an accessor" );
      }
  
      $self->SUPER::_process_accessors(@_);
  }
  
  sub remove_accessors {
      my $self = shift;
      $self->SUPER::remove_accessors(@_);
      $self->remove_delegation if $self->has_handles;
      return;
  }
  
  sub install_delegation {
      my $self = shift;
  
      # NOTE:
      # Here we canonicalize the 'handles' option
      # this will sort out any details and always
      # return an hash of methods which we want
      # to delagate to, see that method for details
      my %handles = $self->_canonicalize_handles;
  
      # install the delegation ...
      my $associated_class = $self->associated_class;
      my $class_name = $associated_class->name;
  
      foreach my $handle ( sort keys %handles ) {
          my $method_to_call = $handles{$handle};
          my $name           = "${class_name}::${handle}";
  
          if ( my $method = $associated_class->get_method($handle) ) {
              throw_exception(
                  CannotDelegateLocalMethodIsPresent => attribute => $self,
                  method                             => $method,
              ) unless $method->is_stub;
          }
  
          # NOTE:
          # handles is not allowed to delegate
          # any of these methods, as they will
          # override the ones in your class, which
          # is almost certainly not what you want.
  
          # FIXME warn when $handle was explicitly specified, but not if the source is a regex or something
          #cluck("Not delegating method '$handle' because it is a core method") and
          next
              if $class_name->isa("Moose::Object")
              and $handle =~ /^BUILD|DEMOLISH$/ || Moose::Object->can($handle);
  
          my $method = $self->_make_delegation_method($handle, $method_to_call);
  
          $self->associated_class->add_method($method->name, $method);
          $self->associate_method($method);
      }
  }
  
  sub remove_delegation {
      my $self = shift;
      my %handles = $self->_canonicalize_handles;
      my $associated_class = $self->associated_class;
      foreach my $handle (keys %handles) {
          next unless any { $handle eq $_ }
                      map { $_->name }
                      @{ $self->associated_methods };
          $self->associated_class->remove_method($handle);
      }
  }
  
  # private methods to help delegation ...
  
  sub _canonicalize_handles {
      my $self    = shift;
      my $handles = $self->handles;
      if (my $handle_type = ref($handles)) {
          if ($handle_type eq 'HASH') {
              return %{$handles};
          }
          elsif ($handle_type eq 'ARRAY') {
              return map { $_ => $_ } @{$handles};
          }
          elsif ($handle_type eq 'Regexp') {
              ($self->has_type_constraint)
                  || throw_exception( CannotDelegateWithoutIsa => attribute => $self );
              return map  { ($_ => $_) }
                     grep { /$handles/ } $self->_get_delegate_method_list;
          }
          elsif ($handle_type eq 'CODE') {
              return $handles->($self, $self->_find_delegate_metaclass);
          }
          elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::DuckType')) {
              return map { $_ => $_ } @{ $handles->methods };
          }
          elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::Role')) {
              $handles = $handles->role;
          }
          else {
              throw_exception( UnableToCanonicalizeHandles => attribute => $self,
                                                              handles   => $handles
                             );
          }
      }
  
      Moose::Util::_load_user_class($handles);
      my $role_meta = Class::MOP::class_of($handles);
  
      (blessed $role_meta && $role_meta->isa('Moose::Meta::Role'))
          || throw_exception( UnableToCanonicalizeNonRolePackage => attribute => $self,
                                                                    handles   => $handles
                            );
  
      return map { $_ => $_ }
          map { $_->name }
          grep { !$_->isa('Class::MOP::Method::Meta') } (
          $role_meta->_get_local_methods,
          $role_meta->get_required_method_list,
          );
  }
  
  sub _get_delegate_method_list {
      my $self = shift;
      my $meta = $self->_find_delegate_metaclass;
      if ($meta->isa('Class::MOP::Class')) {
          return map  { $_->name }  # NOTE: !never! delegate &meta
                 grep { $_->package_name ne 'Moose::Object' && !$_->isa('Class::MOP::Method::Meta') }
                      $meta->get_all_methods;
      }
      elsif ($meta->isa('Moose::Meta::Role')) {
          return $meta->get_method_list;
      }
      else {
          throw_exception( UnableToRecognizeDelegateMetaclass => attribute          => $self,
                                                                 delegate_metaclass => $meta
                         );
      }
  }
  
  sub _find_delegate_metaclass {
      my $self = shift;
      my $class = $self->_isa_metadata;
      my $role = $self->_does_metadata;
  
      if ( $class ) {
          # make sure isa is actually a class
          unless ( $self->type_constraint->isa("Moose::Meta::TypeConstraint::Class") ) {
              throw_exception( DelegationToATypeWhichIsNotAClass => attribute => $self );
          }
  
          # make sure the class is loaded
          unless ( Moose::Util::_is_package_loaded($class) ) {
              throw_exception( DelegationToAClassWhichIsNotLoaded => attribute  => $self,
                                                                     class_name => $class
                             );
          }
          # we might be dealing with a non-Moose class,
          # and need to make our own metaclass. if there's
          # already a metaclass, it will be returned
          return Class::MOP::Class->initialize($class);
      }
      elsif ( $role ) {
          unless ( Moose::Util::_is_package_loaded($role) ) {
              throw_exception( DelegationToARoleWhichIsNotLoaded => attribute => $self,
                                                                    role_name => $role
                             );
          }
  
          return Class::MOP::class_of($role);
      }
      else {
          throw_exception( CannotFindDelegateMetaclass => attribute => $self );
      }
  }
  
  sub delegation_metaclass { 'Moose::Meta::Method::Delegation' }
  
  sub _make_delegation_method {
      my ( $self, $handle_name, $method_to_call ) = @_;
  
      my @curried_arguments;
  
      ($method_to_call, @curried_arguments) = @$method_to_call
          if 'ARRAY' eq ref($method_to_call);
  
      return $self->delegation_metaclass->new(
          name               => $handle_name,
          package_name       => $self->associated_class->name,
          attribute          => $self,
          delegate_to_method => $method_to_call,
          curried_arguments  => \@curried_arguments,
      );
  }
  
  sub _coerce_and_verify {
      my $self     = shift;
      my $val      = shift;
      my $instance = shift;
  
      return $val unless $self->has_type_constraint;
  
      $val = $self->type_constraint->coerce($val)
          if $self->should_coerce && $self->type_constraint->has_coercion;
  
      $self->verify_against_type_constraint($val, instance => $instance);
  
      return $val;
  }
  
  sub verify_against_type_constraint {
      my $self = shift;
      my $val  = shift;
  
      return 1 if !$self->has_type_constraint;
  
      my $type_constraint = $self->type_constraint;
  
      $type_constraint->check($val)
          || throw_exception( ValidationFailedForTypeConstraint => type      => $type_constraint,
                                                                   value     => $val,
                                                                   attribute => $self,
                            );
  }
  
  package Moose::Meta::Attribute::Custom::Moose;
  our $VERSION = '2.1403';
  
  sub register_implementation { 'Moose::Meta::Attribute' }
  1;
  
  # ABSTRACT: The Moose attribute metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute - The Moose attribute metaclass
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Attribute> that provides
  additional Moose-specific functionality.
  
  To really understand this class, you will need to start with the
  L<Class::MOP::Attribute> documentation. This class can be understood
  as a set of additional features on top of the basic feature provided
  by that parent class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Attribute> is a subclass of L<Class::MOP::Attribute>.
  
  =head1 METHODS
  
  Many of the documented below override methods in
  L<Class::MOP::Attribute> and add Moose specific features.
  
  =head2 Creation
  
  =over 4
  
  =item B<< Moose::Meta::Attribute->new($name, %options) >>
  
  This method overrides the L<Class::MOP::Attribute> constructor.
  
  Many of the options below are described in more detail in the
  L<Moose::Manual::Attributes> document.
  
  It adds the following options to the constructor:
  
  =over 8
  
  =item * is => 'ro', 'rw', 'bare'
  
  This provides a shorthand for specifying the C<reader>, C<writer>, or
  C<accessor> names. If the attribute is read-only ('ro') then it will
  have a C<reader> method with the same attribute as the name.
  
  If it is read-write ('rw') then it will have an C<accessor> method
  with the same name. If you provide an explicit C<writer> for a
  read-write attribute, then you will have a C<reader> with the same
  name as the attribute, and a C<writer> with the name you provided.
  
  Use 'bare' when you are deliberately not installing any methods
  (accessor, reader, etc.) associated with this attribute; otherwise,
  Moose will issue a warning when this attribute is added to a
  metaclass.
  
  =item * isa => $type
  
  This option accepts a type. The type can be a string, which should be
  a type name. If the type name is unknown, it is assumed to be a class
  name.
  
  This option can also accept a L<Moose::Meta::TypeConstraint> object.
  
  If you I<also> provide a C<does> option, then your C<isa> option must
  be a class name, and that class must do the role specified with
  C<does>.
  
  =item * does => $role
  
  This is short-hand for saying that the attribute's type must be an
  object which does the named role.
  
  =item * coerce => $bool
  
  This option is only valid for objects with a type constraint
  (C<isa>) that defined a coercion. If this is true, then coercions will be applied whenever
  this attribute is set.
  
  You cannot make both this and the C<weak_ref> option true.
  
  =item * trigger => $sub
  
  This option accepts a subroutine reference, which will be called after
  the attribute is set.
  
  =item * required => $bool
  
  An attribute which is required must be provided to the constructor. An
  attribute which is required can also have a C<default> or C<builder>,
  which will satisfy its required-ness.
  
  A required attribute must have a C<default>, C<builder> or a
  non-C<undef> C<init_arg>
  
  =item * lazy => $bool
  
  A lazy attribute must have a C<default> or C<builder>. When an
  attribute is lazy, the default value will not be calculated until the
  attribute is read.
  
  =item * weak_ref => $bool
  
  If this is true, the attribute's value will be stored as a weak
  reference.
  
  =item * documentation
  
  An arbitrary string that can be retrieved later by calling C<<
  $attr->documentation >>.
  
  =item * auto_deref => $bool
  
  B<Note that in cases where you want this feature you are often better served
  by using a L<Moose::Meta::Attribute::Native> trait instead>.
  
  If this is true, then the reader will dereference the value when it is
  called. The attribute must have a type constraint which defines the
  attribute as an array or hash reference.
  
  =item * lazy_build => $bool
  
  B<Note that use of this feature is strongly discouraged.> Some documentation
  used to encourage use of this feature as a best practice, but we have changed
  our minds.
  
  Setting this to true makes the attribute lazy and provides a number of
  default methods.
  
    has 'size' => (
        is         => 'ro',
        lazy_build => 1,
    );
  
  is equivalent to this:
  
    has 'size' => (
        is        => 'ro',
        lazy      => 1,
        builder   => '_build_size',
        clearer   => 'clear_size',
        predicate => 'has_size',
    );
  
  If your attribute name starts with an underscore (C<_>), then the clearer
  and predicate will as well:
  
    has '_size' => (
        is         => 'ro',
        lazy_build => 1,
    );
  
  becomes:
  
    has '_size' => (
        is        => 'ro',
        lazy      => 1,
        builder   => '_build__size',
        clearer   => '_clear_size',
        predicate => '_has_size',
    );
  
  Note the doubled underscore in the builder name. Internally, Moose
  simply prepends the attribute name with "_build_" to come up with the
  builder name.
  
  =back
  
  =item B<< $attr->clone(%options) >>
  
  This creates a new attribute based on attribute being cloned. You must
  supply a C<name> option to provide a new name for the attribute.
  
  The C<%options> can only specify options handled by
  L<Class::MOP::Attribute>.
  
  =back
  
  =head2 Value management
  
  =over 4
  
  =item B<< $attr->initialize_instance_slot($meta_instance, $instance, $params) >>
  
  This method is used internally to initialize the attribute's slot in
  the object C<$instance>.
  
  This overrides the L<Class::MOP::Attribute> method to handle lazy
  attributes, weak references, and type constraints.
  
  =item B<get_value>
  
  =item B<set_value>
  
    eval { $point->meta->get_attribute('x')->set_value($point, 'forty-two') };
    if($@) {
      print "Oops: $@\n";
    }
  
  I<Attribute (x) does not pass the type constraint (Int) with 'forty-two'>
  
  Before setting the value, a check is made on the type constraint of
  the attribute, if it has one, to see if the value passes it. If the
  value fails to pass, the set operation dies.
  
  Any coercion to convert values is done before checking the type constraint.
  
  To check a value against a type constraint before setting it, fetch the
  attribute instance using L<Class::MOP::Class/find_attribute_by_name>,
  fetch the type_constraint from the attribute using L<Moose::Meta::Attribute/type_constraint>
  and call L<Moose::Meta::TypeConstraint/check>. See L<Moose::Cookbook::Basics::Company_Subtypes>
  for an example.
  
  =back
  
  =head2 Attribute Accessor generation
  
  =over 4
  
  =item B<< $attr->install_accessors >>
  
  This method overrides the parent to also install delegation methods.
  
  If, after installing all methods, the attribute object has no associated
  methods, it throws an error unless C<< is => 'bare' >> was passed to the
  attribute constructor.  (Trying to add an attribute that has no associated
  methods is almost always an error.)
  
  =item B<< $attr->remove_accessors >>
  
  This method overrides the parent to also remove delegation methods.
  
  =item B<< $attr->inline_set($instance_var, $value_var) >>
  
  This method return a code snippet suitable for inlining the relevant
  operation. It expect strings containing variable names to be used in the
  inlining, like C<'$self'> or C<'$_[1]'>.
  
  =item B<< $attr->install_delegation >>
  
  This method adds its delegation methods to the attribute's associated
  class, if it has any to add.
  
  =item B<< $attr->remove_delegation >>
  
  This method remove its delegation methods from the attribute's
  associated class.
  
  =item B<< $attr->accessor_metaclass >>
  
  Returns the accessor metaclass name, which defaults to
  L<Moose::Meta::Method::Accessor>.
  
  =item B<< $attr->delegation_metaclass >>
  
  Returns the delegation metaclass name, which defaults to
  L<Moose::Meta::Method::Delegation>.
  
  =back
  
  =head2 Additional Moose features
  
  These methods are not found in the superclass. They support features
  provided by Moose.
  
  =over 4
  
  =item B<< $attr->does($role) >>
  
  This indicates whether the I<attribute itself> does the given
  role. The role can be given as a full class name, or as a resolvable
  trait name.
  
  Note that this checks the attribute itself, not its type constraint,
  so it is checking the attribute's metaclass and any traits applied to
  the attribute.
  
  =item B<< Moose::Meta::Class->interpolate_class_and_new($name, %options) >>
  
  This is an alternate constructor that handles the C<metaclass> and
  C<traits> options.
  
  Effectively, this method is a factory that finds or creates the
  appropriate class for the given C<metaclass> and/or C<traits>.
  
  Once it has the appropriate class, it will call C<< $class->new($name,
  %options) >> on that class.
  
  =item B<< $attr->clone_and_inherit_options(%options) >>
  
  This method supports the C<has '+foo'> feature. It does various bits
  of processing on the supplied C<%options> before ultimately calling
  the C<clone> method.
  
  One of its main tasks is to make sure that the C<%options> provided
  does not include the options returned by the
  C<illegal_options_for_inheritance> method.
  
  =item B<< $attr->illegal_options_for_inheritance >>
  
  This returns a blacklist of options that can not be overridden in a
  subclass's attribute definition.
  
  This exists to allow a custom metaclass to change or add to the list
  of options which can not be changed.
  
  =item B<< $attr->type_constraint >>
  
  Returns the L<Moose::Meta::TypeConstraint> object for this attribute,
  if it has one.
  
  =item B<< $attr->has_type_constraint >>
  
  Returns true if this attribute has a type constraint.
  
  =item B<< $attr->verify_against_type_constraint($value) >>
  
  Given a value, this method returns true if the value is valid for the
  attribute's type constraint. If the value is not valid, it throws an
  error.
  
  =item B<< $attr->handles >>
  
  This returns the value of the C<handles> option passed to the
  constructor.
  
  =item B<< $attr->has_handles >>
  
  Returns true if this attribute performs delegation.
  
  =item B<< $attr->is_weak_ref >>
  
  Returns true if this attribute stores its value as a weak reference.
  
  =item B<< $attr->is_required >>
  
  Returns true if this attribute is required to have a value.
  
  =item B<< $attr->is_lazy >>
  
  Returns true if this attribute is lazy.
  
  =item B<< $attr->is_lazy_build >>
  
  Returns true if the C<lazy_build> option was true when passed to the
  constructor.
  
  =item B<< $attr->should_coerce >>
  
  Returns true if the C<coerce> option passed to the constructor was
  true.
  
  =item B<< $attr->should_auto_deref >>
  
  Returns true if the C<auto_deref> option passed to the constructor was
  true.
  
  =item B<< $attr->trigger >>
  
  This is the subroutine reference that was in the C<trigger> option
  passed to the constructor, if any.
  
  =item B<< $attr->has_trigger >>
  
  Returns true if this attribute has a trigger set.
  
  =item B<< $attr->documentation >>
  
  Returns the value that was in the C<documentation> option passed to
  the constructor, if any.
  
  =item B<< $attr->has_documentation >>
  
  Returns true if this attribute has any documentation.
  
  =item B<< $attr->applied_traits >>
  
  This returns an array reference of all the traits which were applied
  to this attribute. If none were applied, this returns C<undef>.
  
  =item B<< $attr->has_applied_traits >>
  
  Returns true if this attribute has any traits applied.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE';
  use strict;
  use warnings;
  package Moose::Meta::Attribute::Native;
  our $VERSION = '2.1603';
  
  use Module::Runtime 'require_module';
  
  my @trait_names = qw(Bool Counter Number String Array Hash Code);
  
  for my $trait_name (@trait_names) {
      my $trait_class = "Moose::Meta::Attribute::Native::Trait::$trait_name";
      my $meta = Class::MOP::Class->initialize(
          "Moose::Meta::Attribute::Custom::Trait::$trait_name"
      );
  
      if ($meta->find_method_by_name('register_implementation')) {
          my $class = $meta->name->register_implementation;
          die "An implementation for $trait_name already exists " .
              "(found '$class' when trying to register '$trait_class')"
      }
      $meta->add_method(register_implementation => sub {
          # resolve_metatrait_alias will load classes anyway, but throws away
          # their error message; we WANT to die if there's a problem
          require_module($trait_class);
          return $trait_class;
      });
  }
  
  1;
  
  # ABSTRACT: Delegate to native Perl types
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native - Delegate to native Perl types
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package MyClass;
    use Moose;
  
    has 'mapping' => (
        traits  => ['Hash'],
        is      => 'rw',
        isa     => 'HashRef[Str]',
        default => sub { {} },
        handles => {
            exists_in_mapping => 'exists',
            ids_in_mapping    => 'keys',
            get_mapping       => 'get',
            set_mapping       => 'set',
            set_quantity      => [ set => 'quantity' ],
        },
    );
  
    my $obj = MyClass->new;
    $obj->set_quantity(10);      # quantity => 10
    $obj->set_mapping('foo', 4); # foo => 4
    $obj->set_mapping('bar', 5); # bar => 5
    $obj->set_mapping('baz', 6); # baz => 6
  
    # prints 5
    print $obj->get_mapping('bar') if $obj->exists_in_mapping('bar');
  
    # prints 'quantity, foo, bar, baz'
    print join ', ', $obj->ids_in_mapping;
  
  =head1 DESCRIPTION
  
  Native delegations allow you to delegate to native Perl data
  structures as if they were objects. For example, in the L</SYNOPSIS> you can
  see a hash reference being treated as if it has methods named C<exists()>,
  C<keys()>, C<get()>, and C<set()>.
  
  The delegation methods (mostly) map to Perl builtins and operators. The return
  values of these delegations should be the same as the corresponding Perl
  operation. Any deviations will be explicitly documented.
  
  =head1 API
  
  Native delegations are enabled by passing certain options to C<has> when
  creating an attribute.
  
  =head2 traits
  
  To enable this feature, pass the appropriate name in the C<traits> array
  reference for the attribute. For example, to enable this feature for hash
  reference, we include C<'Hash'> in the list of traits.
  
  =head2 isa
  
  You will need to make sure that the attribute has an appropriate type. For
  example, to use this with a Hash you must specify that your attribute is some
  sort of C<HashRef>.
  
  =head2 handles
  
  This is just like any other delegation, but only a hash reference is allowed
  when defining native delegations. The keys are the methods to be created in
  the class which contains the attribute. The values are the methods provided by
  the associated trait. Currying works the same way as it does with any other
  delegation.
  
  See the docs for each native trait for details on what methods are available.
  
  =head1 TRAITS FOR NATIVE DELEGATIONS
  
  Below are some simple examples of each native trait. More features are
  available than what is shown here; this is just a quick synopsis.
  
  =over
  
  =item Array (L<Moose::Meta::Attribute::Native::Trait::Array>)
  
      has 'queue' => (
          traits  => ['Array'],
          is      => 'ro',
          isa     => 'ArrayRef[Str]',
          default => sub { [] },
          handles => {
              add_item  => 'push',
              next_item => 'shift',
              # ...
          }
      );
  
  =item Bool (L<Moose::Meta::Attribute::Native::Trait::Bool>)
  
      has 'is_lit' => (
          traits  => ['Bool'],
          is      => 'ro',
          isa     => 'Bool',
          default => 0,
          handles => {
              illuminate  => 'set',
              darken      => 'unset',
              flip_switch => 'toggle',
              is_dark     => 'not',
              # ...
          }
      );
  
  =item Code (L<Moose::Meta::Attribute::Native::Trait::Code>)
  
      has 'callback' => (
          traits  => ['Code'],
          is      => 'ro',
          isa     => 'CodeRef',
          default => sub {
              sub {'called'}
          },
          handles => {
              call => 'execute',
              # ...
          }
      );
  
  =item Counter (L<Moose::Meta::Attribute::Native::Trait::Counter>)
  
      has 'counter' => (
          traits  => ['Counter'],
          is      => 'ro',
          isa     => 'Num',
          default => 0,
          handles => {
              inc_counter   => 'inc',
              dec_counter   => 'dec',
              reset_counter => 'reset',
              # ...
          }
      );
  
  =item Hash (L<Moose::Meta::Attribute::Native::Trait::Hash>)
  
      has 'options' => (
          traits  => ['Hash'],
          is      => 'ro',
          isa     => 'HashRef[Str]',
          default => sub { {} },
          handles => {
              set_option => 'set',
              get_option => 'get',
              has_option => 'exists',
              # ...
          }
      );
  
  =item Number (L<Moose::Meta::Attribute::Native::Trait::Number>)
  
      has 'integer' => (
          traits  => ['Number'],
          is      => 'ro',
          isa     => 'Int',
          default => 5,
          handles => {
              set => 'set',
              add => 'add',
              sub => 'sub',
              mul => 'mul',
              div => 'div',
              mod => 'mod',
              abs => 'abs',
              # ...
          }
      );
  
  =item String (L<Moose::Meta::Attribute::Native::Trait::String>)
  
      has 'text' => (
          traits  => ['String'],
          is      => 'ro',
          isa     => 'Str',
          default => q{},
          handles => {
              add_text     => 'append',
              replace_text => 'replace',
              # ...
          }
      );
  
  =back
  
  =head1 COMPATIBILITY WITH MooseX::AttributeHelpers
  
  This feature used to be a separated CPAN distribution called
  L<MooseX::AttributeHelpers>.
  
  When the feature was incorporated into the Moose core, some of the API details
  were changed. The underlying capabilities are the same, but some details of
  the API were changed.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT';
  package Moose::Meta::Attribute::Native::Trait;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  use Module::Runtime 'require_module';
  use Moose::Deprecated;
  use Moose::Util 'throw_exception';
  use Moose::Util::TypeConstraints;
  
  requires '_helper_type';
  
  before '_process_options' => sub {
      my ( $self, $name, $options ) = @_;
  
      $self->_check_helper_type( $options, $name );
  };
  
  sub _check_helper_type {
      my ( $self, $options, $name ) = @_;
  
      my $type = $self->_helper_type;
  
      $options->{isa} = $type
          unless exists $options->{isa};
  
      my $isa;
      my $isa_name;
  
      if (   blessed( $options->{isa} )
          && $options->{isa}->can('does')
          && $options->{isa}->does('Specio::Constraint::Role::Interface') ) {
  
          $isa = $options->{isa};
          require Specio::Library::Builtins;
          return if $isa->is_a_type_of( Specio::Library::Builtins::t($type) );
          $isa_name = $isa->name() || $isa->description();
      }
      else {
          $isa = Moose::Util::TypeConstraints::find_or_create_type_constraint(
              $options->{isa} );
          return if $isa->is_a_type_of($type);
          $isa_name = $isa->name();
      }
  
      throw_exception( WrongTypeConstraintGiven => required_type  => $type,
                                                   given_type     => $isa_name,
                                                   attribute_name => $name,
                                                   params         => $options
                     );
  }
  
  before 'install_accessors' => sub { (shift)->_check_handles_values };
  
  sub _check_handles_values {
      my $self = shift;
  
      my %handles = $self->_canonicalize_handles;
  
      for my $original_method ( values %handles ) {
          my $name = $original_method->[0];
  
          my $accessor_class = $self->_native_accessor_class_for($name);
  
          ( $accessor_class && $accessor_class->can('new') )
              || confess
              "$name is an unsupported method type - $accessor_class";
      }
  }
  
  around '_canonicalize_handles' => sub {
      shift;
      my $self    = shift;
      my $handles = $self->handles;
  
      return unless $handles;
  
      unless ( 'HASH' eq ref $handles ) {
         throw_exception( HandlesMustBeAHashRef => instance      => $self,
                                                   given_handles => $handles
                        );
      }
  
      return
          map { $_ => $self->_canonicalize_handles_value( $handles->{$_} ) }
          keys %$handles;
  };
  
  sub _canonicalize_handles_value {
      my $self  = shift;
      my $value = shift;
  
      if ( ref $value && 'ARRAY' ne ref $value ) {
          throw_exception( InvalidHandleValue => instance     => $self,
                                                 handle_value => $value
                         );
      }
  
      return ref $value ? $value : [$value];
  }
  
  around '_make_delegation_method' => sub {
      my $next = shift;
      my ( $self, $handle_name, $method_to_call ) = @_;
  
      my ( $name, @curried_args ) = @$method_to_call;
  
      my $accessor_class = $self->_native_accessor_class_for($name);
  
      die "Cannot find an accessor class for $name"
          unless $accessor_class && $accessor_class->can('new');
  
      return $accessor_class->new(
          name               => $handle_name,
          package_name       => $self->associated_class->name,
          delegate_to_method => $name,
          attribute          => $self,
          is_inline          => 1,
          curried_arguments  => \@curried_args,
          root_types         => [ $self->_root_types ],
      );
  };
  
  sub _root_types {
      return $_[0]->_helper_type;
  }
  
  sub _native_accessor_class_for {
      my ( $self, $suffix ) = @_;
  
      my $role
          = 'Moose::Meta::Method::Accessor::Native::'
          . $self->_native_type . '::'
          . $suffix;
  
      require_module($role);
      return Moose::Meta::Class->create_anon_class(
          superclasses =>
              [ $self->accessor_metaclass, $self->delegation_metaclass ],
          roles => [$role],
          cache => 1,
      )->name;
  }
  
  sub _build_native_type {
      my $self = shift;
  
      for my $role_name ( map { $_->name } $self->meta->calculate_all_roles ) {
          return $1 if $role_name =~ /::Native::Trait::(\w+)$/;
      }
  
      throw_exception( CannotCalculateNativeType => instance => $self );
  }
  
  has '_native_type' => (
      is      => 'ro',
      isa     => 'Str',
      lazy    => 1,
      builder => '_build_native_type',
  );
  
  no Moose::Role;
  no Moose::Util::TypeConstraints;
  
  1;
  
  # ABSTRACT: Shared role for native delegation traits
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait - Shared role for native delegation traits
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 SEE ALSO
  
  Documentation for Moose native traits can be found in
  L<Moose::Meta::Attribute::Native>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_ARRAY';
  package Moose::Meta::Attribute::Native::Trait::Array;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'ArrayRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for ArrayRef attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Array - Helper trait for ArrayRef attributes
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
      package Stuff;
      use Moose;
  
      has 'options' => (
          traits  => ['Array'],
          is      => 'ro',
          isa     => 'ArrayRef[Str]',
          default => sub { [] },
          handles => {
              all_options    => 'elements',
              add_option     => 'push',
              map_options    => 'map',
              filter_options => 'grep',
              find_option    => 'first',
              get_option     => 'get',
              join_options   => 'join',
              count_options  => 'count',
              has_options    => 'count',
              has_no_options => 'is_empty',
              sorted_options => 'sort',
          },
      );
  
      no Moose;
      1;
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for array references.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<ArrayRef>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<count>
  
  Returns the number of elements in the array.
  
    $stuff = Stuff->new;
    $stuff->options( [ "foo", "bar", "baz", "boo" ] );
  
    print $stuff->count_options; # prints 4
  
  This method does not accept any arguments.
  
  =item * B<is_empty>
  
  Returns a boolean value that is true when the array has no elements.
  
    $stuff->has_no_options ? die "No options!\n" : print "Good boy.\n";
  
  This method does not accept any arguments.
  
  =item * B<elements>
  
  Returns all of the elements of the array as an array (not an array reference).
  
    my @option = $stuff->all_options;
    print "@options\n";    # prints "foo bar baz boo"
  
  This method does not accept any arguments.
  
  =item * B<get($index)>
  
  Returns an element of the array by its index. You can also use negative index
  numbers, just as with Perl's core array handling.
  
    my $option = $stuff->get_option(1);
    print "$option\n";    # prints "bar"
  
  If the specified element does not exist, this will return C<undef>.
  
  This method accepts just one argument.
  
  =item * B<pop>
  
  Just like Perl's builtin C<pop>.
  
  This method does not accept any arguments.
  
  =item * B<push($value1, $value2, value3 ...)>
  
  Just like Perl's builtin C<push>. Returns the number of elements in the new
  array.
  
  This method accepts any number of arguments.
  
  =item * B<shift>
  
  Just like Perl's builtin C<shift>.
  
  This method does not accept any arguments.
  
  =item * B<unshift($value1, $value2, value3 ...)>
  
  Just like Perl's builtin C<unshift>. Returns the number of elements in the new
  array.
  
  This method accepts any number of arguments.
  
  =item * B<splice($offset, $length, @values)>
  
  Just like Perl's builtin C<splice>. In scalar context, this returns the last
  element removed, or C<undef> if no elements were removed. In list context,
  this returns all the elements removed from the array.
  
  This method requires at least one argument.
  
  =item * B<first( sub { ... } )>
  
  This method returns the first matching item in the array, just like
  L<List::Util>'s C<first> function. The matching is done with a subroutine
  reference you pass to this method. The subroutine will be called against each
  element in the array until one matches or all elements have been checked.
  Each list element will be available to the sub in C<$_>.
  
    my $found = $stuff->find_option( sub {/^b/} );
    print "$found\n";    # prints "bar"
  
  This method requires a single argument.
  
  =item * B<first_index( sub { ... } )>
  
  This method returns the index of the first matching item in the array, just
  like L<List::MoreUtils>'s C<first_index> function. The matching is done with a
  subroutine reference you pass to this method. The subroutine will be called
  against each element in the array until one matches or all elements have been
  checked. Each list element will be available to the sub in C<$_>.
  
  This method requires a single argument.
  
  =item * B<grep( sub { ... } )>
  
  This method returns every element matching a given criteria, just like Perl's
  core C<grep> function. This method requires a subroutine which implements the
  matching logic; each list element will be available to the sub in C<$_>.
  
    my @found = $stuff->filter_options( sub {/^b/} );
    print "@found\n";    # prints "bar baz boo"
  
  This method requires a single argument.
  
  =item * B<map( sub { ... } )>
  
  This method transforms every element in the array and returns a new array,
  just like Perl's core C<map> function. This method requires a subroutine which
  implements the transformation; each list element will be available to the sub
  in C<$_>.
  
    my @mod_options = $stuff->map_options( sub { $_ . "-tag" } );
    print "@mod_options\n";    # prints "foo-tag bar-tag baz-tag boo-tag"
  
  This method requires a single argument.
  
  =item * B<reduce( sub { ... } )>
  
  This method turns an array into a single value, by passing a function the
  value so far and the next value in the array, just like L<List::Util>'s
  C<reduce> function. The reducing is done with a subroutine reference you pass
  to this method; each list element will be available to the sub in C<$_>.
  
    my $found = $stuff->reduce_options( sub { $_[0] . $_[1] } );
    print "$found\n";    # prints "foobarbazboo"
  
  This method requires a single argument.
  
  =item * B<sort>
  
  =item * B<sort( sub { ... } )>
  
  Returns the elements of the array (not an array reference) in sorted order,
  or, like C<elements>, returns the number of elements in the array in scalar context.
  
  You can provide an optional subroutine reference to sort with (as you can with
  Perl's core C<sort> function). However, instead of using C<$a> and C<$b> in
  this subroutine, you will need to use C<$_[0]> and C<$_[1]>.
  
    # ascending ASCIIbetical
    my @sorted = $stuff->sort_options();
  
    # Descending alphabetical order
    my @sorted_options = $stuff->sort_options( sub { lc $_[1] cmp lc $_[0] } );
    print "@sorted_options\n";    # prints "foo boo baz bar"
  
  This method accepts a single argument.
  
  =item * B<sort_in_place>
  
  =item * B<sort_in_place( sub { ... } )>
  
  Sorts the array I<in place>, modifying the value of the attribute.
  
  You can provide an optional subroutine reference to sort with (as you can with
  Perl's core C<sort> function). However, instead of using C<$a> and C<$b>, you
  will need to use C<$_[0]> and C<$_[1]> instead.
  
  This method does not define a return value.
  
  This method accepts a single argument.
  
  =item * B<shuffle>
  
  Returns the elements of the array in random order, like C<shuffle> from
  L<List::Util>.
  
  This method does not accept any arguments.
  
  =item * B<uniq>
  
  Returns the array with all duplicate elements removed, like C<uniq> from
  L<List::MoreUtils>.
  
  This method does not accept any arguments.
  
  =item * B<join($str)>
  
  Joins every element of the array using the separator given as argument, just
  like Perl's core C<join> function.
  
    my $joined = $stuff->join_options(':');
    print "$joined\n";    # prints "foo:bar:baz:boo"
  
  This method requires a single argument.
  
  =item * B<set($index, $value)>
  
  Given an index and a value, sets the specified array element's value.
  
  This method returns the value at C<$index> after the set.
  
  This method requires two arguments.
  
  =item * B<delete($index)>
  
  Removes the element at the given index from the array.
  
  This method returns the deleted value. Note that if no value exists, it will
  return C<undef>.
  
  This method requires one argument.
  
  =item * B<insert($index, $value)>
  
  Inserts a new element into the array at the given index.
  
  This method returns the new value at C<$index>.
  
  This method requires two arguments.
  
  =item * B<clear>
  
  Empties the entire array, like C<@array = ()>.
  
  This method does not define a return value.
  
  This method does not accept any arguments.
  
  =item * B<accessor($index)>
  
  =item * B<accessor($index, $value)>
  
  This method provides a get/set accessor for the array, based on array indexes.
  If passed one argument, it returns the value at the specified index.  If
  passed two arguments, it sets the value of the specified index.
  
  When called as a setter, this method returns the new value at C<$index>.
  
  This method accepts one or two arguments.
  
  =item * B<natatime($n)>
  
  =item * B<natatime($n, $code)>
  
  This method returns an iterator which, on each call, returns C<$n> more items
  from the array, in order, like C<natatime> from L<List::MoreUtils>.
  
  If you pass a coderef as the second argument, then this code ref will be
  called on each group of C<$n> elements in the array until the array is
  exhausted.
  
  This method accepts one or two arguments.
  
  =item * B<shallow_clone>
  
  This method returns a shallow clone of the array reference.  The return value
  is a reference to a new array with the same elements.  It is I<shallow>
  because any elements that were references in the original will be the I<same>
  references in the clone.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_ARRAY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Bool.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_BOOL';
  package Moose::Meta::Attribute::Native::Trait::Bool;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Bool' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Bool attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Bool - Helper trait for Bool attributes
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package Room;
    use Moose;
  
    has 'is_lit' => (
        traits  => ['Bool'],
        is      => 'rw',
        isa     => 'Bool',
        default => 0,
        handles => {
            illuminate  => 'set',
            darken      => 'unset',
            flip_switch => 'toggle',
            is_dark     => 'not',
        },
    );
  
    my $room = Room->new();
    $room->illuminate;        # same as $room->is_lit(1);
    $room->darken;            # same as $room->is_lit(0);
    $room->flip_switch;       # same as $room->is_lit(not $room->is_lit);
    return $room->is_dark;    # same as !$room->is_lit
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for boolean values. A boolean is
  a scalar which can be C<1>, C<0>, C<"">, or C<undef>.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Bool>.
  
  =head1 PROVIDED METHODS
  
  None of these methods accept arguments.
  
  =over 4
  
  =item * B<set>
  
  Sets the value to C<1> and returns C<1>.
  
  =item * B<unset>
  
  Set the value to C<0> and returns C<0>.
  
  =item * B<toggle>
  
  Toggles the value. If it's true, set to false, and vice versa.
  
  Returns the new value.
  
  =item * B<not>
  
  Equivalent of 'not C<$value>'.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_BOOL

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_CODE';
  package Moose::Meta::Attribute::Native::Trait::Code;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'CodeRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for CodeRef attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Code - Helper trait for CodeRef attributes
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package Foo;
    use Moose;
  
    has 'callback' => (
        traits  => ['Code'],
        is      => 'ro',
        isa     => 'CodeRef',
        default => sub {
            sub { print "called" }
        },
        handles => {
            call => 'execute',
        },
    );
  
    my $foo = Foo->new;
    $foo->call;    # prints "called"
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for code references.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<CodeRef>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<execute(@args)>
  
  Calls the coderef with the given args.
  
  =item * B<execute_method(@args)>
  
  Calls the coderef with the instance as invocant and given args.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_CODE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Counter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_COUNTER';
  package Moose::Meta::Attribute::Native::Trait::Counter;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Num' }
  sub _root_types { 'Num', 'Int' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Int attributes which represent counters
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Counter - Helper trait for Int attributes which represent counters
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package MyHomePage;
    use Moose;
  
    has 'counter' => (
        traits  => ['Counter'],
        is      => 'ro',
        isa     => 'Num',
        default => 0,
        handles => {
            inc_counter   => 'inc',
            dec_counter   => 'dec',
            reset_counter => 'reset',
        },
    );
  
    my $page = MyHomePage->new();
    $page->inc_counter;    # same as $page->counter( $page->counter + 1 );
    $page->dec_counter;    # same as $page->counter( $page->counter - 1 );
  
    my $count_by_twos = 2;
    $page->inc_counter($count_by_twos);
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for counters. A counter can be
  any sort of number (integer or not). The delegation methods allow you to
  increment, decrement, or reset the value.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Num>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<set($value)>
  
  Sets the counter to the specified value and returns the new value.
  
  This method requires a single argument.
  
  =item * B<inc>
  
  =item * B<inc($arg)>
  
  Increases the attribute value by the amount of the argument, or by 1 if no
  argument is given. This method returns the new value.
  
  This method accepts a single argument.
  
  =item * B<dec>
  
  =item * B<dec($arg)>
  
  Decreases the attribute value by the amount of the argument, or by 1 if no
  argument is given. This method returns the new value.
  
  This method accepts a single argument.
  
  =item * B<reset>
  
  Resets the value stored in this slot to its default value, and returns the new
  value.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_COUNTER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_HASH';
  package Moose::Meta::Attribute::Native::Trait::Hash;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'HashRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for HashRef attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Hash - Helper trait for HashRef attributes
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package Stuff;
    use Moose;
  
    has 'options' => (
        traits    => ['Hash'],
        is        => 'ro',
        isa       => 'HashRef[Str]',
        default   => sub { {} },
        handles   => {
            set_option     => 'set',
            get_option     => 'get',
            has_no_options => 'is_empty',
            num_options    => 'count',
            delete_option  => 'delete',
            option_pairs   => 'kv',
        },
    );
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for hash references.
  
  =head1 PROVIDED METHODS
  
  =head2 get($key, $key2, $key3...)
  
  Returns values from the hash.
  
  In list context it returns a list of values in the hash for the given keys. In
  scalar context it returns the value for the last key specified.
  
  This method requires at least one argument.
  
  =head2 set($key =E<gt> $value, $key2 =E<gt> $value2...)
  
  Sets the elements in the hash to the given values. It returns the new values
  set for each key, in the same order as the keys passed to the method.
  
  This method requires at least two arguments, and expects an even number of
  arguments.
  
  =head2 delete($key, $key2, $key3...)
  
  Removes the elements with the given keys.
  
  In list context it returns a list of values in the hash for the deleted
  keys. In scalar context it returns the value for the last key specified.
  
  =head2 keys
  
  Returns the list of keys in the hash.
  
  This method does not accept any arguments.
  
  =head2 exists($key)
  
  Returns true if the given key is present in the hash.
  
  This method requires a single argument.
  
  =head2 defined($key)
  
  Returns true if the value of a given key is defined.
  
  This method requires a single argument.
  
  =head2 values
  
  Returns the list of values in the hash.
  
  This method does not accept any arguments.
  
  =head2 kv
  
  Returns the key/value pairs in the hash as an array of array references.
  
    for my $pair ( $object->option_pairs ) {
        print "$pair->[0] = $pair->[1]\n";
    }
  
  This method does not accept any arguments.
  
  =head2 elements
  
  Returns the key/value pairs in the hash as a flattened list..
  
  This method does not accept any arguments.
  
  =head2 clear
  
  Resets the hash to an empty value, like C<%hash = ()>.
  
  This method does not accept any arguments.
  
  =head2 count
  
  Returns the number of elements in the hash. Also useful to check for a nonempty hash, because C<count> returns a true (nonzero) value if there is something in the hash:
  C<< has_options => 'count' >>.
  
  This method does not accept any arguments.
  
  =head2 is_empty
  
  If the hash is populated, returns false. Otherwise, returns true.
  
  This method does not accept any arguments.
  
  =head2 accessor($key)
  
  =head2 accessor($key, $value)
  
  If passed one argument, returns the value of the specified key. If passed two
  arguments, sets the value of the specified key.
  
  When called as a setter, this method returns the value that was set.
  
  =head2 shallow_clone
  
  This method returns a shallow clone of the hash reference.  The return value
  is a reference to a new hash with the same keys and values.  It is I<shallow>
  because any values that were references in the original will be the I<same>
  references in the clone.
  
  =head2 Why no C<each>?
  
  We have deliberately omitted a method for C<each>, due to its stateful
  interaction with the hash iterator. Using C<keys> or C<kv> is much safer.
  
  =head2 Moose::Meta::Attribute->meta
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_HASH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_NUMBER';
  package Moose::Meta::Attribute::Native::Trait::Number;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Num' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Num attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Number - Helper trait for Num attributes
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package Real;
    use Moose;
  
    has 'integer' => (
        traits  => ['Number'],
        is      => 'ro',
        isa     => 'Num',
        default => 5,
        handles => {
            set => 'set',
            add => 'add',
            sub => 'sub',
            mul => 'mul',
            div => 'div',
            mod => 'mod',
            abs => 'abs',
        },
    );
  
    my $real = Real->new();
    $real->add(5);    # same as $real->integer($real->integer + 5);
    $real->sub(2);    # same as $real->integer($real->integer - 2);
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for numbers. All of the
  operations correspond to arithmetic operations like addition or
  multiplication.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Num>.
  
  =head1 PROVIDED METHODS
  
  All of these methods modify the attribute's value in place. All methods return
  the new value.
  
  =over 4
  
  =item * B<add($value)>
  
  Adds the current value of the attribute to C<$value>.
  
  =item * B<sub($value)>
  
  Subtracts C<$value> from the current value of the attribute.
  
  =item * B<mul($value)>
  
  Multiplies the current value of the attribute by C<$value>.
  
  =item * B<div($value)>
  
  Divides the current value of the attribute by C<$value>.
  
  =item * B<mod($value)>
  
  Returns the current value of the attribute modulo C<$value>.
  
  =item * B<abs>
  
  Sets the current value of the attribute to its absolute value.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_NUMBER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Attribute/Native/Trait/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_STRING';
  package Moose::Meta::Attribute::Native::Trait::String;
  our $VERSION = '2.1603';
  
  use Moose::Role;
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Str' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Str attributes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::String - Helper trait for Str attributes
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package MyHomePage;
    use Moose;
  
    has 'text' => (
        traits  => ['String'],
        is      => 'rw',
        isa     => 'Str',
        default => q{},
        handles => {
            add_text     => 'append',
            replace_text => 'replace',
        },
    );
  
    my $page = MyHomePage->new();
    $page->add_text("foo");    # same as $page->text($page->text . "foo");
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for strings.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Str>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<inc>
  
  Increments the value stored in this slot using the magical string autoincrement
  operator. Note that Perl doesn't provide analogous behavior in C<-->, so
  C<dec> is not available. This method returns the new value.
  
  This method does not accept any arguments.
  
  =item * B<append($string)>
  
  Appends to the string, like C<.=>, and returns the new value.
  
  This method requires a single argument.
  
  =item * B<prepend($string)>
  
  Prepends to the string and returns the new value.
  
  This method requires a single argument.
  
  =item * B<replace($pattern, $replacement)>
  
  Performs a regexp substitution (L<perlop/s>). There is no way to provide the
  C<g> flag, but code references will be accepted for the replacement, causing
  the regex to be modified with a single C<e>. C</smxi> can be applied using the
  C<qr> operator. This method returns the new value.
  
  This method requires two arguments.
  
  =item * B<match($pattern)>
  
  Runs the regex against the string and returns the matching value(s).
  
  This method requires a single argument.
  
  =item * B<chop>
  
  Just like L<perlfunc/chop>. This method returns the chopped character.
  
  This method does not accept any arguments.
  
  =item * B<chomp>
  
  Just like L<perlfunc/chomp>. This method returns the number of characters
  removed.
  
  This method does not accept any arguments.
  
  =item * B<clear>
  
  Sets the string to the empty string (not the value passed to C<default>).
  
  This method does not have a defined return value.
  
  This method does not accept any arguments.
  
  =item * B<length>
  
  Just like L<perlfunc/length>, returns the length of the string.
  
  =item * B<substr>
  
  This acts just like L<perlfunc/substr>. When called as a writer, it returns
  the substring that was replaced, just like the Perl builtin.
  
  This method requires at least one argument, and accepts no more than three.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_STRING

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_CLASS';
  package Moose::Meta::Class;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::MOP;
  use Data::OptList;
  use List::Util 1.33 qw( any first );
  use List::MoreUtils qw( uniq first_index );
  use Scalar::Util 'blessed';
  
  use Moose::Meta::Method::Overridden;
  use Moose::Meta::Method::Augmented;
  use Moose::Meta::Class::Immutable::Trait;
  use Moose::Meta::Method::Constructor;
  use Moose::Meta::Method::Destructor;
  use Moose::Meta::Method::Meta;
  use Moose::Util 'throw_exception';
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Class';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  __PACKAGE__->meta->add_attribute('roles' => (
      reader  => 'roles',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('role_applications' => (
      reader  => '_get_role_applications',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      Class::MOP::Attribute->new('immutable_trait' => (
          accessor => "immutable_trait",
          default  => 'Moose::Meta::Class::Immutable::Trait',
          Class::MOP::_definition_context(),
      ))
  );
  
  __PACKAGE__->meta->add_attribute('constructor_class' => (
      accessor => 'constructor_class',
      default  => 'Moose::Meta::Method::Constructor',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('destructor_class' => (
      accessor => 'destructor_class',
      default  => 'Moose::Meta::Method::Destructor',
      Class::MOP::_definition_context(),
  ));
  
  sub initialize {
      my $class = shift;
      my @args = @_;
      unshift @args, 'package' if @args % 2;
      my %opts = @args;
      my $package = delete $opts{package};
      return Class::MOP::get_metaclass_by_name($package)
          || $class->SUPER::initialize($package,
                  'attribute_metaclass' => 'Moose::Meta::Attribute',
                  'method_metaclass'    => 'Moose::Meta::Method',
                  'instance_metaclass'  => 'Moose::Meta::Instance',
                  %opts,
              );
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{roles} eq 'ARRAY')
          || throw_exception( RolesInCreateTakesAnArrayRef => params => \%options )
              if exists $options{roles};
  
      my $package = delete $options{package};
      my $roles   = delete $options{roles};
  
      my $new_meta = $class->SUPER::create($package, %options);
  
      if ($roles) {
          Moose::Util::apply_all_roles( $new_meta, @$roles );
      }
  
      return $new_meta;
  }
  
  sub _meta_method_class { 'Moose::Meta::Method::Meta' }
  
  sub _anon_package_prefix { 'Moose::Meta::Class::__ANON__::SERIAL::' }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
  
      my $superclass_key = join('|',
          map { $_->[0] } @{ Data::OptList::mkopt($options{superclasses} || []) }
      );
  
      my $roles = Data::OptList::mkopt(($options{roles} || []), {
          moniker  => 'role',
          val_test => sub { ref($_[0]) eq 'HASH' },
      });
  
      my @role_keys;
      for my $role_spec (@$roles) {
          my ($role, $params) = @$role_spec;
          $params = { %$params } if $params;
  
          my $key = blessed($role) ? $role->name : $role;
  
          if ($params && %$params) {
              my $alias    = delete $params->{'-alias'}
                          || delete $params->{'alias'}
                          || {};
              my $excludes = delete $params->{'-excludes'}
                          || delete $params->{'excludes'}
                          || [];
              $excludes = [$excludes] unless ref($excludes) eq 'ARRAY';
  
              if (%$params) {
                  warn "Roles with parameters cannot be cached. Consider "
                     . "applying the parameters before calling "
                     . "create_anon_class, or using 'weaken => 0' instead";
                  return;
              }
  
              my $alias_key = join('%',
                  map { $_ => $alias->{$_} } sort keys %$alias
              );
              my $excludes_key = join('%',
                  sort @$excludes
              );
              $key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
          }
  
          push @role_keys, $key;
      }
  
      my $role_key = join('|', sort @role_keys);
  
      # Makes something like Super::Class|Super::Class::2=Role|Role::1
      return join('=', $superclass_key, $role_key);
  }
  
  sub reinitialize {
      my $self = shift;
      my $pkg  = shift;
  
      my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);
  
      my %existing_classes;
      if ($meta) {
          %existing_classes = map { $_ => $meta->$_() } qw(
              attribute_metaclass
              method_metaclass
              wrapped_method_metaclass
              instance_metaclass
              constructor_class
              destructor_class
          );
      }
  
      return $self->SUPER::reinitialize(
          $pkg,
          %existing_classes,
          @_,
      );
  }
  
  sub add_role {
      my ($self, $role) = @_;
      (blessed($role) && $role->isa('Moose::Meta::Role'))
          || throw_exception( AddRoleTakesAMooseMetaRoleInstance => role_to_be_added => $role,
                                                                    class_name       => $self->name,
                            );
      push @{$self->roles} => $role;
  }
  
  sub role_applications {
      my ($self) = @_;
  
      return @{$self->_get_role_applications};
  }
  
  sub add_role_application {
      my ($self, $application) = @_;
  
      (blessed($application) && $application->isa('Moose::Meta::Role::Application::ToClass'))
          || throw_exception( InvalidRoleApplication => class_name  => $self->name,
                                                        application => $application,
                            );
  
      push @{$self->_get_role_applications} => $application;
  }
  
  sub calculate_all_roles {
      my $self = shift;
      my %seen;
      grep { !$seen{$_->name}++ } map { $_->calculate_all_roles } @{ $self->roles };
  }
  
  sub _roles_with_inheritance {
      my $self = shift;
      my %seen;
      grep { !$seen{$_->name}++ }
           map { Class::MOP::class_of($_)->can('roles')
                     ? @{ Class::MOP::class_of($_)->roles }
                     : () }
               $self->linearized_isa;
  }
  
  sub calculate_all_roles_with_inheritance {
      my $self = shift;
      my %seen;
      grep { !$seen{$_->name}++ }
           map { Class::MOP::class_of($_)->can('calculate_all_roles')
                     ? Class::MOP::class_of($_)->calculate_all_roles
                     : () }
               $self->linearized_isa;
  }
  
  sub does_role {
      my ($self, $role_name) = @_;
  
      (defined $role_name)
          || throw_exception( RoleNameRequired => class_name => $self->name );
  
      foreach my $class ($self->class_precedence_list) {
          my $meta = Class::MOP::class_of($class);
          # when a Moose metaclass is itself extended with a role,
          # this check needs to be done since some items in the
          # class_precedence_list might in fact be Class::MOP
          # based still.
          next unless $meta && $meta->can('roles');
          foreach my $role (@{$meta->roles}) {
              return 1 if $role->does_role($role_name);
          }
      }
      return 0;
  }
  
  sub excludes_role {
      my ($self, $role_name) = @_;
  
      (defined $role_name)
          || throw_exception( RoleNameRequired => class_name => $self->name );
  
      foreach my $class ($self->class_precedence_list) {
          my $meta = Class::MOP::class_of($class);
          # when a Moose metaclass is itself extended with a role,
          # this check needs to be done since some items in the
          # class_precedence_list might in fact be Class::MOP
          # based still.
          next unless $meta && $meta->can('roles');
          foreach my $role (@{$meta->roles}) {
              return 1 if $role->excludes_role($role_name);
          }
      }
      return 0;
  }
  
  sub new_object {
      my $self   = shift;
      my $params = @_ == 1 ? $_[0] : {@_};
      my $object = $self->SUPER::new_object($params);
  
      $self->_call_all_triggers($object, $params);
  
      $object->BUILDALL($params) if $object->can('BUILDALL');
  
      return $object;
  }
  
  sub _call_all_triggers {
      my ($self, $object, $params) = @_;
  
      foreach my $attr ( $self->get_all_attributes() ) {
  
          next unless $attr->can('has_trigger') && $attr->has_trigger;
  
          my $init_arg = $attr->init_arg;
          next unless defined $init_arg;
          next unless exists $params->{$init_arg};
  
          $attr->trigger->(
              $object,
              (
                    $attr->should_coerce
                  ? $attr->get_read_method_ref->($object)
                  : $params->{$init_arg}
              ),
          );
      }
  }
  
  sub _generate_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return $class . '->Moose::Object::new(@_)'
  }
  
  sub _inline_params {
      my $self = shift;
      my ($params, $class) = @_;
      return (
          'my ' . $params . ' = ',
          $self->_inline_BUILDARGS($class, '@_'),
          ';',
      );
  }
  
  sub _inline_BUILDARGS {
      my $self = shift;
      my ($class, $args) = @_;
  
      my $buildargs = $self->find_method_by_name("BUILDARGS");
  
      if ($args eq '@_'
       && (!$buildargs or $buildargs->body == \&Moose::Object::BUILDARGS)) {
          return (
              'do {',
                  'my $params;',
                  'if (scalar @_ == 1) {',
                      'if (!defined($_[0]) || ref($_[0]) ne \'HASH\') {',
                          $self->_inline_throw_exception(
                              'SingleParamsToNewMustBeHashRef'
                          ) . ';',
                      '}',
                      '$params = { %{ $_[0] } };',
                  '}',
                  'elsif (@_ % 2) {',
                      'Carp::carp(',
                          '"The new() method for ' . $class . ' expects a '
                        . 'hash reference or a key/value list. You passed an '
                        . 'odd number of arguments"',
                      ');',
                      '$params = {@_, undef};',
                  '}',
                  'else {',
                      '$params = {@_};',
                  '}',
                  '$params;',
              '}',
          );
      }
      else {
          return $class . '->BUILDARGS(' . $args . ')';
      }
  }
  
  sub _inline_slot_initializer {
      my $self  = shift;
      my ($attr, $idx) = @_;
  
      return (
          '## ' . $attr->name,
          $self->_inline_check_required_attr($attr),
          $self->SUPER::_inline_slot_initializer(@_),
      );
  }
  
  sub _inline_check_required_attr {
      my $self = shift;
      my ($attr) = @_;
  
      return unless defined $attr->init_arg;
      return unless $attr->can('is_required') && $attr->is_required;
      return if $attr->has_default || $attr->has_builder;
  
      return (
          'if (!exists $params->{\'' . $attr->init_arg . '\'}) {',
              $self->_inline_throw_exception(
                  AttributeIsRequired =>
                  'params         => $params, '.
                  'class_name     => $class_name, '.
                  'attribute_name => "'.quotemeta($attr->name).'"'
              ).';',
          '}',
      );
  }
  
  # XXX: these two are duplicated from cmop, because we have to pass the tc stuff
  # through to _inline_set_value - this should probably be fixed, but i'm not
  # quite sure how. -doy
  sub _inline_init_attr_from_constructor {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my @initial_value = $attr->_inline_set_value(
          '$instance',
          '$params->{\'' . $attr->init_arg . '\'}',
          '$type_constraint_bodies[' . $idx . ']',
          '$type_coercions[' . $idx . ']',
          '$type_constraint_messages[' . $idx . ']',
          'for constructor',
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_init_attr_from_default {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      return if $attr->can('is_lazy') && $attr->is_lazy;
      my $default = $self->_inline_default_value($attr, $idx);
      return unless $default;
  
      my @initial_value = (
          'my $default = ' . $default . ';',
          $attr->_inline_set_value(
              '$instance',
              '$default',
              '$type_constraint_bodies[' . $idx . ']',
              '$type_coercions[' . $idx . ']',
              '$type_constraint_messages[' . $idx . ']',
              'for constructor',
          ),
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_extra_init {
      my $self = shift;
      return (
          $self->_inline_triggers,
          $self->_inline_BUILDALL,
      );
  }
  
  sub _inline_triggers {
      my $self = shift;
      my @trigger_calls;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
      for my $i (0 .. $#attrs) {
          my $attr = $attrs[$i];
  
          next unless $attr->can('has_trigger') && $attr->has_trigger;
  
          my $init_arg = $attr->init_arg;
          next unless defined $init_arg;
  
          push @trigger_calls,
              'if (exists $params->{\'' . $init_arg . '\'}) {',
                  '$triggers->[' . $i . ']->(',
                      '$instance,',
                      $attr->_inline_instance_get('$instance') . ',',
                  ');',
              '}';
      }
  
      return @trigger_calls;
  }
  
  sub _inline_BUILDALL {
      my $self = shift;
  
      my @methods = reverse $self->find_all_methods_by_name('BUILD');
      my @BUILD_calls;
  
      foreach my $method (@methods) {
          push @BUILD_calls,
              '$instance->' . $method->{class} . '::BUILD($params);';
      }
  
      return @BUILD_calls;
  }
  
  sub _eval_environment {
      my $self = shift;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
  
      my $triggers = [
          map { $_->can('has_trigger') && $_->has_trigger ? $_->trigger : undef }
              @attrs
      ];
  
      # We need to check if the attribute ->can('type_constraint')
      # since we may be trying to immutabilize a Moose meta class,
      # which in turn has attributes which are Class::MOP::Attribute
      # objects, rather than Moose::Meta::Attribute. And
      # Class::MOP::Attribute attributes have no type constraints.
      # However we need to make sure we leave an undef value there
      # because the inlined code is using the index of the attributes
      # to determine where to find the type constraint
  
      my @type_constraints = map {
          $_->can('type_constraint') ? $_->type_constraint : undef
      } @attrs;
  
      my @type_constraint_bodies = map {
          defined $_ ? $_->_compiled_type_constraint : undef;
      } @type_constraints;
  
      my @type_coercions = map {
          defined $_ && $_->has_coercion
              ? $_->coercion->_compiled_type_coercion
              : undef
      } @type_constraints;
  
      my @type_constraint_messages = map {
          defined $_
              ? ($_->has_message ? $_->message : $_->_default_message)
              : undef
      } @type_constraints;
  
      return {
          %{ $self->SUPER::_eval_environment },
          ((any { defined && $_->has_initializer } @attrs)
              ? ('$attrs' => \[@attrs])
              : ()),
          '$triggers' => \$triggers,
          '@type_coercions' => \@type_coercions,
          '@type_constraint_bodies' => \@type_constraint_bodies,
          '@type_constraint_messages' => \@type_constraint_messages,
          ( map { defined($_) ? %{ $_->inline_environment } : () }
                @type_constraints ),
          # pretty sure this is only going to be closed over if you use a custom
          # error class at this point, but we should still get rid of this
          # at some point
          '$meta'  => \$self,
          '$class_name' => \($self->name),
      };
  }
  
  sub superclasses {
      my $self = shift;
      my $supers = Data::OptList::mkopt(\@_);
      foreach my $super (@{ $supers }) {
          my ($name, $opts) = @{ $super };
          Moose::Util::_load_user_class($name, $opts);
          my $meta = Class::MOP::class_of($name);
          throw_exception( CanExtendOnlyClasses => role_name => $meta->name )
              if $meta && $meta->isa('Moose::Meta::Role')
      }
      return $self->SUPER::superclasses(map { $_->[0] } @{ $supers });
  }
  
  ### ---------------------------------------------
  
  sub add_attribute {
      my $self = shift;
      my $attr =
          (blessed $_[0] && $_[0]->isa('Class::MOP::Attribute')
              ? $_[0]
              : $self->_process_attribute(@_));
      $self->SUPER::add_attribute($attr);
      # it may be a Class::MOP::Attribute, theoretically, which doesn't have
      # 'bare' and doesn't implement this method
      if ($attr->can('_check_associated_methods')) {
          $attr->_check_associated_methods;
      }
      return $attr;
  }
  
  sub add_override_method_modifier {
      my ($self, $name, $method, $_super_package) = @_;
  
      my $existing_method = $self->get_method($name);
      (!$existing_method)
          || throw_exception( CannotOverrideLocalMethodIsPresent => class_name => $self->name,
                                                                    method     => $existing_method,
                            );
      $self->add_method($name => Moose::Meta::Method::Overridden->new(
          method  => $method,
          class   => $self,
          package => $_super_package, # need this for roles
          name    => $name,
      ));
  }
  
  sub add_augment_method_modifier {
      my ($self, $name, $method) = @_;
      my $existing_method = $self->get_method($name);
      throw_exception( CannotAugmentIfLocalMethodPresent => class_name => $self->name,
                                                            method     => $existing_method,
                     )
          if( $existing_method );
  
      $self->add_method($name => Moose::Meta::Method::Augmented->new(
          method  => $method,
          class   => $self,
          name    => $name,
      ));
  }
  
  ## Private Utility methods ...
  
  sub _find_next_method_by_name_which_is_not_overridden {
      my ($self, $name) = @_;
      foreach my $method ($self->find_all_methods_by_name($name)) {
          return $method->{code}
              if blessed($method->{code}) && !$method->{code}->isa('Moose::Meta::Method::Overridden');
      }
      return undef;
  }
  
  ## Metaclass compatibility
  
  sub _base_metaclasses {
      my $self = shift;
      my %metaclasses = $self->SUPER::_base_metaclasses;
      for my $class (keys %metaclasses) {
          $metaclasses{$class} =~ s/^Class::MOP/Moose::Meta/;
      }
      return (
          %metaclasses,
      );
  }
  
  sub _fix_class_metaclass_incompatibility {
      my $self = shift;
      my ($super_meta) = @_;
  
      $self->SUPER::_fix_class_metaclass_incompatibility(@_);
  
      if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
          ($self->is_pristine)
              || throw_exception( CannotFixMetaclassCompatibility => class      => $self,
                                                                     superclass => $super_meta
                                );
          my $super_meta_name = $super_meta->_real_ref_name;
          my $class_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass(blessed($self), $super_meta_name);
          my $new_self = $class_meta_subclass_meta_name->reinitialize(
              $self->name,
          );
  
          $self->_replace_self( $new_self, $class_meta_subclass_meta_name );
      }
  }
  
  sub _fix_single_metaclass_incompatibility {
      my $self = shift;
      my ($metaclass_type, $super_meta) = @_;
  
      $self->SUPER::_fix_single_metaclass_incompatibility(@_);
  
      if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
          ($self->is_pristine)
              || throw_exception( CannotFixMetaclassCompatibility => class          => $self,
                                                                     superclass     => $super_meta,
                                                                     metaclass_type => $metaclass_type
                                );
          my $super_meta_name = $super_meta->_real_ref_name;
          my $class_specific_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass($self->$metaclass_type, $super_meta->$metaclass_type);
          my $new_self = $super_meta->reinitialize(
              $self->name,
              $metaclass_type => $class_specific_meta_subclass_meta_name,
          );
  
          $self->_replace_self( $new_self, $super_meta_name );
      }
  }
  
  sub _replace_self {
      my $self      = shift;
      my ( $new_self, $new_class)   = @_;
  
      %$self = %$new_self;
      bless $self, $new_class;
  
      # We need to replace the cached metaclass instance or else when it goes
      # out of scope Class::MOP::Class destroy's the namespace for the
      # metaclass's class, causing much havoc.
      my $weaken = Class::MOP::metaclass_is_weak( $self->name );
      Class::MOP::store_metaclass_by_name( $self->name, $self );
      Class::MOP::weaken_metaclass( $self->name ) if $weaken;
  }
  
  sub _process_attribute {
      my ( $self, $name, @args ) = @_;
  
      @args = %{$args[0]} if scalar @args == 1 && ref($args[0]) eq 'HASH';
  
      if (($name || '') =~ /^\+(.*)/) {
          return $self->_process_inherited_attribute($1, @args);
      }
      else {
          return $self->_process_new_attribute($name, @args);
      }
  }
  
  sub _process_new_attribute {
      my ( $self, $name, @args ) = @_;
  
      $self->attribute_metaclass->interpolate_class_and_new($name, @args);
  }
  
  sub _process_inherited_attribute {
      my ($self, $attr_name, %options) = @_;
  
      my $inherited_attr = $self->find_attribute_by_name($attr_name);
      (defined $inherited_attr)
          || throw_exception( NoAttributeFoundInSuperClass => class_name     => $self->name,
                                                              attribute_name => $attr_name,
                                                              params         => \%options
                            );
      if ($inherited_attr->isa('Moose::Meta::Attribute')) {
          return $inherited_attr->clone_and_inherit_options(%options);
      }
      else {
          # NOTE:
          # kind of a kludge to handle Class::MOP::Attributes
          return $inherited_attr->Moose::Meta::Attribute::clone_and_inherit_options(%options);
      }
  }
  
  # reinitialization support
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->SUPER::_restore_metaobjects_from($old_meta);
  
      for my $role ( @{ $old_meta->roles } ) {
          $self->add_role($role);
      }
  
      for my $application ( @{ $old_meta->_get_role_applications } ) {
          $application->class($self);
          $self->add_role_application ($application);
      }
  }
  
  ## Immutability
  
  sub _immutable_options {
      my ( $self, @args ) = @_;
  
      $self->SUPER::_immutable_options(
          inline_destructor => 1,
  
          # Moose always does this when an attribute is created
          inline_accessors => 0,
  
          @args,
      );
  }
  
  sub _fixup_attributes_after_rebless {
      my $self = shift;
      my ($instance, $rebless_from, %params) = @_;
  
      $self->SUPER::_fixup_attributes_after_rebless(
          $instance,
          $rebless_from,
          %params
      );
  
      $self->_call_all_triggers( $instance, \%params );
  }
  
  ## -------------------------------------------------
  
  our $error_level;
  
  sub _inline_throw_exception {
      my ( $self, $exception_type, $throw_args ) = @_;
      return 'die Module::Runtime::use_module("Moose::Exception::' . $exception_type . '")->new(' . ($throw_args || '') . ')';
  }
  
  1;
  
  # ABSTRACT: The Moose metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Class - The Moose metaclass
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Class> that provides
  additional Moose-specific functionality.
  
  To really understand this class, you will need to start with the
  L<Class::MOP::Class> documentation. This class can be understood as a
  set of additional features on top of the basic feature provided by
  that parent class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Class> is a subclass of L<Class::MOP::Class>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Class->initialize($package_name, %options) >>
  
  This overrides the parent's method in order to provide its own
  defaults for the C<attribute_metaclass>, C<instance_metaclass>, and
  C<method_metaclass> options.
  
  These all default to the appropriate Moose class.
  
  =item B<< Moose::Meta::Class->create($package_name, %options) >>
  
  This overrides the parent's method in order to accept a C<roles>
  option. This should be an array reference containing roles
  that the class does, each optionally followed by a hashref of options
  (C<-excludes> and C<-alias>).
  
    my $metaclass = Moose::Meta::Class->create( 'New::Class', roles => [...] );
  
  =item B<< Moose::Meta::Class->create_anon_class >>
  
  This overrides the parent's method to accept a C<roles> option, just
  as C<create> does.
  
  It also accepts a C<cache> option. If this is C<true>, then the anonymous
  class will be cached based on its superclasses and roles. If an
  existing anonymous class in the cache has the same superclasses and
  roles, it will be reused.
  
    my $metaclass = Moose::Meta::Class->create_anon_class(
        superclasses => ['Foo'],
        roles        => [qw/Some Roles Go Here/],
        cache        => 1,
    );
  
  Each entry in both the C<superclasses> and the C<roles> option can be
  followed by a hash reference with arguments. The C<superclasses>
  option can be supplied with a L<-version|Class::MOP/Class Loading
  Options> option that ensures the loaded superclass satisfies the
  required version. The C<role> option also takes the C<-version> as an
  argument, but the option hash reference can also contain any other
  role relevant values like exclusions or parameterized role arguments.
  
  =item B<< $metaclass->new_object(%params) >>
  
  This overrides the parent's method in order to add support for
  attribute triggers.
  
  =item B<< $metaclass->superclasses(@superclasses) >>
  
  This is the accessor allowing you to read or change the parents of
  the class.
  
  Each superclass can be followed by a hash reference containing a
  L<-version|Class::MOP/Class Loading Options> value. If the version
  requirement is not satisfied an error will be thrown.
  
  When you pass classes to this method, we will attempt to load them if they are
  not already loaded.
  
  =item B<< $metaclass->add_override_method_modifier($name, $sub) >>
  
  This adds an C<override> method modifier to the package.
  
  =item B<< $metaclass->add_augment_method_modifier($name, $sub) >>
  
  This adds an C<augment> method modifier to the package.
  
  =item B<< $metaclass->calculate_all_roles >>
  
  This will return a unique array of L<Moose::Meta::Role> instances
  which are attached to this class.
  
  =item B<< $metaclass->calculate_all_roles_with_inheritance >>
  
  This will return a unique array of L<Moose::Meta::Role> instances
  which are attached to this class, and each of this class's ancestors.
  
  =item B<< $metaclass->add_role($role) >>
  
  This takes a L<Moose::Meta::Role> object, and adds it to the class's
  list of roles. This I<does not> actually apply the role to the class.
  
  =item B<< $metaclass->role_applications >>
  
  Returns a list of L<Moose::Meta::Role::Application::ToClass>
  objects, which contain the arguments to role application.
  
  =item B<< $metaclass->add_role_application($application) >>
  
  This takes a L<Moose::Meta::Role::Application::ToClass> object, and
  adds it to the class's list of role applications. This I<does not>
  actually apply any role to the class; it is only for tracking role
  applications.
  
  =item B<< $metaclass->does_role($role) >>
  
  This returns a boolean indicating whether or not the class does the specified
  role. The role provided can be either a role name or a L<Moose::Meta::Role>
  object. This tests both the class and its parents.
  
  =item B<< $metaclass->excludes_role($role_name) >>
  
  A class excludes a role if it has already composed a role which
  excludes the named role. This tests both the class and its parents.
  
  =item B<< $metaclass->add_attribute($attr_name, %params|$params) >>
  
  This overrides the parent's method in order to allow the parameters to
  be provided as a hash reference.
  
  =item B<< $metaclass->constructor_class($class_name) >>
  
  =item B<< $metaclass->destructor_class($class_name) >>
  
  These are the names of classes used when making a class immutable. These
  default to L<Moose::Meta::Method::Constructor> and
  L<Moose::Meta::Method::Destructor> respectively. These accessors are
  read-write, so you can use them to change the class name.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_CLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Class/Immutable/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_CLASS_IMMUTABLE_TRAIT';
  package Moose::Meta::Class::Immutable::Trait;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::MOP;
  use Scalar::Util qw( blessed );
  
  use parent 'Class::MOP::Class::Immutable::Trait';
  
  use Moose::Util 'throw_exception';
  
  sub add_role { $_[1]->_immutable_cannot_call }
  
  sub calculate_all_roles {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{calculate_all_roles} ||= [ $self->$orig ] };
  }
  
  sub calculate_all_roles_with_inheritance {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{calculate_all_roles_with_inheritance} ||= [ $self->$orig ] };
  }
  
  sub does_role {
      shift;
      my $self = shift;
      my $role = shift;
  
      (defined $role)
          || throw_exception( RoleNameRequired => class_name => $self->name );
  
      $self->{__immutable}{does_role} ||= { map { $_->name => 1 } $self->calculate_all_roles_with_inheritance };
  
      my $name = blessed $role ? $role->name : $role;
  
      return $self->{__immutable}{does_role}{$name};
  }
  
  1;
  
  # ABSTRACT: Implements immutability for metaclass objects
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Class::Immutable::Trait - Implements immutability for metaclass objects
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class makes some Moose-specific metaclass methods immutable. This
  is deep guts.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_CLASS_IMMUTABLE_TRAIT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_INSTANCE';
  package Moose::Meta::Instance;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Instance';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  1;
  
  # ABSTRACT: The Moose Instance metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Instance - The Moose Instance metaclass
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
      # nothing to see here
  
  =head1 DESCRIPTION
  
  This class provides the low level data storage abstractions for
  attributes.
  
  Using this API directly in your own code violates encapsulation, and
  we recommend that you use the appropriate APIs in
  L<Moose::Meta::Class> and L<Moose::Meta::Attribute> instead. Those
  APIs in turn call the methods in this class as appropriate.
  
  At present, this is an empty subclass of L<Class::MOP::Instance>, so
  you should see that class for all API details.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Instance> is a subclass of L<Class::MOP::Instance>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_INSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD';
  package Moose::Meta::Method;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Method';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  1;
  
  # ABSTRACT: A Moose Method metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method - A Moose Method metaclass
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method> that provides
  additional Moose-specific functionality, all of which is private.
  
  To understand this class, you should read the the L<Class::MOP::Method>
  documentation.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method> is a subclass of L<Class::MOP::Method>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR';
  package Moose::Meta::Method::Accessor;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Try::Tiny;
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Accessor';
  
  use Moose::Util 'throw_exception';
  
  # multiple inheritance is terrible
  sub new {
      goto &Class::MOP::Method::Accessor::new;
  }
  
  sub _new {
      goto &Class::MOP::Method::Accessor::_new;
  }
  
  sub _error_thrower {
      my $self = shift;
      return $self->associated_attribute
          if ref($self) && defined($self->associated_attribute);
      return $self->SUPER::_error_thrower;
  }
  
  sub _compile_code {
      my $self = shift;
      my @args = @_;
      try {
          $self->SUPER::_compile_code(@args);
      }
      catch {
          throw_exception( CouldNotCreateWriter => attribute      => $self->associated_attribute,
                                                   error          => $_,
                                                   instance       => $self
                         );
      };
  }
  
  sub _eval_environment {
      my $self = shift;
      return $self->associated_attribute->_eval_environment;
  }
  
  sub _instance_is_inlinable {
      my $self = shift;
      return $self->associated_attribute->associated_class->instance_metaclass->is_inlinable;
  }
  
  sub _generate_reader_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_reader_method_inline(@_)
                                    : $self->SUPER::_generate_reader_method(@_);
  }
  
  sub _generate_writer_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_writer_method_inline(@_)
                                    : $self->SUPER::_generate_writer_method(@_);
  }
  
  sub _generate_accessor_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_accessor_method_inline(@_)
                                    : $self->SUPER::_generate_accessor_method(@_);
  }
  
  sub _generate_predicate_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_predicate_method_inline(@_)
                                    : $self->SUPER::_generate_predicate_method(@_);
  }
  
  sub _generate_clearer_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_clearer_method_inline(@_)
                                    : $self->SUPER::_generate_clearer_method(@_);
  }
  
  sub _writer_value_needs_copy {
      shift->associated_attribute->_writer_value_needs_copy(@_);
  }
  
  sub _inline_tc_code {
      shift->associated_attribute->_inline_tc_code(@_);
  }
  
  sub _inline_check_coercion {
      shift->associated_attribute->_inline_check_coercion(@_);
  }
  
  sub _inline_check_constraint {
      shift->associated_attribute->_inline_check_constraint(@_);
  }
  
  sub _inline_check_lazy {
      shift->associated_attribute->_inline_check_lazy(@_);
  }
  
  sub _inline_store_value {
      shift->associated_attribute->_inline_instance_set(@_) . ';';
  }
  
  sub _inline_get_old_value_for_trigger {
      shift->associated_attribute->_inline_get_old_value_for_trigger(@_);
  }
  
  sub _inline_trigger {
      shift->associated_attribute->_inline_trigger(@_);
  }
  
  sub _get_value {
      shift->associated_attribute->_inline_instance_get(@_);
  }
  
  sub _has_value {
      shift->associated_attribute->_inline_instance_has(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for accessors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Accessor - A Moose Method metaclass for accessors
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Accessor> that
  provides additional Moose-specific functionality, all of which is
  private.
  
  To understand this class, you should read the the
  L<Class::MOP::Method::Accessor> documentation.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE';
  package Moose::Meta::Method::Accessor::Native;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Carp qw( confess );
  use Scalar::Util qw( blessed );
  
  use Moose::Role;
  
  use Moose::Util 'throw_exception';
  
  around new => sub {
      my $orig = shift;
      my $class   = shift;
      my %options = @_;
  
      $options{curried_arguments} = []
          unless exists $options{curried_arguments};
  
      throw_exception( MustSupplyArrayRefAsCurriedArguments => params     => \%options,
                                                               class_name => $class
                     )
          unless $options{curried_arguments}
              && ref($options{curried_arguments}) eq 'ARRAY';
  
      my $attr_context = $options{attribute}->definition_context;
      my $desc = 'native delegation method ';
      $desc   .= $options{attribute}->associated_class->name;
      $desc   .= '::' . $options{name};
      $desc   .= " ($options{delegate_to_method})";
      $desc   .= " of attribute " . $options{attribute}->name;
      $options{definition_context} = {
          %{ $attr_context || {} },
          description => $desc,
      };
  
      $options{accessor_type} = 'native';
  
      return $class->$orig(%options);
  };
  
  sub _new {
      my $class = shift;
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless $options, $class;
  }
  
  sub root_types { (shift)->{'root_types'} }
  
  sub _initialize_body {
      my $self = shift;
  
      $self->{'body'} = $self->_compile_code( [$self->_generate_method] );
  
      return;
  }
  
  sub _inline_curried_arguments {
      my $self = shift;
  
      return unless @{ $self->curried_arguments };
  
      return 'unshift @_, @curried;';
  }
  
  sub _inline_check_argument_count {
      my $self = shift;
  
      my @code;
  
      if (my $min = $self->_minimum_arguments) {
          push @code, (
              'if (@_ < ' . $min . ') {',
                  $self->_inline_throw_exception( MethodExpectsMoreArgs =>
                                                  'method_name           => "'.$self->delegate_to_method.'",'.
                                                  "minimum_args          => ".$min,
                  ) . ';',
              '}',
          );
      }
  
      if (defined(my $max = $self->_maximum_arguments)) {
          push @code, (
              'if (@_ > ' . $max . ') {',
                  $self->_inline_throw_exception( MethodExpectsFewerArgs =>
                                                  'method_name            => "'.$self->delegate_to_method.'",'.
                                                  'maximum_args           => '.$max,
                  ) . ';',
              '}',
          );
      }
  
      return @code;
  }
  
  sub _inline_return_value {
      my $self = shift;
      my ($slot_access, $for_writer) = @_;
  
      return 'return ' . $self->_return_value($slot_access, $for_writer) . ';';
  }
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { undef }
  
  override _get_value => sub {
      my $self = shift;
      my ($instance) = @_;
  
      return $self->_slot_access_can_be_inlined
          ? super()
          : $instance . '->$reader';
  };
  
  override _inline_store_value => sub {
      my $self = shift;
      my ($instance, $value) = @_;
  
      return $self->_slot_access_can_be_inlined
          ? super()
          : $instance . '->$writer(' . $value . ');';
  };
  
  override _eval_environment => sub {
      my $self = shift;
  
      my $env = super();
  
      $env->{'@curried'} = $self->curried_arguments;
  
      return $env if $self->_slot_access_can_be_inlined;
  
      my $reader = $self->associated_attribute->get_read_method_ref;
      $reader = $reader->body if blessed $reader;
  
      $env->{'$reader'} = \$reader;
  
      my $writer = $self->associated_attribute->get_write_method_ref;
      $writer = $writer->body if blessed $writer;
  
      $env->{'$writer'} = \$writer;
  
      return $env;
  };
  
  sub _slot_access_can_be_inlined {
      my $self = shift;
  
      return $self->is_inline && $self->_instance_is_inlinable;
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY';
  package Moose::Meta::Method::Accessor::Native::Array;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  sub _inline_check_var_is_valid_index {
      my $self = shift;
      my ($var) = @_;
  
      return (
          'if (!defined(' . $var . ') || ' . $var . ' !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => '.$var.','.
                                              'method_name             => "'.$self->delegate_to_method.'",'.
                                              'type_of_argument        => "integer",'.
                                              'type                    => "Int",'.
                                              'argument_noun           => "index"',
              ) . ';',
          '}',
      );
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_WRITER';
  package Moose::Meta::Method::Accessor::Native::Array::Writer;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer',
       'Moose::Meta::Method::Accessor::Native::Array',
       'Moose::Meta::Method::Accessor::Native::Collection';
  
  sub _inline_coerce_new_values {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Collection::_inline_coerce_new_values(@_);
  }
  
  sub _new_members { '@_' }
  
  sub _copy_old_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{(' . $slot_access . ')} ]';
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_WRITER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ACCESSOR';
  package Moose::Meta::Method::Accessor::Native::Array::accessor;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::set',
       'Moose::Meta::Method::Accessor::Native::Array::get';
  
  sub _inline_process_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_process_arguments(@_);
  }
  
  sub _inline_check_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_check_arguments(@_);
  }
  
  sub _return_value {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Array::get::_return_value(@_);
  }
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
              # get
              'if (@_ == 1) {',
                  $self->_inline_check_var_is_valid_index('$_[0]'),
                  $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_return_value($slot_access),
              '}',
              # set
              'else {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 2 }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ACCESSOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_CLEAR';
  package Moose::Meta::Method::Accessor::Native::Array::clear;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value { '[]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = [];';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_CLEAR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/count.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_COUNT';
  package Moose::Meta::Method::Accessor::Native::Array::count;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_COUNT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/delete.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_DELETE';
  package Moose::Meta::Method::Accessor::Native::Array::delete;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '@return = splice @potential, $_[0], 1; '
               . '\@potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = splice @{ (' . $slot_access . ') }, $_[0], 1;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_DELETE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/elements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ELEMENTS';
  package Moose::Meta::Method::Accessor::Native::Array::elements;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ELEMENTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/first.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST';
  package Moose::Meta::Method::Accessor::Native::Array::first;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use List::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "first",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '&List::Util::first($_[0], @{ (' . $slot_access . ') })';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/first_index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST_INDEX';
  package Moose::Meta::Method::Accessor::Native::Array::first_index;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "first_index",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '&List::MoreUtils::first_index($_[0], @{ (' . $slot_access . ') })';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST_INDEX

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GET';
  package Moose::Meta::Method::Accessor::Native::Array::get;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Array';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[ $_[0] ]';
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/grep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GREP';
  package Moose::Meta::Method::Accessor::Native::Array::grep;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "grep",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'grep { $_[0]->() } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GREP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/insert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_INSERT';
  package Moose::Meta::Method::Accessor::Native::Array::insert;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { 2 }
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . 'splice @potential, $_[0], 0, $_[1]; '
               . '\@potential; '
           . '})';
  }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return '@_ = ($_[0], $member_coercion->($_[1]));';
  };
  
  sub _new_members { '$_[1]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'splice @{ (' . $slot_access . ') }, $_[0], 0, $_[1];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[ $_[0] ]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_INSERT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/is_empty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_IS_EMPTY';
  package Moose::Meta::Method::Accessor::Native::Array::is_empty;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@{ (' . $slot_access . ') } ? 0 : 1';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_IS_EMPTY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/join.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_JOIN';
  package Moose::Meta::Method::Accessor::Native::Array::join;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "join",'.
                                              'type_of_argument        => "string",'.
                                              'type                    => "Str",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'join $_[0], @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_JOIN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_MAP';
  package Moose::Meta::Method::Accessor::Native::Array::map;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "map",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { $_[0]->() } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_MAP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/natatime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_NATATIME';
  package Moose::Meta::Method::Accessor::Native::Array::natatime;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!defined($_[0]) || $_[0] !~ /^\d+$/) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "natatime",'.
                                              'type_of_argument        => "integer",'.
                                              'type                    => "Int",'.
                                              'argument_noun           => "n value"',
              ) . ';',
          '}',
          'if (@_ == 2 && !Params::Util::_CODELIKE($_[1])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[1],'.
                                              'method_name             => "natatime",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",'.
                                              'ordinal                 => "second"',
              ) . ';',
          '}',
      );
  }
  
  sub _inline_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return (
          'my $iter = List::MoreUtils::natatime($_[0], @{ (' . $slot_access . ') });',
          'if ($_[1]) {',
              'while (my @vals = $iter->()) {',
                  '$_[1]->(@vals);',
              '}',
          '}',
          'else {',
              'return $iter;',
          '}',
      );
  }
  
  # Not called, but needed to satisfy the Reader role
  sub _return_value { }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_NATATIME

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_POP';
  package Moose::Meta::Method::Accessor::Native::Array::pop;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } > 1 '
               . '? @{ (' . $slot_access . ') }[0..$#{ (' . $slot_access . ') } - 1] '
               . ': () ]';
  }
  
  sub _inline_capture_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'my $old = ' . $slot_access . '->[-1];';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'pop @{ (' . $slot_access . ') };';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$old';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_POP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/push.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_PUSH';
  package Moose::Meta::Method::Accessor::Native::Array::push;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') }, @_ ]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'push @{ (' . $slot_access . ') }, @_;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_PUSH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/reduce.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_REDUCE';
  package Moose::Meta::Method::Accessor::Native::Array::reduce;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use List::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "reduce",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::Util::reduce { $_[0]->($a, $b) } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_REDUCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SET';
  package Moose::Meta::Method::Accessor::Native::Array::set;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '$potential[$_[0]] = $_[1]; '
               . '\@potential; '
           . '})';
  }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return '@_ = ($_[0], $member_coercion->($_[1]));';
  };
  
  sub _new_members { '$_[1]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . '->[$_[0]] = $_[1];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[$_[0]]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/shallow_clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHALLOW_CLONE';
  package Moose::Meta::Method::Accessor::Native::Array::shallow_clone;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 0 }
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } ]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHALLOW_CLONE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/shift.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHIFT';
  package Moose::Meta::Method::Accessor::Native::Array::shift;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } > 1 '
               . '? @{ (' . $slot_access . ') }[1..$#{ (' . $slot_access . ') }] '
               . ': () ]';
  }
  
  sub _inline_capture_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'my $old = ' . $slot_access . '->[0];';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'shift @{ (' . $slot_access . ') };';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$old';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHIFT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/shuffle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHUFFLE';
  package Moose::Meta::Method::Accessor::Native::Array::shuffle;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use List::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::Util::shuffle @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHUFFLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/sort.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT';
  package Moose::Meta::Method::Accessor::Native::Array::sort;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (@_ && !Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "sort",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return
          'wantarray ? ( ' .
              '$_[0] '
                  . '? sort { $_[0]->($a, $b) } @{ (' . $slot_access . ') } '
                  . ': sort @{ (' . $slot_access . ') }'
              . ' ) : @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/sort_in_place.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT_IN_PLACE';
  package Moose::Meta::Method::Accessor::Native::Array::sort_in_place;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (@_ && !Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "sort_in_place",'.
                                              'type_of_argument        => "code reference",'.
                                              'type                    => "CodeRef",',
              ) . ';',
          '}',
      );
  }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ $_[0] '
               . '? sort { $_[0]->($a, $b) } @{ (' . $slot_access . ') } '
               . ': sort @{ (' . $slot_access . ') } ]';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT_IN_PLACE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/splice.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SPLICE';
  package Moose::Meta::Method::Accessor::Native::Array::splice;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _adds_members { 1 }
  
  sub _inline_process_arguments {
      return (
          'my $idx = shift;',
          'my $len = @_ ? shift : undef;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          $self->_inline_check_var_is_valid_index('$idx'),
          'if (defined($len) && $len !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $len,'.
                                              'method_name             => "splice",'.
                                              'type_of_argument        => "integer",'.
                                              'type                    => "Int",'.
                                              'argument_noun           => "length argument"',
              ) . ';',
          '}',
      );
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '@return = defined $len '
                   . '? (splice @potential, $idx, $len, @_) '
                   . ': (splice @potential, $idx); '
                   . '\@potential;'
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return (
          '@return = defined $len',
              '? (splice @{ (' . $slot_access . ') }, $idx, $len, @_)',
              ': (splice @{ (' . $slot_access . ') }, $idx);',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray ? @return : $return[-1]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SPLICE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/uniq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNIQ';
  package Moose::Meta::Method::Accessor::Native::Array::uniq;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::MoreUtils::uniq @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNIQ

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Array/unshift.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNSHIFT';
  package Moose::Meta::Method::Accessor::Native::Array::unshift;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer';
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @_, @{ (' . $slot_access . ') } ]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'unshift @{ (' . $slot_access . ') }, @_;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNSHIFT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/not.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_NOT';
  package Moose::Meta::Method::Accessor::Native::Bool::not;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '!' . $slot_access;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_NOT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_SET';
  package Moose::Meta::Method::Accessor::Native::Bool::set;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { 1 }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = 1;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_SET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/toggle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_TOGGLE';
  package Moose::Meta::Method::Accessor::Native::Bool::toggle;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' ? 0 : 1';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = ' . $slot_access . ' ? 0 : 1;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_TOGGLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Bool/unset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_UNSET';
  package Moose::Meta::Method::Accessor::Native::Bool::unset;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { 0 }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = 0;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_UNSET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Code/execute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE';
  package Moose::Meta::Method::Accessor::Native::Code::execute;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->(@_)';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Code/execute_method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE_METHOD';
  package Moose::Meta::Method::Accessor::Native::Code::execute_method;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->($self, @_)';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE_METHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COLLECTION';
  package Moose::Meta::Method::Accessor::Native::Collection;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  requires qw( _adds_members );
  
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return (
          '(' . $self->_new_members . ') = map { $member_coercion->($_) }',
                                               $self->_new_members . ';',
      );
  }
  
  sub _tc_member_type_can_coerce {
      my $self = shift;
  
      my $member_tc = $self->_tc_member_type;
  
      return $member_tc && $member_tc->has_coercion;
  }
  
  sub _tc_member_type {
      my $self = shift;
  
      my $tc = $self->associated_attribute->type_constraint;
      while ($tc) {
          return $tc->type_parameter
              if $tc->can('type_parameter');
          $tc = $tc->parent;
      }
  
      return;
  }
  
  sub _writer_value_needs_copy {
      my $self = shift;
  
      return $self->_constraint_must_be_checked
          && !$self->_check_new_members_only;
  }
  
  sub _inline_tc_code {
      my $self = shift;
      my ($value, $tc, $coercion, $message, $is_lazy) = @_;
  
      return unless $self->_constraint_must_be_checked;
  
      if ($self->_check_new_members_only) {
          return unless $self->_adds_members;
  
          return $self->_inline_check_member_constraint($self->_new_members);
      }
      else {
          return (
              $self->_inline_check_coercion($value, $tc, $coercion, $is_lazy),
              $self->_inline_check_constraint($value, $tc, $message, $is_lazy),
          );
      }
  }
  
  sub _check_new_members_only {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      my $tc = $attr->type_constraint;
  
      # If we have a coercion, we could come up with an entirely new value after
      # coercing, so we need to check everything,
      return 0 if $attr->should_coerce && $tc->has_coercion;
  
      # If the parent is our root type (ArrayRef, HashRef, etc), that means we
      # can just check the new members of the collection, because we know that
      # we will always be generating an appropriate collection type.
      #
      # However, if this type has its own constraint (it's Parameteriz_able_,
      # not Paramet_erized_), we don't know what is being checked by the
      # constraint, so we need to check the whole value, not just the members.
      return 1
          if $self->_is_root_type( $tc->parent )
              && ( $tc->isa('Moose::Meta::TypeConstraint::Parameterized')
                   || $tc->isa('Specio::Constraint::Parameterized') );
  
      return 0;
  }
  
  sub _inline_check_member_constraint {
      my $self = shift;
      my ($new_value) = @_;
  
      my $attr_name = $self->associated_attribute->name;
  
      my $check
          = $self->_tc_member_type->can_be_inlined
          ? '! (' . $self->_tc_member_type->_inline_check('$new_val') . ')'
          : ' !$member_tc->($new_val) ';
  
      return (
          'for my $new_val (' . $new_value . ') {',
              "if ($check) {",
                  'my $msg = do { local $_ = $new_val; $member_message->($new_val) };'.
                  $self->_inline_throw_exception( ValidationFailedForInlineTypeConstraint =>
                                                  "attribute_name          => '".$attr_name."',".
                                                  'type_constraint_message => $msg,'.
                                                  'class_name              => $class_name,'.
                                                  'value                   => $new_val,'.
                                                  'new_member              => 1',
                  ) . ';',
              '}',
          '}',
      );
  }
  
  sub _inline_get_old_value_for_trigger {
      my $self = shift;
      my ($instance, $old) = @_;
  
      my $attr = $self->associated_attribute;
      return unless $attr->has_trigger;
  
      return (
          'my ' . $old . ' = ' . $self->_has_value($instance),
              '? ' . $self->_copy_old_value($self->_get_value($instance)),
              ': ();',
      );
  }
  
  around _eval_environment => sub {
      my $orig = shift;
      my $self = shift;
  
      my $env = $self->$orig(@_);
  
      my $member_tc = $self->_tc_member_type;
  
      return $env unless $member_tc;
  
      $env->{'$member_tc'} = \( $member_tc->_compiled_type_constraint );
      $env->{'$member_coercion'} = \(
          $member_tc->coercion->_compiled_type_coercion
      ) if $member_tc->has_coercion;
      $env->{'$member_message'} = \(
          $member_tc->has_message
              ? $member_tc->message
              : $member_tc->_default_message
      );
  
      my $tc_env = $member_tc->inline_environment();
  
      $env = { %{$env}, %{$tc_env} };
  
      return $env;
  };
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COLLECTION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_WRITER';
  package Moose::Meta::Method::Accessor::Native::Counter::Writer;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _constraint_must_be_checked {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      return $attr->has_type_constraint
          && ($attr->type_constraint->name =~ /^(?:Num|Int)$/
           || ($attr->should_coerce && $attr->type_constraint->has_coercion)
             );
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_WRITER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/dec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_DEC';
  package Moose::Meta::Method::Accessor::Native::Counter::dec;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' - (defined $_[0] ? $_[0] : 1)';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' -= defined $_[0] ? $_[0] : 1;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_DEC

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/inc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_INC';
  package Moose::Meta::Method::Accessor::Native::Counter::inc;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' + (defined $_[0] ? $_[0] : 1)';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' += defined $_[0] ? $_[0] : 1;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_INC

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/reset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_RESET';
  package Moose::Meta::Method::Accessor::Native::Counter::reset;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      my $attr = $self->associated_attribute;
  
      return '(do { '
               . join(' ', $attr->_inline_generate_default(
                     '$self', '$default_for_reset'
                 )) . ' '
               . '$default_for_reset; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = ' . $self->_potential_value . ';';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_RESET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Counter/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_SET';
  package Moose::Meta::Method::Accessor::Native::Counter::set;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value { '$_[0]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_SET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH';
  package Moose::Meta::Method::Accessor::Native::Hash;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  sub _inline_check_var_is_valid_key {
      my $self = shift;
      my ($var) = @_;
  
      return (
          'if (!defined(' . $var . ')) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => '.$var.','.
                                              'method_name             => "'.$self->delegate_to_method.'",'.
                                              'type_of_argument        => "defined value",'.
                                              'type                    => "Defined",'.
                                              'argument_noun           => "key"',
              ) . ';',
          '}',
      );
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_WRITER';
  package Moose::Meta::Method::Accessor::Native::Hash::Writer;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer',
       'Moose::Meta::Method::Accessor::Native::Hash',
       'Moose::Meta::Method::Accessor::Native::Collection';
  
  sub _inline_coerce_new_values {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Collection::_inline_coerce_new_values(@_);
  }
  
  sub _new_values { '@values' }
  
  sub _copy_old_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') } }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_WRITER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ACCESSOR';
  package Moose::Meta::Method::Accessor::Native::Hash::accessor;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::set',
       'Moose::Meta::Method::Accessor::Native::Hash::get';
  
  sub _inline_process_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_process_arguments(@_);
  }
  
  sub _inline_check_argument_count {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_check_argument_count(@_);
  }
  
  sub _inline_check_arguments {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_inline_check_arguments(@_);
  }
  
  sub _return_value {
      my $self = shift;
      $self->Moose::Meta::Method::Accessor::Native::Hash::set::_return_value(@_);
  }
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
              # get
              'if (@_ == 1) {',
                  $self->_inline_check_var_is_valid_key('$_[0]'),
                  $slot_access . '->{$_[0]}',
              '}',
              # set
              'else {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 2 }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ACCESSOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_CLEAR';
  package Moose::Meta::Method::Accessor::Native::Hash::clear;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value { '{}' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = {};';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_CLEAR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/count.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_COUNT';
  package Moose::Meta::Method::Accessor::Native::Hash::count;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_COUNT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/defined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DEFINED';
  package Moose::Meta::Method::Accessor::Native::Hash::defined;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_key('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'defined ' . $slot_access . '->{ $_[0] }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DEFINED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/delete.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DELETE';
  package Moose::Meta::Method::Accessor::Native::Hash::delete;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my %potential = %{ (' . $slot_access . ') }; '
               . '@return = delete @potential{@_}; '
               . '\%potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = delete @{ (' . $slot_access . ') }{@_};';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray ? @return : $return[-1]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DELETE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/elements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ELEMENTS';
  package Moose::Meta::Method::Accessor::Native::Hash::elements;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { $_, ' . $slot_access . '->{$_} } '
               . 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ELEMENTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/exists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_EXISTS';
  package Moose::Meta::Method::Accessor::Native::Hash::exists;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_key('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = shift;
  
      return 'exists ' . $slot_access . '->{ $_[0] }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_EXISTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_GET';
  package Moose::Meta::Method::Accessor::Native::Hash::get;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'for (@_) {',
              $self->_inline_check_var_is_valid_key('$_'),
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@_ > 1 '
               . '? @{ (' . $slot_access . ') }{@_} '
               . ': ' . $slot_access . '->{$_[0]}';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_GET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/is_empty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_IS_EMPTY';
  package Moose::Meta::Method::Accessor::Native::Hash::is_empty;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar keys %{ (' . $slot_access . ') } ? 0 : 1';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_IS_EMPTY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/keys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KEYS';
  package Moose::Meta::Method::Accessor::Native::Hash::keys;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KEYS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/kv.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KV';
  package Moose::Meta::Method::Accessor::Native::Hash::kv;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { [ $_, ' . $slot_access . '->{$_} ] } '
               . 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KV

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SET';
  package Moose::Meta::Method::Accessor::Native::Hash::set;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer';
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { undef }
  
  around _inline_check_argument_count => sub {
      my $orig = shift;
      my $self = shift;
  
      return (
          $self->$orig(@_),
          'if (@_ % 2) {',
              $self->_inline_throw_exception( MustPassEvenNumberOfArguments =>
                                              "method_name => '".$self->delegate_to_method."',".
                                              'args        => \@_',
              ) . ';',
          '}',
      );
  };
  
  sub _inline_process_arguments {
      my $self = shift;
  
      return (
          'my @keys_idx = grep { ! ($_ % 2) } 0..$#_;',
          'my @values_idx = grep { $_ % 2 } 0..$#_;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'for (@keys_idx) {',
              'if (!defined($_[$_])) {',
                  $self->_inline_throw_exception( UndefinedHashKeysPassedToMethod =>
                                                  'hash_keys                       => \@keys_idx,'.
                                                  "method_name                     => '".$self->delegate_to_method."'",
                  ) . ';',
              '}',
          '}',
      );
  }
  
  sub _adds_members { 1 }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      # Is there a simpler way to do this?
      return (
          'my $iter = List::MoreUtils::natatime(2, @_);',
          '@_ = ();',
          'while (my ($key, $val) = $iter->()) {',
              'push @_, $key, $member_coercion->($val);',
          '}',
      );
  };
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') }, @_ }';
  }
  
  sub _new_members { '@_[ @values_idx ]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@{ (' . $slot_access . ') }{ @_[@keys_idx] } = @_[@values_idx];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray '
               . '? @{ (' . $slot_access . ') }{ @_[@keys_idx] } '
               . ': ' . $slot_access . '->{ $_[$keys_idx[0]] }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/shallow_clone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SHALLOW_CLONE';
  package Moose::Meta::Method::Accessor::Native::Hash::shallow_clone;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 0 }
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') } }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SHALLOW_CLONE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Hash/values.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_VALUES';
  package Moose::Meta::Method::Accessor::Native::Hash::values;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'values %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_VALUES

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/abs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ABS';
  package Moose::Meta::Method::Accessor::Native::Number::abs;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'abs(' . $slot_access . ')';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = abs(' . $slot_access . ');';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ABS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/add.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ADD';
  package Moose::Meta::Method::Accessor::Native::Number::add;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' + $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' += $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ADD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/div.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_DIV';
  package Moose::Meta::Method::Accessor::Native::Number::div;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' / $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' /= $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_DIV

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/mod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MOD';
  package Moose::Meta::Method::Accessor::Native::Number::mod;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' % $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' %= $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/mul.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MUL';
  package Moose::Meta::Method::Accessor::Native::Number::mul;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' * $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' *= $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MUL

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SET';
  package Moose::Meta::Method::Accessor::Native::Number::set;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value { '$_[0]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SET

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Number/sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SUB';
  package Moose::Meta::Method::Accessor::Native::Number::sub;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' - $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' -= $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SUB

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_READER';
  package Moose::Meta::Method::Accessor::Native::Reader;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native';
  
  requires '_return_value';
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_reader_core($inv, $slot_access, @_),
          '}',
      );
  }
  
  sub _inline_reader_core {
      my $self = shift;
      my ($inv, $slot_access, @extra) = @_;
  
      return (
          $self->_inline_check_argument_count,
          $self->_inline_process_arguments($inv, $slot_access),
          $self->_inline_check_arguments,
          $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
          $self->_inline_return_value($slot_access),
      );
  }
  
  sub _inline_process_arguments { return }
  
  sub _inline_check_arguments { return }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_READER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/append.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_APPEND';
  package Moose::Meta::Method::Accessor::Native::String::append;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '( ' . $slot_access . ' . $_[0] )';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' .= $_[0];';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_APPEND

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/chomp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOMP';
  package Moose::Meta::Method::Accessor::Native::String::chomp;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '@return = chomp $val; '
               . '$val '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = chomp ' . $slot_access . ';';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOMP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/chop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOP';
  package Moose::Meta::Method::Accessor::Native::String::chop;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '@return = chop $val; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = chop ' . $slot_access . ';';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOP

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/clear.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CLEAR';
  package Moose::Meta::Method::Accessor::Native::String::clear;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { '""' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = "";';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CLEAR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/inc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_INC';
  package Moose::Meta::Method::Accessor::Native::String::inc;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '$val++; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . '++;';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_INC

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/length.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_LENGTH';
  package Moose::Meta::Method::Accessor::Native::String::length;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'length ' . $slot_access;
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_LENGTH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_MATCH';
  package Moose::Meta::Method::Accessor::Native::String::match;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'type                    => "Str|RegexpRef",'.
                                              'type_of_argument        => "string or regexp reference",'.
                                              'method_name             => "match"',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' =~ $_[0]';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_MATCH

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/prepend.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_PREPEND';
  package Moose::Meta::Method::Accessor::Native::String::prepend;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$_[0] . ' . $slot_access;
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0] . ' . $slot_access . ';';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_PREPEND

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/replace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_REPLACE';
  package Moose::Meta::Method::Accessor::Native::String::replace;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[0],'.
                                              'method_name             => "replace",'.
                                              'ordinal                 => "first",'.
                                              'type_of_argument        => "string or regexp reference",'.
                                              'type                    => "Str|RegexpRef"',
              ) . ';',
          '}',
          'if (!Moose::Util::_STRINGLIKE0($_[1]) && !Params::Util::_CODELIKE($_[1])) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $_[1],'.
                                              'method_name             => "replace",'.
                                              'ordinal                 => "second",'.
                                              'type_of_argument        => "string or code reference",'.
                                              'type                    => "Str|CodeRef"',
              ) . ';',
          '}',
      );
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . 'ref $_[1] '
                   . '? $val =~ s/$_[0]/$_[1]->()/e '
                   . ': $val =~ s/$_[0]/$_[1]/; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return (
          'ref $_[1]',
              '? ' . $slot_access . ' =~ s/$_[0]/$_[1]->()/e',
              ': ' . $slot_access . ' =~ s/$_[0]/$_[1]/;',
       );
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_REPLACE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/String/substr.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_SUBSTR';
  package Moose::Meta::Method::Accessor::Native::String::substr;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader',
       'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              'if (@_ == 1 || @_ == 2) {',
                  $self->_inline_reader_core($inv, $slot_access),
              '}',
              'elsif (@_ == 3) {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
              'else {',
                  $self->_inline_check_argument_count,
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 3 }
  
  sub _inline_process_arguments {
      my $self = shift;
      my ($inv, $slot_access) = @_;
  
      return (
          'my $offset = shift;',
          'my $length = @_ ? shift : length ' . $slot_access . ';',
          'my $replacement = shift;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
      my ($for_writer) = @_;
  
      my @code = (
          'if ($offset !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $offset,'.
                                              'ordinal                 => "first",'.
                                              'type_of_argument        => "integer",'.
                                              'method_name             => "substr",'.
                                              'type                    => "Int"',
              ) . ';',
          '}',
          'if ($length !~ /^-?\d+$/) {',
              $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                              'argument                => $length,'.
                                              'ordinal                 => "second",'.
                                              'type_of_argument        => "integer",'.
                                              'method_name             => "substr",'.
                                              'type                    => "Int"',
              ) . ';',
          '}',
      );
  
      if ($for_writer) {
          push @code, (
              'if (!Moose::Util::_STRINGLIKE0($replacement)) {',
                  $self->_inline_throw_exception( InvalidArgumentToMethod =>
                                                  'argument                => $replacement,'.
                                                  'ordinal                 => "third",'.
                                                  'type_of_argument        => "string",'.
                                                  'method_name             => "substr",'.
                                                  'type                    => "Str"',
                  ) . ';',
              '}',
          );
      }
  
      return @code;
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $potential = ' . $slot_access . '; '
               . '@return = substr $potential, $offset, $length, $replacement; '
               . '$potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = substr ' . $slot_access . ', '
                             . '$offset, $length, $replacement;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access, $for_writer) = @_;
  
      return '$return[0]' if $for_writer;
  
      return 'substr ' . $slot_access . ', $offset, $length';
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_SUBSTR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Accessor/Native/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_WRITER';
  package Moose::Meta::Method::Accessor::Native::Writer;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use List::Util 1.33 qw( any );
  use Moose::Util;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native';
  
  requires '_potential_value';
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_writer_core($inv, $slot_access),
          '}',
      );
  }
  
  sub _inline_writer_core {
      my $self = shift;
      my ($inv, $slot_access) = @_;
  
      my $potential = $self->_potential_value($slot_access);
      my $old       = '@old';
  
      my @code;
      push @code, (
          $self->_inline_check_argument_count,
          $self->_inline_process_arguments($inv, $slot_access),
          $self->_inline_check_arguments('for writer'),
          $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
      );
  
      if ($self->_return_value($slot_access)) {
          # some writers will save the return value in this variable when they
          # generate the potential value.
          push @code, 'my @return;'
      }
  
      push @code, (
          $self->_inline_coerce_new_values,
          $self->_inline_copy_native_value(\$potential),
          $self->_inline_tc_code($potential, '$type_constraint', '$type_coercion', '$type_message'),
          $self->_inline_get_old_value_for_trigger($inv, $old),
          $self->_inline_capture_return_value($slot_access),
          $self->_inline_set_new_value($inv, $potential, $slot_access),
          $self->_inline_trigger($inv, $slot_access, $old),
          $self->_inline_return_value($slot_access, 'for writer'),
      );
  
      return @code;
  }
  
  sub _inline_process_arguments { return }
  
  sub _inline_check_arguments { return }
  
  sub _inline_coerce_new_values { return }
  
  sub _writer_value_needs_copy {
      my $self = shift;
  
      return $self->_constraint_must_be_checked;
  }
  
  sub _constraint_must_be_checked {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      return $attr->has_type_constraint
          && ( !$self->_is_root_type( $attr->type_constraint )
          || ( $attr->should_coerce && $attr->type_constraint->has_coercion ) );
  }
  
  sub _is_root_type {
      my $self = shift;
      my $type = shift;
  
      if (   blessed($type)
          && $type->can('does')
          && $type->does('Specio::Constraint::Role::Interface') )
      {
          require Specio::Library::Builtins;
          return
              any { $type->is_same_type_as( Specio::Library::Builtins::t($_) ) }
          @{ $self->root_types };
      }
      else {
          my $name = $type->name;
          return any { $name eq $_ } @{ $self->root_types };
      }
  }
  
  sub _inline_copy_native_value {
      my $self = shift;
      my ($potential_ref) = @_;
  
      return unless $self->_writer_value_needs_copy;
  
      my $code = 'my $potential = ' . ${$potential_ref} . ';';
  
      ${$potential_ref} = '$potential';
  
      return $code;
  }
  
  around _inline_tc_code => sub {
      my $orig = shift;
      my $self = shift;
      my ($value, $tc, $coercion, $message, $for_lazy) = @_;
  
      return unless $for_lazy || $self->_constraint_must_be_checked;
  
      return $self->$orig(@_);
  };
  
  around _inline_check_constraint => sub {
      my $orig = shift;
      my $self = shift;
      my ($value, $tc, $message, $for_lazy) = @_;
  
      return unless $for_lazy || $self->_constraint_must_be_checked;
  
      return $self->$orig(@_);
  };
  
  sub _inline_capture_return_value { return }
  
  sub _inline_set_new_value {
      my $self = shift;
  
      return $self->_inline_store_value(@_)
          if $self->_writer_value_needs_copy
          || !$self->_slot_access_can_be_inlined
          || !$self->_get_is_lvalue;
  
      return $self->_inline_optimized_set_new_value(@_);
  }
  
  sub _get_is_lvalue {
      my $self = shift;
  
      return $self->associated_attribute->associated_class->instance_metaclass->inline_get_is_lvalue;
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
  
      return $self->_inline_store_value(@_);
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access;
  }
  
  no Moose::Role;
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_ACCESSOR_NATIVE_WRITER

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Augmented.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_AUGMENTED';
  package Moose::Meta::Method::Augmented;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my ( $class, %args ) = @_;
  
      # the package can be overridden by roles
      # it is really more like body's compilation stash
      # this is where we need to override the definition of super() so that the
      # body of the code can call the right overridden version
      my $name = $args{name};
      my $meta = $args{class};
  
      my $super = $meta->find_next_method_by_name($name);
  
      (defined $super)
          || throw_exception( CannotAugmentNoSuperMethod => params      => \%args,
                                                            class       => $class,
                                                            method_name => $name
                            );
  
      my $_super_package = $super->package_name;
      # BUT!,... if this is an overridden method ....
      if ($super->isa('Moose::Meta::Method::Overridden')) {
          # we need to be sure that we actually
          # find the next method, which is not
          # an 'override' method, the reason is
          # that an 'override' method will not
          # be the one calling inner()
          my $real_super = $meta->_find_next_method_by_name_which_is_not_overridden($name);
          $_super_package = $real_super->package_name;
      }
  
      my $super_body = $super->body;
  
      my $method = $args{method};
  
      my $body = sub {
          local $Moose::INNER_ARGS{$_super_package} = [ @_ ];
          local $Moose::INNER_BODY{$_super_package} = $method;
          $super_body->(@_);
      };
  
      # FIXME store additional attrs
      $class->wrap(
          $body,
          package_name => $meta->name,
          name         => $name
      );
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for augmented methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Augmented - A Moose Method metaclass for augmented methods
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class implements method augmentation logic for the L<Moose>
  C<augment> keyword.
  
  The augmentation subroutine reference will be invoked explicitly using
  the C<inner> keyword from the parent class's method definition.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Augmented> is a subclass of L<Moose::Meta::Method>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Method::Augmented->new(%options)
  
  This constructs a new object. It accepts the following options:
  
  =over 4
  
  =item * class
  
  The metaclass object for the class in which the augmentation is being
  declared. This option is required.
  
  =item * name
  
  The name of the method which we are augmenting. This method must exist
  in one of the class's superclasses. This option is required.
  
  =item * method
  
  The subroutine reference which implements the augmentation. This
  option is required.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_AUGMENTED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_CONSTRUCTOR';
  package Moose::Meta::Method::Constructor;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'weaken';
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Constructor';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      my $meta = $options{metaclass};
  
      (ref $options{options} eq 'HASH')
          || throw_exception( MustPassAHashOfOptions => params => \%options,
                                                        class  => $class
                            );
  
      ($options{package_name} && $options{name})
          || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = bless {
          'body'          => undef,
          'package_name'  => $options{package_name},
          'name'          => $options{name},
          'options'       => $options{options},
          'associated_metaclass' => $meta,
          'definition_context' => $options{definition_context},
          '_expected_method_class' => $options{_expected_method_class} || 'Moose::Object',
      } => $class;
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  ## method
  
  sub _initialize_body {
      my $self = shift;
      $self->{'body'} = $self->_generate_constructor_method_inline;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for constructors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Constructor - Method Meta Object for constructors
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Constructor> that
  provides additional Moose-specific functionality
  
  To understand this class, you should read the the
  L<Class::MOP::Method::Constructor> documentation as well.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Constructor> is a subclass of
  L<Moose::Meta::Method> I<and> L<Class::MOP::Method::Constructor>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_CONSTRUCTOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Delegation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_DELEGATION';
  package Moose::Meta::Method::Delegation;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'weaken';
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Generated';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      ( exists $options{attribute} )
          || throw_exception( MustSupplyAnAttributeToConstructWith => params => \%options,
                                                                      class  => $class
                            );
  
      ( blessed( $options{attribute} )
              && $options{attribute}->isa('Moose::Meta::Attribute') )
          || throw_exception( MustSupplyAMooseMetaAttributeInstance => params => \%options,
                                                                       class  => $class
                            );
  
      ( $options{package_name} && $options{name} )
          || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      ( $options{delegate_to_method} && ( !ref $options{delegate_to_method} )
              || ( 'CODE' eq ref $options{delegate_to_method} ) )
          || throw_exception( MustSupplyADelegateToMethod => params => \%options,
                                                             class  => $class
                            );
  
      exists $options{curried_arguments}
          || ( $options{curried_arguments} = [] );
  
      ( $options{curried_arguments} &&
          ( 'ARRAY' eq ref $options{curried_arguments} ) )
          || throw_exception( MustSupplyArrayRefAsCurriedArguments => params     => \%options,
                                                                      class_name => $class
                            );
  
      my $self = $class->_new( \%options );
  
      weaken( $self->{'attribute'} );
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless $options, $class;
  }
  
  sub curried_arguments { (shift)->{'curried_arguments'} }
  
  sub associated_attribute { (shift)->{'attribute'} }
  
  sub delegate_to_method { (shift)->{'delegate_to_method'} }
  
  sub _initialize_body {
      my $self = shift;
  
      my $method_to_call = $self->delegate_to_method;
      return $self->{body} = $method_to_call
          if ref $method_to_call;
  
      my $accessor = $self->_get_delegate_accessor;
  
      my $handle_name = $self->name;
  
      # NOTE: we used to do a goto here, but the goto didn't handle
      # failure correctly (it just returned nothing), so I took that
      # out. However, the more I thought about it, the less I liked it
      # doing the goto, and I preferred the act of delegation being
      # actually represented in the stack trace.  - SL
      # not inlining this, since it won't really speed things up at
      # all... the only thing that would end up different would be
      # interpolating in $method_to_call, and a bunch of things in the
      # error handling that mostly never gets called - doy
      $self->{body} = sub {
          my $instance = shift;
          my $proxy    = $instance->$accessor();
  
          if( !defined $proxy ) {
              throw_exception( AttributeValueIsNotDefined => method     => $self,
                                                             instance   => $instance,
                                                             attribute  => $self->associated_attribute,
                             );
          }
          elsif( ref($proxy) && !blessed($proxy) ) {
              throw_exception( AttributeValueIsNotAnObject => method      => $self,
                                                              instance    => $instance,
                                                              attribute   => $self->associated_attribute,
                                                              given_value => $proxy
                             );
          }
  
          unshift @_, @{ $self->curried_arguments };
          $proxy->$method_to_call(@_);
      };
  }
  
  sub _get_delegate_accessor {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      # NOTE:
      # always use a named method when
      # possible, if you use the method
      # ref and there are modifiers on
      # the accessors then it will not
      # pick up the modifiers too. Only
      # the named method will assure that
      # we also have any modifiers run.
      # - SL
      my $accessor = $attr->has_read_method
          ? $attr->get_read_method
          : $attr->get_read_method_ref;
  
      $accessor = $accessor->body if Scalar::Util::blessed $accessor;
  
      return $accessor;
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for delegation methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Delegation - A Moose Method metaclass for delegation methods
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Moose::Meta::Method> for delegation
  methods.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Method::Delegation->new(%options)
  
  This creates the delegation methods based on the provided C<%options>.
  
  =over 4
  
  =item I<attribute>
  
  This must be an instance of C<Moose::Meta::Attribute> which this
  accessor is being generated for. This options is B<required>.
  
  =item I<delegate_to_method>
  
  The method in the associated attribute's value to which we
  delegate. This can be either a method name or a code reference.
  
  =item I<curried_arguments>
  
  An array reference of arguments that will be prepended to the argument list for
  any call to the delegating method.
  
  =back
  
  =head2 $metamethod->associated_attribute
  
  Returns the attribute associated with this method.
  
  =head2 $metamethod->curried_arguments
  
  Return any curried arguments that will be passed to the delegated method.
  
  =head2 $metamethod->delegate_to_method
  
  Returns the method to which this method delegates, as passed to the
  constructor.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_DELEGATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Destructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_DESTRUCTOR';
  package Moose::Meta::Method::Destructor;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Devel::GlobalDestruction ();
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Inlined';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (ref $options{options} eq 'HASH')
          || throw_exception( MustPassAHashOfOptions => params => \%options,
                                                        class  => $class
                            );
  
      ($options{package_name} && $options{name})
          || throw_exception( MustSupplyPackageNameAndName => params => \%options,
                                                              class  => $class
                            );
  
      my $self = bless {
          # from our superclass
          'body'                 => undef,
          'package_name'         => $options{package_name},
          'name'                 => $options{name},
          # ...
          'options'              => $options{options},
          'definition_context'   => $options{definition_context},
          'associated_metaclass' => $options{metaclass},
      } => $class;
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  ## accessors
  
  sub options              { (shift)->{'options'}              }
  
  ## method
  
  sub is_needed {
      my $self      = shift;
      my $metaclass = shift;
  
      ( blessed $metaclass && $metaclass->isa('Class::MOP::Class') )
          || throw_exception( MethodExpectedAMetaclassObject => metaclass => $metaclass,
                                                                class     => $self
                            );
  
      return $metaclass->find_method_by_name("DEMOLISHALL");
  }
  
  sub _initialize_body {
      my $self = shift;
      # TODO:
      # the %options should also include a both
      # a call 'initializer' and call 'SUPER::'
      # options, which should cover approx 90%
      # of the possible use cases (even if it
      # requires some adaption on the part of
      # the author, after all, nothing is free)
  
      my $class = $self->associated_metaclass->name;
      my @source = (
          'sub {',
              'my $self = shift;',
              'return ' . $self->_generate_fallback_destructor('$self'),
                  'if Scalar::Util::blessed($self) ne \'' . $class . '\';',
              $self->_generate_DEMOLISHALL('$self'),
              'return;',
          '}',
      );
      warn join("\n", @source) if $self->options->{debug};
  
      my $code = try {
          $self->_compile_code(source => \@source);
      }
      catch {
          my $source = join("\n", @source);
          throw_exception( CouldNotEvalDestructor => method_destructor_object => $self,
                                                     source                   => $source,
                                                     error                    => $_
                         );
      };
  
      $self->{'body'} = $code;
  }
  
  sub _generate_fallback_destructor {
      my $self = shift;
      my ($inv) = @_;
  
      return $inv . '->Moose::Object::DESTROY(@_)';
  }
  
  sub _generate_DEMOLISHALL {
      my $self = shift;
      my ($inv) = @_;
  
      my @methods = $self->associated_metaclass->find_all_methods_by_name('DEMOLISH');
      return unless @methods;
  
      return (
          'local $?;',
          'my $igd = Devel::GlobalDestruction::in_global_destruction;',
          'Try::Tiny::try {',
              (map { $inv . '->' . $_->{class} . '::DEMOLISH($igd);' } @methods),
          '}',
          'Try::Tiny::catch {',
              'die $_;',
          '};',
      );
  }
  
  
  1;
  
  # ABSTRACT: Method Meta Object for destructors
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Destructor - Method Meta Object for destructors
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Inlined> that
  provides Moose-specific functionality for inlining destructors.
  
  To understand this class, you should read the
  L<Class::MOP::Method::Inlined> documentation as well.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Destructor> is a subclass of
  L<Moose::Meta::Method> I<and> L<Class::MOP::Method::Inlined>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Method::Destructor->new(%options)
  
  This constructs a new object. It accepts the following options:
  
  =over 4
  
  =item * package_name
  
  The package for the class in which the destructor is being
  inlined. This option is required.
  
  =item * name
  
  The name of the destructor method. This option is required.
  
  =item * metaclass
  
  The metaclass for the class this destructor belongs to. This is
  optional, as it can be set later by calling C<<
  $metamethod->attach_to_class >>.
  
  =back
  
  =head2 Moose::Meta;:Method::Destructor->is_needed($metaclass)
  
  Given a L<Moose::Meta::Class> object, this method returns a boolean
  indicating whether the class needs a destructor. If the class or any
  of its parents defines a C<DEMOLISH> method, it needs a destructor.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_DESTRUCTOR

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_META';
  package Moose::Meta::Method::Meta;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method',
           'Class::MOP::Method::Meta';
  
  sub _is_caller_mop_internal {
      my $self = shift;
      my ($caller) = @_;
      return 1 if $caller =~ /^Moose(?:::|$)/;
      return $self->SUPER::_is_caller_mop_internal($caller);
  }
  
  # XXX: ugh multiple inheritance
  sub wrap {
      my $class = shift;
      return $class->Class::MOP::Method::Meta::wrap(@_);
  }
  
  sub _make_compatible_with {
      my $self = shift;
      return $self->Class::MOP::Method::Meta::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for C<meta> methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Meta - A Moose Method metaclass for C<meta> methods
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Meta> that
  provides additional Moose-specific functionality, all of which is
  private.
  
  To understand this class, you should read the the
  L<Class::MOP::Method::Meta> documentation.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_META

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Method/Overridden.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_OVERRIDDEN';
  package Moose::Meta::Method::Overridden;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method';
  
  use Moose::Util 'throw_exception';
  
  sub new {
      my ( $class, %args ) = @_;
  
      # the package can be overridden by roles
      # it is really more like body's compilation stash
      # this is where we need to override the definition of super() so that the
      # body of the code can call the right overridden version
      my $super_package = $args{package} || $args{class}->name;
  
      my $name = $args{name};
  
      my $super = $args{class}->find_next_method_by_name($name);
  
      (defined $super)
          || throw_exception( CannotOverrideNoSuperMethod => class       => $class,
                                                             params      => \%args,
                                                             method_name => $name
                            );
  
      my $super_body = $super->body;
  
      my $method = $args{method};
  
      my $body = sub {
          local $Moose::SUPER_PACKAGE = $super_package;
          local @Moose::SUPER_ARGS = @_;
          local $Moose::SUPER_BODY = $super_body;
          return $method->(@_);
      };
  
      # FIXME do we need this make sure this works for next::method?
      # subname "${super_package}::${name}", $method;
  
      # FIXME store additional attrs
      $class->wrap(
          $body,
          package_name => $args{class}->name,
          name         => $name
      );
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for overridden methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Method::Overridden - A Moose Method metaclass for overridden methods
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class implements method overriding logic for the L<Moose>
  C<override> keyword.
  
  The overriding subroutine's parent will be invoked explicitly using
  the C<super> keyword from the parent class's method definition.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Method::Overridden->new(%options)
  
  This constructs a new object. It accepts the following options:
  
  =over 4
  
  =item * class
  
  The metaclass object for the class in which the override is being
  declared. This option is required.
  
  =item * name
  
  The name of the method which we are overriding. This method must exist
  in one of the class's superclasses. This option is required.
  
  =item * method
  
  The subroutine reference which implements the overriding. This option
  is required.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_METHOD_OVERRIDDEN

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Mixin/AttributeCore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_MIXIN_ATTRIBUTECORE';
  package Moose::Meta::Mixin::AttributeCore;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use parent 'Class::MOP::Mixin::AttributeCore';
  
  __PACKAGE__->meta->add_attribute(
      'isa' => (
          reader => '_isa_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'does' => (
          reader => '_does_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'is' => (
          reader => '_is_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'required' => (
          reader => 'is_required',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'lazy' => (
          reader => 'is_lazy', Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'lazy_build' => (
          reader => 'is_lazy_build',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'coerce' => (
          reader => 'should_coerce',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'weak_ref' => (
          reader => 'is_weak_ref',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'auto_deref' => (
          reader => 'should_auto_deref',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'type_constraint' => (
          reader    => 'type_constraint',
          predicate => 'has_type_constraint',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'trigger' => (
          reader    => 'trigger',
          predicate => 'has_trigger',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'handles' => (
          reader    => 'handles',
          writer    => '_set_handles',
          predicate => 'has_handles',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'documentation' => (
          reader    => 'documentation',
          predicate => 'has_documentation',
          Class::MOP::_definition_context(),
      )
  );
  
  1;
  
  # ABSTRACT: Core attributes shared by attribute metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Mixin::AttributeCore - Core attributes shared by attribute metaclasses
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class implements the core attributes (aka properties) shared by all Moose
  attributes. See the L<Moose::Meta::Attribute> documentation for API details.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_MIXIN_ATTRIBUTECORE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Object/Trait.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_OBJECT_TRAIT';
  package Moose::Meta::Object::Trait;
  our $VERSION = '2.1603';
  
  use Scalar::Util qw(blessed);
  
  sub _get_compatible_metaclass {
      my $orig = shift;
      my $self = shift;
      return $self->$orig(@_)
          || $self->_get_compatible_metaclass_by_role_reconciliation(@_);
  }
  
  sub _get_compatible_metaclass_by_role_reconciliation {
      my $self = shift;
      my ($other_name) = @_;
      my $meta_name = blessed($self) ? $self->_real_ref_name : $self;
  
      return unless Moose::Util::_classes_differ_by_roles_only(
          $meta_name, $other_name
      );
  
      return Moose::Util::_reconcile_roles_for_metaclass(
          $meta_name, $other_name
      );
  }
  
  1;
  
  # ABSTRACT: Some overrides for L<Class::MOP::Object> functionality
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Object::Trait - Some overrides for L<Class::MOP::Object> functionality
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This module is entirely private, you shouldn't ever need to interact with
  it directly.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_OBJECT_TRAIT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE';
  package Moose::Meta::Role;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use Moose::Meta::Class;
  use Moose::Meta::Role::Attribute;
  use Moose::Meta::Role::Method;
  use Moose::Meta::Role::Method::Required;
  use Moose::Meta::Role::Method::Conflicting;
  use Moose::Meta::Method::Meta;
  use Moose::Util qw/throw_exception/;
  use Class::MOP::MiniTrait;
  
  use parent 'Class::MOP::Module',
           'Class::MOP::Mixin::HasAttributes',
           'Class::MOP::Mixin::HasMethods',
           'Class::MOP::Mixin::HasOverloads';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  ## ------------------------------------------------------------------
  ## NOTE:
  ## I normally don't do this, but I am doing
  ## a whole bunch of meta-programmin' in this
  ## module, so it just makes sense. For a clearer
  ## picture of what is going on in the next
  ## several lines of code, look at the really
  ## big comment at the end of this file (right
  ## before the POD).
  ## - SL
  ## ------------------------------------------------------------------
  
  my $META = __PACKAGE__->meta;
  
  ## ------------------------------------------------------------------
  ## attributes ...
  
  # NOTE:
  # since roles are lazy, we hold all the attributes
  # of the individual role in 'stasis' until which
  # time when it is applied to a class. This means
  # keeping a lot of things in hash maps, so we are
  # using a little of that meta-programmin' magic
  # here and saving lots of extra typin'. And since
  # many of these attributes above require similar
  # functionality to support them, so we again use
  # the wonders of meta-programmin' to deliver a
  # very compact solution to this normally verbose
  # problem.
  # - SL
  
  foreach my $action (
      {
          name        => 'excluded_roles_map',
          attr_reader => 'get_excluded_roles_map' ,
          methods     => {
              add       => 'add_excluded_roles',
              get_keys  => 'get_excluded_roles_list',
              existence => 'excludes_role',
          }
      },
      {
          name        => 'required_methods',
          attr_reader => 'get_required_methods_map',
          methods     => {
              remove     => 'remove_required_methods',
              get_values => 'get_required_method_list',
              existence  => 'requires_method',
          }
      },
  ) {
  
      my $attr_reader = $action->{attr_reader};
      my $methods     = $action->{methods};
  
      # create the attribute
      $META->add_attribute($action->{name} => (
          reader  => $attr_reader,
          default => sub { {} },
          Class::MOP::_definition_context(),
      ));
  
      # create some helper methods
      $META->add_method($methods->{add} => sub {
          my ($self, @values) = @_;
          $self->$attr_reader->{$_} = undef foreach @values;
      }) if exists $methods->{add};
  
      $META->add_method($methods->{get_keys} => sub {
          my ($self) = @_;
          keys %{$self->$attr_reader};
      }) if exists $methods->{get_keys};
  
      $META->add_method($methods->{get_values} => sub {
          my ($self) = @_;
          values %{$self->$attr_reader};
      }) if exists $methods->{get_values};
  
      $META->add_method($methods->{get} => sub {
          my ($self, $name) = @_;
          $self->$attr_reader->{$name}
      }) if exists $methods->{get};
  
      $META->add_method($methods->{existence} => sub {
          my ($self, $name) = @_;
          exists $self->$attr_reader->{$name} ? 1 : 0;
      }) if exists $methods->{existence};
  
      $META->add_method($methods->{remove} => sub {
          my ($self, @values) = @_;
          delete $self->$attr_reader->{$_} foreach @values;
      }) if exists $methods->{remove};
  }
  
  $META->add_attribute(
      'method_metaclass',
      reader  => 'method_metaclass',
      default => 'Moose::Meta::Role::Method',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'required_method_metaclass',
      reader  => 'required_method_metaclass',
      default => 'Moose::Meta::Role::Method::Required',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'conflicting_method_metaclass',
      reader  => 'conflicting_method_metaclass',
      default => 'Moose::Meta::Role::Method::Conflicting',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_class_class',
      reader  => 'application_to_class_class',
      default => 'Moose::Meta::Role::Application::ToClass',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_role_class',
      reader  => 'application_to_role_class',
      default => 'Moose::Meta::Role::Application::ToRole',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_instance_class',
      reader  => 'application_to_instance_class',
      default => 'Moose::Meta::Role::Application::ToInstance',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'applied_attribute_metaclass',
      reader  => 'applied_attribute_metaclass',
      default => 'Moose::Meta::Attribute',
      Class::MOP::_definition_context(),
  );
  
  # More or less copied from Moose::Meta::Class
  sub initialize {
      my $class = shift;
      my @args = @_;
      unshift @args, 'package' if @args % 2;
      my %opts = @args;
      my $package = delete $opts{package};
      return Class::MOP::get_metaclass_by_name($package)
          || $class->SUPER::initialize($package,
                  'attribute_metaclass' => 'Moose::Meta::Role::Attribute',
                  %opts,
              );
  }
  
  sub reinitialize {
      my $self = shift;
      my $pkg  = shift;
  
      my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);
  
      my %existing_classes;
      if ($meta) {
          %existing_classes = map { $_ => $meta->$_() } qw(
              attribute_metaclass
              method_metaclass
              wrapped_method_metaclass
              required_method_metaclass
              conflicting_method_metaclass
              application_to_class_class
              application_to_role_class
              application_to_instance_class
              applied_attribute_metaclass
          );
      }
  
      my %options = @_;
      $options{weaken} = Class::MOP::metaclass_is_weak($meta->name)
          if !exists $options{weaken}
          && blessed($meta)
          && $meta->isa('Moose::Meta::Role');
  
      # don't need to remove generated metaobjects here yet, since we don't
      # yet generate anything in roles. this may change in the future though...
      # keep an eye on that
      my $new_meta = $self->SUPER::reinitialize(
          $pkg,
          %existing_classes,
          %options,
      );
      $new_meta->_restore_metaobjects_from($meta)
          if $meta && $meta->isa('Moose::Meta::Role');
      return $new_meta;
  }
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->_restore_metamethods_from($old_meta);
      $self->_restore_metaattributes_from($old_meta);
  
      for my $role ( @{ $old_meta->get_roles } ) {
          $self->add_role($role);
      }
  }
  
  sub add_attribute {
      my $self = shift;
  
      if (blessed $_[0] && ! $_[0]->isa('Moose::Meta::Role::Attribute') ) {
          my $class = ref $_[0];
          throw_exception( CannotAddAsAnAttributeToARole => role_name       => $self->name,
                                                            attribute_class => $class,
                         );
      }
      elsif (!blessed($_[0]) && defined($_[0]) && $_[0] =~ /^\+(.*)/) {
          throw_exception( AttributeExtensionIsNotSupportedInRoles => attribute_name => $_[0],
                                                                      role_name      => $self->name,
                         );
      }
  
      return $self->SUPER::add_attribute(@_);
  }
  
  sub _attach_attribute {
      my ( $self, $attribute ) = @_;
  
      $attribute->attach_to_role($self);
  }
  
  sub add_required_methods {
      my $self = shift;
  
      for (@_) {
          my $method = $_;
          if (!blessed($method)) {
              $method = $self->required_method_metaclass->new(
                  name => $method,
              );
          }
          $self->get_required_methods_map->{$method->name} = $method;
      }
  }
  
  sub add_conflicting_method {
      my $self = shift;
  
      my $method;
      if (@_ == 1 && blessed($_[0])) {
          $method = shift;
      }
      else {
          $method = $self->conflicting_method_metaclass->new(@_);
      }
  
      $self->add_required_methods($method);
  }
  
  ## ------------------------------------------------------------------
  ## method modifiers
  
  # NOTE:
  # the before/around/after method modifiers are
  # stored by name, but there can be many methods
  # then associated with that name. So again we have
  # lots of similar functionality, so we can do some
  # meta-programmin' and save some time.
  # - SL
  
  foreach my $modifier_type (qw[ before around after ]) {
  
      my $attr_reader = "get_${modifier_type}_method_modifiers_map";
  
      # create the attribute ...
      $META->add_attribute("${modifier_type}_method_modifiers" => (
          reader  => $attr_reader,
          default => sub { {} },
          Class::MOP::_definition_context(),
      ));
  
      # and some helper methods ...
      $META->add_method("get_${modifier_type}_method_modifiers" => sub {
          my ($self, $method_name) = @_;
          #return () unless exists $self->$attr_reader->{$method_name};
          my $mm = $self->$attr_reader->{$method_name};
          $mm ? @$mm : ();
      });
  
      $META->add_method("has_${modifier_type}_method_modifiers" => sub {
          my ($self, $method_name) = @_;
          # NOTE:
          # for now we assume that if it exists,..
          # it has at least one modifier in it
          (exists $self->$attr_reader->{$method_name}) ? 1 : 0;
      });
  
      $META->add_method("add_${modifier_type}_method_modifier" => sub {
          my ($self, $method_name, $method) = @_;
  
          $self->$attr_reader->{$method_name} = []
              unless exists $self->$attr_reader->{$method_name};
  
          my $modifiers = $self->$attr_reader->{$method_name};
  
          # NOTE:
          # check to see that we aren't adding the
          # same code twice. We err in favor of the
          # first on here, this may not be as expected
          foreach my $modifier (@{$modifiers}) {
              return if $modifier == $method;
          }
  
          push @{$modifiers} => $method;
      });
  
  }
  
  ## ------------------------------------------------------------------
  ## override method modifiers
  
  $META->add_attribute('override_method_modifiers' => (
      reader  => 'get_override_method_modifiers_map',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  # NOTE:
  # these are a little different because there
  # can only be one per name, whereas the other
  # method modifiers can have multiples.
  # - SL
  
  sub add_override_method_modifier {
      my ($self, $method_name, $method) = @_;
      (!$self->has_method($method_name))
          || throw_exception( CannotOverrideALocalMethod => method_name => $method_name,
                                                            role_name   => $self->name,
                            );
      $self->get_override_method_modifiers_map->{$method_name} = $method;
  }
  
  sub has_override_method_modifier {
      my ($self, $method_name) = @_;
      # NOTE:
      # for now we assume that if it exists,..
      # it has at least one modifier in it
      (exists $self->get_override_method_modifiers_map->{$method_name}) ? 1 : 0;
  }
  
  sub get_override_method_modifier {
      my ($self, $method_name) = @_;
      $self->get_override_method_modifiers_map->{$method_name};
  }
  
  ## general list accessor ...
  
  sub get_method_modifier_list {
      my ($self, $modifier_type) = @_;
      my $accessor = "get_${modifier_type}_method_modifiers_map";
      keys %{$self->$accessor};
  }
  
  sub _meta_method_class { 'Moose::Meta::Method::Meta' }
  
  ## ------------------------------------------------------------------
  ## subroles
  
  $META->add_attribute('roles' => (
      reader  => 'get_roles',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  sub add_role {
      my ($self, $role) = @_;
      (blessed($role) && $role->isa('Moose::Meta::Role'))
          || throw_exception( AddRoleToARoleTakesAMooseMetaRole => role_to_be_added => $role,
                                                                   role_name        => $self->name,
                            );
      push @{$self->get_roles} => $role;
      $self->reset_package_cache_flag;
  }
  
  sub calculate_all_roles {
      my $self = shift;
      my %seen;
      grep {
          !$seen{$_->name}++
      } ($self, map {
                    $_->calculate_all_roles
                } @{ $self->get_roles });
  }
  
  sub does_role {
      my ($self, $role) = @_;
      (defined $role)
          || throw_exception( RoleNameRequiredForMooseMetaRole => role_name => $self->name );
      my $role_name = blessed $role ? $role->name : $role;
      # if we are it,.. then return true
      return 1 if $role_name eq $self->name;
      # otherwise.. check our children
      foreach my $role (@{$self->get_roles}) {
          return 1 if $role->does_role($role_name);
      }
      return 0;
  }
  
  sub find_method_by_name { (shift)->get_method(@_) }
  
  ## ------------------------------------------------------------------
  ## role construction
  ## ------------------------------------------------------------------
  
  sub apply {
      my ($self, $other, %args) = @_;
  
      (blessed($other))
          || throw_exception( ApplyTakesABlessedInstance => param     => $other,
                                                            role_name => $self->name,
                            );
  
      my $application_class;
      if ($other->isa('Moose::Meta::Role')) {
          $application_class = $self->application_to_role_class;
      }
      elsif ($other->isa('Moose::Meta::Class')) {
          $application_class = $self->application_to_class_class;
      }
      else {
          $application_class = $self->application_to_instance_class;
      }
  
      Moose::Util::_load_user_class($application_class);
  
      if ( exists $args{'-excludes'} ) {
          # I wish we had coercion here :)
          $args{'-excludes'} = (
              ref $args{'-excludes'} eq 'ARRAY'
              ? $args{'-excludes'}
              : [ $args{'-excludes'} ]
          );
      }
  
      return $application_class->new(%args)->apply($self, $other, \%args);
  }
  
  sub composition_class_roles { }
  
  sub combine {
      my ($class, @role_specs) = @_;
  
      require Moose::Meta::Role::Composite;
  
      my (@roles, %role_params);
      while (@role_specs) {
          my ($role, $params) = @{ splice @role_specs, 0, 1 };
          my $requested_role
              = blessed $role
              ? $role
              : Class::MOP::class_of($role);
  
          my $actual_role = $requested_role->_role_for_combination($params);
          push @roles => $actual_role;
  
          next unless defined $params;
          $role_params{$actual_role->name} = $params;
      }
  
      my $c = Moose::Meta::Role::Composite->new(roles => \@roles);
      return $c->apply_params(\%role_params);
  }
  
  sub _role_for_combination {
      my ($self, $params) = @_;
      return $self;
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{attributes} eq 'HASH')
          || throw_exception( CreateTakesHashRefOfAttributes => params           => \%options,
                                                                attribute_class  => $class
                            )
              if exists $options{attributes};
  
      (ref $options{methods} eq 'HASH')
          || throw_exception( CreateTakesHashRefOfMethods => params           => \%options,
                                                             attribute_class  => $class
                            )
              if exists $options{methods};
  
      (ref $options{roles} eq 'ARRAY')
          || throw_exception( CreateTakesArrayRefOfRoles => params           => \%options,
                                                            attribute_class  => $class
                            )
              if exists $options{roles};
  
      my $package      = delete $options{package};
      my $roles        = delete $options{roles};
      my $attributes   = delete $options{attributes};
      my $methods      = delete $options{methods};
      my $meta_name    = exists $options{meta_name}
                           ? delete $options{meta_name}
                           : 'meta';
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  
      if (defined $attributes) {
          foreach my $attribute_name (keys %{$attributes}) {
              my $attr = $attributes->{$attribute_name};
              $meta->add_attribute(
                  $attribute_name => blessed $attr ? $attr : %{$attr} );
          }
      }
  
      if (defined $methods) {
          foreach my $method_name (keys %{$methods}) {
              $meta->add_method($method_name, $methods->{$method_name});
          }
      }
  
      if ($roles) {
          Moose::Util::apply_all_roles($meta, @$roles);
      }
  
      return $meta;
  }
  
  sub consumers {
      my $self = shift;
      my @consumers;
      for my $meta (Class::MOP::get_all_metaclass_instances) {
          next if $meta->name eq $self->name;
          next unless $meta->isa('Moose::Meta::Class')
                   || $meta->isa('Moose::Meta::Role');
          push @consumers, $meta->name
              if $meta->does_role($self->name);
      }
      return @consumers;
  }
  
  # XXX: something more intelligent here?
  sub _anon_package_prefix { 'Moose::Meta::Role::__ANON__::SERIAL::' }
  
  sub create_anon_role { shift->create_anon(@_) }
  sub is_anon_role     { shift->is_anon(@_)     }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
  
      # XXX fix this duplication (see MMC::_anon_cache_key
      my $roles = Data::OptList::mkopt(($options{roles} || []), {
          moniker  => 'role',
          val_test => sub { ref($_[0]) eq 'HASH' },
      });
  
      my @role_keys;
      for my $role_spec (@$roles) {
          my ($role, $params) = @$role_spec;
          $params = { %$params };
  
          my $key = blessed($role) ? $role->name : $role;
  
          if ($params && %$params) {
              my $alias    = delete $params->{'-alias'}
                          || delete $params->{'alias'}
                          || {};
              my $excludes = delete $params->{'-excludes'}
                          || delete $params->{'excludes'}
                          || [];
              $excludes = [$excludes] unless ref($excludes) eq 'ARRAY';
  
              if (%$params) {
                  warn "Roles with parameters cannot be cached. Consider "
                     . "applying the parameters before calling "
                     . "create_anon_class, or using 'weaken => 0' instead";
                  return;
              }
  
              my $alias_key = join('%',
                  map { $_ => $alias->{$_} } sort keys %$alias
              );
              my $excludes_key = join('%',
                  sort @$excludes
              );
              $key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
          }
  
          push @role_keys, $key;
      }
  
      # Makes something like Role|Role::1
      return join('|', sort @role_keys);
  }
  
  #####################################################################
  ## NOTE:
  ## This is Moose::Meta::Role as defined by Moose (plus the use of
  ## MooseX::AttributeHelpers module). It is here as a reference to
  ## make it easier to see what is happening above with all the meta
  ## programming. - SL
  #####################################################################
  #
  # has 'roles' => (
  #     metaclass => 'Array',
  #     reader    => 'get_roles',
  #     isa       => 'ArrayRef[Moose::Meta::Role]',
  #     default   => sub { [] },
  #     provides  => {
  #         'push' => 'add_role',
  #     }
  # );
  #
  # has 'excluded_roles_map' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_excluded_roles_map',
  #     isa       => 'HashRef[Str]',
  #     provides  => {
  #         # Not exactly set, cause it sets multiple
  #         'set'    => 'add_excluded_roles',
  #         'keys'   => 'get_excluded_roles_list',
  #         'exists' => 'excludes_role',
  #     }
  # );
  #
  # has 'required_methods' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_required_methods_map',
  #     isa       => 'HashRef[Moose::Meta::Role::Method::Required]',
  #     provides  => {
  #         # not exactly set, or delete since it works for multiple
  #         'set'    => 'add_required_methods',
  #         'delete' => 'remove_required_methods',
  #         'keys'   => 'get_required_method_list',
  #         'exists' => 'requires_method',
  #     }
  # );
  #
  # # the before, around and after modifiers are
  # # HASH keyed by method-name, with ARRAY of
  # # CODE refs to apply in that order
  #
  # has 'before_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_before_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_before_method_modifiers',
  #         'exists' => 'has_before_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_before_method_modifier'
  #     }
  # );
  #
  # has 'after_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_after_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_after_method_modifiers',
  #         'exists' => 'has_after_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_after_method_modifier'
  #     }
  # );
  #
  # has 'around_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_around_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_around_method_modifiers',
  #         'exists' => 'has_around_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_around_method_modifier'
  #     }
  # );
  #
  # # override is similar to the other modifiers
  # # except that it is not an ARRAY of code refs
  # # but instead just a single name->code mapping
  #
  # has 'override_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_override_method_modifiers_map',
  #     isa       => 'HashRef[CodeRef]',
  #     provides  => {
  #         'keys'   => 'get_override_method_modifier',
  #         'exists' => 'has_override_method_modifier',
  #         'add'    => 'add_override_method_modifier', # checks for local method ..
  #     }
  # );
  #
  #####################################################################
  
  
  1;
  
  # ABSTRACT: The Moose Role metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role - The Moose Role metaclass
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Module> that provides
  additional Moose-specific functionality.
  
  Its API looks a lot like L<Moose::Meta::Class>, but internally it
  implements many things differently. This may change in the future.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role> is a subclass of L<Class::MOP::Module>.
  
  =head1 METHODS
  
  =head2 Construction
  
  =head3 Moose::Meta::Role->initialize($role_name)
  
  This method creates a new role object with the provided name.
  
  =head3 Moose::Meta::Role->combine( [ $role => { ... } ], [ $role ], ... )
  
  This method accepts a list of array references. Each array reference
  should contain a role name or L<Moose::Meta::Role> object as its first element. The second element is
  an optional hash reference. The hash reference can contain C<-excludes>
  and C<-alias> keys to control how methods are composed from the role.
  
  The return value is a new L<Moose::Meta::Role::Composite> that
  represents the combined roles.
  
  =head3 $metarole->composition_class_roles
  
  When combining multiple roles using C<combine>, this method is used to obtain a
  list of role names to be applied to the L<Moose::Meta::Role::Composite>
  instance returned by C<combine>. The default implementation returns an empty
  list. Extensions that need to hook into role combination may wrap this method
  to return additional role names.
  
  =head3 Moose::Meta::Role->create($name, %options)
  
  This method is identical to the L<Moose::Meta::Class> C<create>
  method.
  
  =head3 Moose::Meta::Role->create_anon_role
  
  This method is identical to the L<Moose::Meta::Class>
  C<create_anon_class> method.
  
  =head3 $metarole->is_anon_role
  
  Returns true if the role is an anonymous role.
  
  =head3 $metarole->consumers
  
  Returns a list of names of classes and roles which consume this role.
  
  =head2 Role application
  
  =head3 $metarole->apply( $thing, @options )
  
  This method applies a role to the given C<$thing>. That can be another
  L<Moose::Meta::Role>, object, a L<Moose::Meta::Class> object, or a
  (non-meta) object instance.
  
  The options are passed directly to the constructor for the appropriate
  L<Moose::Meta::Role::Application> subclass.
  
  Note that this will apply the role even if the C<$thing> in question already
  C<does> this role.  L<Moose::Util/does_role> is a convenient wrapper for
  finding out if role application is necessary.
  
  =head2 Roles and other roles
  
  =head3 $metarole->get_roles
  
  This returns an array reference of roles which this role does. This
  list may include duplicates.
  
  =head3 $metarole->calculate_all_roles
  
  This returns a I<unique> list of all roles that this role does, and
  all the roles that its roles do.
  
  =head3 $metarole->does_role($role)
  
  Given a role I<name> or L<Moose::Meta::Role> object, returns true if this role
  does the given role.
  
  =head3 $metarole->add_role($role)
  
  Given a L<Moose::Meta::Role> object, this adds the role to the list of
  roles that the role does.
  
  =head3 $metarole->get_excluded_roles_list
  
  Returns a list of role names which this role excludes.
  
  =head3 $metarole->excludes_role($role_name)
  
  Given a role I<name>, returns true if this role excludes the named
  role.
  
  =head3 $metarole->add_excluded_roles(@role_names)
  
  Given one or more role names, adds those roles to the list of excluded
  roles.
  
  =head2 Methods
  
  The methods for dealing with a role's methods are all identical in API
  and behavior to the same methods in L<Class::MOP::Class>.
  
  =head3 $metarole->method_metaclass
  
  Returns the method metaclass name for the role. This defaults to
  L<Moose::Meta::Role::Method>.
  
  =head3 $metarole->get_method($name)
  
  =head3 $metarole->has_method($name)
  
  =head3 $metarole->add_method( $name, $body )
  
  =head3 $metarole->get_method_list
  
  =head3 $metarole->find_method_by_name($name)
  
  These methods are all identical to the methods of the same name in
  L<Class::MOP::Package>
  
  =head2 Attributes
  
  As with methods, the methods for dealing with a role's attribute are
  all identical in API and behavior to the same methods in
  L<Class::MOP::Class>.
  
  However, attributes stored in this class are I<not> stored as
  objects. Rather, the attribute definition is stored as a hash
  reference. When a role is composed into a class, this hash reference
  is passed directly to the metaclass's C<add_attribute> method.
  
  This is quite likely to change in the future.
  
  =head3 $metarole->get_attribute($attribute_name)
  
  =head3 $metarole->has_attribute($attribute_name)
  
  =head3 $metarole->get_attribute_list
  
  =head3 $metarole->add_attribute($name, %options)
  
  =head3 $metarole->remove_attribute($attribute_name)
  
  =head2 Overload introspection and creation
  
  The methods for dealing with a role's overloads are all identical in API and
  behavior to the same methods in L<Class::MOP::Class>.
  
  =head3 $metarole->is_overloaded
  
  =head3 $metarole->get_overloaded_operator($op)
  
  =head3 $metarole->has_overloaded_operator($op)
  
  =head3 $metarole->get_overload_list
  
  =head3 $metarole->get_all_overloaded_operators
  
  =head3 $metarole->add_overloaded_operator($op, $impl)
  
  =head3 $metarole->remove_overloaded_operator($op)
  
  =head2 Required methods
  
  =head3 $metarole->get_required_method_list
  
  Returns the list of methods required by the role.
  
  =head3 $metarole->requires_method($name)
  
  Returns true if the role requires the named method.
  
  =head3 $metarole->add_required_methods(@names)
  
  Adds the named methods to the role's list of required methods.
  
  =head3 $metarole->remove_required_methods(@names)
  
  Removes the named methods from the role's list of required methods.
  
  =head3 $metarole->add_conflicting_method(%params)
  
  Instantiate the parameters as a L<Moose::Meta::Role::Method::Conflicting>
  object, then add it to the required method list.
  
  =head2 Method modifiers
  
  These methods act like their counterparts in L<Class::MOP::Class> and
  L<Moose::Meta::Class>.
  
  However, method modifiers are simply stored internally, and are not
  applied until the role itself is applied to a class.
  
  =head3 $metarole->add_after_method_modifier($method_name, $method)
  
  =head3 $metarole->add_around_method_modifier($method_name, $method)
  
  =head3 $metarole->add_before_method_modifier($method_name, $method)
  
  =head3 $metarole->add_override_method_modifier($method_name, $method)
  
  These methods all add an appropriate modifier to the internal list of
  modifiers.
  
  =head3 $metarole->has_after_method_modifiers
  
  =head3 $metarole->has_around_method_modifiers
  
  =head3 $metarole->has_before_method_modifiers
  
  =head3 $metarole->has_override_method_modifier
  
  Return true if the role has any modifiers of the given type.
  
  =head3 $metarole->get_after_method_modifiers($method_name)
  
  =head3 $metarole->get_around_method_modifiers($method_name)
  
  =head3 $metarole->get_before_method_modifiers($method_name)
  
  Given a method name, returns a list of the appropriate modifiers for
  that method.
  
  =head3 $metarole->get_override_method_modifier($method_name)
  
  Given a method name, returns the override method modifier for that
  method, if it has one.
  
  =head2 Introspection
  
  =head3 Moose::Meta::Role->meta
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Application.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION';
  package Moose::Meta::Role::Application;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  use overload ();
  
  use List::Util 1.33 qw( all );
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('method_exclusions' => (
      init_arg => '-excludes',
      reader   => 'get_method_exclusions',
      default  => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('method_aliases' => (
      init_arg => '-alias',
      reader   => 'get_method_aliases',
      default  => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my ($class, %params) = @_;
      $class->_new(\%params);
  }
  
  sub is_method_excluded {
      my ($self, $method_name) = @_;
      foreach (@{$self->get_method_exclusions}) {
          return 1 if $_ eq $method_name;
      }
      return 0;
  }
  
  sub is_method_aliased {
      my ($self, $method_name) = @_;
      exists $self->get_method_aliases->{$method_name} ? 1 : 0
  }
  
  sub is_aliased_method {
      my ($self, $method_name) = @_;
      my %aliased_names = reverse %{$self->get_method_aliases};
      exists $aliased_names{$method_name} ? 1 : 0;
  }
  
  sub apply {
      my $self = shift;
  
      $self->check_role_exclusions(@_);
      $self->check_required_methods(@_);
      $self->check_required_attributes(@_);
  
      $self->apply_overloading(@_);
      $self->apply_attributes(@_);
      $self->apply_methods(@_);
  
      $self->apply_override_method_modifiers(@_);
  
      $self->apply_before_method_modifiers(@_);
      $self->apply_around_method_modifiers(@_);
      $self->apply_after_method_modifiers(@_);
  }
  
  sub check_role_exclusions           { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub check_required_methods          { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub check_required_attributes       { throw_exception( "CannotCallAnAbstractMethod" ); }
  
  sub apply_attributes                { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub apply_methods                   { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub apply_override_method_modifiers { throw_exception( "CannotCallAnAbstractMethod" ); }
  sub apply_method_modifiers          { throw_exception( "CannotCallAnAbstractMethod" ); }
  
  sub apply_before_method_modifiers   { (shift)->apply_method_modifiers('before' => @_) }
  sub apply_around_method_modifiers   { (shift)->apply_method_modifiers('around' => @_) }
  sub apply_after_method_modifiers    { (shift)->apply_method_modifiers('after'  => @_) }
  
  sub apply_overloading {
      my ( $self, $role, $other ) = @_;
  
      return unless $role->is_overloaded;
  
      unless ( $other->is_overloaded ) {
          $other->set_overload_fallback_value(
              $role->get_overload_fallback_value );
      }
  
      for my $overload ( $role->get_all_overloaded_operators ) {
          next if $other->has_overloaded_operator( $overload->operator );
          $other->add_overloaded_operator(
              $overload->operator => $overload->clone );
      }
  }
  
  1;
  
  # ABSTRACT: A base class for role application
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application - A base class for role application
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This is the abstract base class for role applications.
  
  The API for this class and its subclasses still needs some
  consideration, and is intentionally not yet documented.
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<get_method_exclusions>
  
  =item B<is_method_excluded>
  
  =item B<get_method_aliases>
  
  =item B<is_aliased_method>
  
  =item B<is_method_aliased>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_overloading>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_before_method_modifiers>
  
  =item B<apply_after_method_modifiers>
  
  =item B<apply_around_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Application/RoleSummation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_ROLESUMMATION';
  package Moose::Meta::Role::Application::RoleSummation;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use List::Util 1.33 qw( all );
  use Scalar::Util 'blessed';
  
  use Moose::Meta::Role::Composite;
  
  use parent 'Moose::Meta::Role::Application';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('role_params' => (
      reader  => 'role_params',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub get_exclusions_for_role {
      my ($self, $role) = @_;
      $role = $role->name if blessed $role;
      my $excludes_key = exists $self->role_params->{$role}->{'-excludes'} ?
                             '-excludes' : 'excludes';
      if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$excludes_key}) {
          if (ref $self->role_params->{$role}->{$excludes_key} eq 'ARRAY') {
              return $self->role_params->{$role}->{$excludes_key};
          }
          return [ $self->role_params->{$role}->{$excludes_key} ];
      }
      return [];
  }
  
  sub get_method_aliases_for_role {
      my ($self, $role) = @_;
      $role = $role->name if blessed $role;
      my $alias_key = exists $self->role_params->{$role}->{'-alias'} ?
                          '-alias' : 'alias';
      if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$alias_key}) {
          return $self->role_params->{$role}->{$alias_key};
      }
      return {};
  }
  
  sub is_method_excluded {
      my ($self, $role, $method_name) = @_;
      foreach ($self->get_exclusions_for_role($role->name)) {
          return 1 if $_ eq $method_name;
      }
      return 0;
  }
  
  sub is_method_aliased {
      my ($self, $role, $method_name) = @_;
      exists $self->get_method_aliases_for_role($role->name)->{$method_name} ? 1 : 0
  }
  
  sub is_aliased_method {
      my ($self, $role, $method_name) = @_;
      my %aliased_names = reverse %{$self->get_method_aliases_for_role($role->name)};
      exists $aliased_names{$method_name} ? 1 : 0;
  }
  
  sub check_role_exclusions {
      my ($self, $c) = @_;
  
      my %excluded_roles;
      for my $role (@{ $c->get_roles }) {
          my $name = $role->name;
  
          for my $excluded ($role->get_excluded_roles_list) {
              push @{ $excluded_roles{$excluded} }, $name;
          }
      }
  
      foreach my $role (@{$c->get_roles}) {
          foreach my $excluded (keys %excluded_roles) {
              next unless $role->does_role($excluded);
  
              my @excluding = @{ $excluded_roles{$excluded} };
  
              throw_exception( RoleExclusionConflict => roles     => \@excluding,
                                                        role_name => $excluded
                             );
          }
      }
  
      $c->add_excluded_roles(keys %excluded_roles);
  }
  
  sub check_required_methods {
      my ($self, $c) = @_;
  
      my %all_required_methods =
          map { $_->name => $_ }
          map { $_->get_required_method_list }
          @{$c->get_roles};
  
      foreach my $role (@{$c->get_roles}) {
          foreach my $required (keys %all_required_methods) {
  
              delete $all_required_methods{$required}
                  if $role->has_method($required)
                  || $self->is_aliased_method($role, $required);
          }
      }
  
      $c->add_required_methods(values %all_required_methods);
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $c) = @_;
  
      my @all_attributes;
  
      for my $role ( @{ $c->get_roles } ) {
          push @all_attributes,
              map { $role->get_attribute($_) } $role->get_attribute_list;
      }
  
      my %seen;
      foreach my $attr (@all_attributes) {
          my $name = $attr->name;
  
          if ( exists $seen{$name} ) {
              next if $seen{$name}->is_same_as($attr);
  
              my $role1 = $seen{$name}->associated_role->name;
              my $role2 = $attr->associated_role->name;
  
              throw_exception( AttributeConflictInSummation => attribute_name   => $name,
                                                               role_name        => $role1,
                                                               second_role_name => $role2,
                             );
          }
  
          $seen{$name} = $attr;
      }
  
      foreach my $attr (@all_attributes) {
          $c->add_attribute( $attr->clone );
      }
  }
  
  sub apply_methods {
      my ($self, $c) = @_;
  
      my @all_methods = map {
          my $role     = $_;
          my $aliases  = $self->get_method_aliases_for_role($role);
          my %excludes = map { $_ => undef } @{ $self->get_exclusions_for_role($role) };
          (
              (map {
                  exists $excludes{$_} ? () :
                  +{
                      role   => $role,
                      name   => $_,
                      method => $role->get_method($_),
                  }
              } map { $_->name }
                grep { !$_->isa('Class::MOP::Method::Meta') }
                     $role->_get_local_methods),
              (map {
                  +{
                      role   => $role,
                      name   => $aliases->{$_},
                      method => $role->get_method($_),
                  }
              } keys %$aliases)
          );
      } @{$c->get_roles};
  
      my (%seen, %conflicts, %method_map);
      foreach my $method (@all_methods) {
          next if $conflicts{$method->{name}};
          my $seen = $seen{$method->{name}};
  
          if ($seen) {
              if ($seen->{method}->body != $method->{method}->body) {
                  $c->add_conflicting_method(
                      name  => $method->{name},
                      roles => [$method->{role}->name, $seen->{role}->name],
                  );
  
                  delete $method_map{$method->{name}};
                  $conflicts{$method->{name}} = 1;
                  next;
              }
          }
  
          $seen{$method->{name}}       = $method;
          $method_map{$method->{name}} = $method->{method};
      }
  
      $c->add_method($_ => $method_map{$_}) for keys %method_map;
  }
  
  sub apply_override_method_modifiers {
      my ($self, $c) = @_;
  
      my @all_overrides = map {
          my $role = $_;
          map {
              +{
                  name   => $_,
                  method => $role->get_override_method_modifier($_),
              }
          } $role->get_method_modifier_list('override');
      } @{$c->get_roles};
  
      my %seen;
      foreach my $override (@all_overrides) {
          my @role_names = map { $_->name } @{$c->get_roles};
          if ( $c->has_method($override->{name}) ){
              throw_exception( OverrideConflictInSummation => role_names       => \@role_names,
                                                              role_application => $self,
                                                              method_name      => $override->{name}
                             );
          }
          if (exists $seen{$override->{name}}) {
              if ( $seen{$override->{name}} != $override->{method} ) {
                  throw_exception( OverrideConflictInSummation => role_names          => \@role_names,
                                                                  role_application    => $self,
                                                                  method_name         => $override->{name},
                                                                  two_overrides_found => 1
                                 );
              }
          }
          $seen{$override->{name}} = $override->{method};
      }
  
      $c->add_override_method_modifier(
          $_->{name}, $_->{method}
      ) for @all_overrides;
  
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $c) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $role (@{$c->get_roles}) {
          foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
              $c->$add(
                  $method_name,
                  $_
              ) foreach $role->$get($method_name);
          }
      }
  }
  
  sub apply_overloading {
      my ( $self, $c ) = @_;
  
      my @overloaded_roles = grep { $_->is_overloaded } @{ $c->get_roles };
      return unless @overloaded_roles;
  
      my %fallback;
      for my $role (@overloaded_roles) {
          $fallback{ $role->name } = $role->get_overload_fallback_value;
      }
  
      for my $role_name ( keys %fallback ) {
          for my $other_role_name ( grep { $_ ne $role_name } keys %fallback ) {
              my @fb_values = @fallback{ $role_name, $other_role_name };
              if ( all {defined} @fb_values ) {
                  next if $fallback{$role_name} eq $fallback{$other_role_name};
                  throw_exception(
                      'OverloadConflictInSummation',
                      role_names       => [ $role_name, $other_role_name ],
                      role_application => $self,
                      overloaded_op    => 'fallback',
                  );
              }
  
              next if all { !defined } @fb_values;
              throw_exception(
                  'OverloadConflictInSummation',
                  role_names       => [ $role_name, $other_role_name ],
                  role_application => $self,
                  overloaded_op    => 'fallback',
              );
          }
      }
  
      if ( keys %fallback ) {
          $c->set_overload_fallback_value( ( values %fallback )[0] );
      }
  
      my %overload_map;
      for my $role (@overloaded_roles) {
          for my $overload ( $role->get_all_overloaded_operators ) {
              $overload_map{ $overload->operator }{ $role->name } = $overload;
          }
      }
  
      for my $op_name ( keys %overload_map ) {
          my @roles = keys %{ $overload_map{$op_name} };
          my $overload = $overload_map{$op_name}{ $roles[0] };
  
          if ( @roles > 1 && !all { $overload->_is_equal_to($_) }
              values %{ $overload_map{$op_name} } ) {
  
              throw_exception(
                  'OverloadConflictInSummation',
                  role_names       => [ @roles[ 0, 1 ] ],
                  role_application => $self,
                  overloaded_op    => $op_name,
              );
          }
  
          $c->add_overloaded_operator(
              $op_name => $overload_map{$op_name}{ $roles[0] } );
      }
  }
  
  1;
  
  # ABSTRACT: Combine two or more roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::RoleSummation - Combine two or more roles
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  Summation composes two traits, forming the union of non-conflicting
  bindings and 'disabling' the conflicting bindings
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<role_params>
  
  =item B<get_exclusions_for_role>
  
  =item B<get_method_aliases_for_role>
  
  =item B<is_aliased_method>
  
  =item B<is_method_aliased>
  
  =item B<is_method_excluded>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_overloading>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_ROLESUMMATION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Application/ToClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOCLASS';
  package Moose::Meta::Role::Application::ToClass;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use List::Util 'first';
  use Moose::Util 'throw_exception';
  use Scalar::Util 'weaken';
  
  use parent 'Moose::Meta::Role::Application';
  
  __PACKAGE__->meta->add_attribute('role' => (
      reader => 'role',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('class' => (
      accessor => 'class',
      Class::MOP::_definition_context(),
  ));
  
  sub apply {
      my ($self, $role, $class) = @_;
  
      # We need weak_ref in CMOP :(
      weaken($self->{role}  = $role);
      weaken($self->{class} = $class);
  
      $self->SUPER::apply($role, $class);
  
      $class->add_role($role);
      $class->add_role_application($self);
  }
  
  sub check_role_exclusions {
      my ($self, $role, $class) = @_;
      if ($class->excludes_role($role->name)) {
          throw_exception( ConflictDetectedInCheckRoleExclusionsInToClass => class_name => $class->name,
                                                                             role_name  => $role->name,
                         );
      }
      foreach my $excluded_role_name ($role->get_excluded_roles_list) {
          if ($class->does_role($excluded_role_name)) {
              throw_exception( ClassDoesTheExcludedRole => role_name          => $role->name,
                                                           excluded_role_name => $excluded_role_name,
                                                           class_name         => $class->name,
                             );
          }
      }
  }
  
  sub check_required_methods {
      my ($self, $role, $class) = @_;
  
      my @missing;
      my @is_attr;
  
      # NOTE:
      # we might need to move this down below the
      # the attributes so that we can require any
      # attribute accessors. However I am thinking
      # that maybe those are somehow exempt from
      # the require methods stuff.
      foreach my $required_method ($role->get_required_method_list) {
          my $required_method_name = $required_method->name;
  
          if (!$class->find_method_by_name($required_method_name)) {
  
              next if $self->is_aliased_method($required_method_name);
  
              push @missing, $required_method;
          }
      }
  
      return unless @missing;
  
      my $error = '';
  
      @missing = sort { $a->name cmp $b->name } @missing;
      my @conflicts = grep { $_->isa('Moose::Meta::Role::Method::Conflicting') } @missing;
  
      if (@conflicts) {
          my $conflict = $conflicts[0];
          my $roles = $conflict->roles_as_english_list;
  
          my @same_role_conflicts = grep { $_->roles_as_english_list eq $roles } @conflicts;
  
          throw_exception( MethodNameConflictInRoles => conflict   => \@same_role_conflicts,
                                                        class_name => $class->name
                         );
      }
      elsif (@missing) {
          if (my $meth = first { $class->name->can($_) } @missing) {
              throw_exception( RequiredMethodsImportedByClass => class_name      => $class->name,
                                                                 role_name       => $role->name,
                                                                 missing_methods => \@missing,
                                                                 imported_method => $meth
                             );
          }
          else {
              throw_exception( RequiredMethodsNotImplementedByClass => class_name      => $class->name,
                                                                       role_name       => $role->name,
                                                                       missing_methods => \@missing,
                             );
          }
      }
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $role, $class) = @_;
  
      foreach my $attribute_name ($role->get_attribute_list) {
          # it if it has one already
          if ($class->has_attribute($attribute_name) &&
              # make sure we haven't seen this one already too
              $class->get_attribute($attribute_name) != $role->get_attribute($attribute_name)) {
              next;
          }
          else {
              $class->add_attribute(
                  $role->get_attribute($attribute_name)->attribute_for_class
              );
          }
      }
  }
  
  sub apply_methods {
      my ( $self, $role, $class ) = @_;
  
      foreach my $method ( $role->_get_local_methods ) {
          my $method_name = $method->name;
  
          next if $method->isa('Class::MOP::Method::Meta');
  
          unless ( $self->is_method_excluded($method_name) ) {
  
              my $class_method = $class->get_method($method_name);
  
              next if $class_method && $class_method->body != $method->body;
  
              $class->add_method(
                  $method_name,
                  $method,
              );
          }
  
          next unless $self->is_method_aliased($method_name);
  
          my $aliased_method_name = $self->get_method_aliases->{$method_name};
  
          my $class_method = $class->get_method($aliased_method_name);
  
          if ( $class_method && $class_method->body != $method->body ) {
              throw_exception( CannotCreateMethodAliasLocalMethodIsPresentInClass => aliased_method_name => $aliased_method_name,
                                                                                     method              => $method,
                                                                                     role_name           => $role->name,
                                                                                     class_name          => $class->name,
                             );
          }
  
          $class->add_method(
              $aliased_method_name,
              $method,
          );
      }
  
      # we must reset the cache here since
      # we are just aliasing methods, otherwise
      # the modifiers go wonky.
      $class->reset_package_cache_flag;
  }
  
  sub apply_override_method_modifiers {
      my ($self, $role, $class) = @_;
      foreach my $method_name ($role->get_method_modifier_list('override')) {
          # it if it has one already then ...
          if ($class->has_method($method_name)) {
              next;
          }
          else {
              # if this is not a role, then we need to
              # find the original package of the method
              # so that we can tell the class were to
              # find the right super() method
              my $method = $role->get_override_method_modifier($method_name);
              my ($package) = Class::MOP::get_code_info($method);
              # if it is a class, we just add it
              $class->add_override_method_modifier($method_name, $method, $package);
          }
      }
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $role, $class) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
          $class->$add(
              $method_name,
              $_
          ) foreach $role->$get($method_name);
      }
  }
  
  1;
  
  # ABSTRACT: Compose a role into a class
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToClass - Compose a role into a class
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOCLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Application/ToInstance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOINSTANCE';
  package Moose::Meta::Role::Application::ToInstance;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  use List::Util 1.33 'all';
  use Devel::OverloadInfo 0.004 'is_overloaded';
  
  use parent 'Moose::Meta::Role::Application';
  
  __PACKAGE__->meta->add_attribute('rebless_params' => (
      reader  => 'rebless_params',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  use constant _NEED_OVERLOAD_HACK_FOR_OBJECTS => $] < 5.008009;
  
  sub apply {
      my ( $self, $role, $object, $args ) = @_;
  
      my $obj_meta = Class::MOP::class_of($object) || 'Moose::Meta::Class';
  
      # This is a special case to handle the case where the object's metaclass
      # is a Class::MOP::Class, but _not_ a Moose::Meta::Class (for example,
      # when applying a role to a Moose::Meta::Attribute object).
      $obj_meta = 'Moose::Meta::Class'
          unless $obj_meta->isa('Moose::Meta::Class');
  
      my $class = $obj_meta->create_anon_class(
          superclasses => [ blessed($object) ],
          roles => [ $role, keys(%$args) ? ($args) : () ],
          cache => (all { $_ eq '-alias' || $_ eq '-excludes' } keys %$args),
      );
  
      $class->rebless_instance( $object, %{ $self->rebless_params } );
  
      if ( _NEED_OVERLOAD_HACK_FOR_OBJECTS
          && is_overloaded( ref $object ) ) {
  
          # need to use $_[2] here to apply to the object in the caller
          _reset_amagic($_[2]);
      }
  
      return $object;
  }
  
  1;
  
  # ABSTRACT: Compose a role into an instance
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToInstance - Compose a role into an instance
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<rebless_params>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOINSTANCE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Application/ToRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOROLE';
  package Moose::Meta::Role::Application::ToRole;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use parent 'Moose::Meta::Role::Application';
  
  use Moose::Util 'throw_exception';
  
  sub apply {
      my ($self, $role1, $role2) = @_;
      $self->SUPER::apply($role1, $role2);
      $role2->add_role($role1);
  }
  
  sub check_role_exclusions {
      my ($self, $role1, $role2) = @_;
      if ( $role2->excludes_role($role1->name) ) {
          throw_exception( ConflictDetectedInCheckRoleExclusions => role_name          => $role2->name,
                                                                    excluded_role_name => $role1->name,
                         );
      }
      foreach my $excluded_role_name ($role1->get_excluded_roles_list) {
          if ( $role2->does_role($excluded_role_name) ) {
              throw_exception( RoleDoesTheExcludedRole => role_name          => $role2->name,
                                                          excluded_role_name => $excluded_role_name,
                                                          second_role_name   => $role1->name,
                             );
          }
          $role2->add_excluded_roles($excluded_role_name);
      }
  }
  
  sub check_required_methods {
      my ($self, $role1, $role2) = @_;
      foreach my $required_method ($role1->get_required_method_list) {
          my $required_method_name = $required_method->name;
  
          next if $self->is_aliased_method($required_method_name);
  
          $role2->add_required_methods($required_method)
              unless $role2->find_method_by_name($required_method_name);
      }
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $role1, $role2) = @_;
      foreach my $attribute_name ($role1->get_attribute_list) {
          # it if it has one already
          if ($role2->has_attribute($attribute_name) &&
              # make sure we haven't seen this one already too
              $role2->get_attribute($attribute_name) != $role1->get_attribute($attribute_name)) {
  
              my $role2_name = $role2->name;
  
              throw_exception( AttributeConflictInRoles => role_name        => $role1->name,
                                                           second_role_name => $role2->name,
                                                           attribute_name   => $attribute_name
                             );
          }
          else {
              $role2->add_attribute(
                  $role1->get_attribute($attribute_name)->clone
              );
          }
      }
  }
  
  sub apply_methods {
      my ( $self, $role1, $role2 ) = @_;
      foreach my $method ( $role1->_get_local_methods ) {
  
          my $method_name = $method->name;
  
          next if $method->isa('Class::MOP::Method::Meta');
  
          unless ( $self->is_method_excluded($method_name) ) {
  
              my $role2_method = $role2->get_method($method_name);
              if (   $role2_method
                  && $role2_method->body != $method->body ) {
  
                  # method conflicts between roles used to result in the method
                  # becoming a requirement but now are permitted just like
                  # for classes, hence no code in this branch anymore.
              }
              else {
                  $role2->add_method(
                      $method_name,
                      $method,
                  );
              }
          }
  
          next unless $self->is_method_aliased($method_name);
  
          my $aliased_method_name = $self->get_method_aliases->{$method_name};
  
          my $role2_method = $role2->get_method($aliased_method_name);
  
          if (   $role2_method
              && $role2_method->body != $method->body ) {
  
              throw_exception( CannotCreateMethodAliasLocalMethodIsPresent => aliased_method_name     => $aliased_method_name,
                                                                              method                  => $method,
                                                                              role_name               => $role2->name,
                                                                              role_being_applied_name => $role1->name,
                             );
          }
  
          $role2->add_method(
              $aliased_method_name,
              $role1->get_method($method_name)
          );
  
          if ( !$role2->has_method($method_name) ) {
              $role2->add_required_methods($method_name)
                  unless $self->is_method_excluded($method_name);
          }
      }
  }
  
  sub apply_override_method_modifiers {
      my ($self, $role1, $role2) = @_;
      foreach my $method_name ($role1->get_method_modifier_list('override')) {
          # it if it has one already then ...
          if ($role2->has_method($method_name)) {
              # if it is being composed into another role
              # we have a conflict here, because you cannot
              # combine an overridden method with a locally
              # defined one
              throw_exception( OverrideConflictInComposition => role_name               => $role2->name,
                                                                role_being_applied_name => $role1->name,
                                                                method_name             => $method_name
                             );
          }
          else {
              # if we are a role, we need to make sure
              # we don't have a conflict with the role
              # we are composing into
              if ($role2->has_override_method_modifier($method_name) &&
                  $role1->get_override_method_modifier($method_name) != $role2->get_override_method_modifier($method_name)) {
  
                  throw_exception( OverrideConflictInComposition => role_name               => $role2->name,
                                                                    role_being_applied_name => $role1->name,
                                                                    method_name             => $method_name,
                                                                    two_overrides_found     => 1
                                 );
              }
              else {
                  # if there is no conflict,
                  # just add it to the role
                  $role2->add_override_method_modifier(
                      $method_name,
                      $role1->get_override_method_modifier($method_name)
                  );
              }
          }
      }
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $role1, $role2) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $method_name ($role1->get_method_modifier_list($modifier_type)) {
          $role2->$add(
              $method_name,
              $_
          ) foreach $role1->$get($method_name);
      }
  }
  
  1;
  
  # ABSTRACT: Compose a role into another role
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToRole - Compose a role into another role
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_APPLICATION_TOROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_ATTRIBUTE';
  package Moose::Meta::Role::Attribute;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use List::Util 1.33 'all';
  use Scalar::Util 'blessed', 'weaken';
  
  use parent 'Moose::Meta::Mixin::AttributeCore', 'Class::MOP::Object';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute(
      'metaclass' => (
          reader => 'metaclass',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'associated_role' => (
          reader => 'associated_role',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      '_original_role' => (
          reader => '_original_role',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'is' => (
          reader => 'is',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'original_options' => (
          reader => 'original_options',
          Class::MOP::_definition_context(),
      )
  );
  
  sub new {
      my ( $class, $name, %options ) = @_;
  
      (defined $name)
          || throw_exception( MustProvideANameForTheAttribute => params => \%options,
                                                                 class  => $class
                            );
  
      my $role = delete $options{_original_role};
  
      return bless {
          name             => $name,
          original_options => \%options,
          _original_role   => $role,
          %options,
      }, $class;
  }
  
  sub attach_to_role {
      my ( $self, $role ) = @_;
  
      ( blessed($role) && $role->isa('Moose::Meta::Role') )
          || throw_exception( MustPassAMooseMetaRoleInstanceOrSubclass => class  => $self,
                                                                          role   => $role
                            );
  
      weaken( $self->{'associated_role'} = $role );
  }
  
  sub original_role {
      my $self = shift;
  
      return $self->_original_role || $self->associated_role;
  }
  
  sub attribute_for_class {
      my $self = shift;
  
      my $metaclass = $self->original_role->applied_attribute_metaclass;
  
      return $metaclass->interpolate_class_and_new(
          $self->name => %{ $self->original_options } );
  }
  
  sub clone {
      my $self = shift;
  
      my $role = $self->original_role;
  
      return ( ref $self )->new(
          $self->name,
          %{ $self->original_options },
          _original_role => $role,
      );
  }
  
  sub is_same_as {
      my $self = shift;
      my $attr = shift;
  
      my $self_options = $self->original_options;
      my $other_options = $attr->original_options;
  
      return 0
          unless ( join q{|}, sort keys %{$self_options} ) eq ( join q{|}, sort keys %{$other_options} );
  
      for my $key ( keys %{$self_options} ) {
          return 0 if defined $self_options->{$key} && ! defined $other_options->{$key};
          return 0 if ! defined $self_options->{$key} && defined $other_options->{$key};
  
          next if all { ! defined } $self_options->{$key}, $other_options->{$key};
  
          return 0 unless $self_options->{$key} eq $other_options->{$key};
      }
  
      return 1;
  }
  
  1;
  
  # ABSTRACT: The Moose attribute metaclass for Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Attribute - The Moose attribute metaclass for Roles
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class implements the API for attributes in roles. Attributes in roles are
  more like attribute prototypes than full blown attributes. While they are
  introspectable, they have very little behavior.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Role::Attribute->new(...)
  
  This method accepts all the options that would be passed to the constructor
  for L<Moose::Meta::Attribute>.
  
  =head2 $attr->metaclass
  
  =head2 $attr->is
  
  Returns the option as passed to the constructor.
  
  =head2 $attr->associated_role
  
  Returns the L<Moose::Meta::Role> to which this attribute belongs, if any.
  
  =head2 $attr->original_role
  
  Returns the L<Moose::Meta::Role> in which this attribute was first
  defined. This may not be the same as the value of C<associated_role()> for
  attributes in a composite role, or when one role consumes other roles.
  
  =head2 $attr->original_options
  
  Returns a hash reference of options passed to the constructor. This is used
  when creating a L<Moose::Meta::Attribute> object from this object.
  
  =head2 $attr->attach_to_role($role)
  
  Attaches the attribute to the given L<Moose::Meta::Role>.
  
  =head2 $attr->attribute_for_class($metaclass)
  
  Given an attribute metaclass name, this method calls C<<
  $metaclass->interpolate_class_and_new >> to construct an attribute object
  which can be added to a L<Moose::Meta::Class>.
  
  =head2 $attr->clone
  
  Creates a new object identical to the object on which the method is called.
  
  =head2 $attr->is_same_as($other_attr)
  
  Compares two role attributes and returns true if they are identical.
  
  In addition, this class implements all informational predicates implements by
  L<Moose::Meta::Attribute> (and L<Class::MOP::Attribute>).
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_ATTRIBUTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Composite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_COMPOSITE';
  package Moose::Meta::Role::Composite;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  use Moose::Util 'throw_exception';
  use parent 'Moose::Meta::Role';
  
  # NOTE:
  # we need to override the ->name
  # method from Class::MOP::Package
  # since we don't have an actual
  # package for this.
  # - SL
  __PACKAGE__->meta->add_attribute('name' => (
      reader => 'name',
      Class::MOP::_definition_context(),
  ));
  
  # NOTE:
  # Again, since we don't have a real
  # package to store our methods in,
  # we use a HASH ref instead.
  # - SL
  __PACKAGE__->meta->add_attribute('_methods' => (
      reader  => '_method_map',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_overloads' => (
      reader  => '_overload_map',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_overload_fallback' => (
      accessor  => '_overload_fallback',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      'application_role_summation_class',
      reader  => 'application_role_summation_class',
      default => 'Moose::Meta::Role::Application::RoleSummation',
      Class::MOP::_definition_context(),
  );
  
  sub new {
      my ($class, %params) = @_;
  
      # the roles param is required ...
      foreach ( @{$params{roles}} ) {
          unless ( $_->isa('Moose::Meta::Role') ) {
              throw_exception( RolesListMustBeInstancesOfMooseMetaRole => params => \%params,
                                                                          role   => $_,
                                                                          class  => $class
                             );
          }
      }
  
      my @composition_roles = map {
          $_->composition_class_roles
      } @{ $params{roles} };
  
      if (@composition_roles) {
          my $meta = Moose::Meta::Class->create_anon_class(
              superclasses => [ $class ],
              roles        => [ @composition_roles ],
              cache        => 1,
          );
          $class = $meta->name;
      }
  
      # and the name is created from the
      # roles if one has not been provided
      $params{name} ||= (join "|" => map { $_->name } @{$params{roles}});
      $class->_new(\%params);
  }
  
  # There's no such thing as an anonymous composite role since composites are an
  # artifact of Moose's internals. However, a composite role that contains an
  # anon role may _look_ like an anon role since $self->name =~ /$anon_key/ can
  # return true if the first role in the composite is anonymous itself.
  sub is_anon { 0 }
  
  # This is largely a copy of what's in Moose::Meta::Role (itself
  # largely a copy of Class::MOP::Class). However, we can't actually
  # call add_package_symbol, because there's no package into which to
  # add the symbol.
  sub add_method {
      my ($self, $method_name, $method) = @_;
  
      unless ( defined $method_name && $method_name ) {
          throw_exception( MustDefineAMethodName => instance => $self );
      }
  
      my $body;
      if (blessed($method)) {
          $body = $method->body;
          if ($method->package_name ne $self->name) {
              $method = $method->clone(
                  package_name => $self->name,
                  name         => $method_name
              ) if $method->can('clone');
          }
      }
      else {
          $body = $method;
          $method = $self->wrap_method_body( body => $body, name => $method_name );
      }
  
      $self->_method_map->{$method_name} = $method;
  }
  
  sub get_method_list {
      my $self = shift;
      return keys %{ $self->_method_map };
  }
  
  sub _get_local_methods {
      my $self = shift;
      return values %{ $self->_method_map };
  }
  
  sub has_method {
      my ($self, $method_name) = @_;
  
      return exists $self->_method_map->{$method_name};
  }
  
  sub get_method {
      my ($self, $method_name) = @_;
  
      return $self->_method_map->{$method_name};
  }
  
  sub is_overloaded {
      my ($self) = @_;
      return keys %{ $self->_overload_map };
  }
  
  sub add_overloaded_operator {
      my ( $self, $op_name, $overload ) = @_;
  
      unless ( defined $op_name && $op_name ) {
          throw_exception(
              'MustDefineAnOverloadOperator',
              instance => $self,
          );
      }
  
      $self->_overload_map->{$op_name} = $overload;
  }
  
  sub get_overload_fallback_value {
      my ($self) = @_;
      return $self->_overload_fallback;
  }
  
  sub set_overload_fallback_value {
      my $self = shift;
      $self->_overload_fallback(shift);
  }
  
  sub get_all_overloaded_operators {
      my ( $self, $method_name ) = @_;
      return values %{ $self->_overload_map };
  }
  
  sub apply_params {
      my ($self, $role_params) = @_;
      Moose::Util::_load_user_class($self->application_role_summation_class);
  
      $self->application_role_summation_class->new(
          role_params => $role_params,
      )->apply($self);
  
      return $self;
  }
  
  sub reinitialize {
      my ( $class, $old_meta, @args ) = @_;
  
      throw_exception( CannotInitializeMooseMetaRoleComposite => old_meta       => $old_meta,
                                                                 args           => \@args,
                                                                 role_composite => $class
                     )
          if !blessed $old_meta
              || !$old_meta->isa('Moose::Meta::Role::Composite');
  
      my %existing_classes = map { $_ => $old_meta->$_() } qw(
          application_role_summation_class
      );
  
      return $old_meta->meta->clone_object( $old_meta, %existing_classes, @args );
  }
  
  1;
  
  # ABSTRACT: An object to represent the set of roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Composite - An object to represent the set of roles
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  A composite is a role that consists of a set of two or more roles.
  
  The API of a composite role is almost identical to that of a regular
  role.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Composite> is a subclass of L<Moose::Meta::Role>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Role::Composite->new(%options)
  
  This returns a new composite role object. It accepts the same
  options as its parent class, with a few changes:
  
  =over 4
  
  =item * roles
  
  This option is an array reference containing a list of
  L<Moose::Meta::Role> object. This is a required option.
  
  =item * name
  
  If a name is not given, one is generated from the roles provided.
  
  =item * apply_params(\%role_params)
  
  Creates a new RoleSummation role application with C<%role_params> and applies
  the composite role to it. The RoleSummation role application class used is
  determined by the composite role's C<application_role_summation_class>
  attribute.
  
  =item * reinitialize($metaclass)
  
  Like C<< Class::MOP::Package->reinitialize >>, but doesn't allow passing a
  string with the package name, as there is no real package for composite roles.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_COMPOSITE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD';
  package Moose::Meta::Role::Method;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use parent 'Moose::Meta::Method';
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is blah blah blah
      # see the comments in CMOP::Method::Meta and CMOP::Method::Wrapped
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Method - A Moose Method metaclass for Roles
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This is primarily used to mark methods coming from a role
  as being different. Right now it is nothing but a subclass
  of L<Moose::Meta::Method>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Method/Conflicting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD_CONFLICTING';
  package Moose::Meta::Role::Method::Conflicting;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Util;
  
  use parent 'Moose::Meta::Role::Method::Required';
  
  __PACKAGE__->meta->add_attribute('roles' => (
      reader   => 'roles',
      required => 1,
      Class::MOP::_definition_context(),
  ));
  
  sub roles_as_english_list {
      my $self = shift;
      Moose::Util::english_list( map { q{'} . $_ . q{'} } @{ $self->roles } );
  }
  
  1;
  
  # ABSTRACT: A Moose metaclass for conflicting methods in Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Method::Conflicting - A Moose metaclass for conflicting methods in Roles
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Method::Conflicting> is a subclass of
  L<Moose::Meta::Role::Method::Required>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Role::Method::Conflicting->new(%options)
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 4
  
  =item * name
  
  The method name. This is required.
  
  =item * roles
  
  The list of role names that generated the conflict. This is required.
  
  =back
  
  =head2 $method->name
  
  Returns the conflicting method's name, as provided to the constructor.
  
  =head2 $method->roles
  
  Returns the roles that generated this conflicting method, as provided to the
  constructor.
  
  =head2 $method->roles_as_english_list
  
  Returns the roles that generated this conflicting method as an English list.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD_CONFLICTING

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/Role/Method/Required.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD_REQUIRED';
  package Moose::Meta::Role::Method::Required;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use overload
      '""' => sub { shift->name },   # stringify to method name
      'bool' => sub { 1 },
      fallback => 1;
  
  use parent 'Class::MOP::Object';
  
  # This is not a Moose::Meta::Role::Method because it has no implementation, it
  # is just a name
  
  __PACKAGE__->meta->add_attribute('name' => (
      reader   => 'name',
      required => 1,
      Class::MOP::_definition_context(),
  ));
  
  sub new { shift->_new(@_) }
  
  1;
  
  # ABSTRACT: A Moose metaclass for required methods in Roles
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::Role::Method::Required - A Moose metaclass for required methods in Roles
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Method::Required> is a subclass of L<Class::MOP::Object>.
  It is B<not> a subclass of C<Moose::Meta::Role::Method> since it does not
  provide an implementation of the method.
  
  =head1 METHODS
  
  =head2 Moose::Meta::Role::Method::Required->new(%options)
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 4
  
  =item * name
  
  The method name. This is required.
  
  =back
  
  =head2 $method->name
  
  Returns the required method's name, as provided to the constructor.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_ROLE_METHOD_REQUIRED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeCoercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECOERCION';
  package Moose::Meta::TypeCoercion;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Moose::Meta::Attribute;
  use Moose::Util::TypeConstraints ();
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('type_coercion_map' => (
      reader  => 'type_coercion_map',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      Moose::Meta::Attribute->new('type_constraint' => (
          reader   => 'type_constraint',
          weak_ref => 1,
          Class::MOP::_definition_context(),
      ))
  );
  
  # private accessor
  __PACKAGE__->meta->add_attribute('compiled_type_coercion' => (
      accessor => '_compiled_type_coercion',
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my $self  = Class::MOP::class_of($class)->new_object(@_);
      $self->compile_type_coercion;
      return $self;
  }
  
  sub compile_type_coercion {
      my $self = shift;
      my @coercion_map = @{$self->type_coercion_map};
      my @coercions;
      while (@coercion_map) {
          my ($constraint_name, $action) = splice(@coercion_map, 0, 2);
          my $type_constraint = ref $constraint_name ? $constraint_name : Moose::Util::TypeConstraints::find_or_parse_type_constraint($constraint_name);
  
          unless ( defined $type_constraint ) {
              throw_exception( CouldNotFindTypeConstraintToCoerceFrom => constraint_name => $constraint_name,
                                                                         instance        => $self
                             );
          }
  
          push @coercions => [
              $type_constraint->_compiled_type_constraint,
              $action
          ];
      }
      $self->_compiled_type_coercion(sub {
          my $thing = shift;
          foreach my $coercion (@coercions) {
              my ($constraint, $converter) = @$coercion;
              if ($constraint->($thing)) {
                  local $_ = $thing;
                  return $converter->($thing);
              }
          }
          return $thing;
      });
  }
  
  sub has_coercion_for_type {
      my ($self, $type_name) = @_;
      my %coercion_map = @{$self->type_coercion_map};
      exists $coercion_map{$type_name} ? 1 : 0;
  }
  
  sub add_type_coercions {
      my ($self, @new_coercion_map) = @_;
  
      my $coercion_map = $self->type_coercion_map;
      my %has_coercion = @$coercion_map;
  
      while (@new_coercion_map) {
          my ($constraint_name, $action) = splice(@new_coercion_map, 0, 2);
  
          if ( exists $has_coercion{$constraint_name} ) {
              throw_exception( CoercionAlreadyExists => constraint_name => $constraint_name,
                                                        instance        => $self
                             );
          }
  
          push @{$coercion_map} => ($constraint_name, $action);
      }
  
      # and re-compile ...
      $self->compile_type_coercion;
  }
  
  sub coerce { $_[0]->_compiled_type_coercion->($_[1]) }
  
  
  1;
  
  # ABSTRACT: The Moose Type Coercion metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeCoercion - The Moose Type Coercion metaclass
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  A type coercion object is basically a mapping of one or more type
  constraints and the associated coercions subroutines.
  
  It's unlikely that you will need to instantiate an object of this
  class directly, as it's part of the deep internals of Moose.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeCoercion->new(%options)
  
  Creates a new type coercion object, based on the options provided.
  
  =over 4
  
  =item * type_constraint
  
  This is the L<Moose::Meta::TypeConstraint> object for the type that is
  being coerced I<to>.
  
  =back
  
  =head2 $coercion->type_coercion_map
  
  This returns the map of type constraints to coercions as an array
  reference. The values of the array alternate between type names and
  subroutine references which implement the coercion.
  
  The value is an array reference because coercions are tried in the
  order they are added.
  
  =head2 $coercion->type_constraint
  
  This returns the L<Moose::Meta::TypeConstraint> that was passed to the
  constructor.
  
  =head2 $coercion->has_coercion_for_type($type_name)
  
  Returns true if the coercion can coerce the named type.
  
  =head2 $coercion->add_type_coercions( $type_name => $sub, ... )
  
  This method takes a list of type names and subroutine references. If
  the coercion already has a mapping for a given type, it throws an
  exception.
  
  Coercions are actually
  
  =head2 $coercion->coerce($value)
  
  This method takes a value and applies the first valid coercion it
  finds.
  
  This means that if the value could belong to more than type in the
  coercion object, the first coercion added is used.
  
  =head2 Moose::Meta::TypeCoercion->meta
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECOERCION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeCoercion/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECOERCION_UNION';
  package Moose::Meta::TypeCoercion::Union;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use parent 'Moose::Meta::TypeCoercion';
  
  use Moose::Util 'throw_exception';
  
  sub compile_type_coercion {
      my $self            = shift;
      my $type_constraint = $self->type_constraint;
  
      (blessed $type_constraint && $type_constraint->isa('Moose::Meta::TypeConstraint::Union'))
       || throw_exception( NeedsTypeConstraintUnionForTypeCoercionUnion => type_coercion_union_object => $self,
                                                                           type_name                  => $type_constraint->name
                         );
  
      $self->_compiled_type_coercion(
          sub {
              my $value = shift;
  
              foreach my $type ( grep { $_->has_coercion }
                  @{ $type_constraint->type_constraints } ) {
                  my $temp = $type->coerce($value);
                  return $temp if $type_constraint->check($temp);
              }
  
              return $value;
          }
      );
  }
  
  sub has_coercion_for_type { 0 }
  
  sub add_type_coercions {
      my $self = shift;
      throw_exception( CannotAddAdditionalTypeCoercionsToUnion => type_coercion_union_object => $self );
  }
  
  1;
  
  # ABSTRACT: The Moose Type Coercion metaclass for Unions
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeCoercion::Union - The Moose Type Coercion metaclass for Unions
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Moose::Meta::TypeCoercion> that is used for
  L<Moose::Meta::TypeConstraint::Union> objects.
  
  =head1 METHODS
  
  =head2 $coercion->has_coercion_for_type
  
  This method always returns false.
  
  =head2 $coercion->add_type_coercions
  
  This method always throws an error. You cannot add coercions to a
  union type coercion.
  
  =head2 $coercion->coerce($value)
  
  This method will coerce by trying the coercions for each type in the
  union.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECOERCION_UNION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT';
  package Moose::Meta::TypeConstraint;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use overload '0+'     => sub { refaddr(shift) }, # id an object
               '""'     => sub { shift->name },   # stringify to tc name
               bool     => sub { 1 },
               fallback => 1;
  
  use Eval::Closure;
  use Scalar::Util qw(refaddr);
  use Sub::Name qw(subname);
  use Try::Tiny;
  
  use base 'Class::MOP::Object';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('name'       => (
      reader => 'name',
      Class::MOP::_definition_context(),
  ));
  __PACKAGE__->meta->add_attribute('parent'     => (
      reader    => 'parent',
      predicate => 'has_parent',
      Class::MOP::_definition_context(),
  ));
  
  my $null_constraint = sub { 1 };
  __PACKAGE__->meta->add_attribute('constraint' => (
      reader  => 'constraint',
      writer  => '_set_constraint',
      default => sub { $null_constraint },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('message'   => (
      accessor  => 'message',
      predicate => 'has_message',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_default_message' => (
      accessor  => '_default_message',
      Class::MOP::_definition_context(),
  ));
  
  # can't make this a default because it has to close over the type name, and
  # cmop attributes don't have lazy
  my $_default_message_generator = sub {
      my $name = shift;
      sub {
          my $value = shift;
          # have to load it late like this, since it uses Moose itself
          my $can_partialdump = try {
              # versions prior to 0.14 had a potential infinite loop bug
              require Devel::PartialDump;
              Devel::PartialDump->VERSION(0.14);
              1;
          };
          if ($can_partialdump) {
              $value = Devel::PartialDump->new->dump($value);
          }
          else {
              $value = (defined $value ? overload::StrVal($value) : 'undef');
          }
          return "Validation failed for '" . $name . "' with value $value";
      }
  };
  __PACKAGE__->meta->add_attribute('coercion'   => (
      accessor  => 'coercion',
      predicate => 'has_coercion',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inlined' => (
      init_arg  => 'inlined',
      accessor  => 'inlined',
      predicate => '_has_inlined_type_constraint',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inline_environment' => (
      init_arg => 'inline_environment',
      accessor => '_inline_environment',
      default  => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub parents {
      my $self = shift;
      $self->parent;
  }
  
  # private accessors
  
  __PACKAGE__->meta->add_attribute('compiled_type_constraint' => (
      accessor  => '_compiled_type_constraint',
      predicate => '_has_compiled_type_constraint',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('package_defined_in' => (
      accessor => '_package_defined_in',
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my ($first, @rest) = @_;
      my %args = ref $first ? %$first : $first ? ($first, @rest) : ();
      $args{name} = $args{name} ? "$args{name}" : "__ANON__";
  
      if ( exists $args{message}
        && (!ref($args{message}) || ref($args{message}) ne 'CODE') ) {
          throw_exception( MessageParameterMustBeCodeRef => params => \%args,
                                                            class  => $class
                         );
      }
  
      my $self  = $class->_new(%args);
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
      $self->_default_message($_default_message_generator->($self->name))
          unless $self->has_message;
      return $self;
  }
  
  
  
  sub coerce {
      my $self = shift;
  
      my $coercion = $self->coercion;
  
      unless ($coercion) {
          throw_exception( CoercingWithoutCoercions => type_name => $self->name );
      }
  
      return $_[0] if $self->check($_[0]);
  
      return $coercion->coerce(@_);
  }
  
  sub assert_coerce {
      my $self = shift;
  
      my $result = $self->coerce(@_);
  
      $self->assert_valid($result);
  
      return $result;
  }
  
  sub check {
      my ($self, @args) = @_;
      my $constraint_subref = $self->_compiled_type_constraint;
      return $constraint_subref->(@args) ? 1 : undef;
  }
  
  sub validate {
      my ($self, $value) = @_;
      if ($self->_compiled_type_constraint->($value)) {
          return undef;
      }
      else {
          $self->get_message($value);
      }
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->can_be_inlined;
      }
  
      return $self->_has_inlined_type_constraint;
  }
  
  sub _inline_check {
      my $self = shift;
  
      unless ( $self->can_be_inlined ) {
          throw_exception( CannotInlineTypeConstraintCheck => type_name => $self->name );
      }
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->_inline_check(@_);
      }
  
      return '( do { ' . $self->inlined->( $self, @_ ) . ' } )';
  }
  
  sub inline_environment {
      my $self = shift;
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->inline_environment;
      }
  
      return $self->_inline_environment;
  }
  
  sub assert_valid {
      my ( $self, $value ) = @_;
  
      return 1 if $self->check($value);
  
      throw_exception(
          'ValidationFailedForTypeConstraint',
          type  => $self,
          value => $value
      );
  }
  
  sub get_message {
      my ($self, $value) = @_;
      my $msg = $self->has_message
          ? $self->message
          : $self->_default_message;
      local $_ = $value;
      return $msg->($value);
  }
  
  ## type predicates ...
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
      return if not $other;
  
      return 1 if $self == $other;
  
      return unless $self->constraint == $other->constraint;
  
      if ( $self->has_parent ) {
          return unless $other->has_parent;
          return unless $self->parent->equals( $other->parent );
      } else {
          return if $other->has_parent;
      }
  
      return;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
      return if not $type;
  
      ($self->equals($type) || $self->is_subtype_of($type));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
      return if not $type;
  
      my $current = $self;
  
      while (my $parent = $current->parent) {
          return 1 if $parent->equals($type);
          $current = $parent;
      }
  
      return 0;
  }
  
  ## compiling the type constraint
  
  sub compile_type_constraint {
      my $self = shift;
      $self->_compiled_type_constraint($self->_actually_compile_type_constraint);
  }
  
  ## type compilers ...
  
  sub _actually_compile_type_constraint {
      my $self = shift;
  
      if ( $self->can_be_inlined ) {
          return eval_closure(
              source      => 'sub { ' . $self->_inline_check('$_[0]') . ' }',
              environment => $self->inline_environment,
          );
      }
  
      my $check = $self->constraint;
      unless ( defined $check ) {
          throw_exception( NoConstraintCheckForTypeConstraint => type_name => $self->name );
      }
  
      return $self->_compile_subtype($check)
          if $self->has_parent;
  
      return $self->_compile_type($check);
  }
  
  sub _compile_subtype {
      my ($self, $check) = @_;
  
      # gather all the parent constraints in order
      my @parents;
      foreach my $parent ($self->_collect_all_parents) {
          push @parents => $parent->constraint;
      }
  
      @parents = grep { $_ != $null_constraint } reverse @parents;
  
      unless ( @parents ) {
          return $self->_compile_type($check);
      } else {
          # general case, check all the constraints, from the first parent to ourselves
          my @checks = @parents;
          push @checks, $check if $check != $null_constraint;
          return subname($self->name => sub {
              my (@args) = @_;
              local $_ = $args[0];
              foreach my $check (@checks) {
                  return undef unless $check->(@args);
              }
              return 1;
          });
      }
  }
  
  sub _compile_type {
      my ($self, $check) = @_;
  
      return $check if $check == $null_constraint; # Item, Any
  
      return subname($self->name => sub {
          my (@args) = @_;
          local $_ = $args[0];
          $check->(@args);
      });
  }
  
  ## other utils ...
  
  sub _collect_all_parents {
      my $self = shift;
      my @parents;
      my $current = $self->parent;
      while (defined $current) {
          push @parents => $current;
          $current = $current->parent;
      }
      return @parents;
  }
  
  sub create_child_type {
      my ($self, %opts) = @_;
      my $class = ref $self;
      return $class->new(%opts, parent => $self);
  }
  
  1;
  
  # ABSTRACT: The Moose Type Constraint metaclass
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint - The Moose Type Constraint metaclass
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class represents a single type constraint. Moose's built-in type
  constraints, as well as constraints you define, are all stored in a
  L<Moose::Meta::TypeConstraint::Registry> object as objects of this
  class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint> is a subclass of L<Class::MOP::Object>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint->new(%options)
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 4
  
  =item * name
  
  The constraint name. If a name is not provided, it will be set to
  "__ANON__".
  
  =item * parent
  
  A C<Moose::Meta::TypeConstraint> object which is the parent type for
  the type being created. This is optional.
  
  =item * constraint
  
  This is the subroutine reference that implements the actual constraint
  check. This defaults to a subroutine which always returns true.
  
  =item * message
  
  A subroutine reference which is used to generate an error message when
  the constraint fails. This is optional.
  
  =item * coercion
  
  A L<Moose::Meta::TypeCoercion> object representing the coercions to
  the type. This is optional.
  
  =item * inlined
  
  A subroutine which returns a string suitable for inlining this type
  constraint. It will be called as a method on the type constraint object, and
  will receive a single additional parameter, a variable name to be tested
  (usually C<"$_"> or C<"$_[0]">.
  
  This is optional.
  
  =item * inline_environment
  
  A hash reference of variables to close over. The keys are variables names, and
  the values are I<references> to the variables.
  
  =back
  
  =head2 $constraint->equals($type_name_or_object)
  
  Returns true if the supplied name or type object is the same as the
  current type.
  
  =head2 $constraint->is_subtype_of($type_name_or_object)
  
  Returns true if the supplied name or type object is a parent of the
  current type.
  
  =head2 $constraint->is_a_type_of($type_name_or_object)
  
  Returns true if the given type is the same as the current type, or is
  a parent of the current type. This is a shortcut for checking
  C<equals> and C<is_subtype_of>.
  
  =head2 $constraint->coerce($value)
  
  This will attempt to coerce the value to the type. If the type does not
  have any defined coercions this will throw an error.
  
  If no coercion can produce a value matching C<$constraint>, the original
  value is returned.
  
  =head2 $constraint->assert_coerce($value)
  
  This method behaves just like C<coerce>, but if the result is not valid
  according to C<$constraint>, an error is thrown.
  
  =head2 $constraint->check($value)
  
  Returns true if the given value passes the constraint for the type.
  
  =head2 $constraint->validate($value)
  
  This is similar to C<check>. However, if the type I<is valid> then the
  method returns an explicit C<undef>. If the type is not valid, we call
  C<< $self->get_message($value) >> internally to generate an error
  message.
  
  =head2 $constraint->assert_valid($value)
  
  Like C<check> and C<validate>, this method checks whether C<$value> is
  valid under the constraint.  If it is, it will return true.  If it is not,
  an exception will be thrown with the results of
  C<< $self->get_message($value) >>.
  
  =head2 $constraint->name
  
  Returns the type's name, as provided to the constructor.
  
  =head2 $constraint->parent
  
  Returns the type's parent, as provided to the constructor, if any.
  
  =head2 $constraint->has_parent
  
  Returns true if the type has a parent type.
  
  =head2 $constraint->parents
  
  Returns all of the types parents as an list of type constraint objects.
  
  =head2 $constraint->constraint
  
  Returns the type's constraint, as provided to the constructor.
  
  =head2 $constraint->get_message($value)
  
  This generates a method for the given value. If the type does not have
  an explicit message, we generate a default message.
  
  =head2 $constraint->has_message
  
  Returns true if the type has a message.
  
  =head2 $constraint->message
  
  Returns the type's message as a subroutine reference.
  
  =head2 $constraint->coercion
  
  Returns the type's L<Moose::Meta::TypeCoercion> object, if one
  exists.
  
  =head2 $constraint->has_coercion
  
  Returns true if the type has a coercion.
  
  =head2 $constraint->can_be_inlined
  
  Returns true if this type constraint can be inlined. A type constraint which
  subtypes an inlinable constraint and does not add an additional constraint
  "inherits" its parent type's inlining.
  
  =head2 $constraint->create_child_type(%options)
  
  This returns a new type constraint of the same class using the
  provided C<%options>. The C<parent> option will be the current type.
  
  This method exists so that subclasses of this class can override this
  behavior and change how child types are created.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_CLASS';
  package Moose::Meta::TypeConstraint::Class;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Scalar::Util ();
  use Moose::Util::TypeConstraints ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('class' => (
      reader => 'class',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'Scalar::Util::blessed(' . $val . ')'
               . ' && ' . $val . '->isa(' . B::perlstring($self->class) . ')';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent}
          = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my $class_name = $args{class};
      $args{constraint} = sub { $_[0]->isa($class_name) };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new( \%args );
  
      $self->compile_type_constraint();
  
      return $self;
  }
  
  sub parents {
      my $self = shift;
      return (
          $self->parent,
          map {
              # FIXME find_type_constraint might find a TC named after the class but that isn't really it
              # I did this anyway since it's a convention that preceded TypeConstraint::Class, and it should DWIM
              # if anybody thinks this problematic please discuss on IRC.
              # a possible fix is to add by attr indexing to the type registry to find types of a certain property
              # regardless of their name
              Moose::Util::TypeConstraints::find_type_constraint($_)
                  ||
              __PACKAGE__->new( class => $_, name => "__ANON__" )
          } Class::MOP::class_of($self->class)->superclasses,
      );
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      if (!defined($other)) {
          if (!ref($type_or_name)) {
              return $self->class eq $type_or_name;
          }
          return;
      }
  
      return unless $other->isa(__PACKAGE__);
  
      return $self->class eq $other->class;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      ($self->equals($type_or_name) || $self->is_subtype_of($type_or_name));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name_or_class ) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_class);
  
      if ( not defined $type ) {
          if ( not ref $type_or_name_or_class ) {
              # it might be a class
              my $class = $self->class;
              return 1 if $class ne $type_or_name_or_class
                       && $class->isa( $type_or_name_or_class );
          }
          return;
      }
  
      if ( $type->isa(__PACKAGE__) && $type->class ne $self->class) {
          # if $type_or_name_or_class isn't a class, it might be the TC name of another ::Class type
          # or it could also just be a type object in this branch
          return $self->class->isa( $type->class );
      } else {
          # the only other thing we are a subtype of is Object
          $self->SUPER::is_subtype_of($type);
      }
  }
  
  # This is a bit counter-intuitive, but a child type of a Class type
  # constraint is not itself a Class type constraint (it has no class
  # attribute). This whole create_child_type thing needs some changing
  # though, probably making MMC->new a factory or something.
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  sub get_message {
      my $self = shift;
      my ($value) = @_;
  
      if ($self->has_message) {
          return $self->SUPER::get_message(@_);
      }
  
      $value = (defined $value ? overload::StrVal($value) : 'undef');
      return "Validation failed for '" . $self->name . "' with value $value (not isa " . $self->class . ")";
  }
  
  1;
  
  # ABSTRACT: Class/TypeConstraint parallel hierarchy
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Class - Class/TypeConstraint parallel hierarchy
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class represents type constraints for a class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Class> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::Class->new(%options)
  
  This creates a new class type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with two exceptions. First,
  it requires an additional option, C<class>, which is name of the
  constraint's class.  Second, it automatically sets the parent to the
  C<Object> type.
  
  The constructor also overrides the hand optimized type constraint with
  one it creates internally.
  
  =head2 $constraint->class
  
  Returns the class name associated with the constraint.
  
  =head2 $constraint->parents
  
  Returns all the type's parent types, corresponding to its parent
  classes.
  
  =head2 $constraint->is_subtype_of($type_name_or_object)
  
  If the given type is also a class type, then this checks that the
  type's class is a subclass of the other type's class.
  
  Otherwise it falls back to the implementation in
  L<Moose::Meta::TypeConstraint>.
  
  =head2 $constraint->create_child_type(%options)
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a
  C<Moose::Meta::TypeConstraint::Class> object!
  
  =head2 $constraint->get_message($value)
  
  This is the same as L<Moose::Meta::TypeConstraint/get_message> except
  that it explicitly says C<isa> was checked. This is to help users deal
  with accidentally autovivified type constraints.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_CLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/DuckType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_DUCKTYPE';
  package Moose::Meta::TypeConstraint::DuckType;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Scalar::Util 'blessed';
  use List::Util 1.33 qw(all);
  use Moose::Util 'english_list';
  
  use Moose::Util::TypeConstraints ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('methods' => (
      accessor => 'methods',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return $self->parent->_inline_check($val)
           . ' && do {' . "\n"
               . 'my $val = ' . $val . ';' . "\n"
               . '&List::Util::all(' . "\n"
                   . 'sub { $val->can($_) },' . "\n"
                   . join(', ', map { B::perlstring($_) } @{ $self->methods })
               . ');' . "\n"
           . '}';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent}
          = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my @methods = @{ $args{methods} };
      $args{constraint} = sub {
          my $val = $_[0];
          return all { $val->can($_) } @methods;
      };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new(\%args);
  
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
  
      return $self;
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_methods  = sort @{ $self->methods };
      my @other_methods = sort @{ $other->methods };
  
      return unless @self_methods == @other_methods;
  
      while ( @self_methods ) {
          my $method = shift @self_methods;
          my $other_method = shift @other_methods;
  
          return unless $method eq $other_method;
      }
  
      return 1;
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  sub get_message {
      my $self = shift;
      my ($value) = @_;
  
      if ($self->has_message) {
          return $self->SUPER::get_message(@_);
      }
  
      return $self->SUPER::get_message($value) unless blessed($value);
  
      my @methods = grep { !$value->can($_) } @{ $self->methods };
      my $class = blessed $value;
      $class ||= $value;
  
      return $class
           . " is missing methods "
           . english_list(map { "'$_'" } @methods);
  }
  
  1;
  
  # ABSTRACT: Type constraint for duck typing
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::DuckType - Type constraint for duck typing
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class represents type constraints based on an enumerated list of
  required methods.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::DuckType> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::DuckType->new(%options)
  
  This creates a new duck type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with several
  exceptions. First, it requires an additional option, C<methods>. This
  should be an array reference containing a list of required method
  names. Second, it automatically sets the parent to the C<Object> type.
  
  Finally, it ignores any provided C<constraint> option. The constraint
  is generated automatically based on the provided C<methods>.
  
  =head2 $constraint->methods
  
  Returns the array reference of required methods provided to the
  constructor.
  
  =head2 $constraint->create_child_type
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::DuckType>
  object!
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_DUCKTYPE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ENUM';
  package Moose::Meta::TypeConstraint::Enum;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Moose::Util::TypeConstraints ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('values' => (
      accessor => 'values',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_inline_var_name' => (
      accessor => '_inline_var_name',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'defined(' . $val . ') '
               . '&& !ref(' . $val . ') '
               . '&& $' . $self->_inline_var_name . '{' . $val . '}';
  };
  
  my $var_suffix = 0;
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent} = Moose::Util::TypeConstraints::find_type_constraint('Str');
      $args{inlined} = $inliner;
  
      if ( scalar @{ $args{values} } < 1 ) {
          throw_exception( MustHaveAtLeastOneValueToEnumerate => params => \%args,
                                                                 class  => $class
                         );
      }
  
      for (@{ $args{values} }) {
          if (!defined($_)) {
              throw_exception( EnumValuesMustBeString => params => \%args,
                                                         class  => $class,
                                                         value  => $_
                             );
          }
          elsif (ref($_)) {
              throw_exception( EnumValuesMustBeString => params => \%args,
                                                         class  => $class,
                                                         value  => $_
                             );
          }
      }
  
      my %values = map { $_ => 1 } @{ $args{values} };
      $args{constraint} = sub { $values{ $_[0] } };
  
      my $var_name = 'enums' . $var_suffix++;;
      $args{_inline_var_name} = $var_name;
      $args{inline_environment} = { '%' . $var_name => \%values };
  
      my $self = $class->SUPER::new(\%args);
  
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
  
      return $self;
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_values  = sort @{ $self->values };
      my @other_values = sort @{ $other->values };
  
      return unless @self_values == @other_values;
  
      while ( @self_values ) {
          my $value = shift @self_values;
          my $other_value = shift @other_values;
  
          return unless $value eq $other_value;
      }
  
      return 1;
  }
  
  sub constraint {
      my $self = shift;
  
      my %values = map { $_ => undef } @{ $self->values };
  
      return sub { exists $values{$_[0]} };
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  1;
  
  # ABSTRACT: Type constraint for enumerated values.
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Enum - Type constraint for enumerated values.
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class represents type constraints based on an enumerated list of
  acceptable values.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Enum> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::Enum->new(%options)
  
  This creates a new enum type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with several
  exceptions. First, it requires an additional option, C<values>. This
  should be an array reference containing a list of valid string
  values. Second, it automatically sets the parent to the C<Str> type.
  
  Finally, it ignores any provided C<constraint> option. The constraint
  is generated automatically based on the provided C<values>.
  
  =head2 $constraint->values
  
  Returns the array reference of acceptable values provided to the
  constructor.
  
  =head2 $constraint->create_child_type
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::Enum>
  object!
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ENUM

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Parameterizable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZABLE';
  package Moose::Meta::TypeConstraint::Parameterizable;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use parent 'Moose::Meta::TypeConstraint';
  use Moose::Meta::TypeConstraint::Parameterized;
  use Moose::Util::TypeConstraints ();
  
  use Moose::Util 'throw_exception';
  
  use Carp 'confess';
  
  __PACKAGE__->meta->add_attribute('constraint_generator' => (
      accessor  => 'constraint_generator',
      predicate => 'has_constraint_generator',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inline_generator' => (
      accessor  => 'inline_generator',
      predicate => 'has_inline_generator',
      Class::MOP::_definition_context(),
  ));
  
  sub generate_constraint_for {
      my ($self, $type) = @_;
  
      return unless $self->has_constraint_generator;
  
      return $self->constraint_generator->($type->type_parameter)
          if $type->is_subtype_of($self->name);
  
      return $self->_can_coerce_constraint_from($type)
          if $self->has_coercion
          && $self->coercion->has_coercion_for_type($type->parent->name);
  
      return;
  }
  
  sub _can_coerce_constraint_from {
      my ($self, $type) = @_;
      my $coercion   = $self->coercion;
      my $constraint = $self->constraint_generator->($type->type_parameter);
      return sub {
          local $_ = $coercion->coerce($_);
          $constraint->(@_);
      };
  }
  
  sub generate_inline_for {
      my ($self, $type, $val) = @_;
  
      throw_exception( CannotGenerateInlineConstraint => parameterizable_type_object_name => $self->name,
                                                         type_name                        => $type->name,
                                                         value                            => $val,
                     )
          unless $self->has_inline_generator;
  
      return '( do { ' . $self->inline_generator->( $self, $type, $val ) . ' } )';
  }
  
  sub _parse_type_parameter {
      my ($self, $type_parameter) = @_;
      return Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($type_parameter);
  }
  
  sub parameterize {
      my ($self, $type_parameter) = @_;
  
      my $contained_tc = $self->_parse_type_parameter($type_parameter);
  
      ## The type parameter should be a subtype of the parent's type parameter
      ## if there is one.
  
      if(my $parent = $self->parent) {
          if($parent->can('type_parameter')) {
              unless ( $contained_tc->is_a_type_of($parent->type_parameter) ) {
                  throw_exception( ParameterIsNotSubtypeOfParent => type_parameter => $type_parameter,
                                                                    type_name      => $self->name,
                                 );
              }
          }
      }
  
      if ( $contained_tc->isa('Moose::Meta::TypeConstraint') ) {
          my $tc_name = $self->name . '[' . $contained_tc->name . ']';
          return Moose::Meta::TypeConstraint::Parameterized->new(
              name               => $tc_name,
              parent             => $self,
              type_parameter     => $contained_tc,
              parameterized_from => $self,
          );
      }
      else {
          confess("The type parameter must be a Moose meta type");
      }
  }
  
  
  1;
  
  # ABSTRACT: Type constraints which can take a parameter (ArrayRef)
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Parameterizable - Type constraints which can take a parameter (ArrayRef)
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class represents a parameterizable type constraint. This is a
  type constraint like C<ArrayRef> or C<HashRef>, that can be
  parameterized and made more specific by specifying a contained
  type. For example, instead of just an C<ArrayRef> of anything, you can
  specify that is an C<ArrayRef[Int]>.
  
  A parameterizable constraint should not be used as an attribute type
  constraint. Instead, when parameterized it creates a
  L<Moose::Meta::TypeConstraint::Parameterized> which should be used.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Parameterizable> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  This class is intentionally not documented because the API is
  confusing and needs some work.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZABLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Parameterized.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZED';
  package Moose::Meta::TypeConstraint::Parameterized;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  use Moose::Util::TypeConstraints;
  use Moose::Meta::TypeConstraint::Parameterizable;
  use Moose::Util 'throw_exception';
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('type_parameter' => (
      accessor  => 'type_parameter',
      predicate => 'has_type_parameter',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('parameterized_from' => (
      accessor   => 'parameterized_from',
      predicate  => 'has_parameterized_from',
      Class::MOP::_definition_context(),
  ));
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      return (
          $self->type_parameter->equals( $other->type_parameter )
              and
          $self->parent->equals( $other->parent )
      );
  }
  
  sub compile_type_constraint {
      my $self = shift;
  
      unless ( $self->has_type_parameter ) {
          throw_exception( CannotCreateHigherOrderTypeWithoutATypeParameter => type_name => $self->name );
      }
  
      my $type_parameter = $self->type_parameter;
  
      unless ( blessed $type_parameter && $type_parameter->isa('Moose::Meta::TypeConstraint') ) {
          throw_exception( TypeParameterMustBeMooseMetaType => type_name => $self->name );
      }
  
      foreach my $type (Moose::Util::TypeConstraints::get_all_parameterizable_types()) {
          if (my $constraint = $type->generate_constraint_for($self)) {
              $self->_set_constraint($constraint);
              return $self->SUPER::compile_type_constraint;
          }
      }
  
      # if we get here, then we couldn't
      # find a way to parameterize this type
      throw_exception( TypeConstraintCannotBeUsedForAParameterizableType => type_name        => $self->name,
                                                                            parent_type_name => $self->parent->name,
                     );
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      return
             $self->has_parameterized_from
          && $self->parameterized_from->has_inline_generator
          && $self->type_parameter->can_be_inlined;
  }
  
  sub inline_environment {
      my $self = shift;
  
      return {
          ($self->has_parameterized_from
              ? (%{ $self->parameterized_from->inline_environment })
              : ()),
          ($self->has_type_parameter
              ? (%{ $self->type_parameter->inline_environment })
              : ()),
      };
  }
  
  sub _inline_check {
      my $self = shift;
  
      return unless $self->can_be_inlined;
  
      return $self->parameterized_from->generate_inline_for( $self->type_parameter, @_ );
  }
  
  sub create_child_type {
      my ($self, %opts) = @_;
      return Moose::Meta::TypeConstraint::Parameterizable->new(%opts, parent=>$self);
  }
  
  1;
  
  # ABSTRACT: Type constraints with a bound parameter (ArrayRef[Int])
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Parameterized - Type constraints with a bound parameter (ArrayRef[Int])
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 METHODS
  
  This class is intentionally not documented because the API is
  confusing and needs some work.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Parameterized> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_PARAMETERIZED

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_REGISTRY';
  package Moose::Meta::TypeConstraint::Registry;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use parent 'Class::MOP::Object';
  
  use Moose::Util 'throw_exception';
  
  __PACKAGE__->meta->add_attribute('parent_registry' => (
      reader    => 'get_parent_registry',
      writer    => 'set_parent_registry',
      predicate => 'has_parent_registry',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('type_constraints' => (
      reader  => 'type_constraints',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my $self  = $class->_new(@_);
      return $self;
  }
  
  sub has_type_constraint {
      my ($self, $type_name) = @_;
      ($type_name and exists $self->type_constraints->{$type_name}) ? 1 : 0
  }
  
  sub get_type_constraint {
      my ($self, $type_name) = @_;
      return unless defined $type_name;
      $self->type_constraints->{$type_name}
  }
  
  sub add_type_constraint {
      my ($self, $type) = @_;
  
      unless ( $type && blessed $type && $type->isa('Moose::Meta::TypeConstraint') ) {
          throw_exception( InvalidTypeConstraint => registry_object => $self,
                                                    type            => $type
                         );
      }
  
      $self->type_constraints->{$type->name} = $type;
  }
  
  sub find_type_constraint {
      my ($self, $type_name) = @_;
      return $self->get_type_constraint($type_name)
          if $self->has_type_constraint($type_name);
      return $self->get_parent_registry->find_type_constraint($type_name)
          if $self->has_parent_registry;
      return;
  }
  
  1;
  
  # ABSTRACT: registry for type constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Registry - registry for type constraints
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class is a registry that maps type constraint names to
  L<Moose::Meta::TypeConstraint> objects.
  
  Currently, it is only used internally by
  L<Moose::Util::TypeConstraints>, which creates a single global
  registry.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Registry> is a subclass of
  L<Class::MOP::Object>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::Registry->new(%options)
  
  This creates a new registry object based on the provided C<%options>:
  
  =over 4
  
  =item * parent_registry
  
  This is an optional L<Moose::Meta::TypeConstraint::Registry>
  object.
  
  =item * type_constraints
  
  This is hash reference of type names to type objects. This is
  optional. Constraints can be added to the registry after it is
  created.
  
  =back
  
  =head2 $registry->get_parent_registry
  
  Returns the registry's parent registry, if it has one.
  
  =head2 $registry->has_parent_registry
  
  Returns true if the registry has a parent.
  
  =head2 $registry->set_parent_registry($registry)
  
  Sets the parent registry.
  
  =head2 $registry->get_type_constraint($type_name)
  
  This returns the L<Moose::Meta::TypeConstraint> object from the
  registry for the given name, if one exists.
  
  =head2 $registry->has_type_constraint($type_name)
  
  Returns true if the registry has a type of the given name.
  
  =head2 $registry->add_type_constraint($type)
  
  Adds a new L<Moose::Meta::TypeConstraint> object to the registry.
  
  =head2 $registry->find_type_constraint($type_name)
  
  This method looks in the current registry for the named type. If the
  type is not found, then this method will look in the registry's
  parent, if it has one.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_REGISTRY

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ROLE';
  package Moose::Meta::TypeConstraint::Role;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Moose::Util::TypeConstraints ();
  use Moose::Util ();
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('role' => (
      reader => 'role',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'Moose::Util::does_role('
               . $val . ', '
               . B::perlstring($self->role)
           . ')';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent} = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my $role_name = $args{role};
      $args{constraint} = sub { Moose::Util::does_role( $_[0], $role_name ) };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new( \%args );
  
      $self->compile_type_constraint();
  
      return $self;
  }
  
  sub parents {
      my $self = shift;
      return (
          $self->parent,
          map {
              # FIXME find_type_constraint might find a TC named after the role but that isn't really it
              # I did this anyway since it's a convention that preceded TypeConstraint::Role, and it should DWIM
              # if anybody thinks this problematic please discuss on IRC.
              # a possible fix is to add by attr indexing to the type registry to find types of a certain property
              # regardless of their name
              Moose::Util::TypeConstraints::find_type_constraint($_)
                  ||
              __PACKAGE__->new( role => $_, name => "__ANON__" )
          } @{ Class::MOP::class_of($self->role)->get_roles },
      );
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless defined $other;
      return unless $other->isa(__PACKAGE__);
  
      return $self->role eq $other->role;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      ($self->equals($type) || $self->is_subtype_of($type_or_name));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name_or_role ) = @_;
  
      if ( not ref $type_or_name_or_role ) {
          # it might be a role
          my $class = Class::MOP::class_of($self->role);
          return 1 if defined($class) && $class->does_role( $type_or_name_or_role );
      }
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_role);
  
      return unless defined $type;
  
      if ( $type->isa(__PACKAGE__) ) {
          # if $type_or_name_or_role isn't a role, it might be the TC name of another ::Role type
          # or it could also just be a type object in this branch
          my $class = Class::MOP::class_of($self->role);
          return defined($class) && $class->does_role( $type->role );
      } else {
          # the only other thing we are a subtype of is Object
          $self->SUPER::is_subtype_of($type);
      }
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  1;
  
  # ABSTRACT: Role/TypeConstraint parallel hierarchy
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Role - Role/TypeConstraint parallel hierarchy
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class represents type constraints for a role.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Role> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::Role->new(%options)
  
  This creates a new role type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with two exceptions. First,
  it requires an additional option, C<role>, which is name of the
  constraint's role.  Second, it automatically sets the parent to the
  C<Object> type.
  
  The constructor also overrides the hand optimized type constraint with
  one it creates internally.
  
  =head2 $constraint->role
  
  Returns the role name associated with the constraint.
  
  =head2 $constraint->parents
  
  Returns all the type's parent types, corresponding to the roles that
  its role does.
  
  =head2 $constraint->is_subtype_of($type_name_or_object)
  
  If the given type is also a role type, then this checks that the
  type's role does the other type's role.
  
  Otherwise it falls back to the implementation in
  L<Moose::Meta::TypeConstraint>.
  
  =head2 $constraint->create_child_type(%options)
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::Role>
  object!
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_ROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Meta/TypeConstraint/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_UNION';
  package Moose::Meta::TypeConstraint::Union;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use metaclass;
  
  use Moose::Meta::TypeCoercion::Union;
  
  use List::Util 1.33 qw(first all);
  
  use parent 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('type_constraints' => (
      accessor  => 'type_constraints',
      default   => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my ($class, %options) = @_;
  
      my $name = join '|' => sort { $a cmp $b }
          map { $_->name } @{ $options{type_constraints} };
  
      my $self = $class->SUPER::new(
          name => $name,
          %options,
      );
  
      $self->_set_constraint( $self->_compiled_type_constraint );
  
      return $self;
  }
  
  # XXX - this is a rather gross implementation of laziness for the benefit of
  # MX::Types. If we try to call ->has_coercion on the objects during object
  # construction, this does not work when defining a recursive constraint with
  # MX::Types.
  sub coercion {
      my $self = shift;
  
      return $self->{coercion} if exists $self->{coercion};
  
      # Using any instead of grep here causes a weird error with some corner
      # cases when MX::Types is in use. See RT #61001.
      if ( grep { $_->has_coercion } @{ $self->type_constraints } ) {
          return $self->{coercion} = Moose::Meta::TypeCoercion::Union->new(
              type_constraint => $self );
      }
      else {
          return $self->{coercion} = undef;
      }
  }
  
  sub has_coercion {
      return defined $_[0]->coercion;
  }
  
  sub _actually_compile_type_constraint {
      my $self = shift;
  
      my @constraints = @{ $self->type_constraints };
  
      return sub {
          my $value = shift;
          foreach my $type (@constraints) {
              return 1 if $type->check($value);
          }
          return undef;
      };
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      # This was originally done with all() from List::MoreUtils, but that
      # caused some sort of bizarro parsing failure under 5.10.
      for my $tc ( @{ $self->type_constraints } ) {
          return 0 unless $tc->can_be_inlined;
      }
  
      return 1;
  }
  
  sub _inline_check {
      my $self = shift;
      my $val  = shift;
  
      return '('
                 . (
                    join ' || ', map { '(' . $_->_inline_check($val) . ')' }
                    @{ $self->type_constraints }
                   )
             . ')';
  }
  
  sub inline_environment {
      my $self = shift;
  
      return { map { %{ $_->inline_environment } }
              @{ $self->type_constraints } };
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_constraints  = @{ $self->type_constraints };
      my @other_constraints = @{ $other->type_constraints };
  
      return unless @self_constraints == @other_constraints;
  
      # FIXME presort type constraints for efficiency?
      constraint: foreach my $constraint ( @self_constraints ) {
          for ( my $i = 0; $i < @other_constraints; $i++ ) {
              if ( $constraint->equals($other_constraints[$i]) ) {
                  splice @other_constraints, $i, 1;
                  next constraint;
              }
          }
      }
  
      return @other_constraints == 0;
  }
  
  sub parent {
      my $self = shift;
  
      my ($first, @rest) = @{ $self->type_constraints };
  
      for my $parent ( $first->_collect_all_parents ) {
          return $parent if all { $_->is_a_type_of($parent) } @rest;
      }
  
      return;
  }
  
  sub validate {
      my ($self, $value) = @_;
      my $message;
      foreach my $type (@{$self->type_constraints}) {
          my $err = $type->validate($value);
          return unless defined $err;
          $message .= ($message ? ' and ' : '') . $err
              if defined $err;
      }
      return ($message . ' in (' . $self->name . ')') ;
  }
  
  sub find_type_for {
      my ($self, $value) = @_;
  
      return first { $_->check($value) } @{ $self->type_constraints };
  }
  
  sub is_a_type_of {
      my ($self, $type_name) = @_;
  
      return all { $_->is_a_type_of($type_name) } @{ $self->type_constraints };
  }
  
  sub is_subtype_of {
      my ($self, $type_name) = @_;
  
      return all { $_->is_subtype_of($type_name) } @{ $self->type_constraints };
  }
  
  sub create_child_type {
      my ( $self, %opts ) = @_;
  
      my $constraint
          = Moose::Meta::TypeConstraint->new( %opts, parent => $self );
  
      # if we have a type constraint union, and no
      # type check, this means we are just aliasing
      # the union constraint, which means we need to
      # handle this differently.
      # - SL
      if ( not( defined $opts{constraint} )
          && $self->has_coercion ) {
          $constraint->coercion(
              Moose::Meta::TypeCoercion::Union->new(
                  type_constraint => $self,
              )
          );
      }
  
      return $constraint;
  }
  
  1;
  
  # ABSTRACT: A union of Moose type constraints
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Union - A union of Moose type constraints
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This metaclass represents a union of type constraints. A union takes
  multiple type constraints, and is true if any one of its member
  constraints is true.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Union> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =head2 Moose::Meta::TypeConstraint::Union->new(%options)
  
  This creates a new class type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent. It also requires an
  additional option, C<type_constraints>. This is an array reference
  containing the L<Moose::Meta::TypeConstraint> objects that are the
  members of the union type. The C<name> option defaults to the names
  all of these member types sorted and then joined by a pipe (|).
  
  The constructor sets the implementation of the constraint so that is
  simply calls C<check> on the newly created object.
  
  Finally, the constructor also makes sure that the object's C<coercion>
  attribute is a L<Moose::Meta::TypeCoercion::Union> object.
  
  =head2 $constraint->type_constraints
  
  This returns the array reference of C<type_constraints> provided to
  the constructor.
  
  =head2 $constraint->parent
  
  This returns the nearest common ancestor of all the components of the union.
  
  =head2 $constraint->check($value)
  
  =head2 $constraint->validate($value)
  
  These two methods simply call the relevant method on each of the
  member type constraints in the union. If any type accepts the value,
  the value is valid.
  
  With C<validate> the error message returned includes all of the error
  messages returned by the member type constraints.
  
  =head2 $constraint->equals($type_name_or_object)
  
  A type is considered equal if it is also a union type, and the two
  unions have the same member types.
  
  =head2 $constraint->find_type_for($value)
  
  This returns the first member type constraint for which C<check($value)> is
  true, allowing you to determine which of the Union's member type constraints
  a given value matches.
  
  =head2 $constraint->is_a_type_of($type_name_or_object)
  
  This returns true if all of the member type constraints return true
  for the C<is_a_type_of> method.
  
  =head2 $constraint->is_subtype_of
  
  This returns true if all of the member type constraints return true
  for the C<is_a_subtype_of> method.
  
  =head2 $constraint->create_child_type(%options)
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_META_TYPECONSTRAINT_UNION

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_OBJECT';
  package Moose::Object;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Carp ();
  use Devel::GlobalDestruction ();
  use MRO::Compat ();
  use Scalar::Util ();
  use Try::Tiny ();
  
  use Moose::Util ();
  
  use if ( not our $__mx_is_compiled ), 'Moose::Meta::Class';
  use if ( not our $__mx_is_compiled ), metaclass => 'Moose::Meta::Class';
  
  sub new {
      my $class = shift;
      my $real_class = Scalar::Util::blessed($class) || $class;
  
      my $params = $real_class->BUILDARGS(@_);
  
      return Class::MOP::Class->initialize($real_class)->new_object($params);
  }
  
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              Moose::Util::throw_exception( "SingleParamsToNewMustBeHashRef" );
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          Carp::carp(
              "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments" );
          return { @_, undef };
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
      # NOTE: we ask Perl if we even
      # need to do this first, to avoid
      # extra meta level calls
      return unless $_[0]->can('BUILD');
      my ($self, $params) = @_;
      foreach my $method (reverse Class::MOP::class_of($self)->find_all_methods_by_name('BUILD')) {
          $method->{code}->execute($self, $params);
      }
  }
  
  sub DEMOLISHALL {
      my $self = shift;
      my ($in_global_destruction) = @_;
  
      # NOTE: we ask Perl if we even
      # need to do this first, to avoid
      # extra meta level calls
      return unless $self->can('DEMOLISH');
  
      my @isa;
      if ( my $meta = Class::MOP::class_of($self ) ) {
          @isa = $meta->linearized_isa;
      } else {
          # We cannot count on being able to retrieve a previously made
          # metaclass, _or_ being able to make a new one during global
          # destruction. However, we should still be able to use mro at
          # that time (at least tests suggest so ;)
          my $class_name = ref $self;
          @isa = @{ mro::get_linear_isa($class_name) }
      }
  
      foreach my $class (@isa) {
          no strict 'refs';
          my $demolish = *{"${class}::DEMOLISH"}{CODE};
          $self->$demolish($in_global_destruction)
              if defined $demolish;
      }
  }
  
  sub DESTROY {
      my $self = shift;
  
      local $?;
  
      # < doy> if the destructor is being called because an exception is thrown, then $@ will be set
      # < doy> but if DEMOLISH does an eval which succeeds, that will clear $@
      # < doy> which is broken
      # < doy> try::tiny implicitly localizes $@ in the try block, which fixes that
      Try::Tiny::try {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
      }
      Try::Tiny::catch {
          die $_;
      };
  
      return;
  }
  
  # support for UNIVERSAL::DOES ...
  BEGIN {
      my $does = UNIVERSAL->can("DOES") ? "SUPER::DOES" : "isa";
      eval 'sub DOES {
          my ( $self, $class_or_role_name ) = @_;
          return $self->'.$does.'($class_or_role_name)
              || $self->does($class_or_role_name);
      }';
  }
  
  # new does() methods will be created
  # as appropriate see Moose::Meta::Role
  sub does {
      my ($self, $role_name) = @_;
      my $class = Scalar::Util::blessed($self) || $self;
      my $meta = Class::MOP::Class->initialize($class);
      (defined $role_name)
          || Moose::Util::throw_exception( DoesRequiresRoleName => class_name => $meta->name );
      return 1 if $meta->can('does_role') && $meta->does_role($role_name);
      return 0;
  }
  
  sub dump {
      my $self = shift;
      require Data::Dumper;
      local $Data::Dumper::Maxdepth = shift if @_;
      Data::Dumper::Dumper $self;
  }
  
  1;
  
  # ABSTRACT: The base object for Moose
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Object - The base object for Moose
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 DESCRIPTION
  
  This class is the default base class for all Moose-using classes. When
  you C<use Moose> in this class, your class will inherit from this
  class.
  
  It provides a default constructor and destructor, which run all of the
  C<BUILD> and C<DEMOLISH> methods in the inheritance hierarchy,
  respectively.
  
  You don't actually I<need> to inherit from this in order to use Moose,
  but it makes it easier to take advantage of all of Moose's features.
  
  =head1 METHODS
  
  =head2 Moose::Object->new(%params|$params)
  
  This method calls C<< $class->BUILDARGS(@_) >>, and then creates a new
  instance of the appropriate class. Once the instance is created, it
  calls C<< $instance->BUILD($params) >> for each C<BUILD> method in the
  inheritance hierarchy.
  
  =head2 Moose::Object->BUILDARGS(%params|$params)
  
  The default implementation of this method accepts a hash or hash
  reference of named parameters. If it receives a single argument that
  I<isn't> a hash reference it throws an error.
  
  You can override this method in your class to handle other types of
  options passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 $object->does($role_name)
  
  This returns true if the object does the given role.
  
  =head2 $object->DOES($class_or_role_name)
  
  This is a Moose role-aware implementation of L<UNIVERSAL/DOES>.
  
  This is effectively the same as writing:
  
    $object->does($name) || $object->isa($name)
  
  This method will work with Perl 5.8, which did not implement
  C<UNIVERSAL::DOES>.
  
  =head2 $object->dump($maxdepth)
  
  This is a handy utility for C<Data::Dumper>ing an object. By default,
  the maximum depth is 1, to avoid making a mess.
  
  =head2 $object->DESTROY
  
  A default destructor is provided, which calls
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method in the inheritance hierarchy.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_OBJECT

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_ROLE';
  use strict;
  use warnings;
  package Moose::Role;
  our $VERSION = '2.1603';
  
  use Scalar::Util ();
  use Carp ();
  use Class::Load  'is_class_loaded';
  use Module::Runtime 'module_notional_filename';
  
  use Sub::Exporter;
  
  use Moose       ();
  use Moose::Util 'throw_exception';
  
  use Moose::Exporter;
  use Moose::Meta::Role;
  use Moose::Util::TypeConstraints;
  
  sub extends {
      throw_exception("RolesDoNotSupportExtends");
  }
  
  sub with {
      Moose::Util::apply_all_roles( shift, @_ );
  }
  
  sub requires {
      my $meta = shift;
      throw_exception( MustSpecifyAtleastOneMethod => role_name => $meta->name ) unless @_;
      $meta->add_required_methods(@_);
  }
  
  sub excludes {
      my $meta = shift;
      throw_exception( MustSpecifyAtleastOneRole => role_name => $meta->name ) unless @_;
      $meta->add_excluded_roles(@_);
  }
  
  sub has {
      my $meta = shift;
      my $name = shift;
      throw_exception( InvalidHasProvidedInARole => role_name       => $meta->name,
                                                    attribute_name  => $name,
                     )
          if @_ == 1;
      my %context = Moose::Util::_caller_info;
      $context{context} = 'has declaration';
      $context{type} = 'role';
      my %options = ( definition_context => \%context, @_ );
      my $attrs = ( ref($name) eq 'ARRAY' ) ? $name : [ ($name) ];
      $meta->add_attribute( $_, %options ) for @$attrs;
  }
  
  sub _add_method_modifier {
      my $type = shift;
      my $meta = shift;
  
      if ( ref($_[0]) eq 'Regexp' ) {
          throw_exception( RolesDoNotSupportRegexReferencesForMethodModifiers => modifier_type => $type,
                                                                                 role_name     => $meta->name,
                         );
      }
  
      Moose::Util::add_method_modifier($meta, $type, \@_);
  }
  
  sub before { _add_method_modifier('before', @_) }
  
  sub after  { _add_method_modifier('after',  @_) }
  
  sub around { _add_method_modifier('around', @_) }
  
  # see Moose.pm for discussion
  sub super {
      return unless $Moose::SUPER_BODY;
      $Moose::SUPER_BODY->(@Moose::SUPER_ARGS);
  }
  
  sub override {
      my $meta = shift;
      my ( $name, $code ) = @_;
      $meta->add_override_method_modifier( $name, $code );
  }
  
  sub inner {
      throw_exception("RolesDoNotSupportInner");
  }
  
  sub augment {
      throw_exception("RolesDoNotSupportAugment");
  }
  
  Moose::Exporter->setup_import_methods(
      with_meta => [
          qw( with requires excludes has before after around override )
      ],
      as_is => [
          qw( extends super inner augment ),
          'Carp::confess',
          'Scalar::Util::blessed',
      ],
  );
  
  sub init_meta {
      shift;
      my %args = @_;
  
      my $role = $args{for_class};
  
      unless ($role) {
          require Moose;
          throw_exception( InitMetaRequiresClass => params => \%args );
      }
  
      my $metaclass = $args{metaclass} || "Moose::Meta::Role";
      my $meta_name = exists $args{meta_name} ? $args{meta_name} : 'meta';
  
      throw_exception( MetaclassNotLoaded => class_name => $metaclass )
          unless is_class_loaded($metaclass);
  
      throw_exception( MetaclassMustBeASubclassOfMooseMetaRole => role_name => $metaclass )
          unless $metaclass->isa('Moose::Meta::Role');
  
      # make a subtype for each Moose role
      role_type $role unless find_type_constraint($role);
  
      my $meta;
      if ( $meta = Class::MOP::get_metaclass_by_name($role) ) {
          unless ( $meta->isa("Moose::Meta::Role") ) {
              if ( $meta->isa('Moose::Meta::Class') ) {
                  throw_exception( MetaclassIsAClassNotASubclassOfGivenMetaclass => class_name => $role,
                                                                                    metaclass  => $metaclass,
                                 );
              } else {
                  throw_exception( MetaclassIsNotASubclassOfGivenMetaclass => class_name => $role,
                                                                              metaclass  => $metaclass,
                                 );
              }
          }
      }
      else {
          $meta = $metaclass->initialize($role);
          my $filename = module_notional_filename($meta->name);
          $INC{$filename} = '(set by Moose)'
              unless exists $INC{$filename};
      }
  
      if (defined $meta_name) {
          # also check for inherited non moose 'meta' method?
          my $existing = $meta->get_method($meta_name);
          if ($existing && !$existing->isa('Class::MOP::Method::Meta')) {
              Carp::cluck "Moose::Role is overwriting an existing method named "
                        . "$meta_name in role $role with a method "
                        . "which returns the class's metaclass. If this is "
                        . "actually what you want, you should remove the "
                        . "existing method, otherwise, you should rename or "
                        . "disable this generated method using the "
                        . "'-meta_name' option to 'use Moose::Role'.";
          }
          $meta->_add_meta_method($meta_name);
      }
  
      return $meta;
  }
  
  1;
  
  # ABSTRACT: The Moose Role
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Role - The Moose Role
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package Eq;
    use Moose::Role; # automatically turns on strict and warnings
  
    requires 'equal';
  
    sub no_equal {
        my ($self, $other) = @_;
        !$self->equal($other);
    }
  
    # ... then in your classes
  
    package Currency;
    use Moose; # automatically turns on strict and warnings
  
    with 'Eq';
  
    sub equal {
        my ($self, $other) = @_;
        $self->as_float == $other->as_float;
    }
  
    # ... and also
  
    package Comparator;
    use Moose;
  
    has compare_to => (
        is      => 'ro',
        does    => 'Eq',
        handles => 'Eq',
    );
  
    # ... which allows
  
    my $currency1 = Currency->new(...);
    my $currency2 = Currency->new(...);
    Comparator->new(compare_to => $currency1)->equal($currency2);
  
  =head1 DESCRIPTION
  
  The concept of roles is documented in L<Moose::Manual::Roles>. This document
  serves as API documentation.
  
  =head1 EXPORTED FUNCTIONS
  
  Moose::Role currently supports all of the functions that L<Moose> exports, but
  differs slightly in how some items are handled (see L</CAVEATS> below for
  details).
  
  Moose::Role also offers two role-specific keyword exports:
  
  =head2 requires (@method_names)
  
  Roles can require that certain methods are implemented by any class which
  C<does> the role.
  
  Note that attribute accessors also count as methods for the purposes
  of satisfying the requirements of a role.
  
  =head2 excludes (@role_names)
  
  Roles can C<exclude> other roles, in effect saying "I can never be combined
  with these C<@role_names>". This is a feature which should not be used
  lightly.
  
  =head2 no Moose::Role
  
  Moose::Role offers a way to remove the keywords it exports, through the
  C<unimport> method. You simply have to say C<no Moose::Role> at the bottom of
  your code for this to work.
  
  =head1 METACLASS
  
  When you use Moose::Role, you can specify traits which will be applied to your
  role metaclass:
  
      use Moose::Role -traits => 'My::Trait';
  
  This is very similar to the attribute traits feature. When you do
  this, your class's C<meta> object will have the specified traits
  applied to it. See L<Moose/Metaclass and Trait Name Resolution> for more
  details.
  
  All role metaclasses (note, not the role itself) extend L<Moose::Meta::Role>.
  You can test if a package is a role or not using L<Moose::Util/is_role>.
  
  =head1 APPLYING ROLES
  
  In addition to being applied to a class using the 'with' syntax (see
  L<Moose::Manual::Roles>) and using the L<Moose::Util> 'apply_all_roles'
  method, roles may also be applied to an instance of a class using
  L<Moose::Util> 'apply_all_roles' or the role's metaclass:
  
     MyApp::Test::SomeRole->meta->apply( $instance );
  
  Doing this creates a new, mutable, anonymous subclass, applies the role to that,
  and reblesses. In a debugger, for example, you will see class names of the
  form C< Moose::Meta::Class::__ANON__::SERIAL::6 >, which means that doing a
  'ref' on your instance may not return what you expect. See L<Moose::Object> for
  'DOES'.
  
  Additional params may be added to the new instance by providing
  'rebless_params'. See L<Moose::Meta::Role::Application::ToInstance>.
  
  =head1 CAVEATS
  
  Role support has only a few caveats:
  
  =over 4
  
  =item *
  
  Roles cannot use the C<extends> keyword; it will throw an exception for now.
  The same is true of the C<augment> and C<inner> keywords (not sure those
  really make sense for roles). All other Moose keywords will be I<deferred>
  so that they can be applied to the consuming class.
  
  =item *
  
  Role composition does its best to B<not> be order-sensitive when it comes to
  conflict resolution and requirements detection. However, it is order-sensitive
  when it comes to method modifiers. All before/around/after modifiers are
  included whenever a role is composed into a class, and then applied in the order
  in which the roles are used. This also means that there is no conflict for
  before/around/after modifiers.
  
  In most cases, this will be a non-issue; however, it is something to keep in
  mind when using method modifiers in a role. You should never assume any
  ordering.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_ROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL';
  package Moose::Util;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.014 'use_package_optimistically', 'use_module', 'module_notional_filename';
  use Data::OptList;
  use Params::Util qw( _STRING );
  use Sub::Exporter;
  use Scalar::Util 'blessed';
  use List::Util 1.33 qw(first any all);
  use overload ();
  use Try::Tiny;
  
  
  my @exports = qw[
      find_meta
      is_role
      does_role
      search_class_by_role
      ensure_all_roles
      apply_all_roles
      with_traits
      get_all_init_args
      get_all_attribute_values
      resolve_metatrait_alias
      resolve_metaclass_alias
      add_method_modifier
      english_list
      meta_attribute_alias
      meta_class_alias
      throw_exception
  ];
  
  Sub::Exporter::setup_exporter({
      exports => \@exports,
      groups  => { all => \@exports }
  });
  
  # Things that need to ->import from Moose::Util
  # should be loaded after Moose::Util defines ->import
  require Class::MOP;
  
  sub throw_exception {
      my ($class_name, @args_to_exception) = @_;
      my $class = "Moose::Exception::$class_name";
      _load_user_class( $class );
      die $class->new( @args_to_exception );
  }
  
  ## some utils for the utils ...
  
  sub find_meta { Class::MOP::class_of(@_) }
  
  ## the functions ...
  
  sub is_role {
      my $package_or_obj = shift;
  
      my $meta = find_meta($package_or_obj);
      return if not $meta;
      return $meta->isa('Moose::Meta::Role');
  }
  
  sub does_role {
      my ($class_or_obj, $role) = @_;
  
      if (try { $class_or_obj->isa('Moose::Object') }) {
          return $class_or_obj->does($role);
      }
  
      my $meta = find_meta($class_or_obj);
  
      return unless defined $meta;
      return unless $meta->can('does_role');
      return 1 if $meta->does_role($role);
      return;
  }
  
  sub search_class_by_role {
      my ($class_or_obj, $role) = @_;
  
      my $meta = find_meta($class_or_obj);
  
      return unless defined $meta;
  
      my $role_name = blessed $role ? $role->name : $role;
  
      foreach my $class ($meta->class_precedence_list) {
  
          my $_meta = find_meta($class);
  
          next unless defined $_meta;
  
          foreach my $role (@{ $_meta->roles || [] }) {
              return $class if $role->name eq $role_name;
          }
      }
  
      return;
  }
  
  # this can possibly behave in unexpected ways because the roles being composed
  # before being applied could differ from call to call; I'm not sure if or how
  # to document this possible quirk.
  sub ensure_all_roles {
      my $applicant = shift;
      _apply_all_roles($applicant, sub { !does_role($applicant, $_) }, @_);
  }
  
  sub apply_all_roles {
      my $applicant = shift;
      _apply_all_roles($applicant, undef, @_);
  }
  
  sub _apply_all_roles {
      my $applicant = shift;
      my $role_filter = shift;
  
      unless (@_) {
          require Moose;
          throw_exception( MustSpecifyAtleastOneRoleToApplicant => applicant => $applicant );
      }
  
      # If @_ contains role meta objects, mkopt will think that they're values,
      # because they're references.  In other words (roleobj1, roleobj2,
      # roleobj3) will become [ [ roleobj1, roleobj2 ], [ roleobj3, undef ] ]
      # -- this is no good.  We'll preprocess @_ first to eliminate the potential
      # bug.
      # -- rjbs, 2011-04-08
      my $roles = Data::OptList::mkopt( [@_], {
        moniker   => 'role',
        name_test => sub {
          ! ref $_[0] or blessed($_[0]) && $_[0]->isa('Moose::Meta::Role')
        }
      });
  
      my @role_metas;
      foreach my $role (@$roles) {
          my $meta;
  
          if ( blessed $role->[0] ) {
              $meta = $role->[0];
          }
          else {
              &use_module($role->[0], $role->[1] && $role->[1]{-version} ? $role->[1]{-version} : ());
              $meta = find_meta( $role->[0] );
          }
  
          unless ($meta && $meta->isa('Moose::Meta::Role') ) {
              throw_exception( CanOnlyConsumeRole => role_name => $role->[0] );
          }
  
          push @role_metas, [ $meta, $role->[1] ];
      }
  
      if ( defined $role_filter ) {
          @role_metas = grep { local $_ = $_->[0]; $role_filter->() } @role_metas;
      }
  
      return unless @role_metas;
  
      _load_user_class($applicant)
          unless blessed($applicant)
              || Class::MOP::class_of($applicant);
  
      my $meta = ( blessed $applicant ? $applicant : Moose::Meta::Class->initialize($applicant) );
  
      if ( scalar @role_metas == 1 ) {
          my ( $role, $params ) = @{ $role_metas[0] };
          $role->apply( $meta, ( defined $params ? %$params : () ) );
      }
      else {
          Moose::Meta::Role->combine(@role_metas)->apply($meta);
      }
  }
  
  sub with_traits {
      my ($class, @roles) = @_;
      return $class unless @roles;
      return Moose::Meta::Class->create_anon_class(
          superclasses => [$class],
          roles        => \@roles,
          cache        => 1,
      )->name;
  }
  
  # instance deconstruction ...
  
  sub get_all_attribute_values {
      my ($class, $instance) = @_;
      return +{
          map { $_->name => $_->get_value($instance) }
              grep { $_->has_value($instance) }
                  $class->get_all_attributes
      };
  }
  
  sub get_all_init_args {
      my ($class, $instance) = @_;
      return +{
          map { $_->init_arg => $_->get_value($instance) }
              grep { $_->has_value($instance) }
                  grep { defined($_->init_arg) }
                      $class->get_all_attributes
      };
  }
  
  sub resolve_metatrait_alias {
      return resolve_metaclass_alias( @_, trait => 1 );
  }
  
  sub _build_alias_package_name {
      my ($type, $name, $trait) = @_;
      return 'Moose::Meta::'
           . $type
           . '::Custom::'
           . ( $trait ? 'Trait::' : '' )
           . $name;
  }
  
  {
      my %cache;
  
      sub resolve_metaclass_alias {
          my ( $type, $metaclass_name, %options ) = @_;
  
          my $cache_key = $type . q{ } . ( $options{trait} ? '-Trait' : '' );
          return $cache{$cache_key}{$metaclass_name}
              if $cache{$cache_key}{$metaclass_name};
  
          my $possible_full_name = _build_alias_package_name(
              $type, $metaclass_name, $options{trait}
          );
  
          my @possible = ($possible_full_name, $metaclass_name);
          for my $package (@possible) {
              use_package_optimistically($package);
              if ($package->can('register_implementation')) {
                  return $cache{$cache_key}{$metaclass_name} =
                      $package->register_implementation;
              }
              elsif (find_meta($package)) {
                  return $cache{$cache_key}{$metaclass_name} = $package;
              }
          }
  
          throw_exception( CannotLocatePackageInINC => possible_packages => _english_list_or(@possible),
                                                       INC               => \@INC,
                                                       type              => $type,
                                                       metaclass_name    => $metaclass_name,
                                                       params            => \%options
                         );
      }
  }
  
  sub add_method_modifier {
      my ( $class_or_obj, $modifier_name, $args ) = @_;
      my $meta
          = $class_or_obj->can('add_before_method_modifier')
          ? $class_or_obj
          : find_meta($class_or_obj);
      my $code                = pop @{$args};
      my $add_modifier_method = 'add_' . $modifier_name . '_method_modifier';
      if ( my $method_modifier_type = ref( @{$args}[0] ) ) {
          if ( $method_modifier_type eq 'Regexp' ) {
              my @all_methods = $meta->get_all_methods;
              my @matched_methods
                  = grep { $_->name =~ @{$args}[0] } @all_methods;
              $meta->$add_modifier_method( $_->name, $code )
                  for @matched_methods;
          }
          elsif ($method_modifier_type eq 'ARRAY') {
              $meta->$add_modifier_method( $_, $code ) for @{$args->[0]};
          }
          else {
              throw_exception( IllegalMethodTypeToAddMethodModifier => class_or_object => $class_or_obj,
                                                                       modifier_name   => $modifier_name,
                                                                       params          => $args
                             );
          }
      }
      else {
          $meta->$add_modifier_method( $_, $code ) for @{$args};
      }
  }
  
  sub english_list {
      _english_list_and(@_);
  }
  
  sub _english_list_and {
      _english_list('and', \@_);
  }
  
  sub _english_list_or {
      _english_list('or', \@_);
  }
  
  sub _english_list {
      my ($conjunction, $items) = @_;
  
      my @items = sort @$items;
  
      return $items[0] if @items == 1;
      return "$items[0] $conjunction $items[1]" if @items == 2;
  
      my $tail = pop @items;
      my $list = join ', ', @items;
      $list .= ", $conjunction " . $tail;
  
      return $list;
  }
  
  sub _caller_info {
      my $level = @_ ? ($_[0] + 1) : 2;
      my %info;
      @info{qw(package file line)} = caller($level);
      return %info;
  }
  
  sub _create_alias {
      my ($type, $name, $trait, $for) = @_;
      my $package = _build_alias_package_name($type, $name, $trait);
      Class::MOP::Class->initialize($package)->add_method(
          register_implementation => sub { $for }
      );
  }
  
  sub meta_attribute_alias {
      my ($to, $from) = @_;
      $from ||= caller;
      my $meta = Class::MOP::class_of($from);
      my $trait = $meta->isa('Moose::Meta::Role');
      _create_alias('Attribute', $to, $trait, $from);
  }
  
  sub meta_class_alias {
      my ($to, $from) = @_;
      $from ||= caller;
      my $meta = Class::MOP::class_of($from);
      my $trait = $meta->isa('Moose::Meta::Role');
      _create_alias('Class', $to, $trait, $from);
  }
  
  sub _load_user_class {
      my ($class, $opts) = @_;
      &use_package_optimistically(
          $class,
          $opts && $opts->{-version} ? $opts->{-version} : ()
      );
  }
  
  # XXX - this should be added to Params::Util
  sub _STRINGLIKE0 ($) {
      return 1 if _STRING( $_[0] );
      if ( blessed $_[0] ) {
          return overload::Method( $_[0], q{""} );
      }
  
      return 1 if defined $_[0] && $_[0] eq q{};
  
      return 0;
  }
  
  sub _reconcile_roles_for_metaclass {
      my ($class_meta_name, $super_meta_name) = @_;
  
      my @role_differences = _role_differences(
          $class_meta_name, $super_meta_name,
      );
  
      # handle the case where we need to fix compatibility between a class and
      # its parent, but all roles in the class are already also done by the
      # parent
      # see t/metaclasses/metaclass_compat_no_fixing_bug.t
      return $super_meta_name
          unless @role_differences;
  
      return Moose::Meta::Class->create_anon_class(
          superclasses => [$super_meta_name],
          roles        => [map { $_->name } @role_differences],
          cache        => 1,
      )->name;
  }
  
  sub _role_differences {
      my ($class_meta_name, $super_meta_name) = @_;
      my @super_role_metas = map {
          $_->isa('Moose::Meta::Role::Composite')
              ? (@{ $_->get_roles })
              : ($_)
      } $super_meta_name->meta->can('_roles_with_inheritance')
          ? $super_meta_name->meta->_roles_with_inheritance
      : $super_meta_name->meta->can('roles')
          ? @{ $super_meta_name->meta->roles }
      :     ();
      my @role_metas = map {
          $_->isa('Moose::Meta::Role::Composite')
              ? (@{ $_->get_roles })
              : ($_)
      } $class_meta_name->meta->can('_roles_with_inheritance')
          ? $class_meta_name->meta->_roles_with_inheritance
      : $class_meta_name->meta->can('roles')
          ? @{ $class_meta_name->meta->roles }
      :     ();
      my @differences;
      for my $role_meta (@role_metas) {
          push @differences, $role_meta
              unless any { $_->name eq $role_meta->name } @super_role_metas;
      }
      return @differences;
  }
  
  sub _classes_differ_by_roles_only {
      my ( $self_meta_name, $super_meta_name ) = @_;
  
      my $common_base_name
          = _find_common_base( $self_meta_name, $super_meta_name );
  
      return unless defined $common_base_name;
  
      my @super_meta_name_ancestor_names
          = _get_ancestors_until( $super_meta_name, $common_base_name );
      my @class_meta_name_ancestor_names
          = _get_ancestors_until( $self_meta_name, $common_base_name );
  
      return
          unless all { _is_role_only_subclass($_) }
          @super_meta_name_ancestor_names,
          @class_meta_name_ancestor_names;
  
      return 1;
  }
  
  sub _find_common_base {
      my ($meta1, $meta2) = map { Class::MOP::class_of($_) } @_;
      return unless defined $meta1 && defined $meta2;
  
      # FIXME? This doesn't account for multiple inheritance (not sure
      # if it needs to though). For example, if somewhere in $meta1's
      # history it inherits from both ClassA and ClassB, and $meta2
      # inherits from ClassB & ClassA, does it matter? And what crazy
      # fool would do that anyway?
  
      my %meta1_parents = map { $_ => 1 } $meta1->linearized_isa;
  
      return first { $meta1_parents{$_} } $meta2->linearized_isa;
  }
  
  sub _get_ancestors_until {
      my ($start_name, $until_name) = @_;
  
      my @ancestor_names;
      for my $ancestor_name (Class::MOP::class_of($start_name)->linearized_isa) {
          last if $ancestor_name eq $until_name;
          push @ancestor_names, $ancestor_name;
      }
      return @ancestor_names;
  }
  
  sub _is_role_only_subclass {
      my ($meta_name) = @_;
      my $meta = Class::MOP::Class->initialize($meta_name);
      my @parent_names = $meta->superclasses;
  
      # XXX: don't feel like messing with multiple inheritance here... what would
      # that even do?
      return unless @parent_names == 1;
      my ($parent_name) = @parent_names;
      my $parent_meta = Class::MOP::Class->initialize($parent_name);
  
      # only get the roles attached to this particular class, don't look at
      # superclasses
      my @roles = $meta->can('calculate_all_roles')
                      ? $meta->calculate_all_roles
                      : ();
  
      # it's obviously not a role-only subclass if it doesn't do any roles
      return unless @roles;
  
      # loop over all methods that are a part of the current class
      # (not inherited)
      for my $method ( $meta->_get_local_methods ) {
          # always ignore meta
          next if $method->isa('Class::MOP::Method::Meta');
          # we'll deal with attributes below
          next if $method->can('associated_attribute');
          # if the method comes from a role we consumed, ignore it
          next if $meta->can('does_role')
               && $meta->does_role($method->original_package_name);
          # FIXME - this really isn't right. Just because a modifier is
          # defined in a role doesn't mean it isn't _also_ defined in the
          # subclass.
          next if $method->isa('Class::MOP::Method::Wrapped')
               && (
                   (!scalar($method->around_modifiers)
                 || any { $_->has_around_method_modifiers($method->name) } @roles)
                && (!scalar($method->before_modifiers)
                 || any { $_->has_before_method_modifiers($method->name) } @roles)
                && (!scalar($method->after_modifiers)
                 || any { $_->has_after_method_modifiers($method->name) } @roles)
                  );
  
          return 0;
      }
  
      # loop over all attributes that are a part of the current class
      # (not inherited)
      # FIXME - this really isn't right. Just because an attribute is
      # defined in a role doesn't mean it isn't _also_ defined in the
      # subclass.
      for my $attr (map { $meta->get_attribute($_) } $meta->get_attribute_list) {
          next if any { $_->has_attribute($attr->name) } @roles;
  
          return 0;
      }
  
      return 1;
  }
  
  sub _is_package_loaded {
      my ($package) = @_;
      defined $INC{module_notional_filename($package)};
  }
  
  1;
  
  # ABSTRACT: Utilities for working with Moose classes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Util - Utilities for working with Moose classes
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    use Moose::Util qw/find_meta does_role search_class_by_role/;
  
    my $meta = find_meta($object) || die "No metaclass found";
  
    if (does_role($object, $role)) {
      print "The object can do $role!\n";
    }
  
    my $class = search_class_by_role($object, 'FooRole');
    print "Nearest class with 'FooRole' is $class\n";
  
  =head1 DESCRIPTION
  
  This module provides a set of utility functions. Many of these
  functions are intended for use in Moose itself or MooseX modules, but
  some of them may be useful for use in your own code.
  
  =head1 EXPORTED FUNCTIONS
  
  =head2 find_meta($class_or_obj)
  
  This method takes a class name or object and attempts to find a
  metaclass for the class, if one exists. It will B<not> create one if it
  does not yet exist.
  
  =head2 is_role($package_or_obj)
  
  Returns true if the provided package name or object is a L<Moose::Role>.
  
  =head2 does_role($class_or_obj, $role_or_obj)
  
  Returns true if C<$class_or_obj> does the given C<$role_or_obj>. The role can
  be provided as a name or a L<Moose::Meta::Role> object.
  
  The class must already have a metaclass for this to work. If it doesn't, this
  function simply returns false.
  
  =head2 search_class_by_role($class_or_obj, $role_or_obj)
  
  Returns the first class in the class's precedence list that does
  C<$role_or_obj>, if any. The role can be either a name or a
  L<Moose::Meta::Role> object.
  
  The class must already have a metaclass for this to work.
  
  =head2 apply_all_roles($applicant, @roles)
  
  This function applies one or more roles to the given C<$applicant>. The
  applicant can be a role name, class name, or object.
  
  The C<$applicant> must already have a metaclass object.
  
  The list of C<@roles> should a list of names or L<Moose::Meta::Role> objects,
  each of which can be followed by an optional hash reference of options
  (C<-excludes> and C<-alias>).
  
  =head2 ensure_all_roles($applicant, @roles)
  
  This function is similar to C<apply_all_roles>, but only applies roles that
  C<$applicant> does not already consume.
  
  =head2 with_traits($class_name, @role_names)
  
  This function creates a new class from C<$class_name> with each of
  C<@role_names> applied. It returns the name of the new class.
  
  =head2 get_all_attribute_values($meta, $instance)
  
  Returns a hash reference containing all of the C<$instance>'s
  attributes. The keys are attribute names.
  
  =head2 get_all_init_args($meta, $instance)
  
  Returns a hash reference containing all of the C<init_arg> values for
  the instance's attributes. The values are the associated attribute
  values. If an attribute does not have a defined C<init_arg>, it is
  skipped.
  
  This could be useful in cloning an object.
  
  =head2 resolve_metaclass_alias($category, $name, %options)
  
  =head2 resolve_metatrait_alias($category, $name, %options)
  
  Resolves a short name to a full class name. Short names are often used
  when specifying the C<metaclass> or C<traits> option for an attribute:
  
      has foo => (
          metaclass => "Bar",
      );
  
  The name resolution mechanism is covered in
  L<Moose/Metaclass and Trait Name Resolution>.
  
  =head2 meta_class_alias($to[, $from])
  
  =head2 meta_attribute_alias($to[, $from])
  
  Create an alias from the class C<$from> (or the current package, if
  C<$from> is unspecified), so that
  L<Moose/Metaclass and Trait Name Resolution> works properly.
  
  =head2 english_list(@items)
  
  Given a list of scalars, turns them into a proper list in English
  ("one and two", "one, two, three, and four"). This is used to help us
  make nicer error messages.
  
  =head2 throw_exception( $class_name, %arguments_to_exception)
  
  Calls die with an object of Moose::Exception::$class_name, with
  %arguments_to_exception passed as arguments.
  
  =head1 TODO
  
  Here is a list of possible functions to write
  
  =over 4
  
  =item discovering original method from modified method
  
  =item search for origin class of a method or attribute
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Util/MetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_METAROLE';
  package Moose::Util::MetaRole;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  use Scalar::Util 'blessed';
  
  use List::Util 1.33 qw( first all );
  use Moose::Deprecated;
  use Moose::Util 'throw_exception';
  
  sub apply_metaroles {
      my %args = @_;
  
      my $for = _metathing_for( $args{for} );
  
      if ( $for->isa('Moose::Meta::Role') ) {
          return _make_new_metaclass( $for, $args{role_metaroles}, 'role' );
      }
      else {
          return _make_new_metaclass( $for, $args{class_metaroles}, 'class' );
      }
  }
  
  sub _metathing_for {
      my $passed = shift;
  
      my $found
          = blessed $passed
          ? $passed
          : Class::MOP::class_of($passed);
  
      return $found
          if defined $found
              && blessed $found
              && (   $found->isa('Moose::Meta::Role')
                  || $found->isa('Moose::Meta::Class') );
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
  
      throw_exception( InvalidArgPassedToMooseUtilMetaRole => argument => $passed );
  }
  
  sub _make_new_metaclass {
      my $for     = shift;
      my $roles   = shift;
      my $primary = shift;
  
      return $for unless keys %{$roles};
  
      my $new_metaclass
          = exists $roles->{$primary}
          ? _make_new_class( ref $for, $roles->{$primary} )
          : blessed $for;
  
      my %classes;
  
      for my $key ( grep { $_ ne $primary } keys %{$roles} ) {
          my $attr = first {$_}
              map { $for->meta->find_attribute_by_name($_) } (
              $key . '_metaclass',
              $key . '_class'
          );
  
          my $reader = $attr->get_read_method;
  
          $classes{ $attr->init_arg }
              = _make_new_class( $for->$reader(), $roles->{$key} );
      }
  
      my $new_meta = $new_metaclass->reinitialize( $for, %classes );
  
      return $new_meta;
  }
  
  sub apply_base_class_roles {
      my %args = @_;
  
      my $meta = _metathing_for( $args{for} || $args{for_class} );
      throw_exception( CannotApplyBaseClassRolesToRole => params    => \%args,
                                                          role_name => $meta->name,
                     )
          if $meta->isa('Moose::Meta::Role');
  
      my $new_base = _make_new_class(
          $meta->name,
          $args{roles},
          [ $meta->superclasses() ],
      );
  
      $meta->superclasses($new_base)
          if $new_base ne $meta->name();
  }
  
  sub _make_new_class {
      my $existing_class = shift;
      my $roles          = shift;
      my $superclasses   = shift || [$existing_class];
  
      return $existing_class unless $roles;
  
      my $meta = Class::MOP::Class->initialize($existing_class);
  
      return $existing_class
          if $meta->can('does_role') && all  { $meta->does_role($_) }
                                        grep { !ref $_ } @{$roles};
  
      return Moose::Meta::Class->create_anon_class(
          superclasses => $superclasses,
          roles        => $roles,
          cache        => 1,
      )->name();
  }
  
  1;
  
  # ABSTRACT: Apply roles to any metaclass, as well as the object base class
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Util::MetaRole - Apply roles to any metaclass, as well as the object base class
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package MyApp::Moose;
  
    use Moose ();
    use Moose::Exporter;
    use Moose::Util::MetaRole;
  
    use MyApp::Role::Meta::Class;
    use MyApp::Role::Meta::Method::Constructor;
    use MyApp::Role::Object;
  
    Moose::Exporter->setup_import_methods( also => 'Moose' );
  
    sub init_meta {
        shift;
        my %args = @_;
  
        Moose->init_meta(%args);
  
        Moose::Util::MetaRole::apply_metaroles(
            for             => $args{for_class},
            class_metaroles => {
                class       => ['MyApp::Role::Meta::Class'],
                constructor => ['MyApp::Role::Meta::Method::Constructor'],
            },
        );
  
        Moose::Util::MetaRole::apply_base_class_roles(
            for   => $args{for_class},
            roles => ['MyApp::Role::Object'],
        );
  
        return $args{for_class}->meta();
    }
  
  =head1 DESCRIPTION
  
  This utility module is designed to help authors of Moose extensions
  write extensions that are able to cooperate with other Moose
  extensions. To do this, you must write your extensions as roles, which
  can then be dynamically applied to the caller's metaclasses.
  
  This module makes sure to preserve any existing superclasses and roles
  already set for the meta objects, which means that any number of
  extensions can apply roles in any order.
  
  =head1 USAGE
  
  The easiest way to use this module is through L<Moose::Exporter>, which can
  generate the appropriate C<init_meta> method for you, and make sure it is
  called when imported.
  
  =head1 FUNCTIONS
  
  This module provides two functions.
  
  =head2 apply_metaroles( ... )
  
  This function will apply roles to one or more metaclasses for the specified
  class. It will return a new metaclass object for the class or role passed in
  the "for" parameter.
  
  It accepts the following parameters:
  
  =over 4
  
  =item * for => $name
  
  This specifies the class or for which to alter the meta classes. This can be a
  package name, or an appropriate meta-object (a L<Moose::Meta::Class> or
  L<Moose::Meta::Role>).
  
  =item * class_metaroles => \%roles
  
  This is a hash reference specifying which metaroles will be applied to the
  class metaclass and its contained metaclasses and helper classes.
  
  Each key should in turn point to an array reference of role names.
  
  It accepts the following keys:
  
  =over 8
  
  =item class
  
  =item attribute
  
  =item method
  
  =item wrapped_method
  
  =item instance
  
  =item constructor
  
  =item destructor
  
  =item error
  
  =back
  
  =item * role_metaroles => \%roles
  
  This is a hash reference specifying which metaroles will be applied to the
  role metaclass and its contained metaclasses and helper classes.
  
  It accepts the following keys:
  
  =over 8
  
  =item role
  
  =item attribute
  
  =item method
  
  =item required_method
  
  =item conflicting_method
  
  =item application_to_class
  
  =item application_to_role
  
  =item application_to_instance
  
  =item application_role_summation
  
  =item applied_attribute
  
  =back
  
  =back
  
  =head2 apply_base_class_roles( for => $class, roles => \@roles )
  
  This function will apply the specified roles to the object's base class.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_METAROLE

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Util/TypeConstraints.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS';
  package Moose::Util::TypeConstraints;
  our $VERSION = '2.1603';
  
  use Carp ();
  use Scalar::Util qw( blessed );
  use Moose::Exporter;
  use Moose::Deprecated;
  
  ## --------------------------------------------------------
  # Prototyped subs must be predeclared because we have a
  # circular dependency with Moose::Meta::Attribute et. al.
  # so in case of us being use'd first the predeclaration
  # ensures the prototypes are in scope when consumers are
  # compiled.
  
  # dah sugah!
  sub where (&);
  sub via (&);
  sub message (&);
  sub inline_as (&);
  
  ## --------------------------------------------------------
  
  use Moose::Meta::TypeConstraint;
  use Moose::Meta::TypeConstraint::Union;
  use Moose::Meta::TypeConstraint::Parameterized;
  use Moose::Meta::TypeConstraint::Parameterizable;
  use Moose::Meta::TypeConstraint::Class;
  use Moose::Meta::TypeConstraint::Role;
  use Moose::Meta::TypeConstraint::Enum;
  use Moose::Meta::TypeConstraint::DuckType;
  use Moose::Meta::TypeCoercion;
  use Moose::Meta::TypeCoercion::Union;
  use Moose::Meta::TypeConstraint::Registry;
  
  use Moose::Util 'throw_exception';
  
  Moose::Exporter->setup_import_methods(
      as_is => [
          qw(
              type subtype class_type role_type maybe_type duck_type
              as where message inline_as
              coerce from via
              enum union
              find_type_constraint
              register_type_constraint
              match_on_type )
      ],
  );
  
  ## --------------------------------------------------------
  ## type registry and some useful functions for it
  ## --------------------------------------------------------
  
  my $REGISTRY = Moose::Meta::TypeConstraint::Registry->new;
  
  sub get_type_constraint_registry {$REGISTRY}
  sub list_all_type_constraints    { keys %{ $REGISTRY->type_constraints } }
  
  sub export_type_constraints_as_functions {
      my $pkg = caller();
      no strict 'refs';
      foreach my $constraint ( keys %{ $REGISTRY->type_constraints } ) {
          my $tc = $REGISTRY->get_type_constraint($constraint)
              ->_compiled_type_constraint;
          *{"${pkg}::${constraint}"}
              = sub { $tc->( $_[0] ) ? 1 : undef };    # the undef is for compat
      }
  }
  
  sub create_type_constraint_union {
      _create_type_constraint_union(\@_);
  }
  
  sub create_named_type_constraint_union {
      my $name = shift;
      _create_type_constraint_union($name, \@_);
  }
  
  sub _create_type_constraint_union {
      my $name;
      $name = shift if @_ > 1;
      my @tcs = @{ shift() };
  
      my @type_constraint_names;
  
      if ( scalar @tcs == 1 && _detect_type_constraint_union( $tcs[0] ) ) {
          @type_constraint_names = _parse_type_constraint_union( $tcs[0] );
      }
      else {
          @type_constraint_names = @tcs;
      }
  
      ( scalar @type_constraint_names >= 2 )
          || throw_exception("UnionTakesAtleastTwoTypeNames");
  
      my @type_constraints = map {
          find_or_parse_type_constraint($_)
              || throw_exception( CouldNotLocateTypeConstraintForUnion => type_name => $_ );
      } @type_constraint_names;
  
      my %options = (
        type_constraints => \@type_constraints
      );
      $options{name} = $name if defined $name;
  
      return Moose::Meta::TypeConstraint::Union->new(%options);
  }
  
  
  sub create_parameterized_type_constraint {
      my $type_constraint_name = shift;
      my ( $base_type, $type_parameter )
          = _parse_parameterized_type_constraint($type_constraint_name);
  
      ( defined $base_type && defined $type_parameter )
          || throw_exception( InvalidTypeGivenToCreateParameterizedTypeConstraint => type_name => $type_constraint_name );
  
      if ( $REGISTRY->has_type_constraint($base_type) ) {
          my $base_type_tc = $REGISTRY->get_type_constraint($base_type);
          return _create_parameterized_type_constraint(
              $base_type_tc,
              $type_parameter
          );
      }
      else {
          throw_exception( InvalidBaseTypeGivenToCreateParameterizedTypeConstraint => type_name => $base_type );
      }
  }
  
  sub _create_parameterized_type_constraint {
      my ( $base_type_tc, $type_parameter ) = @_;
      if ( $base_type_tc->can('parameterize') ) {
          return $base_type_tc->parameterize($type_parameter);
      }
      else {
          return Moose::Meta::TypeConstraint::Parameterized->new(
              name   => $base_type_tc->name . '[' . $type_parameter . ']',
              parent => $base_type_tc,
              type_parameter =>
                  find_or_create_isa_type_constraint($type_parameter),
          );
      }
  }
  
  #should we also support optimized checks?
  sub create_class_type_constraint {
      my ( $class, $options ) = @_;
  
  # too early for this check
  #find_type_constraint("ClassName")->check($class)
  #    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");
  
      my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );
  
      if (my $type = $REGISTRY->get_type_constraint($class)) {
          if (!($type->isa('Moose::Meta::TypeConstraint::Class') && $type->class eq $class)) {
              throw_exception( TypeConstraintIsAlreadyCreated => package_defined_in => $pkg_defined_in,
                                                                 type_name          => $type->name,
                             );
          }
          else {
              return $type;
          }
      }
  
      my %options = (
          class              => $class,
          name               => $class,
          package_defined_in => $pkg_defined_in,
          %{ $options || {} },    # overrides options from above
      );
  
      $options{name} ||= "__ANON__";
  
      my $tc = Moose::Meta::TypeConstraint::Class->new(%options);
      $REGISTRY->add_type_constraint($tc);
      return $tc;
  }
  
  sub create_role_type_constraint {
      my ( $role, $options ) = @_;
  
  # too early for this check
  #find_type_constraint("ClassName")->check($class)
  #    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");
  
      my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );
  
      if (my $type = $REGISTRY->get_type_constraint($role)) {
          if (!($type->isa('Moose::Meta::TypeConstraint::Role') && $type->role eq $role)) {
              throw_exception( TypeConstraintIsAlreadyCreated => type_name          => $type->name,
                                                                 package_defined_in => $pkg_defined_in
                             );
          }
          else {
              return $type;
          }
      }
  
      my %options = (
          role               => $role,
          name               => $role,
          package_defined_in => $pkg_defined_in,
          %{ $options || {} },
      );
  
      $options{name} ||= "__ANON__";
  
      my $tc = Moose::Meta::TypeConstraint::Role->new(%options);
      $REGISTRY->add_type_constraint($tc);
      return $tc;
  }
  
  sub find_or_create_type_constraint {
      my ( $type_constraint_name, $options_for_anon_type ) = @_;
  
      if ( my $constraint
          = find_or_parse_type_constraint($type_constraint_name) ) {
          return $constraint;
      }
      elsif ( defined $options_for_anon_type ) {
  
          # NOTE:
          # if there is no $options_for_anon_type
          # specified, then we assume they don't
          # want to create one, and return nothing.
  
          # otherwise assume that we should create
          # an ANON type with the $options_for_anon_type
          # options which can be passed in. It should
          # be noted that these don't get registered
          # so we need to return it.
          # - SL
          return Moose::Meta::TypeConstraint->new(
              name => '__ANON__',
              %{$options_for_anon_type}
          );
      }
  
      return;
  }
  
  sub find_or_create_isa_type_constraint {
      my ($type_constraint_name, $options) = @_;
      find_or_parse_type_constraint($type_constraint_name)
          || create_class_type_constraint($type_constraint_name, $options);
  }
  
  sub find_or_create_does_type_constraint {
      my ($type_constraint_name, $options) = @_;
      find_or_parse_type_constraint($type_constraint_name)
          || create_role_type_constraint($type_constraint_name, $options);
  }
  
  sub find_or_parse_type_constraint {
      my $type_constraint_name = normalize_type_constraint_name(shift);
      my $constraint;
  
      if ( $constraint = find_type_constraint($type_constraint_name) ) {
          return $constraint;
      }
      elsif ( _detect_type_constraint_union($type_constraint_name) ) {
          $constraint = create_type_constraint_union($type_constraint_name);
      }
      elsif ( _detect_parameterized_type_constraint($type_constraint_name) ) {
          $constraint
              = create_parameterized_type_constraint($type_constraint_name);
      }
      else {
          return;
      }
  
      $REGISTRY->add_type_constraint($constraint);
      return $constraint;
  }
  
  sub normalize_type_constraint_name {
      my $type_constraint_name = shift;
      $type_constraint_name =~ s/\s//g;
      return $type_constraint_name;
  }
  
  sub _confess {
      my $error = shift;
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      Carp::confess($error);
  }
  
  ## --------------------------------------------------------
  ## exported functions ...
  ## --------------------------------------------------------
  
  sub find_type_constraint {
      my $type = shift;
  
      if ( blessed $type and $type->isa("Moose::Meta::TypeConstraint") ) {
          return $type;
      }
      else {
          return unless $REGISTRY->has_type_constraint($type);
          return $REGISTRY->get_type_constraint($type);
      }
  }
  
  sub register_type_constraint {
      my $constraint = shift;
      throw_exception( CannotRegisterUnnamedTypeConstraint => type => $constraint )
          unless defined $constraint->name;
      $REGISTRY->add_type_constraint($constraint);
      return $constraint;
  }
  
  # type constructors
  
  sub type {
      my $name = shift;
  
      my %p = map { %{$_} } @_;
  
      return _create_type_constraint(
          $name, undef, $p{where}, $p{message},
          $p{inline_as},
      );
  }
  
  sub subtype {
      if ( @_ == 1 && !ref $_[0] ) {
          throw_exception( NoParentGivenToSubtype => name => $_[0] );
      }
  
      # The blessed check is mostly to accommodate MooseX::Types, which
      # uses an object which overloads stringification as a type name.
      my $name = ref $_[0] && !blessed $_[0] ? undef : shift;
  
      my %p = map { %{$_} } @_;
  
      # subtype Str => where { ... };
      if ( !exists $p{as} ) {
          $p{as} = $name;
          $name = undef;
      }
  
      return _create_type_constraint(
          $name, $p{as}, $p{where}, $p{message},
          $p{inline_as},
      );
  }
  
  sub class_type {
      create_class_type_constraint(@_);
  }
  
  sub role_type ($;$) {
      create_role_type_constraint(@_);
  }
  
  sub maybe_type {
      my ($type_parameter) = @_;
  
      register_type_constraint(
          $REGISTRY->get_type_constraint('Maybe')->parameterize($type_parameter)
      );
  }
  
  sub duck_type {
      my ( $type_name, @methods ) = @_;
      if ( ref $type_name eq 'ARRAY' && !@methods ) {
          @methods   = ($type_name);
          $type_name = undef;
      }
      if ( @methods == 1 && ref $methods[0] eq 'ARRAY' ) {
          @methods = @{ $methods[0] };
      }
      else {
          Moose::Deprecated::deprecated(
              feature => 'non-arrayref form of duck_type',
              message => "Passing a list of values to duck_type is deprecated. "
                       . "The method names should be wrapped in an arrayref.",
          );
      }
  
      register_type_constraint(
          create_duck_type_constraint(
              $type_name,
              \@methods,
          )
      );
  }
  
  sub coerce {
      my ( $type_name, @coercion_map ) = @_;
      _install_type_coercions( $type_name, \@coercion_map );
  }
  
  # The trick of returning @_ lets us avoid having to specify a
  # prototype. Perl will parse this:
  #
  # subtype 'Foo'
  #     => as 'Str'
  #     => where { ... }
  #
  # as this:
  #
  # subtype( 'Foo', as( 'Str', where { ... } ) );
  #
  # If as() returns all its extra arguments, this just works, and
  # preserves backwards compatibility.
  sub as { { as => shift }, @_ }
  sub where (&)       { { where       => $_[0] } }
  sub message (&)     { { message     => $_[0] } }
  sub inline_as (&)   { { inline_as   => $_[0] } }
  
  sub from    {@_}
  sub via (&) { $_[0] }
  
  sub enum {
      my ( $type_name, @values ) = @_;
  
      # NOTE:
      # if only an array-ref is passed then
      # you get an anon-enum
      # - SL
      if ( ref $type_name eq 'ARRAY' ) {
          @values == 0
              || throw_exception( EnumCalledWithAnArrayRefAndAdditionalArgs => array => $type_name,
                                                                               args  => \@values
                                );
          @values    = ($type_name);
          $type_name = undef;
      }
      if ( @values == 1 && ref $values[0] eq 'ARRAY' ) {
          @values = @{ $values[0] };
      }
      else {
          Moose::Deprecated::deprecated(
              feature => 'non-arrayref form of enum',
              message => "Passing a list of values to enum is deprecated. "
                       . "Enum values should be wrapped in an arrayref.",
          );
      }
  
      register_type_constraint(
          create_enum_type_constraint(
              $type_name,
              \@values,
          )
      );
  }
  
  sub union {
    my ( $type_name, @constraints ) = @_;
    if ( ref $type_name eq 'ARRAY' ) {
      @constraints == 0
        || throw_exception( UnionCalledWithAnArrayRefAndAdditionalArgs => array => $type_name,
                                                                          args  => \@constraints
                          );
      @constraints = @$type_name;
      $type_name   = undef;
    }
    if ( @constraints == 1 && ref $constraints[0] eq 'ARRAY' ) {
      @constraints = @{ $constraints[0] };
    }
    if ( defined $type_name ) {
      return register_type_constraint(
        create_named_type_constraint_union( $type_name, @constraints )
      );
    }
    return create_type_constraint_union( @constraints );
  }
  
  sub create_enum_type_constraint {
      my ( $type_name, $values ) = @_;
  
      Moose::Meta::TypeConstraint::Enum->new(
          name => $type_name || '__ANON__',
          values => $values,
      );
  }
  
  sub create_duck_type_constraint {
      my ( $type_name, $methods ) = @_;
  
      Moose::Meta::TypeConstraint::DuckType->new(
          name => $type_name || '__ANON__',
          methods => $methods,
      );
  }
  
  sub match_on_type {
      my ($to_match, @cases) = @_;
      my $default;
      if (@cases % 2 != 0) {
          $default = pop @cases;
          (ref $default eq 'CODE')
              || throw_exception( DefaultToMatchOnTypeMustBeCodeRef => to_match            => $to_match,
                                                                       default_action      => $default,
                                                                       cases_to_be_matched => \@cases
                                );
      }
      while (@cases) {
          my ($type, $action) = splice @cases, 0, 2;
  
          unless (blessed $type && $type->isa('Moose::Meta::TypeConstraint')) {
              $type = find_or_parse_type_constraint($type)
                   || throw_exception( CannotFindTypeGivenToMatchOnType => type     => $type,
                                                                           to_match => $to_match,
                                                                           action   => $action
                                     );
          }
  
          (ref $action eq 'CODE')
              || throw_exception( MatchActionMustBeACodeRef => type_name => $type->name,
                                                               action    => $action,
                                                               to_match  => $to_match
                                );
  
          if ($type->check($to_match)) {
              local $_ = $to_match;
              return $action->($to_match);
          }
      }
      (defined $default)
          || throw_exception( NoCasesMatched => to_match            => $to_match,
                                                cases_to_be_matched => \@cases
                            );
      {
          local $_ = $to_match;
          return $default->($to_match);
      }
  }
  
  
  ## --------------------------------------------------------
  ## desugaring functions ...
  ## --------------------------------------------------------
  
  sub _create_type_constraint ($$$;$) {
      my $name      = shift;
      my $parent    = shift;
      my $check     = shift;
      my $message   = shift;
      my $inlined   = shift;
  
      my $pkg_defined_in = scalar( caller(1) );
  
      if ( defined $name ) {
          my $type = $REGISTRY->get_type_constraint($name);
  
          ( $type->_package_defined_in eq $pkg_defined_in )
              || throw_exception( TypeConstraintIsAlreadyCreated => package_defined_in => $pkg_defined_in,
                                                                    type_name          => $type->name,
                                )
              if defined $type;
  
          if( $name !~ /^[\w:\.]+$/ ) {
              throw_exception( InvalidNameForType => name => $name );
          }
      }
  
      my %opts = (
          name               => $name,
          package_defined_in => $pkg_defined_in,
  
          ( $check     ? ( constraint => $check )     : () ),
          ( $message   ? ( message    => $message )   : () ),
          ( $inlined   ? ( inlined    => $inlined )   : () ),
      );
  
      my $constraint;
      if (
          defined $parent
          and $parent
          = blessed $parent
          ? $parent
          : find_or_create_isa_type_constraint($parent)
          ) {
          $constraint = $parent->create_child_type(%opts);
      }
      else {
          $constraint = Moose::Meta::TypeConstraint->new(%opts);
      }
  
      $REGISTRY->add_type_constraint($constraint)
          if defined $name;
  
      return $constraint;
  }
  
  sub _install_type_coercions ($$) {
      my ( $type_name, $coercion_map ) = @_;
      my $type = find_type_constraint($type_name);
      ( defined $type )
          || throw_exception( CannotFindType => type_name => $type_name );
  
      if ( $type->has_coercion ) {
          $type->coercion->add_type_coercions(@$coercion_map);
      }
      else {
          my $type_coercion = Moose::Meta::TypeCoercion->new(
              type_coercion_map => $coercion_map,
              type_constraint   => $type
          );
          $type->coercion($type_coercion);
      }
  }
  
  ## --------------------------------------------------------
  ## type notation parsing ...
  ## --------------------------------------------------------
  
  {
  
      # All I have to say is mugwump++ cause I know
      # do not even have enough regexp-fu to be able
      # to have written this (I can only barely
      # understand it as it is)
      # - SL
  
      use re "eval";
  
      my $valid_chars = qr{[\w:\.]};
      my $type_atom   = qr{ (?>$valid_chars+) }x;
      my $ws          = qr{ (?>\s*) }x;
      my $op_union    = qr{ $ws \| $ws }x;
  
      my ($type, $type_capture_parts, $type_with_parameter, $union, $any);
      if (Class::MOP::IS_RUNNING_ON_5_10) {
          my $type_pattern
              = q{  (?&type_atom)  (?: \[ (?&ws)  (?&any)  (?&ws) \] )? };
          my $type_capture_parts_pattern
              = q{ ((?&type_atom)) (?: \[ (?&ws) ((?&any)) (?&ws) \] )? };
          my $type_with_parameter_pattern
              = q{  (?&type_atom)      \[ (?&ws)  (?&any)  (?&ws) \]    };
          my $union_pattern
              = q{ (?&type) (?> (?: (?&op_union) (?&type) )+ ) };
          my $any_pattern
              = q{ (?&type) | (?&union) };
  
          my $defines = qr{(?(DEFINE)
              (?<valid_chars>         $valid_chars)
              (?<type_atom>           $type_atom)
              (?<ws>                  $ws)
              (?<op_union>            $op_union)
              (?<type>                $type_pattern)
              (?<type_capture_parts>  $type_capture_parts_pattern)
              (?<type_with_parameter> $type_with_parameter_pattern)
              (?<union>               $union_pattern)
              (?<any>                 $any_pattern)
          )}x;
  
          $type                = qr{ $type_pattern                $defines }x;
          $type_capture_parts  = qr{ $type_capture_parts_pattern  $defines }x;
          $type_with_parameter = qr{ $type_with_parameter_pattern $defines }x;
          $union               = qr{ $union_pattern               $defines }x;
          $any                 = qr{ $any_pattern                 $defines }x;
      }
      else {
          $type
              = qr{  $type_atom  (?: \[ $ws  (??{$any})  $ws \] )? }x;
          $type_capture_parts
              = qr{ ($type_atom) (?: \[ $ws ((??{$any})) $ws \] )? }x;
          $type_with_parameter
              = qr{  $type_atom      \[ $ws  (??{$any})  $ws \]    }x;
          $union
              = qr{ $type (?> (?: $op_union $type )+ ) }x;
          $any
              = qr{ $type | $union }x;
      }
  
  
      sub _parse_parameterized_type_constraint {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{ $type_capture_parts }x;
          return ( $1, $2 );
      }
  
      sub _detect_parameterized_type_constraint {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{ ^ $type_with_parameter $ }x;
      }
  
      sub _parse_type_constraint_union {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          my $given = shift;
          my @rv;
          while ( $given =~ m{ \G (?: $op_union )? ($type) }gcx ) {
              push @rv => $1;
          }
          ( pos($given) eq length($given) )
              || throw_exception( CouldNotParseType => type     => $given,
                                                       position => pos($given)
                                );
          @rv;
      }
  
      sub _detect_type_constraint_union {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{^ $type $op_union $type ( $op_union .* )? $}x;
      }
  }
  
  ## --------------------------------------------------------
  # define some basic built-in types
  ## --------------------------------------------------------
  
  # By making these classes immutable before creating all the types in
  # Moose::Util::TypeConstraints::Builtin , we avoid repeatedly calling the slow
  # MOP-based accessors.
  $_->make_immutable(
      inline_constructor => 1,
      constructor_name   => "_new",
  
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { Class::MOP::class_of($_) }
      qw(
      Moose::Meta::TypeConstraint
      Moose::Meta::TypeConstraint::Union
      Moose::Meta::TypeConstraint::Parameterized
      Moose::Meta::TypeConstraint::Parameterizable
      Moose::Meta::TypeConstraint::Class
      Moose::Meta::TypeConstraint::Role
      Moose::Meta::TypeConstraint::Enum
      Moose::Meta::TypeConstraint::DuckType
      Moose::Meta::TypeConstraint::Registry
  );
  
  require Moose::Util::TypeConstraints::Builtins;
  Moose::Util::TypeConstraints::Builtins::define_builtins($REGISTRY);
  
  my @PARAMETERIZABLE_TYPES
      = map { $REGISTRY->get_type_constraint($_) } qw[ScalarRef ArrayRef HashRef Maybe];
  
  sub get_all_parameterizable_types {@PARAMETERIZABLE_TYPES}
  
  sub add_parameterizable_type {
      my $type = shift;
      ( blessed $type
              && $type->isa('Moose::Meta::TypeConstraint::Parameterizable') )
          || throw_exception( AddParameterizableTypeTakesParameterizableType => type_name => $type );
  
      push @PARAMETERIZABLE_TYPES => $type;
  }
  
  ## --------------------------------------------------------
  # end of built-in types ...
  ## --------------------------------------------------------
  
  {
      my @BUILTINS = list_all_type_constraints();
      sub list_all_builtin_type_constraints {@BUILTINS}
  }
  
  1;
  
  # ABSTRACT: Type constraint system for Moose
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Moose::Util::TypeConstraints - Type constraint system for Moose
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    use Moose::Util::TypeConstraints;
  
    subtype 'Natural',
        as 'Int',
        where { $_ > 0 };
  
    subtype 'NaturalLessThanTen',
        as 'Natural',
        where { $_ < 10 },
        message { "This number ($_) is not less than ten!" };
  
    coerce 'Num',
        from 'Str',
        via { 0+$_ };
  
    class_type 'DateTimeClass', { class => 'DateTime' };
  
    role_type 'Barks', { role => 'Some::Library::Role::Barks' };
  
    enum 'RGBColors', [qw(red green blue)];
  
    union 'StringOrArray', [qw( String ArrayRef )];
  
    no Moose::Util::TypeConstraints;
  
  =head1 DESCRIPTION
  
  This module provides Moose with the ability to create custom type
  constraints to be used in attribute definition.
  
  =head2 Important Caveat
  
  This is B<NOT> a type system for Perl 5. These are type constraints,
  and they are not used by Moose unless you tell it to. No type
  inference is performed, expressions are not typed, etc. etc. etc.
  
  A type constraint is at heart a small "check if a value is valid"
  function. A constraint can be associated with an attribute. This
  simplifies parameter validation, and makes your code clearer to read,
  because you can refer to constraints by name.
  
  =head2 Slightly Less Important Caveat
  
  It is B<always> a good idea to quote your type names.
  
  This prevents Perl from trying to execute the call as an indirect
  object call. This can be an issue when you have a subtype with the
  same name as a valid class.
  
  For instance:
  
    subtype DateTime => as Object => where { $_->isa('DateTime') };
  
  will I<just work>, while this:
  
    use DateTime;
    subtype DateTime => as Object => where { $_->isa('DateTime') };
  
  will fail silently and cause many headaches. The simple way to solve
  this, as well as future proof your subtypes from classes which have
  yet to have been created, is to quote the type name:
  
    use DateTime;
    subtype 'DateTime', as 'Object', where { $_->isa('DateTime') };
  
  =head2 Default Type Constraints
  
  This module also provides a simple hierarchy for Perl 5 types, here is
  that hierarchy represented visually.
  
    Any
        Item
            Bool
            Maybe[`a]
            Undef
            Defined
                Value
                    Str
                        Num
                            Int
                        ClassName
                        RoleName
                Ref
                    ScalarRef[`a]
                    ArrayRef[`a]
                    HashRef[`a]
                    CodeRef
                    RegexpRef
                    GlobRef
                    FileHandle
                    Object
  
  B<NOTE:> Any type followed by a type parameter C<[`a]> can be
  parameterized, this means you can say:
  
    ArrayRef[Int]    # an array of integers
    HashRef[CodeRef] # a hash of str to CODE ref mappings
    ScalarRef[Int]   # a reference to an integer
    Maybe[Str]       # value may be a string, may be undefined
  
  If Moose finds a name in brackets that it does not recognize as an
  existing type, it assumes that this is a class name, for example
  C<ArrayRef[DateTime]>.
  
  B<NOTE:> Unless you parameterize a type, then it is invalid to include
  the square brackets. I.e. C<ArrayRef[]> will be treated as a new type
  name, I<not> as a parameterization of C<ArrayRef>.
  
  B<NOTE:> The C<Undef> type constraint for the most part works
  correctly now, but edge cases may still exist, please use it
  sparingly.
  
  B<NOTE:> The C<ClassName> type constraint does a complex package
  existence check. This means that your class B<must> be loaded for this
  type constraint to pass.
  
  B<NOTE:> The C<RoleName> constraint checks a string is a I<package
  name> which is a role, like C<'MyApp::Role::Comparable'>.
  
  =head2 Type Constraint Naming
  
  Type name declared via this module can only contain alphanumeric
  characters, colons (:), and periods (.).
  
  Since the types created by this module are global, it is suggested
  that you namespace your types just as you would namespace your
  modules. So instead of creating a I<Color> type for your
  B<My::Graphics> module, you would call the type
  I<My::Graphics::Types::Color> instead.
  
  =head2 Use with Other Constraint Modules
  
  This module can play nicely with other constraint modules with some
  slight tweaking. The C<where> clause in types is expected to be a
  C<CODE> reference which checks its first argument and returns a
  boolean. Since most constraint modules work in a similar way, it
  should be simple to adapt them to work with Moose.
  
  For instance, this is how you could use it with
  L<Declare::Constraints::Simple> to declare a completely new type.
  
    type 'HashOfArrayOfObjects',
        where {
            IsHashRef(
                -keys   => HasLength,
                -values => IsArrayRef(IsObject)
            )->(@_);
        };
  
  For more examples see the F<t/examples/example_w_DCS.t> test
  file.
  
  Here is an example of using L<Test::Deep> and its non-test
  related C<eq_deeply> function.
  
    type 'ArrayOfHashOfBarsAndRandomNumbers',
        where {
            eq_deeply($_,
                array_each(subhashof({
                    bar           => isa('Bar'),
                    random_number => ignore()
                })))
          };
  
  For a complete example see the
  F<t/examples/example_w_TestDeep.t> test file.
  
  =head2 Error messages
  
  Type constraints can also specify custom error messages, for when they fail to
  validate. This is provided as just another coderef, which receives the invalid
  value in C<$_>, as in:
  
    subtype 'PositiveInt',
         as 'Int',
         where { $_ > 0 },
         message { "$_ is not a positive integer!" };
  
  If no message is specified, a default message will be used, which indicates
  which type constraint was being used and what value failed. If
  L<Devel::PartialDump> (version 0.14 or higher) is installed, it will be used to
  display the invalid value, otherwise it will just be printed as is.
  
  =head1 FUNCTIONS
  
  =head2 Type Constraint Constructors
  
  The following functions are used to create type constraints.  They
  will also register the type constraints your create in a global
  registry that is used to look types up by name.
  
  See the L</SYNOPSIS> for an example of how to use these.
  
  =head3 subtype 'Name', as 'Parent', where { } ...
  
  This creates a named subtype.
  
  If you provide a parent that Moose does not recognize, it will
  automatically create a new class type constraint for this name.
  
  When creating a named type, the C<subtype> function should either be
  called with the sugar helpers (C<where>, C<message>, etc), or with a
  name and a hashref of parameters:
  
   subtype( 'Foo', { where => ..., message => ... } );
  
  The valid hashref keys are C<as> (the parent), C<where>, C<message>,
  and C<inline_as>.
  
  =head3 subtype as 'Parent', where { } ...
  
  This creates an unnamed subtype and will return the type
  constraint meta-object, which will be an instance of
  L<Moose::Meta::TypeConstraint>.
  
  When creating an anonymous type, the C<subtype> function should either
  be called with the sugar helpers (C<where>, C<message>, etc), or with
  just a hashref of parameters:
  
   subtype( { where => ..., message => ... } );
  
  =head3 class_type ($class, ?$options)
  
  Creates a new subtype of C<Object> with the name C<$class> and the
  metaclass L<Moose::Meta::TypeConstraint::Class>.
  
    # Create a type called 'Box' which tests for objects which ->isa('Box')
    class_type 'Box';
  
  By default, the name of the type and the name of the class are the same, but
  you can specify both separately.
  
    # Create a type called 'Box' which tests for objects which ->isa('ObjectLibrary::Box');
    class_type 'Box', { class => 'ObjectLibrary::Box' };
  
  =head3 role_type ($role, ?$options)
  
  Creates a C<Role> type constraint with the name C<$role> and the
  metaclass L<Moose::Meta::TypeConstraint::Role>.
  
    # Create a type called 'Walks' which tests for objects which ->does('Walks')
    role_type 'Walks';
  
  By default, the name of the type and the name of the role are the same, but
  you can specify both separately.
  
    # Create a type called 'Walks' which tests for objects which ->does('MooseX::Role::Walks');
    role_type 'Walks', { role => 'MooseX::Role::Walks' };
  
  =head3 maybe_type ($type)
  
  Creates a type constraint for either C<undef> or something of the
  given type.
  
  =head3 duck_type ($name, \@methods)
  
  This will create a subtype of Object and test to make sure the value
  C<can()> do the methods in C<\@methods>.
  
  This is intended as an easy way to accept non-Moose objects that
  provide a certain interface. If you're using Moose classes, we
  recommend that you use a C<requires>-only Role instead.
  
  =head3 duck_type (\@methods)
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@methods> pair, this will create an unnamed duck type.
  This can be used in an attribute definition like so:
  
    has 'cache' => (
        is  => 'ro',
        isa => duck_type( [qw( get_set )] ),
    );
  
  =head3 enum ($name, \@values)
  
  This will create a basic subtype for a given set of strings.
  The resulting constraint will be a subtype of C<Str> and
  will match any of the items in C<\@values>. It is case sensitive.
  See the L</SYNOPSIS> for a simple example.
  
  B<NOTE:> This is not a true proper enum type, it is simply
  a convenient constraint builder.
  
  =head3 enum (\@values)
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@values> pair, this will create an unnamed enum. This
  can then be used in an attribute definition like so:
  
    has 'sort_order' => (
        is  => 'ro',
        isa => enum([qw[ ascending descending ]]),
    );
  
  =head3 union ($name, \@constraints)
  
  This will create a basic subtype where any of the provided constraints
  may match in order to satisfy this constraint.
  
  =head3 union (\@constraints)
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@constraints> pair, this will create an unnamed union.
  This can then be used in an attribute definition like so:
  
    has 'items' => (
        is => 'ro',
        isa => union([qw[ Str ArrayRef ]]),
    );
  
  This is similar to the existing string union:
  
    isa => 'Str|ArrayRef'
  
  except that it supports anonymous elements as child constraints:
  
    has 'color' => (
      isa => 'ro',
      isa => union([ 'Int',  enum([qw[ red green blue ]]) ]),
    );
  
  =head3 as 'Parent'
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a single argument, which is the name of a parent type.
  
  =head3 where { ... }
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a subroutine reference as an argument. When the type
  constraint is tested, the reference is run with the value to be tested
  in C<$_>. This reference should return true or false to indicate
  whether or not the constraint check passed.
  
  =head3 message { ... }
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a subroutine reference as an argument. When the type
  constraint fails, then the code block is run with the value provided
  in C<$_>. This reference should return a string, which will be used in
  the text of the exception thrown.
  
  =head3 inline_as { ... }
  
  This can be used to define a "hand optimized" inlinable version of your type
  constraint.
  
  You provide a subroutine which will be called I<as a method> on a
  L<Moose::Meta::TypeConstraint> object. It will receive a single parameter, the
  name of the variable to check, typically something like C<"$_"> or C<"$_[0]">.
  
  The subroutine should return a code string suitable for inlining. You can
  assume that the check will be wrapped in parentheses when it is inlined.
  
  The inlined code should include any checks that your type's parent types
  do. If your parent type constraint defines its own inlining, you can simply use
  that to avoid repeating code. For example, here is the inlining code for the
  C<Value> type, which is a subtype of C<Defined>:
  
      sub {
          $_[0]->parent()->_inline_check($_[1])
          . ' && !ref(' . $_[1] . ')'
      }
  
  =head3 type 'Name', where { } ...
  
  This creates a base type, which has no parent.
  
  The C<type> function should either be called with the sugar helpers
  (C<where>, C<message>, etc), or with a name and a hashref of
  parameters:
  
    type( 'Foo', { where => ..., message => ... } );
  
  The valid hashref keys are C<where>, C<message>, and C<inlined_as>.
  
  =head2 Type Constraint Utilities
  
  =head3 match_on_type $value => ( $type => \&action, ... ?\&default )
  
  This is a utility function for doing simple type based dispatching similar to
  match/case in OCaml and case/of in Haskell. It is not as featureful as those
  languages, nor does not it support any kind of automatic destructuring
  bind. Here is a simple Perl pretty printer dispatching over the core Moose
  types.
  
    sub ppprint {
        my $x = shift;
        match_on_type $x => (
            HashRef => sub {
                my $hash = shift;
                '{ '
                    . (
                    join ", " => map { $_ . ' => ' . ppprint( $hash->{$_} ) }
                        sort keys %$hash
                    ) . ' }';
            },
            ArrayRef => sub {
                my $array = shift;
                '[ ' . ( join ", " => map { ppprint($_) } @$array ) . ' ]';
            },
            CodeRef   => sub {'sub { ... }'},
            RegexpRef => sub { 'qr/' . $_ . '/' },
            GlobRef   => sub { '*' . B::svref_2object($_)->NAME },
            Object    => sub { $_->can('to_string') ? $_->to_string : $_ },
            ScalarRef => sub { '\\' . ppprint( ${$_} ) },
            Num       => sub {$_},
            Str       => sub { '"' . $_ . '"' },
            Undef     => sub {'undef'},
            => sub { die "I don't know what $_ is" }
        );
    }
  
  Or a simple JSON serializer:
  
    sub to_json {
        my $x = shift;
        match_on_type $x => (
            HashRef => sub {
                my $hash = shift;
                '{ '
                    . (
                    join ", " =>
                        map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
                        sort keys %$hash
                    ) . ' }';
            },
            ArrayRef => sub {
                my $array = shift;
                '[ ' . ( join ", " => map { to_json($_) } @$array ) . ' ]';
            },
            Num   => sub {$_},
            Str   => sub { '"' . $_ . '"' },
            Undef => sub {'null'},
            => sub { die "$_ is not acceptable json type" }
        );
    }
  
  The matcher is done by mapping a C<$type> to an C<\&action>. The C<$type> can
  be either a string type or a L<Moose::Meta::TypeConstraint> object, and
  C<\&action> is a subroutine reference. This function will dispatch on the
  first match for C<$value>. It is possible to have a catch-all by providing an
  additional subroutine reference as the final argument to C<match_on_type>.
  
  =head2 Type Coercion Constructors
  
  You can define coercions for type constraints, which allow you to
  automatically transform values to something valid for the type
  constraint. If you ask your accessor to coerce by adding the option C<< coerce => 1 >>, then Moose will run
  the type-coercion code first, followed by the type constraint
  check. This feature should be used carefully as it is very powerful
  and could easily take off a limb if you are not careful.
  
  See the L</SYNOPSIS> for an example of how to use these.
  
  =head3 coerce 'Name', from 'OtherName', via { ... }
  
  This defines a coercion from one type to another. The C<Name> argument
  is the type you are coercing I<to>.
  
  To define multiple coercions, supply more sets of from/via pairs:
  
    coerce 'Name',
      from 'OtherName', via { ... },
      from 'ThirdName', via { ... };
  
  =head3 from 'OtherName'
  
  This is just sugar for the type coercion construction syntax.
  
  It takes a single type name (or type object), which is the type being
  coerced I<from>.
  
  =head3 via { ... }
  
  This is just sugar for the type coercion construction syntax.
  
  It takes a subroutine reference. This reference will be called with
  the value to be coerced in C<$_>. It is expected to return a new value
  of the proper type for the coercion.
  
  =head2 Creating and Finding Type Constraints
  
  These are additional functions for creating and finding type
  constraints. Most of these functions are not available for
  importing. The ones that are importable as specified.
  
  =head3 find_type_constraint($type_name)
  
  This function can be used to locate the L<Moose::Meta::TypeConstraint>
  object for a named type.
  
  This function is importable.
  
  =head3 register_type_constraint($type_object)
  
  This function will register a L<Moose::Meta::TypeConstraint> with the
  global type registry.
  
  This function is importable.
  
  =head3 normalize_type_constraint_name($type_constraint_name)
  
  This method takes a type constraint name and returns the normalized
  form. This removes any whitespace in the string.
  
  =head3 create_type_constraint_union($pipe_separated_types | @type_constraint_names)
  
  =head3 create_named_type_constraint_union($name, $pipe_separated_types | @type_constraint_names)
  
  This can take a union type specification like C<'Int|ArrayRef[Int]'>,
  or a list of names. It returns a new
  L<Moose::Meta::TypeConstraint::Union> object.
  
  =head3 create_parameterized_type_constraint($type_name)
  
  Given a C<$type_name> in the form of C<'BaseType[ContainerType]'>,
  this will create a new L<Moose::Meta::TypeConstraint::Parameterized>
  object. The C<BaseType> must already exist as a parameterizable
  type.
  
  =head3 create_class_type_constraint($class, $options)
  
  Given a class name this function will create a new
  L<Moose::Meta::TypeConstraint::Class> object for that class name.
  
  The C<$options> is a hash reference that will be passed to the
  L<Moose::Meta::TypeConstraint::Class> constructor (as a hash).
  
  =head3 create_role_type_constraint($role, $options)
  
  Given a role name this function will create a new
  L<Moose::Meta::TypeConstraint::Role> object for that role name.
  
  The C<$options> is a hash reference that will be passed to the
  L<Moose::Meta::TypeConstraint::Role> constructor (as a hash).
  
  =head3 create_enum_type_constraint($name, $values)
  
  Given a enum name this function will create a new
  L<Moose::Meta::TypeConstraint::Enum> object for that enum name.
  
  =head3 create_duck_type_constraint($name, $methods)
  
  Given a duck type name this function will create a new
  L<Moose::Meta::TypeConstraint::DuckType> object for that enum name.
  
  =head3 find_or_parse_type_constraint($type_name)
  
  Given a type name, this first attempts to find a matching constraint
  in the global registry.
  
  If the type name is a union or parameterized type, it will create a
  new object of the appropriate, but if given a "regular" type that does
  not yet exist, it simply returns false.
  
  When given a union or parameterized type, the member or base type must
  already exist.
  
  If it creates a new union or parameterized type, it will add it to the
  global registry.
  
  =head3 find_or_create_isa_type_constraint($type_name)
  
  =head3 find_or_create_does_type_constraint($type_name)
  
  These functions will first call C<find_or_parse_type_constraint>. If
  that function does not return a type, a new type object will
  be created.
  
  The C<isa> variant will use C<create_class_type_constraint> and the
  C<does> variant will use C<create_role_type_constraint>.
  
  =head3 get_type_constraint_registry
  
  Returns the L<Moose::Meta::TypeConstraint::Registry> object which
  keeps track of all type constraints.
  
  =head3 list_all_type_constraints
  
  This will return a list of type constraint names in the global
  registry. You can then fetch the actual type object using
  C<find_type_constraint($type_name)>.
  
  =head3 list_all_builtin_type_constraints
  
  This will return a list of builtin type constraints, meaning those
  which are defined in this module. See the L<Default Type Constraints>
  section for a complete list.
  
  =head3 export_type_constraints_as_functions
  
  This will export all the current type constraints as functions into
  the caller's namespace (C<Int()>, C<Str()>, etc). Right now, this is
  mostly used for testing, but it might prove useful to others.
  
  =head3 get_all_parameterizable_types
  
  This returns all the parameterizable types that have been registered,
  as a list of type objects.
  
  =head3 add_parameterizable_type($type)
  
  Adds C<$type> to the list of parameterizable types
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Moose/Util/TypeConstraints/Builtins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS_BUILTINS';
  package Moose::Util::TypeConstraints::Builtins;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Class::Load qw( is_class_loaded );
  use List::Util 1.33 ();
  use Scalar::Util qw( blessed );
  
  sub type { goto &Moose::Util::TypeConstraints::type }
  sub subtype { goto &Moose::Util::TypeConstraints::subtype }
  sub as { goto &Moose::Util::TypeConstraints::as }
  sub where (&) { goto &Moose::Util::TypeConstraints::where }
  sub inline_as (&) { goto &Moose::Util::TypeConstraints::inline_as }
  
  sub define_builtins {
      my $registry = shift;
  
      type 'Any'    # meta-type including all
          => where {1}
          => inline_as { '1' };
  
      subtype 'Item'  # base type
          => as 'Any'
          => inline_as { '1' };
  
      subtype 'Undef'
          => as 'Item'
          => where { !defined($_) }
          => inline_as {
              '!defined(' . $_[1] . ')'
          };
  
      subtype 'Defined'
          => as 'Item'
          => where { defined($_) }
          => inline_as {
              'defined(' . $_[1] . ')'
          };
  
      subtype 'Bool'
          => as 'Item'
          => where { !defined($_) || $_ eq "" || "$_" eq '1' || "$_" eq '0' }
          => inline_as {
              '('
                  . '!defined(' . $_[1] . ') '
                  . '|| ' . $_[1] . ' eq "" '
                  . '|| (' . $_[1] . '."") eq "1" '
                  . '|| (' . $_[1] . '."") eq "0"'
              . ')'
          };
  
      subtype 'Value'
          => as 'Defined'
          => where { !ref($_) }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && !ref(' . $_[1] . ')'
          };
  
      subtype 'Ref'
          => as 'Defined'
          => where { ref($_) }
              # no need to call parent - ref also checks for definedness
          => inline_as { 'ref(' . $_[1] . ')' };
  
      subtype 'Str'
          => as 'Value'
          => where { ref(\$_) eq 'SCALAR' || ref(\(my $val = $_)) eq 'SCALAR' }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && ('
                  . 'ref(\\' . $_[1] . ') eq "SCALAR"'
                  . ' || ref(\\(my $val = ' . $_[1] . ')) eq "SCALAR"'
              . ')'
          };
  
      my $value_type = Moose::Util::TypeConstraints::find_type_constraint('Value');
      subtype 'Num'
          => as 'Str'
          => where {
          my $val = $_;
          ($val =~ /\A[+-]?[0-9]+\z/) ||
          ( $val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
          (?=[0-9]|\.[0-9])                     #matches previous +- only if there is something like 3 or .3
          [0-9]*                                #matches 0-9 zero or more times
          (?:\.[0-9]+)?                         #matches optional .89 or nothing
              (?:[Ee](?:[+-]?[0-9]+))?              #matches E1 or e1 or e-1 or e+1 etc
          \z/x );
             }
          => inline_as {
              # the long Str tests are redundant here
          #storing $_[1] in a temporary value,
          #so that $_[1] won't get converted to a string for regex match
          #see t/attributes/numeric_defaults.t for more details
          'my $val = '.$_[1].';'.
          $value_type->_inline_check('$val')
          .' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
          . '$val =~ /\A(?:[+-]?)               #matches optional +- in the beginning
                  (?=[0-9]|\.[0-9])                 #matches previous +- only if there is something like 3 or .3
                  [0-9]*                            #matches 0-9 zero or more times
                  (?:\.[0-9]+)?                     #matches optional .89 or nothing
                  (?:[Ee](?:[+-]?[0-9]+))?          #matches E1 or e1 or e-1 or e+1 etc
                  \z/x ); '
          };
  
      subtype 'Int'
          => as 'Num'
          => where { (my $val = $_) =~ /\A-?[0-9]+\z/ }
          => inline_as {
              $value_type->_inline_check($_[1])
              . ' && (my $val = ' . $_[1] . ') =~ /\A-?[0-9]+\z/'
          };
  
      subtype 'CodeRef'
          => as 'Ref'
          => where { ref($_) eq 'CODE' }
          => inline_as { 'ref(' . $_[1] . ') eq "CODE"' };
  
      subtype 'RegexpRef'
          => as 'Ref'
          => where( \&_RegexpRef )
          => inline_as {
              'Moose::Util::TypeConstraints::Builtins::_RegexpRef(' . $_[1] . ')'
          };
  
      subtype 'GlobRef'
          => as 'Ref'
          => where { ref($_) eq 'GLOB' }
          => inline_as { 'ref(' . $_[1] . ') eq "GLOB"' };
  
      # NOTE: scalar filehandles are GLOB refs, but a GLOB ref is not always a
      # filehandle
      subtype 'FileHandle'
          => as 'Ref'
          => where {
              (ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
           || (blessed($_) && $_->isa("IO::Handle"));
          }
          => inline_as {
              '(ref(' . $_[1] . ') eq "GLOB" '
              . '&& Scalar::Util::openhandle(' . $_[1] . ')) '
              . '|| (Scalar::Util::blessed(' . $_[1] . ') '
              . '&& ' . $_[1] . '->isa("IO::Handle"))'
          };
  
      subtype 'Object'
          => as 'Ref'
          => where { blessed($_) }
          => inline_as { 'Scalar::Util::blessed(' . $_[1] . ')' };
  
      subtype 'ClassName'
          => as 'Str'
          => where { is_class_loaded($_) }
              # the long Str tests are redundant here
          => inline_as { 'Class::Load::is_class_loaded(' . $_[1] . ')' };
  
      subtype 'RoleName'
          => as 'ClassName'
          => where {
              (Class::MOP::class_of($_) || return)->isa('Moose::Meta::Role');
          }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && do {'
                  . 'my $meta = Class::MOP::class_of(' . $_[1] . ');'
                  . '$meta && $meta->isa("Moose::Meta::Role");'
              . '}'
          };
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'ScalarRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'SCALAR' || ref($_) eq 'REF' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      return $check->( ${$_} );
                  };
              },
              inlined => sub {
                  'ref(' . $_[1] . ') eq "SCALAR" '
                    . '|| ref(' . $_[1] . ') eq "REF"'
              },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
                  '(ref(' . $val . ') eq "SCALAR" || ref(' . $val . ') eq "REF") '
                    . '&& ' . $type_parameter->_inline_check('${(' . $val . ')}')
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'ArrayRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'ARRAY' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      foreach my $x (@$_) {
                          ( $check->($x) ) || return;
                      }
                      1;
                      }
              },
              inlined          => sub { 'ref(' . $_[1] . ') eq "ARRAY"' },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
  
                  'do {'
                      . 'my $check = ' . $val . ';'
                      . 'ref($check) eq "ARRAY" '
                          . '&& &List::Util::all('
                              . 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
                              . '@{$check}'
                          . ')'
                  . '}';
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'HashRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'HASH' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      foreach my $x ( values %$_ ) {
                          ( $check->($x) ) || return;
                      }
                      1;
                      }
              },
              inlined          => sub { 'ref(' . $_[1] . ') eq "HASH"' },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
  
                  'do {'
                      . 'my $check = ' . $val . ';'
                      . 'ref($check) eq "HASH" '
                          . '&& &List::Util::all('
                              . 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
                              . 'values %{$check}'
                          . ')'
                  . '}';
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'Maybe',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Item'),
              constraint           => sub {1},
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      return 1 if not( defined($_) ) || $check->($_);
                      return;
                      }
              },
              inlined          => sub {'1'},
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
                  '!defined(' . $val . ') '
                    . '|| (' . $type_parameter->_inline_check($val) . ')'
              },
          )
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =for pod_coverage_needs_some_pod
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_MOOSE_UTIL_TYPECONSTRAINTS_BUILTINS

$fatpacked{"x86_64-linux-gnu-thread-multi/Test/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_TEST_MOOSE';
  package Test::Moose;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Sub::Exporter;
  use Test::Builder;
  
  use List::Util 1.33 'all';
  use Moose::Util 'does_role', 'find_meta';
  
  my @exports = qw[
      meta_ok
      does_ok
      has_attribute_ok
      with_immutable
  ];
  
  Sub::Exporter::setup_exporter({
      exports => \@exports,
      groups  => { default => \@exports }
  });
  
  ## the test builder instance ...
  
  my $Test = Test::Builder->new;
  
  ## exported functions
  
  sub meta_ok ($;$) {
      my ($class_or_obj, $message) = @_;
  
      $message ||= "The object has a meta";
  
      if (find_meta($class_or_obj)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub does_ok ($$;$) {
      my ($class_or_obj, $does, $message) = @_;
  
      $message ||= "The object does $does";
  
      if (does_role($class_or_obj, $does)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub has_attribute_ok ($$;$) {
      my ($class_or_obj, $attr_name, $message) = @_;
  
      $message ||= "The object does has an attribute named $attr_name";
  
      my $meta = find_meta($class_or_obj);
  
      if ($meta->find_attribute_by_name($attr_name)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub with_immutable (&@) {
      my $block = shift;
      my $before = $Test->current_test;
  
      $block->(0);
      Class::MOP::class_of($_)->make_immutable for @_;
      $block->(1);
  
      my $num_tests = $Test->current_test - $before;
      my $all_passed = all { $_ } ($Test->summary)[-$num_tests..-1];
      return $all_passed;
  }
  
  1;
  
  # ABSTRACT: Test functions for Moose specific features
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::Moose - Test functions for Moose specific features
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    use Test::More plan => 1;
    use Test::Moose;
  
    meta_ok($class_or_obj, "... Foo has a ->meta");
    does_ok($class_or_obj, $role, "... Foo does the Baz role");
    has_attribute_ok($class_or_obj, $attr_name, "... Foo has the 'bar' attribute");
  
  =head1 DESCRIPTION
  
  This module provides some useful test functions for Moose based classes. It
  is an experimental first release, so comments and suggestions are very welcome.
  
  =head1 EXPORTED FUNCTIONS
  
  =head2 meta_ok ($class_or_object)
  
  Tests if a class or object has a metaclass.
  
  =head2 does_ok ($class_or_object, $role, ?$message)
  
  Tests if a class or object does a certain role, similar to what C<isa_ok>
  does for the C<isa> method.
  
  =head2 has_attribute_ok($class_or_object, $attr_name, ?$message)
  
  Tests if a class or object has a certain attribute, similar to what C<can_ok>
  does for the methods.
  
  =head2 with_immutable { CODE } @class_names
  
  Runs B<CODE> (which should contain normal tests) twice, and make each
  class in C<@class_names> immutable in between the two runs.
  
  The B<CODE> block is called with a single boolean argument indicating whether
  or not the classes have been made immutable yet.
  
  =head1 TODO
  
  =over 4
  
  =item Convert the Moose test suite to use this module.
  
  =item Here is a list of possible functions to write
  
  =over 4
  
  =item immutability predicates
  
  =item anon-class predicates
  
  =item discovering original method from modified method
  
  =item attribute metaclass predicates (attribute_isa?)
  
  =back
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<Test::More>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_TEST_MOOSE

$fatpacked{"x86_64-linux-gnu-thread-multi/metaclass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_METACLASS';
  package metaclass;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Module::Runtime 'use_package_optimistically', 'use_module';
  use Class::MOP;
  
  sub import {
      my ( $class, @args ) = @_;
  
      unshift @args, "metaclass" if @args % 2 == 1;
      my %options = @args;
  
      my $meta_name = exists $options{meta_name} ? $options{meta_name} : 'meta';
      my $metaclass = delete $options{metaclass};
  
      unless ( defined $metaclass ) {
          $metaclass = "Class::MOP::Class";
      } else {
          use_package_optimistically($metaclass);
      }
  
      ($metaclass->isa('Class::MOP::Class'))
          || die use_module('Moose::Exception::MetaclassMustBeDerivedFromClassMOPClass')->new( class_name => $metaclass );
  
      # make sure the custom metaclasses get loaded
      foreach my $key (grep { /_(?:meta)?class$/ } keys %options) {
          unless ( ref( my $class = $options{$key} ) ) {
              use_package_optimistically($class)
          }
      }
  
      my $package = caller();
  
      # create a meta object so we can install &meta
      my $meta = $metaclass->initialize($package => %options);
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  }
  
  1;
  
  # ABSTRACT: a pragma for installing and using Class::MOP metaclasses
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  metaclass - a pragma for installing and using Class::MOP metaclasses
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    package MyClass;
  
    # use Class::MOP::Class
    use metaclass;
  
    # ... or use a custom metaclass
    use metaclass 'MyMetaClass';
  
    # ... or use a custom metaclass
    # and custom attribute and method
    # metaclasses
    use metaclass 'MyMetaClass' => (
        'attribute_metaclass' => 'MyAttributeMetaClass',
        'method_metaclass'    => 'MyMethodMetaClass',
    );
  
    # ... or just specify custom attribute
    # and method classes, and Class::MOP::Class
    # is the assumed metaclass
    use metaclass (
        'attribute_metaclass' => 'MyAttributeMetaClass',
        'method_metaclass'    => 'MyMethodMetaClass',
    );
  
    # if we'd rather not install a 'meta' method, we can do this
    use metaclass meta_name => undef;
    # or if we'd like it to have a different name,
    use metaclass meta_name => 'my_meta';
  
  =head1 DESCRIPTION
  
  This is a pragma to make it easier to use a specific metaclass
  and a set of custom attribute and method metaclasses. It also
  installs a C<meta> method to your class as well, unless C<undef>
  is passed to the C<meta_name> option.
  
  Note that if you are using Moose, you most likely do B<not> want
  to be using this - look into L<Moose::Util::MetaRole> instead.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_METACLASS

$fatpacked{"x86_64-linux-gnu-thread-multi/oose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_OOSE';
  package oose;
  our $VERSION = '2.1603';
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  
  BEGIN {
      my $package;
      sub import {
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              Moose::Util::_load_user_class($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moose;use Moose::Util::TypeConstraints;\n/; }
  }
  
  1;
  
  # ABSTRACT: syntactic sugar to make Moose one-liners easier
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  oose - syntactic sugar to make Moose one-liners easier
  
  =head1 VERSION
  
  version 2.1603
  
  =head1 SYNOPSIS
  
    # create a Moose class on the fly ...
    perl -Moose=Foo -e 'has bar => ( is=>q[ro], default => q[baz] ); print Foo->new->bar' # prints baz
  
    # loads an existing class (Moose or non-Moose)
    # and re-"opens" the package definition to make
    # debugging/introspection easier
    perl -Moose=+My::Class -e 'print join ", " => __PACKAGE__->meta->get_method_list'
  
    # also loads Moose::Util::TypeConstraints to allow subtypes etc
    perl -Moose=Person -e'subtype q[ValidAge] => as q[Int] => where { $_ > 0 && $_ < 78 }; has => age ( isa => q[ValidAge], is => q[ro]); Person->new(age => 90)'
  
  =head1 DESCRIPTION
  
  oose.pm is a simple source filter that adds
  C<package $name; use Moose; use Moose::Util::TypeConstraints;>
  to the beginning of your script and was entirely created because typing
  C<perl -e'package Foo; use Moose; ...'> was annoying me.
  
  =head1 INTERFACE
  
  oose provides exactly one method and it's automatically called by perl:
  
  =over 4
  
  =item B<import($package)>
  
  Pass a package name to import to be used by the source filter. The
  package defaults to C<Class> if none is given.
  
  =back
  
  =head1 DEPENDENCIES
  
  You will need L<Filter::Simple> and eventually L<Moose>
  
  =head1 INCOMPATIBILITIES
  
  None reported. But it is a source filter and might have issues there.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Stevan Little <stevan.little@iinteractive.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Shawn M Moore <code@sartak.org>
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Chris Prather <chris@prather.org>
  
  =item *
  
  Matt S Trout <mst@shadowcat.co.uk>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_OOSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use strict;
use warnings;

use FindBin;
use lib "$FindBin::Bin/../lib";
use Domo2;

Domo2->to_app;


